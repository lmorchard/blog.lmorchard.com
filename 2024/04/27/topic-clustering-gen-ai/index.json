{
  "attachments": [],
  "title": "Clustering ideas by topic with machine learning and generative AI",
  "tags": [
    "ai",
    "ml",
    "llm",
    "genai",
    "ClusteringIdeasWithAI"
  ],
  "year": "2024",
  "month": "04",
  "day": "27",
  "isDir": true,
  "slug": "topic-clustering-gen-ai",
  "type": "entry",
  "date": "2024-04-27T19:00:00.000Z",
  "postName": "2024-04-27-topic-clustering-gen-ai",
  "html": "<p><strong>TL;DR</strong>: FigJam has a feature where you can automatically cluster sticky notes by topic. I wanted to see if I could glue some things together to implement this myself.</p>\n<!--more-->\n\n\n\n<figure class=\"wide\">\n  <img src=\"./cover.png\" width=\"\" height=\"\">\n  <figcaption>I asked DALL-E to generate \"a whimsical depiction of astronauts arranging ideas into clusters while floating in deep space\". Then, I ran a few imagemagick transformations on it for fun.</figcaption>\n</figure>\n\n<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\n<h2 id=\"organizing-sticky-notes-automatically\">Organizing sticky notes automatically</h2>\n<p>Over the years and on various teams, I've been in a lot of brainstorming and clustering exercises. Years ago, we did it with literal paper sticky notes slapped onto a wall. More recently and remotely, we've done this with <a href=\"https://www.figma.com/figjam/\">FigJam</a> over Zoom.</p>\n<p>We'd also do the clustering as a manual group exercise, whether moving little slips of paper around or dragging boxes on the screen. Well, over the past year or so, <a href=\"https://www.theverge.com/2023/11/7/23950667/figma-figjam-generative-ai-design-tools-beta-announcement\">Figma added AI features to FigJam</a>. One of these features is the ability to automatically cluster sticky notes by topic:</p>\n<figure class=\"wide\">\n  <video controls=\"\">\n    <source src=\"./figjam-sorting-demo.mp4\" type=\"video/mp4\">\n    <a href=\"./figjam-sorting-demo.mp4\">figjam-sorting-demo.mp4</a>\n  </video>\n  <figcaption>A quick demo of FigJam's sticky organization feature - it's more legible in fullscreen view</figcaption>\n</figure>\n\n<p>Sometimes, the group exercise of shuffling ideas around is the entire point - it can help folks review everything during the process. But, sometimes, that just chews up time better spent parsing through things at a higher level. So, this is a neat tool to have around for rough cuts and quick passes.</p>\n<p>Also, with respect to this tool in the context of the generative AI hype cycle, I don't think it's a terrible application of the tech. The results can be imperfect, but a brainstorming process is pretty tolerant of fuzziness. This thing can be pretty handy even with the glitches and quirks.</p>\n<h2 id=\"so-how-does-it-work\">So, how does it work?</h2>\n<p>Since I don't work at Figma, I don't really know how they implemented this in FigJam. But, lately, I've been trying to catch up on the last decade of machine learning and language models. That gives me a few ideas of what I can glue together to make something like this work.</p>\n<p>First, there are two main parts to this clustering activity:</p>\n<ol>\n<li>clustering the sticky notes by topic</li>\n<li>labelling the topic of each cluster</li>\n</ol>\n<p>Simple, right? You just look at the notes and physically move the ones you think are similar closer together. Then, you look at each group, scratch your head a bit, and write down a few words that seem to describe what seems similar about them.</p>\n<p>Now, how can a computer do any of that? Well, not simply. At least, not without having a significant bit of tooling to deal with language and semantics. As it turns out, we have some of that tooling these days.</p>\n<p>With that in mind, here's a technobabble outline of what I'll spend the rest of the blog post explaining:</p>\n<ol>\n<li>we map the notes as points in a virtual semantic space using <a href=\"https://cloud.google.com/blog/topics/developers-practitioners/meet-ais-multitool-vector-embeddings\">vector embeddings</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/K-means_clustering\">k-means clustering</a> can find groups of points that are close together in space</li>\n<li>we map the points back to notes and a <a href=\"https://en.wikipedia.org/wiki/Large_language_model\">large language model</a> can help generate labels for each group</li>\n</ol>\n<p>This process is sorta-kinda like what we'd do as humans? Only, instead of pushing sticky notes closer together, the machine constructs a space wherein the sticky notes are already in close proximity. And, instead of scratching its head, it does a bunch of funky math to figure out what words are plausibly appropriate given the context.</p>\n<p>Okay, yeah, that hurt my head to write. Let's get into some code.</p>\n<h2 id=\"play-along-at-home-with-a-notebook\">Play along at home with a notebook</h2>\n<p>By the way, if you've got time, you can play along with this blog post at home with this notebook:</p>\n<ul>\n<li><a href=\"./topic_clustering_with_openai.ipynb\">topic_clustering_with_openai.ipynb</a></li>\n</ul>\n<p>Someday, I might figure out a way to integrate notebooks into this blog. But, until then, you can run it with <a href=\"https://colab.research.google.com/\">Google Colab</a> and see the results for yourself. If you want to do that, you'll also need an <a href=\"https://platform.openai.com/\">OpenAI API key</a>, since I won't be sharing my own here.</p>\n<p>I'll leave it as an exercise to the reader to figure out how to get all this working. But, it's worth learning how to use these tools if you're interested in this kind of thing.</p>\n<h2 id=\"opening-ceremonies\">Opening ceremonies</h2>\n<p>To kick things off, consider this code that constructs a list of notes to cluster:</p>\n<pre><code class=\"language-python\">items_text = \"\"\"\n- pasta\n- thomas dolby\n- alpha\n- apples\n- cats\n- pears\n- meters\n- brick\n- dogs\n- beta\n- howard jones\n- concrete\n- asphalt\n- milk\n- rebar\n- gillian gilbert\n- hamsters\n- bread\n- butter\n- wendy carlos\n- gamma\n- birds\n- bananas\n- rick wakeman\n- inches\n- glass\n- feet\n- gary numan\n- miles\n- lumber\n- kilometers\n- geoff downes\n\"\"\"\n\n# Split the text into non-empty lines...\nitems = [x for x in items_text.split(\"\\n\") if x]\n</code></pre>\n<p>It's a pretty random grab bag of things. Maybe you'd roll these up in <a href=\"https://en.wikipedia.org/wiki/Katamari_Damacy\">Katamari Damacy</a>? Anyway, along with giving you a weird view of my brain, it's a good starting point for a clustering exercise.</p>\n<p>Next, here's some preamble to install some needful modules and to create an OpenAI client. There are other ways to get all this working, but OpenAI's APIs are a quick option to start playing:</p>\n<pre><code class=\"language-python\">%pip install openai scikit-learn\n\nfrom openai import OpenAI\nfrom google.colab import userdata\n\nopenai_client = OpenAI(api_key=userdata.get('openai_api_key'))\n</code></pre>\n<p>This notebook expects an OpenAI API key to be provided in a Collab secret named <code>openai_api_key</code> and the <code>userdata.get()</code> method is how it's fetched. Collab has a handy little tab with a \"key\" icon on the side <a href=\"https://twitter.com/GoogleColab/status/1719798406195867814\">where you can add secrets</a>, so I don't have to share mine with you here.</p>\n<h2 id=\"mapping-notes-with-vector-embeddings\">Mapping notes with vector embeddings</h2>\n<p>Now, consider a <a href=\"https://en.wikipedia.org/wiki/Hash_function\">hash function</a> like <a href=\"https://en.wikipedia.org/wiki/MD5\">MD5</a> or <a href=\"https://en.wikipedia.org/wiki/SHA-2\">SHA-256</a>: using one of these, we can generate a consistent, fixed-length hash for any chunk of data. Since these hashes are likely to correspond to a specific chunk of data, we can fairly reliably compare hashes to see if two pieces of data are identical or not.</p>\n<p>Similarly, a <a href=\"https://cloud.google.com/blog/topics/developers-practitioners/meet-ais-multitool-vector-embeddings\">vector embedding</a> is a fixed-length list of numbers that can be consistently generated for any chunk of text. Just like hashes, we can compare two embeddings to see if they came from the same text. (Though, as I'll explain shortly, this is not the most exciting feature of embeddings.)</p>\n<p>Here's how we can get embeddings for our list of notes, using the OpenAI API:</p>\n<pre><code class=\"language-python\"># Get embeddings for the list of items\nembeddings_response = openai_client.embeddings.create(\n  model=\"text-embedding-ada-002\",\n  input=items,\n  encoding_format=\"float\"\n)\n\n# Simplify the response data model to just a list of embeddings\nembeddings = [embedding_item.embedding for embedding_item in embeddings_response.data]\n</code></pre>\n<p>This uses <a href=\"https://platform.openai.com/docs/guides/embeddings\">OpenAI's embeddings API</a> to access a model named <code>text-embedding-ada-002</code> and generate embeddings for each item in the list. There are other models available - just like there are different hash functions - but this one is a good starting point.</p>\n<p>As promised, if you peek at one of the embeddings, you'll see a list of numbers like this:</p>\n<pre><code class=\"language-python\">embeddings[0]\n[0.0094045475,\n -0.009105674,\n 0.01120443,\n -0.018105082,\n -0.007730857,\n 0.015474997,\n -0.026951734,\n -0.026725918,\n 0.0040049027,\n -0.035120938,\n 0.021890812,\n 0.019061478,\n -0.014438903,\n ...\n</code></pre>\n<p>Here's where vector embeddings have a superpower over hashes: You can consider that list of numbers as the coordinates of a point somewhere in a very high-dimensional space. And, in this space, geometric distance between points is roughly approximate to semantic similarity.</p>\n<p>When I first learned about <a href=\"https://cloud.google.com/blog/topics/developers-practitioners/meet-ais-multitool-vector-embeddings\">vector embeddings</a>, it sounded entirely sci-fi and bruised my brain. But, it's practical technology. Some researchers at Google figured it out back in 2013 and called it <a href=\"https://en.wikipedia.org/wiki/Word2vec\">Word2vec</a>. Of course folks have built on that a lot since, but the basic notion remains handy.</p>\n<p>To make it work, you need to train a machine learning model over an enormous corpus of example text. Roughly speaking, the training encodes the relationships of words and phrases based on surrounding context. The resulting model can then generate what I think of as positions along a large number of semantic axes for any given text you throw at it.</p>\n<p>The <code>text-embedding-ada-002</code> model produces vectors of 384 floating point numbers. I take this to mean that the model has encoded 384 axes of semantic similarity - sort of the \"resolution\" of the model, if you will. This, along with other factors I don't quite understand yet, can be used to decide on which embedding model to use for a given task. (And there are quite a few to choose from.)</p>\n<p>Honestly, it's a black box to me - I don't know what the semantic axes mean in any given model. And, modulo research I haven't yet read, I don't think anyone really knows what they mean.</p>\n<p>But, the gist is that you get a fancy hash function that can be used to index text in a way that roughly corresponds to semantics.</p>\n<h2 id=\"k-means-clustering-in-a-semantic-space\">K-means clustering in a semantic space</h2>\n<p>Okay, so, we've got a list of notes and we've got an associated list of embeddings. Assuming you believe that the embeddings can be used as coordinates in a semantic space, we can apply a spatial algorithm to group the points - and, thereby, the notes - into clusters.</p>\n<p>The <a href=\"https://en.wikipedia.org/wiki/K-means_clustering\">k-means clustering</a> algorithm is a way to do this. It's another black box to me, but I think the way it works is by placing a set number of points in space at random and then jiggling them away from each other until they're each in the middle of a dense bunch of other points. Then, it divides the space up in a clever way around those \"centroid\" points to define clusters.</p>\n<p>The real interesting thing here is that <a href=\"https://en.wikipedia.org/wiki/K-means_clustering\">k-means clustering</a> doesn't know anything about words or language. It just knows about points in a space of arbitrary dimensions. But, since we've managed to map text into meaning-like points, we can use it to cluster text. And, in turn, since we've expressed ideas as text, this can help us organize ideas.</p>\n<p>Weird, but I'm counting this as food for thought in considering further tools that can be applied to language, thanks to <a href=\"https://cloud.google.com/blog/topics/developers-practitioners/meet-ais-multitool-vector-embeddings\">vector embeddings</a>.</p>\n<p>Anyway, here's some code that applies k-means clustering to our list of embeddings - which in turn corresponds to our list of notes. The heavy lifting is done with the <code>sklearn</code> package, the rest of the code just juggles the results into a more convenient shape:</p>\n<pre><code class=\"language-python\">from sklearn.cluster import KMeans\nfrom itertools import groupby\n\n# Let's say we want to organize the list into this many clusters\nn_clusters = 12\n\n# Use the k-means algorithm to come up with a cluster ID for each embedding\ncluster_ids = KMeans(n_clusters=n_clusters, n_init='auto').fit_predict(embeddings)\n\n# Associate each cluster ID with the corresponding item\ncluster_ids_with_items = zip(cluster_ids, items)\n\n# Group the pairs of (cluster_id, item) into lists based on cluster ID\ngrouped_cluster_ids_with_items = groupby(\n    sorted(cluster_ids_with_items, key=lambda x: x[0]),\n    key=lambda x: x[0]\n)\n\n# Simplify that whole mess so we just have a list of clustered items\nclustered_items = [\n    [item for cluster_id, item in item_group]\n    for cluster_id, item_group\n    in grouped_cluster_ids_with_items\n]\n</code></pre>\n<p>Another interesting thing is that k-means clustering is not consistent. You can run it repeatedly and get different results. In fact, if you're following along in the notebook, you should try that.</p>\n<p>Print out the value of <code>clustered_items</code>, it'll look something like this:</p>\n<pre><code class=\"language-python\">clustered_items\n[['- cats', '- dogs', '- hamsters', '- birds'],\n ['- gillian gilbert', '- gary numan'],\n ['- alpha', '- beta', '- gamma'],\n ['- lumber'],\n ['- meters', '- miles', '- kilometers'],\n ['- brick', '- concrete', '- asphalt', '- rebar', '- glass'],\n ['- pasta', '- milk', '- bread', '- butter'],\n ['- rick wakeman'],\n ['- thomas dolby', '- howard jones', '- geoff downes'],\n ['- apples', '- pears', '- bananas'],\n ['- inches', '- feet'],\n ['- wendy carlos']]\n</code></pre>\n<p>Not too bad, huh? It's a pretty good rough pass at organizing similar notes. Some of the groupings are a bit weird, but that's to be expected. You can also adjust the <code>n_clusters</code> variable to see how the results change with fewer or more clusters.</p>\n<p>On the next try, it might look like this:</p>\n<pre><code class=\"language-python\">clustered_items\n[['- rebar', '- lumber'],\n ['- meters', '- inches', '- feet', '- miles', '- kilometers'],\n ['- apples', '- bananas'],\n ['- alpha', '- beta', '- gamma'],\n ['- gillian gilbert', '- gary numan'],\n ['- wendy carlos', '- rick wakeman'],\n ['- hamsters'],\n ['- concrete', '- asphalt'],\n ['- cats', '- dogs', '- birds'],\n ['- pears', '- howard jones'],\n ['- thomas dolby', '- geoff downes'],\n ['- pasta', '- brick', '- milk', '- bread', '- butter', '- glass']]\n</code></pre>\n<p>Oh, hmm: bricks and glass don't really belong on a grocery list, do they? That's kind of what I was talking about earlier with the fuzziness of the results.</p>\n<p>Still, I think it's pretty interesting for a machine to do this at all! If I actually built a tool around this, it'd be handy to offer the ability to run the clustering repeatedly until a pleasing arrangement resulted. Keep the human in the loop, so to speak.</p>\n<h2 id=\"generating-labels-with-a-large-language-model\">Generating labels with a large language model</h2>\n<p>So, I've talked a lot about black boxes and fuzziness so far. And, alas, there's no stopping now since my next tool is a <a href=\"https://en.wikipedia.org/wiki/Large_language_model\">large language model</a>.</p>\n<p>These are machine learning models that have been trained on a lot of text and can, in turn, generate plausible text that seems to be in the same style as the training data. They can also be fine-tuned to generate text for more focused purposes - e.g. generating responses seemingly in the role of a chatbot assistant, answering questions, or summarizing text.</p>\n<p>I'm still working to wrap my head around how these work. My current hypothesis is that because models have been trained on text which narrates giving and taking instructions - and includes the results of following out instructions - many models can generate the semblance of performing tasks. It's <a href=\"https://en.wikipedia.org/wiki/Chinese_room\">Chinese rooms</a> all the way down, except sometimes the results are useful despite the hype.</p>\n<p>Anyway, with that in mind, here's some code that will soon be employed to do stuff:</p>\n<pre><code class=\"language-python\">topic_generation_prompt = \"\"\"\nPlease consider a list of items, one item per line.\n\nFrom that list, produce a single concise label describing the entire list of\nitems as a whole while avoiding the inclusion of the items.\n\nThe label should consist of fewer than 7 words.\n\nDo not offer conversational preamble.\n\nDo not explain the result.\n\nDo not include any extraneous formatting or punctuation.\n\nThank you!\n\"\"\"\n</code></pre>\n<p>Oh wait, that's not code, that's wishful thinking.</p>\n<p>Except, it sort of <em>is</em> code? I mean, I typed that into a box over at <a href=\"https://chat.openai.com/\">chat.openai.com</a> and it did stuff I wanted it to do. And I'm reasonably sure there wasn't a person on the other end. I think it was somebody else's computer (i.e. the cloud).</p>\n<p>Unfortunately, I didn't think to capture the half-dozen rounds of fumbling it took me to get to this point. But, here's a screenshot of that prompt in action:</p>\n<p><img src=\"chatgpt-transcript.png\" alt=\"a screenshot of a transcript working with ChatGPT\" width=\"\" height=\"\"></p>\n<p>Pretty nifty. \"Common Household Pets\" was an acceptable answer for me. Though, why did I thank the computer? <a href=\"https://blog.lmorchard.com/2022/06/12/jays-machine-friends/\">I don't know. It didn't hurt?</a> And maybe I'll be last <a href=\"https://hitchhikers.fandom.com/wiki/Sirius_Cybernetics_Corporation\">up against the wall when the revolution comes</a>?</p>\n<p>This, in the biz, is what we call \"<a href=\"https://www.ibm.com/topics/prompt-engineering\">prompt engineering</a>\". In a nutshell, you throw many drafts of wishful thinking at the machine until it starts to give you what you want. And, weirdly, it often does.</p>\n<p>It's nowhere near an exact science, though there's tooling and techniques I've yet to learn. My working hypothesis is that you're nudging the model into areas of its training that roughly correspond to what you want, based on how other folks wrote things similar to your request in the training set.</p>\n<p>And, in the case of this blog post, the prompt seems good enough to generate labels for our clusters:</p>\n<pre><code class=\"language-python\">def generate_topic(items):\n    text = \"\\n\".join(items)\n    completion = openai_client.chat.completions.create(\n      model=\"gpt-3.5-turbo\",\n      messages=[\n        {\"role\": \"system\", \"content\": topic_generation_prompt},\n        {\"role\": \"user\", \"content\": text}\n      ]\n    )\n    return completion.choices[0].message.content\n</code></pre>\n<p>This little function takes a list of notes, joins them into a single string, and then sends that along with our prompt to the OpenAI API. The API then uses the model (i.e. <code>gpt-3.5-turbo</code>) to generate an acceptable label for the list of notes and returns it to us. Usually. Most of the time. Sometimes.</p>\n<p>Well, often enough to run in a loop and get interesting results:</p>\n<pre><code class=\"language-python\">for cluster in clustered_items:\n    topic = generate_topic(cluster)\n\n    print(f\"# {topic}\")\n    print()\n    for item in cluster:\n        print(f\"{item}\")\n    print()\n</code></pre>\n<p>This code takes each cluster of notes, generates a label for the cluster, and then prints out the label followed by the notes in the cluster.</p>\n<p>When I ran it, this is what I got:</p>\n<pre><code class=\"language-markdown\"># Pets\n\n- cats\n- dogs\n- hamsters\n- birds\n\n# Synthpop musicians\n\n- gillian gilbert\n- gary numan\n\n# Greek letters\n\n- alpha\n- beta\n- gamma\n\n# Building Materials\n\n- lumber\n\n# Units of Distance\n\n- meters\n- miles\n- kilometers\n\n# Construction materials\n\n- brick\n- concrete\n- asphalt\n- rebar\n- glass\n\n# Grocery essentials\n\n- pasta\n- milk\n- bread\n- butter\n\n# Musician\n\n- rick wakeman\n\n# Synthpop music pioneers\n\n- thomas dolby\n- howard jones\n- geoff downes\n\n# Assorted fruits\n\n- apples\n- pears\n- bananas\n\n# Length measurements\n\n- inches\n- feet\n\n# Music producer and composer.\n\n- wendy carlos\n</code></pre>\n<p>I mean, that's not bad? If I were using this for something serious, I'd go through and nudge a few items around. But, it would have saved me (or a group) maybe 20 minutes, having taken only about 30 seconds to run end-to-end in the notebook.</p>\n<p>Also, if you run it repeatedly, you'll get different labels. Sometimes the labels won't make sense. But, that's another place where you can play with the fuzziness. And, in a brainstorming context, that's not a terrible thing.</p>\n<h2 id=\"wrapping-up\">Wrapping up</h2>\n<p>So, that's a rough pass at how you might implement a tool to cluster notes by topic using machine learning and generative AI. There's not a ton to it, code-wise. I'm good at gluing things together, and that's what I've done. But, there's a lot of interesting stuff going on under the hood and things to think about further.</p>\n<p>Some next steps, top of mind:</p>\n<ul>\n<li><p>There are multiple choices for embedding models, clustering algorithms, and language models. I'd like to try this whole exercise again, but with different choices in each slot to see how the results change.</p>\n</li>\n<li><p>I used the OpenAI APIs here, but local models are a thing. I'd like to see how much of this exercise I can run entirely on my own hardware without sending data off to third parties.</p>\n</li>\n<li><p>I'd like to try throwing a larger set of more complex ideas at this and see what what that means for refining the prompt.</p>\n</li>\n</ul>\n<p>All-in-all, I'm skeptical of the latest hype wave around AI. But, I don't think that this stuff can be dismissed as a fad. There's a lot of potential here, and it's important to understand what this stuff can and can't do.</p>\n<p>I'd like to be able to make practical engineering decisions, even if a lot of it remains a collection of black boxes to me. The best way I know how to do that is by plugging things into other things and seeing what happens.</p>\n",
  "body": "**TL;DR**: FigJam has a feature where you can automatically cluster sticky notes by topic. I wanted to see if I could glue some things together to implement this myself.\n\n<!--more-->\n\n<figure class=\"wide\">\n  <img src=\"./cover.png\">\n  <figcaption>I asked DALL-E to generate \"a whimsical depiction of astronauts arranging ideas into clusters while floating in deep space\". Then, I ran a few imagemagick transformations on it for fun.</figcaption>\n</figure>\n\n<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\n## Organizing sticky notes automatically\n\nOver the years and on various teams, I've been in a lot of brainstorming and clustering exercises. Years ago, we did it with literal paper sticky notes slapped onto a wall. More recently and remotely, we've done this with [FigJam](https://www.figma.com/figjam/) over Zoom.\n\nWe'd also do the clustering as a manual group exercise, whether moving little slips of paper around or dragging boxes on the screen. Well, over the past year or so, [Figma added AI features to FigJam](https://www.theverge.com/2023/11/7/23950667/figma-figjam-generative-ai-design-tools-beta-announcement). One of these features is the ability to automatically cluster sticky notes by topic:\n\n<figure class=\"wide\">\n  <video controls>\n    <source src=\"./figjam-sorting-demo.mp4\" type=\"video/mp4\" />\n    <a href=\"./figjam-sorting-demo.mp4\">figjam-sorting-demo.mp4</a>\n  </video>\n  <figcaption>A quick demo of FigJam's sticky organization feature - it's more legible in fullscreen view</figcaption>\n</figure>\n\nSometimes, the group exercise of shuffling ideas around is the entire point - it can help folks review everything during the process. But, sometimes, that just chews up time better spent parsing through things at a higher level. So, this is a neat tool to have around for rough cuts and quick passes.\n\nAlso, with respect to this tool in the context of the generative AI hype cycle, I don't think it's a terrible application of the tech. The results can be imperfect, but a brainstorming process is pretty tolerant of fuzziness. This thing can be pretty handy even with the glitches and quirks.\n\n## So, how does it work?\n\nSince I don't work at Figma, I don't really know how they implemented this in FigJam. But, lately, I've been trying to catch up on the last decade of machine learning and language models. That gives me a few ideas of what I can glue together to make something like this work.\n\nFirst, there are two main parts to this clustering activity:\n\n1. clustering the sticky notes by topic\n1. labelling the topic of each cluster\n\nSimple, right? You just look at the notes and physically move the ones you think are similar closer together. Then, you look at each group, scratch your head a bit, and write down a few words that seem to describe what seems similar about them.\n\nNow, how can a computer do any of that? Well, not simply. At least, not without having a significant bit of tooling to deal with language and semantics. As it turns out, we have some of that tooling these days.\n\nWith that in mind, here's a technobabble outline of what I'll spend the rest of the blog post explaining:\n\n1. we map the notes as points in a virtual semantic space using [vector embeddings][]\n1. [k-means clustering][] can find groups of points that are close together in space\n1. we map the points back to notes and a [large language model][] can help generate labels for each group\n\nThis process is sorta-kinda like what we'd do as humans? Only, instead of pushing sticky notes closer together, the machine constructs a space wherein the sticky notes are already in close proximity. And, instead of scratching its head, it does a bunch of funky math to figure out what words are plausibly appropriate given the context.\n\nOkay, yeah, that hurt my head to write. Let's get into some code.\n\n## Play along at home with a notebook\n\nBy the way, if you've got time, you can play along with this blog post at home with this notebook:\n\n- [topic_clustering_with_openai.ipynb](./topic_clustering_with_openai.ipynb)\n\nSomeday, I might figure out a way to integrate notebooks into this blog. But, until then, you can run it with [Google Colab][] and see the results for yourself. If you want to do that, you'll also need an [OpenAI API key][], since I won't be sharing my own here.\n\nI'll leave it as an exercise to the reader to figure out how to get all this working. But, it's worth learning how to use these tools if you're interested in this kind of thing.\n\n[openai api key]: https://platform.openai.com/\n[google colab]: https://colab.research.google.com/\n\n## Opening ceremonies\n\nTo kick things off, consider this code that constructs a list of notes to cluster:\n\n```python\nitems_text = \"\"\"\n- pasta\n- thomas dolby\n- alpha\n- apples\n- cats\n- pears\n- meters\n- brick\n- dogs\n- beta\n- howard jones\n- concrete\n- asphalt\n- milk\n- rebar\n- gillian gilbert\n- hamsters\n- bread\n- butter\n- wendy carlos\n- gamma\n- birds\n- bananas\n- rick wakeman\n- inches\n- glass\n- feet\n- gary numan\n- miles\n- lumber\n- kilometers\n- geoff downes\n\"\"\"\n\n# Split the text into non-empty lines...\nitems = [x for x in items_text.split(\"\\n\") if x]\n```\n\nIt's a pretty random grab bag of things. Maybe you'd roll these up in [Katamari Damacy][]? Anyway, along with giving you a weird view of my brain, it's a good starting point for a clustering exercise.\n\nNext, here's some preamble to install some needful modules and to create an OpenAI client. There are other ways to get all this working, but OpenAI's APIs are a quick option to start playing:\n\n```python\n%pip install openai scikit-learn\n\nfrom openai import OpenAI\nfrom google.colab import userdata\n\nopenai_client = OpenAI(api_key=userdata.get('openai_api_key'))\n```\n\nThis notebook expects an OpenAI API key to be provided in a Collab secret named `openai_api_key` and the `userdata.get()` method is how it's fetched. Collab has a handy little tab with a \"key\" icon on the side [where you can add secrets](https://twitter.com/GoogleColab/status/1719798406195867814), so I don't have to share mine with you here.\n\n## Mapping notes with vector embeddings\n\nNow, consider a [hash function][] like [MD5][] or [SHA-256][]: using one of these, we can generate a consistent, fixed-length hash for any chunk of data. Since these hashes are likely to correspond to a specific chunk of data, we can fairly reliably compare hashes to see if two pieces of data are identical or not.\n\nSimilarly, a [vector embedding][vector embeddings] is a fixed-length list of numbers that can be consistently generated for any chunk of text. Just like hashes, we can compare two embeddings to see if they came from the same text. (Though, as I'll explain shortly, this is not the most exciting feature of embeddings.)\n\nHere's how we can get embeddings for our list of notes, using the OpenAI API:\n\n```python\n# Get embeddings for the list of items\nembeddings_response = openai_client.embeddings.create(\n  model=\"text-embedding-ada-002\",\n  input=items,\n  encoding_format=\"float\"\n)\n\n# Simplify the response data model to just a list of embeddings\nembeddings = [embedding_item.embedding for embedding_item in embeddings_response.data]\n```\n\nThis uses [OpenAI's embeddings API](https://platform.openai.com/docs/guides/embeddings) to access a model named `text-embedding-ada-002` and generate embeddings for each item in the list. There are other models available - just like there are different hash functions - but this one is a good starting point.\n\nAs promised, if you peek at one of the embeddings, you'll see a list of numbers like this:\n\n```python\nembeddings[0]\n[0.0094045475,\n -0.009105674,\n 0.01120443,\n -0.018105082,\n -0.007730857,\n 0.015474997,\n -0.026951734,\n -0.026725918,\n 0.0040049027,\n -0.035120938,\n 0.021890812,\n 0.019061478,\n -0.014438903,\n ...\n```\n\nHere's where vector embeddings have a superpower over hashes: You can consider that list of numbers as the coordinates of a point somewhere in a very high-dimensional space. And, in this space, geometric distance between points is roughly approximate to semantic similarity.\n\nWhen I first learned about [vector embeddings][], it sounded entirely sci-fi and bruised my brain. But, it's practical technology. Some researchers at Google figured it out back in 2013 and called it [Word2vec][]. Of course folks have built on that a lot since, but the basic notion remains handy.\n\nTo make it work, you need to train a machine learning model over an enormous corpus of example text. Roughly speaking, the training encodes the relationships of words and phrases based on surrounding context. The resulting model can then generate what I think of as positions along a large number of semantic axes for any given text you throw at it.\n\nThe `text-embedding-ada-002` model produces vectors of 384 floating point numbers. I take this to mean that the model has encoded 384 axes of semantic similarity - sort of the \"resolution\" of the model, if you will. This, along with other factors I don't quite understand yet, can be used to decide on which embedding model to use for a given task. (And there are quite a few to choose from.)\n\nHonestly, it's a black box to me - I don't know what the semantic axes mean in any given model. And, modulo research I haven't yet read, I don't think anyone really knows what they mean.\n\nBut, the gist is that you get a fancy hash function that can be used to index text in a way that roughly corresponds to semantics.\n\n## K-means clustering in a semantic space\n\nOkay, so, we've got a list of notes and we've got an associated list of embeddings. Assuming you believe that the embeddings can be used as coordinates in a semantic space, we can apply a spatial algorithm to group the points - and, thereby, the notes - into clusters.\n\nThe [k-means clustering][] algorithm is a way to do this. It's another black box to me, but I think the way it works is by placing a set number of points in space at random and then jiggling them away from each other until they're each in the middle of a dense bunch of other points. Then, it divides the space up in a clever way around those \"centroid\" points to define clusters.\n\nThe real interesting thing here is that [k-means clustering][] doesn't know anything about words or language. It just knows about points in a space of arbitrary dimensions. But, since we've managed to map text into meaning-like points, we can use it to cluster text. And, in turn, since we've expressed ideas as text, this can help us organize ideas.\n\nWeird, but I'm counting this as food for thought in considering further tools that can be applied to language, thanks to [vector embeddings][].\n\nAnyway, here's some code that applies k-means clustering to our list of embeddings - which in turn corresponds to our list of notes. The heavy lifting is done with the `sklearn` package, the rest of the code just juggles the results into a more convenient shape:\n\n```python\nfrom sklearn.cluster import KMeans\nfrom itertools import groupby\n\n# Let's say we want to organize the list into this many clusters\nn_clusters = 12\n\n# Use the k-means algorithm to come up with a cluster ID for each embedding\ncluster_ids = KMeans(n_clusters=n_clusters, n_init='auto').fit_predict(embeddings)\n\n# Associate each cluster ID with the corresponding item\ncluster_ids_with_items = zip(cluster_ids, items)\n\n# Group the pairs of (cluster_id, item) into lists based on cluster ID\ngrouped_cluster_ids_with_items = groupby(\n    sorted(cluster_ids_with_items, key=lambda x: x[0]),\n    key=lambda x: x[0]\n)\n\n# Simplify that whole mess so we just have a list of clustered items\nclustered_items = [\n    [item for cluster_id, item in item_group]\n    for cluster_id, item_group\n    in grouped_cluster_ids_with_items\n]\n```\n\nAnother interesting thing is that k-means clustering is not consistent. You can run it repeatedly and get different results. In fact, if you're following along in the notebook, you should try that.\n\nPrint out the value of `clustered_items`, it'll look something like this:\n\n```python\nclustered_items\n[['- cats', '- dogs', '- hamsters', '- birds'],\n ['- gillian gilbert', '- gary numan'],\n ['- alpha', '- beta', '- gamma'],\n ['- lumber'],\n ['- meters', '- miles', '- kilometers'],\n ['- brick', '- concrete', '- asphalt', '- rebar', '- glass'],\n ['- pasta', '- milk', '- bread', '- butter'],\n ['- rick wakeman'],\n ['- thomas dolby', '- howard jones', '- geoff downes'],\n ['- apples', '- pears', '- bananas'],\n ['- inches', '- feet'],\n ['- wendy carlos']]\n```\n\nNot too bad, huh? It's a pretty good rough pass at organizing similar notes. Some of the groupings are a bit weird, but that's to be expected. You can also adjust the `n_clusters` variable to see how the results change with fewer or more clusters.\n\nOn the next try, it might look like this:\n\n```python\nclustered_items\n[['- rebar', '- lumber'],\n ['- meters', '- inches', '- feet', '- miles', '- kilometers'],\n ['- apples', '- bananas'],\n ['- alpha', '- beta', '- gamma'],\n ['- gillian gilbert', '- gary numan'],\n ['- wendy carlos', '- rick wakeman'],\n ['- hamsters'],\n ['- concrete', '- asphalt'],\n ['- cats', '- dogs', '- birds'],\n ['- pears', '- howard jones'],\n ['- thomas dolby', '- geoff downes'],\n ['- pasta', '- brick', '- milk', '- bread', '- butter', '- glass']]\n```\n\nOh, hmm: bricks and glass don't really belong on a grocery list, do they? That's kind of what I was talking about earlier with the fuzziness of the results.\n\nStill, I think it's pretty interesting for a machine to do this at all! If I actually built a tool around this, it'd be handy to offer the ability to run the clustering repeatedly until a pleasing arrangement resulted. Keep the human in the loop, so to speak.\n\n## Generating labels with a large language model\n\nSo, I've talked a lot about black boxes and fuzziness so far. And, alas, there's no stopping now since my next tool is a [large language model][].\n\nThese are machine learning models that have been trained on a lot of text and can, in turn, generate plausible text that seems to be in the same style as the training data. They can also be fine-tuned to generate text for more focused purposes - e.g. generating responses seemingly in the role of a chatbot assistant, answering questions, or summarizing text.\n\nI'm still working to wrap my head around how these work. My current hypothesis is that because models have been trained on text which narrates giving and taking instructions - and includes the results of following out instructions - many models can generate the semblance of performing tasks. It's [Chinese rooms][] all the way down, except sometimes the results are useful despite the hype.\n\nAnyway, with that in mind, here's some code that will soon be employed to do stuff:\n\n```python\ntopic_generation_prompt = \"\"\"\nPlease consider a list of items, one item per line.\n\nFrom that list, produce a single concise label describing the entire list of\nitems as a whole while avoiding the inclusion of the items.\n\nThe label should consist of fewer than 7 words.\n\nDo not offer conversational preamble.\n\nDo not explain the result.\n\nDo not include any extraneous formatting or punctuation.\n\nThank you!\n\"\"\"\n```\n\nOh wait, that's not code, that's wishful thinking.\n\nExcept, it sort of *is* code? I mean, I typed that into a box over at [chat.openai.com](https://chat.openai.com/) and it did stuff I wanted it to do. And I'm reasonably sure there wasn't a person on the other end. I think it was somebody else's computer (i.e. the cloud).\n\nUnfortunately, I didn't think to capture the half-dozen rounds of fumbling it took me to get to this point. But, here's a screenshot of that prompt in action:\n\n![a screenshot of a transcript working with ChatGPT](chatgpt-transcript.png)\n\nPretty nifty. \"Common Household Pets\" was an acceptable answer for me. Though, why did I thank the computer? [I don't know. It didn't hurt?](https://blog.lmorchard.com/2022/06/12/jays-machine-friends/) And maybe I'll be last [up against the wall when the revolution comes](https://hitchhikers.fandom.com/wiki/Sirius_Cybernetics_Corporation)?\n\nThis, in the biz, is what we call \"[prompt engineering][]\". In a nutshell, you throw many drafts of wishful thinking at the machine until it starts to give you what you want. And, weirdly, it often does.\n\nIt's nowhere near an exact science, though there's tooling and techniques I've yet to learn. My working hypothesis is that you're nudging the model into areas of its training that roughly correspond to what you want, based on how other folks wrote things similar to your request in the training set.\n\nAnd, in the case of this blog post, the prompt seems good enough to generate labels for our clusters:\n\n```python\ndef generate_topic(items):\n    text = \"\\n\".join(items)\n    completion = openai_client.chat.completions.create(\n      model=\"gpt-3.5-turbo\",\n      messages=[\n        {\"role\": \"system\", \"content\": topic_generation_prompt},\n        {\"role\": \"user\", \"content\": text}\n      ]\n    )\n    return completion.choices[0].message.content\n```\n\nThis little function takes a list of notes, joins them into a single string, and then sends that along with our prompt to the OpenAI API. The API then uses the model (i.e. `gpt-3.5-turbo`) to generate an acceptable label for the list of notes and returns it to us. Usually. Most of the time. Sometimes.\n\nWell, often enough to run in a loop and get interesting results:\n\n```python\nfor cluster in clustered_items:\n    topic = generate_topic(cluster)\n\n    print(f\"# {topic}\")\n    print()\n    for item in cluster:\n        print(f\"{item}\")\n    print()\n```\n\nThis code takes each cluster of notes, generates a label for the cluster, and then prints out the label followed by the notes in the cluster.\n\nWhen I ran it, this is what I got:\n\n```markdown\n# Pets\n\n- cats\n- dogs\n- hamsters\n- birds\n\n# Synthpop musicians\n\n- gillian gilbert\n- gary numan\n\n# Greek letters\n\n- alpha\n- beta\n- gamma\n\n# Building Materials\n\n- lumber\n\n# Units of Distance\n\n- meters\n- miles\n- kilometers\n\n# Construction materials\n\n- brick\n- concrete\n- asphalt\n- rebar\n- glass\n\n# Grocery essentials\n\n- pasta\n- milk\n- bread\n- butter\n\n# Musician\n\n- rick wakeman\n\n# Synthpop music pioneers\n\n- thomas dolby\n- howard jones\n- geoff downes\n\n# Assorted fruits\n\n- apples\n- pears\n- bananas\n\n# Length measurements\n\n- inches\n- feet\n\n# Music producer and composer.\n\n- wendy carlos\n```\n\nI mean, that's not bad? If I were using this for something serious, I'd go through and nudge a few items around. But, it would have saved me (or a group) maybe 20 minutes, having taken only about 30 seconds to run end-to-end in the notebook.\n\nAlso, if you run it repeatedly, you'll get different labels. Sometimes the labels won't make sense. But, that's another place where you can play with the fuzziness. And, in a brainstorming context, that's not a terrible thing.\n\n## Wrapping up\n\nSo, that's a rough pass at how you might implement a tool to cluster notes by topic using machine learning and generative AI. There's not a ton to it, code-wise. I'm good at gluing things together, and that's what I've done. But, there's a lot of interesting stuff going on under the hood and things to think about further.\n\nSome next steps, top of mind:\n\n- There are multiple choices for embedding models, clustering algorithms, and language models. I'd like to try this whole exercise again, but with different choices in each slot to see how the results change.\n\n- I used the OpenAI APIs here, but local models are a thing. I'd like to see how much of this exercise I can run entirely on my own hardware without sending data off to third parties.\n\n- I'd like to try throwing a larger set of more complex ideas at this and see what what that means for refining the prompt.\n\nAll-in-all, I'm skeptical of the latest hype wave around AI. But, I don't think that this stuff can be dismissed as a fad. There's a lot of potential here, and it's important to understand what this stuff can and can't do.\n\nI'd like to be able to make practical engineering decisions, even if a lot of it remains a collection of black boxes to me. The best way I know how to do that is by plugging things into other things and seeing what happens.\n\n[word2vec]: https://en.wikipedia.org/wiki/Word2vec\n[hash function]: https://en.wikipedia.org/wiki/Hash_function\n[md5]: https://en.wikipedia.org/wiki/MD5\n[sha-256]: https://en.wikipedia.org/wiki/SHA-2\n[vector embeddings]: https://cloud.google.com/blog/topics/developers-practitioners/meet-ais-multitool-vector-embeddings\n[k-means clustering]: https://en.wikipedia.org/wiki/K-means_clustering\n[large language model]: https://en.wikipedia.org/wiki/Large_language_model\n[large language models]: https://en.wikipedia.org/wiki/Large_language_model\n[katamari damacy]: https://en.wikipedia.org/wiki/Katamari_Damacy\n[prompt engineering]: https://www.ibm.com/topics/prompt-engineering\n[chinese rooms]: https://en.wikipedia.org/wiki/Chinese_room",
  "parentPath": "./content/posts/archives/2024/2024-04-27-topic-clustering-gen-ai",
  "path": "2024/04/27/topic-clustering-gen-ai",
  "thumbnail": "/blog.lmorchard.com/2024/04/27/topic-clustering-gen-ai/cover.png",
  "summary": "TL;DR: FigJam has a feature where you can automatically cluster sticky notes by topic. I wanted to see if I could glue some things together to implement this myself.",
  "prevPostPath": "2024/05/01/topic-clustering-local-models",
  "prevPostTitle": "Clustering ideas with local ML/AI models",
  "nextPostPath": "2024/03/13/github-actions-for-didthis",
  "nextPostTitle": "I like automations for inclusive development"
}