{
  "version": 3,
  "sources": ["../../../node_modules/pixi.js/src/environment/autoDetectEnvironment.ts", "../../../node_modules/pixi.js/src/utils/browser/unsafeEvalSupported.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/const.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/system/SystemRunner.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/system/AbstractRenderer.ts", "../../../node_modules/pixi.js/src/scene/container/CustomRenderPipe.ts", "../../../node_modules/pixi.js/src/scene/container/utils/executeInstructions.ts", "../../../node_modules/pixi.js/src/scene/container/RenderGroupPipe.ts", "../../../node_modules/pixi.js/src/scene/container/utils/clearList.ts", "../../../node_modules/pixi.js/src/scene/container/utils/updateRenderGroupTransforms.ts", "../../../node_modules/pixi.js/src/scene/container/utils/validateRenderables.ts", "../../../node_modules/pixi.js/src/scene/container/RenderGroupSystem.ts", "../../../node_modules/pixi.js/src/scene/sprite/SpritePipe.ts", "../../../node_modules/pixi.js/src/utils/const.ts", "../../../node_modules/pixi.js/src/utils/global/globalHooks.ts", "../../../node_modules/pixi.js/src/rendering/batcher/shared/BatcherPipe.ts", "../../../node_modules/pixi.js/src/filters/Filter.ts", "../../../node_modules/pixi.js/lib/filters/mask/mask.frag.mjs", "../../../node_modules/pixi.js/lib/filters/mask/mask.vert.mjs", "../../../node_modules/pixi.js/lib/filters/mask/mask.wgsl.mjs", "../../../node_modules/pixi.js/src/filters/mask/MaskFilter.ts", "../../../node_modules/pixi.js/src/rendering/mask/alpha/AlphaMaskPipe.ts", "../../../node_modules/pixi.js/src/rendering/mask/color/ColorMaskPipe.ts", "../../../node_modules/pixi.js/src/rendering/mask/stencil/StencilMaskPipe.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/background/BackgroundSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/blendModes/BlendModePipe.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/extract/ExtractSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderTexture.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/extract/GenerateTextureSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/GlobalUniformSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/SchedulerSystem.ts", "../../../node_modules/pixi.js/src/utils/sayHello.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/startup/HelloSystem.ts", "../../../node_modules/pixi.js/src/utils/data/clean.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/RenderableGCSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureGCSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTarget.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/utils/getCanvasTexture.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/view/ViewSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/system/SharedSystems.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/textureBit.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/UboSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uniformParsers.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/createUboSyncFunction.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/uboSyncFunctions.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/buffer/BufferResource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/ensureAttributes.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStencilModesToPixi.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/calculateProjection.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/isRenderingToScreen.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/renderTarget/RenderTargetSystem.ts"],
  "sourcesContent": ["import { extensions, ExtensionType } from '../extensions/Extensions';\n\nconst environments: { name: string; value: { test: () => boolean; load: () => Promise<boolean> } }[] = [];\n\nextensions.handleByNamedList(ExtensionType.Environment, environments);\n\n/**\n * Automatically detects the environment and loads the appropriate extensions.\n * @param skip - whether to skip loading the default extensions\n */\nexport async function loadEnvironmentExtensions(skip: boolean): Promise<void>\n{\n    if (skip) return;\n\n    for (let i = 0; i < environments.length; i++)\n    {\n        const env = environments[i];\n\n        if (env.value.test())\n        {\n            await env.value.load();\n\n            return;\n        }\n    }\n}\n\n/**\n * @param add - whether to add the default imports to the bundle\n * @deprecated since 8.1.6. Use `loadEnvironmentExtensions` instead\n */\nexport async function autoDetectEnvironment(add: boolean): Promise<void>\n{\n    return loadEnvironmentExtensions(!add);\n}\n", "// Cache the result to prevent running this over and over\nlet unsafeEval: boolean;\n\n/**\n * Not all platforms allow to generate function code (e.g., `new Function`).\n * this provides the platform-level detection.\n * @private\n * @returns {boolean} `true` if `new Function` is supported.\n */\nexport function unsafeEvalSupported(): boolean\n{\n    if (typeof unsafeEval === 'boolean')\n    {\n        return unsafeEval;\n    }\n\n    try\n    {\n        /* eslint-disable no-new-func */\n        const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n        /* eslint-enable no-new-func */\n\n        unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n    }\n    catch (_e)\n    {\n        unsafeEval = false;\n    }\n\n    return unsafeEval;\n}\n", "export enum CLEAR\n{\n    NONE = 0,\n    COLOR = 16384,\n    STENCIL = 1024,\n    DEPTH = 256,\n\n    COLOR_DEPTH = COLOR | DEPTH,\n    COLOR_STENCIL = COLOR | STENCIL,\n    DEPTH_STENCIL = DEPTH | STENCIL,\n    ALL = COLOR | DEPTH | STENCIL,\n\n}\n\n/** Used for clearing render textures. true is the same as `ALL` false is the same as `NONE` */\nexport type CLEAR_OR_BOOL = CLEAR | boolean;\n", "/**\n * SystemRunner is used internally by the renderers as an efficient way for systems to\n * be notified about what the renderer is up to during the rendering phase.\n *\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myObject = {\n *     loaded: new SystemRunner('loaded')\n * }\n *\n * const listener = {\n *     loaded: function(){\n *         // thin\n *     }\n * }\n *\n * myObject.loaded.add(listener);\n *\n * myObject.loaded.emit();\n * ```\n *\n * Or for handling calling the same function on many items\n * ```\n * import { SystemRunner } from 'pixi.js';\n *\n * const myGame = {\n *     update: new SystemRunner('update')\n * }\n *\n * const gameObject = {\n *     update: function(time){\n *         // update my gamey state\n *     }\n * }\n *\n * myGame.update.add(gameObject);\n *\n * myGame.update.emit(time);\n * ```\n * @memberof rendering\n */\nexport class SystemRunner\n{\n    public items: any[];\n    private _name: string;\n\n    /**\n     * @param name - The function name that will be executed on the listeners added to this Runner.\n     */\n    constructor(name: string)\n    {\n        this.items = [];\n        this._name = name;\n    }\n\n    /* jsdoc/check-param-names */\n    /**\n     * Dispatch/Broadcast Runner to all listeners added to the queue.\n     * @param {...any} params - (optional) parameters to pass to each listener\n     */\n    /* jsdoc/check-param-names */\n    public emit(a0?: unknown, a1?: unknown, a2?: unknown, a3?: unknown,\n        a4?: unknown, a5?: unknown, a6?: unknown, a7?: unknown): this\n    {\n        const { name, items } = this;\n\n        for (let i = 0, len = items.length; i < len; i++)\n        {\n            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a listener to the Runner\n     *\n     * Runners do not need to have scope or functions passed to them.\n     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name\n     * as the name provided to the Runner when it was created.\n     *\n     * Eg A listener passed to this Runner will require a 'complete' function.\n     *\n     * ```\n     * import { Runner } from 'pixi.js';\n     *\n     * const complete = new Runner('complete');\n     * ```\n     *\n     * The scope used will be the object itself.\n     * @param {any} item - The object that will be listening.\n     */\n    public add(item: unknown): this\n    {\n        if ((item as any)[this._name])\n        {\n            this.remove(item);\n            this.items.push(item);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove a single listener from the dispatch queue.\n     * @param {any} item - The listener that you would like to remove.\n     */\n    public remove(item: unknown): this\n    {\n        const index = this.items.indexOf(item);\n\n        if (index !== -1)\n        {\n            this.items.splice(index, 1);\n        }\n\n        return this;\n    }\n\n    /**\n     * Check to see if the listener is already in the Runner\n     * @param {any} item - The listener that you would like to check.\n     */\n    public contains(item: unknown): boolean\n    {\n        return this.items.indexOf(item) !== -1;\n    }\n\n    /** Remove all listeners from the Runner */\n    public removeAll(): this\n    {\n        this.items.length = 0;\n\n        return this;\n    }\n\n    /** Remove all references, don't use after this. */\n    public destroy(): void\n    {\n        this.removeAll();\n        this.items = null;\n        this._name = null;\n    }\n\n    /**\n     * `true` if there are no this Runner contains no listeners\n     * @readonly\n     */\n    public get empty(): boolean\n    {\n        return this.items.length === 0;\n    }\n\n    /**\n     * The name of the runner.\n     * @readonly\n     */\n    public get name(): string\n    {\n        return this._name;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { loadEnvironmentExtensions } from '../../../../environment/autoDetectEnvironment';\nimport { Container } from '../../../../scene/container/Container';\nimport { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { EventEmitter } from '../../../../utils/utils';\nimport { CLEAR } from '../../gl/const';\nimport { SystemRunner } from './SystemRunner';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { Renderer } from '../../types';\nimport type { BackgroundSystem } from '../background/BackgroundSystem';\nimport type { GenerateTextureOptions, GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport type { PipeConstructor } from '../instructions/RenderPipe';\nimport type { RenderSurface } from '../renderTarget/RenderTargetSystem';\nimport type { Texture } from '../texture/Texture';\nimport type { ViewSystem, ViewSystemDestroyOptions } from '../view/ViewSystem';\nimport type { SharedRendererOptions } from './SharedSystems';\nimport type { System, SystemConstructor } from './System';\n\nexport interface RendererConfig\n{\n    type: number;\n    name: string;\n    runners?: string[];\n    systems: {name: string, value: SystemConstructor}[];\n    renderPipes: {name: string, value: PipeConstructor}[];\n    renderPipeAdaptors: {name: string, value: any}[];\n}\n\n/**\n * The options for rendering a view.\n * @memberof rendering\n */\nexport interface RenderOptions extends ClearOptions\n{\n    /** The container to render. */\n    container: Container;\n    /** the transform to apply to the container. */\n    transform?: Matrix;\n}\n\n/**\n * The options for clearing the render target.\n * @memberof rendering\n */\nexport interface ClearOptions\n{\n    /**\n     * The render target to render. if this target is a canvas and  you are using the WebGL renderer,\n     * please ensure you have set `multiView` to `true` on renderer.\n     */\n    target?: RenderSurface;\n    /** The color to clear with. */\n    clearColor?: ColorSource;\n    /** The clear mode to use. */\n    clear?: CLEAR_OR_BOOL\n}\n\nexport type RendererDestroyOptions = TypeOrBool<ViewSystemDestroyOptions>;\n\nconst defaultRunners = [\n    'init',\n    'destroy',\n    'contextChange',\n    'resolutionChange',\n    'resetState',\n    'renderEnd',\n    'renderStart',\n    'render',\n    'update',\n    'postrender',\n    'prerender'\n] as const;\n\ntype DefaultRunners = typeof defaultRunners[number];\ntype Runners = {[key in DefaultRunners]: SystemRunner} & {\n    [K: ({} & string) | ({} & symbol)]: SystemRunner;\n};\n\n/* eslint-disable max-len */\n/**\n * The base class for a PixiJS Renderer. It contains the shared logic for all renderers.\n *\n * You should not use this class directly, but instead use {@linkrendering.WebGLRenderer}\n * or {@link rendering.WebGPURenderer}.\n * Alternatively, you can also use {@link rendering.autoDetectRenderer} if you want us to\n * determine the best renderer for you.\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a renderer:\n *\n *\n * | Generic Systems                      | Systems that manage functionality that all renderer types share               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.ViewSystem}              | This manages the main view of the renderer usually a Canvas              |\n * | {@link rendering.BackgroundSystem}        | This manages the main views background color and alpha                   |\n * | {@link events.EventSystem}           | This manages UI events.                                                       |\n * | {@link accessibility.AccessibilitySystem} | This manages accessibility features. Requires `import 'pixi.js/accessibility'`|\n *\n * | Core Systems                   | Provide an optimised, easy to use API to work with WebGL/WebGPU               |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.RenderGroupSystem} | This manages the what what we are rendering to (eg - canvas or texture)   |\n * | {@link rendering.GlobalUniformSystem} | This manages shaders, programs that run on the GPU to calculate 'em pixels.   |\n * | {@link rendering.TextureGCSystem}     | This will automatically remove textures from the GPU if they are not used.    |\n *\n * | PixiJS High-Level Systems            | Set of specific systems designed to work with PixiJS objects                  |\n * | ------------------------------------ | ----------------------------------------------------------------------------- |\n * | {@link rendering.HelloSystem}               | Says hello, buy printing out the pixi version into the console log (along with the renderer type)       |\n * | {@link rendering.GenerateTextureSystem} | This adds the ability to generate textures from any Container       |\n * | {@link rendering.FilterSystem}          | This manages the filtering pipeline for post-processing effects.             |\n * | {@link rendering.PrepareSystem}               | This manages uploading assets to the GPU. Requires `import 'pixi.js/prepare'`|\n * | {@link rendering.ExtractSystem}               | This extracts image data from display objects.                               |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @abstract\n * @memberof rendering\n * @property {rendering.HelloSystem} hello - HelloSystem instance.\n * @property {rendering.RenderGroupSystem} renderGroup - RenderGroupSystem instance.\n * @property {rendering.TextureGCSystem} textureGC - TextureGCSystem instance.\n * @property {rendering.FilterSystem} filter - FilterSystem instance.\n * @property {rendering.GlobalUniformSystem} globalUniforms - GlobalUniformSystem instance.\n * @property {rendering.TextureSystem} texture - TextureSystem instance.\n * @property {rendering.EventSystem} events - EventSystem instance.\n * @property {rendering.ExtractSystem} extract - ExtractSystem instance. Requires `import 'pixi.js/extract'`.\n * @property {rendering.PrepareSystem} prepare - PrepareSystem instance. Requires `import 'pixi.js/prepare'`.\n * @property {rendering.AccessibilitySystem} accessibility - AccessibilitySystem instance. Requires `import 'pixi.js/accessibility'`.\n */\n/* eslint-enable max-len */\nexport class AbstractRenderer<\n    PIPES, OPTIONS extends SharedRendererOptions, CANVAS extends ICanvas = HTMLCanvasElement\n> extends EventEmitter<{resize: [screenWidth: number, screenHeight: number, resolution: number]}>\n{\n    /** The default options for the renderer. */\n    public static defaultOptions = {\n        /**\n         * Default resolution / device pixel ratio of the renderer.\n         * @default 1\n         */\n        resolution: 1,\n        /**\n         * Should the `failIfMajorPerformanceCaveat` flag be enabled as a context option used in the `isWebGLSupported`\n         * function. If set to true, a WebGL renderer can fail to be created if the browser thinks there could be\n         * performance issues when using WebGL.\n         *\n         * In PixiJS v6 this has changed from true to false by default, to allow WebGL to work in as many\n         * scenarios as possible. However, some users may have a poor experience, for example, if a user has a gpu or\n         * driver version blacklisted by the\n         * browser.\n         *\n         * If your application requires high performance rendering, you may wish to set this to false.\n         * We recommend one of two options if you decide to set this flag to false:\n         *\n         * 1: Use the Canvas renderer as a fallback in case high performance WebGL is\n         *    not supported.\n         *\n         * 2: Call `isWebGLSupported` (which if found in the utils package) in your code before attempting to create a\n         *    PixiJS renderer, and show an error message to the user if the function returns false, explaining that their\n         *    device & browser combination does not support high performance WebGL.\n         *    This is a much better strategy than trying to create a PixiJS renderer and finding it then fails.\n         * @default false\n         */\n        failIfMajorPerformanceCaveat: false,\n        /**\n         * Should round pixels be forced when rendering?\n         * @default false\n         */\n        roundPixels: false\n    };\n\n    public readonly type: number;\n    /** The name of the renderer. */\n    public readonly name: string;\n\n    public _roundPixels: 0 | 1;\n\n    public readonly runners: Runners = Object.create(null) as Runners;\n    public readonly renderPipes = Object.create(null) as PIPES;\n    /** The view system manages the main canvas that is attached to the DOM */\n    public view!: ViewSystem;\n    /** The background system manages the background color and alpha of the main view. */\n    public background: BackgroundSystem;\n    /** System that manages the generation of textures from the renderer */\n    public textureGenerator: GenerateTextureSystem;\n\n    protected _initOptions: OPTIONS = {} as OPTIONS;\n    protected config: RendererConfig;\n\n    private _systemsHash: Record<string, System> = Object.create(null);\n    private _lastObjectRendered: Container;\n\n    /**\n     * Set up a system with a collection of SystemClasses and runners.\n     * Systems are attached dynamically to this class when added.\n     * @param config - the config for the system manager\n     */\n    constructor(config: RendererConfig)\n    {\n        super();\n        this.type = config.type;\n        this.name = config.name;\n        this.config = config;\n\n        const combinedRunners = [...defaultRunners, ...(this.config.runners ?? [])];\n\n        this._addRunners(...combinedRunners);\n        // Validation check that this environment support `new Function`\n        this._unsafeEvalCheck();\n    }\n\n    /**\n     * Initialize the renderer.\n     * @param options - The options to use to create the renderer.\n     */\n    public async init(options: Partial<OPTIONS> = {})\n    {\n        const skip = options.skipExtensionImports === true ? true : options.manageImports === false;\n\n        await loadEnvironmentExtensions(skip);\n\n        this._addSystems(this.config.systems);\n        this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);\n\n        // loop through all systems...\n        for (const systemName in this._systemsHash)\n        {\n            const system = this._systemsHash[systemName];\n\n            const defaultSystemOptions = (system.constructor as any).defaultOptions;\n\n            options = { ...defaultSystemOptions, ...options };\n        }\n\n        options = { ...AbstractRenderer.defaultOptions, ...options };\n        this._roundPixels = options.roundPixels ? 1 : 0;\n\n        // await emits..\n        for (let i = 0; i < this.runners.init.items.length; i++)\n        {\n            await this.runners.init.items[i].init(options);\n        }\n\n        // store options\n        this._initOptions = options as OPTIONS;\n    }\n\n    /**\n     * Renders the object to its view.\n     * @param options - The options to render with.\n     * @param options.container - The container to render.\n     * @param [options.target] - The target to render to.\n     */\n    public render(options: RenderOptions | Container): void;\n    /** @deprecated since 8.0.0 */\n    public render(container: Container, options: {renderTexture: any}): void;\n    public render(args: RenderOptions | Container, deprecated?: {renderTexture: any}): void\n    {\n        let options = args;\n\n        if (options instanceof Container)\n        {\n            options = { container: options };\n\n            if (deprecated)\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'passing a second argument is deprecated, please use render options instead');\n                // #endif\n\n                options.target = deprecated.renderTexture;\n            }\n        }\n\n        options.target ||= this.view.renderTarget;\n\n        // TODO: we should eventually fix events so that it can handle multiple canvas elements\n        if (options.target === this.view.renderTarget)\n        {\n            // TODO get rid of this\n            this._lastObjectRendered = options.container;\n\n            options.clearColor ??= this.background.colorRgba;\n            options.clear ??= this.background.clearBeforeRender;\n        }\n\n        if (options.clearColor)\n        {\n            const isRGBAArray = Array.isArray(options.clearColor) && options.clearColor.length === 4;\n\n            options.clearColor = isRGBAArray ? options.clearColor : Color.shared.setValue(options.clearColor).toArray();\n        }\n\n        if (!options.transform)\n        {\n            options.container.updateLocalTransform();\n            options.transform = options.container.localTransform;\n        }\n\n        // lets ensure this object is a render group so we can render it!\n        // the renderer only likes to render - render groups.\n        options.container.enableRenderGroup();\n\n        this.runners.prerender.emit(options);\n        this.runners.renderStart.emit(options);\n        this.runners.render.emit(options);\n        this.runners.renderEnd.emit(options);\n        this.runners.postrender.emit(options);\n    }\n\n    /**\n     * Resizes the WebGL view to the specified width and height.\n     * @param desiredScreenWidth - The desired width of the screen.\n     * @param desiredScreenHeight - The desired height of the screen.\n     * @param resolution - The resolution / device pixel ratio of the renderer.\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution?: number): void\n    {\n        const previousResolution = this.view.resolution;\n\n        this.view.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n        this.emit('resize', this.view.screen.width, this.view.screen.height, this.view.resolution);\n        if (resolution !== undefined && resolution !== previousResolution)\n        {\n            this.runners.resolutionChange.emit(resolution);\n        }\n    }\n\n    public clear(options: ClearOptions = {}): void\n    {\n        // override!\n        const renderer = this as unknown as Renderer;\n\n        options.target ||= renderer.renderTarget.renderTarget;\n        options.clearColor ||= this.background.colorRgba;\n        options.clear ??= CLEAR.ALL;\n\n        const { clear, clearColor, target } = options;\n\n        Color.shared.setValue(clearColor ?? this.background.colorRgba);\n\n        renderer.renderTarget.clear(target, clear, Color.shared.toArray() as RgbaArray);\n    }\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.view.resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.view.resolution = value;\n        this.runners.resolutionChange.emit(value);\n    }\n\n    /**\n     * Same as view.width, actual number of pixels in the canvas by horizontal.\n     * @member {number}\n     * @readonly\n     * @default 800\n     */\n    get width(): number\n    {\n        return this.view.texture.frame.width;\n    }\n\n    /**\n     * Same as view.height, actual number of pixels in the canvas by vertical.\n     * @default 600\n     */\n    get height(): number\n    {\n        return this.view.texture.frame.height;\n    }\n\n    // NOTE: this was `view` in v7\n    /**\n     * The canvas element that everything is drawn to.\n     * @type {environment.ICanvas}\n     */\n    get canvas(): CANVAS\n    {\n        return this.view.canvas as CANVAS;\n    }\n\n    /**\n     * the last object rendered by the renderer. Useful for other plugins like interaction managers\n     * @readonly\n     */\n    get lastObjectRendered(): Container\n    {\n        return this._lastObjectRendered;\n    }\n\n    /**\n     * Flag if we are rendering to the screen vs renderTexture\n     * @readonly\n     * @default true\n     */\n    get renderingToScreen(): boolean\n    {\n        const renderer = this as unknown as Renderer;\n\n        return renderer.renderTarget.renderingToScreen;\n    }\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    get screen(): Rectangle\n    {\n        return this.view.screen;\n    }\n\n    /**\n     * Create a bunch of runners based of a collection of ids\n     * @param runnerIds - the runner ids to add\n     */\n    private _addRunners(...runnerIds: string[]): void\n    {\n        runnerIds.forEach((runnerId) =>\n        {\n            this.runners[runnerId] = new SystemRunner(runnerId);\n        });\n    }\n\n    private _addSystems(systems: RendererConfig['systems']): void\n    {\n        let i: keyof typeof systems;\n\n        for (i in systems)\n        {\n            const val = systems[i];\n\n            this._addSystem(val.value, val.name);\n        }\n    }\n\n    /**\n     * Add a new system to the renderer.\n     * @param ClassRef - Class reference\n     * @param name - Property name for system, if not specified\n     *        will use a static `name` property on the class itself. This\n     *        name will be assigned as s property on the Renderer so make\n     *        sure it doesn't collide with properties on Renderer.\n     * @returns Return instance of renderer\n     */\n    private _addSystem(ClassRef: SystemConstructor, name: string): this\n    {\n        const system = new ClassRef(this as unknown as Renderer);\n\n        if ((this as any)[name])\n        {\n            throw new Error(`Whoops! The name \"${name}\" is already in use`);\n        }\n\n        (this as any)[name] = system;\n\n        this._systemsHash[name] = system;\n\n        for (const i in this.runners)\n        {\n            this.runners[i].add(system);\n        }\n\n        return this;\n    }\n\n    private _addPipes(pipes: RendererConfig['renderPipes'], pipeAdaptors: RendererConfig['renderPipeAdaptors']): void\n    {\n        const adaptors = pipeAdaptors.reduce((acc, adaptor) =>\n        {\n            acc[adaptor.name] = adaptor.value;\n\n            return acc;\n        }, {} as Record<string, any>);\n\n        pipes.forEach((pipe) =>\n        {\n            const PipeClass = pipe.value;\n            const name = pipe.name;\n\n            const Adaptor = adaptors[name];\n\n            // sorry typescript..\n            (this.renderPipes as any)[name] = new PipeClass(\n                this as unknown as Renderer,\n                Adaptor ? new Adaptor() : null\n            );\n        });\n    }\n\n    public destroy(options: RendererDestroyOptions = false): void\n    {\n        this.runners.destroy.items.reverse();\n        this.runners.destroy.emit(options);\n\n        // destroy all runners\n        Object.values(this.runners).forEach((runner) =>\n        {\n            runner.destroy();\n        });\n\n        this._systemsHash = null;\n\n        // destroy all pipes\n        (this.renderPipes as null) = null;\n    }\n\n    /**\n     * Generate a texture from a container.\n     * @param options - options or container target to use when generating the texture\n     * @returns a texture\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        return this.textureGenerator.generateTexture(options);\n    }\n\n    /**\n     * Whether the renderer will round coordinates to whole pixels when rendering.\n     * Can be overridden on a per scene item basis.\n     */\n    get roundPixels(): boolean\n    {\n        return !!this._roundPixels;\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     * @ignore\n     */\n    public _unsafeEvalCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n               + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n    /**\n     * Resets the rendering state of the renderer.\n     * This is useful when you want to use the WebGL context directly and need to ensure PixiJS's internal state\n     * stays synchronized. When modifying the WebGL context state externally, calling this method before the next Pixi\n     * render will reset all internal caches and ensure it executes correctly.\n     *\n     * This is particularly useful when combining PixiJS with other rendering engines like Three.js:\n     * ```js\n     * // Reset Three.js state\n     * threeRenderer.resetState();\n     *\n     * // Render a Three.js scene\n     * threeRenderer.render(threeScene, threeCamera);\n     *\n     * // Reset PixiJS state since Three.js modified the WebGL context\n     * pixiRenderer.resetState();\n     *\n     * // Now render Pixi content\n     * pixiRenderer.render(pixiScene);\n     * ```\n     */\n    public resetState(): void\n    {\n        this.runners.resetState.emit();\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe, RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderContainer } from './RenderContainer';\n\n/**\n * The CustomRenderPipe is a render pipe that allows for custom rendering logic for your renderable objects.\n * @example\n * import { RenderContainer } from 'pixi.js';\n *\n * const renderContainer = new RenderContainer(\n * (renderer) =>  {\n *     renderer.clear({\n *       clearColor: 'green', // clear the screen to green when rendering this item\n *     });\n * })\n * @memberof rendering\n */\nexport class CustomRenderPipe implements InstructionPipe<RenderContainer>, RenderPipe<RenderContainer>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'customRender',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public updateRenderable() { /** empty */ }\n    public destroyRenderable() { /** empty */ }\n    public validateRenderable() { return false; }\n\n    public addRenderable(container: RenderContainer, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add(container);\n    }\n\n    public execute(container: RenderContainer)\n    {\n        if (!container.isRenderable) return;\n\n        container.render(this._renderer);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import type { InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function executeInstructions(renderGroup: RenderGroup, renderer: RenderPipes)\n{\n    const instructionSet = renderGroup.instructionSet;\n    const instructions = instructionSet.instructions;\n\n    for (let i = 0; i < instructionSet.instructionSize; i++)\n    {\n        const instruction = instructions[i];\n\n        (renderer[instruction.renderPipeId as keyof RenderPipes] as InstructionPipe<any>).execute(instruction);\n    }\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from '../sprite/BatchableSprite';\nimport { executeInstructions } from './utils/executeInstructions';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\nexport class RenderGroupPipe implements InstructionPipe<RenderGroup>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public addRenderGroup(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._addRenderableCacheAsTexture(renderGroup, instructionSet);\n        }\n        else\n        {\n            this._addRenderableDirect(renderGroup, instructionSet);\n        }\n    }\n\n    public execute(renderGroup: RenderGroup)\n    {\n        if (!renderGroup.isRenderable) return;\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            this._executeCacheAsTexture(renderGroup);\n        }\n        else\n        {\n            this._executeDirect(renderGroup);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n\n    private _addRenderableDirect(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        if (renderGroup._batchableRenderGroup)\n        {\n            BigPool.return(renderGroup._batchableRenderGroup);\n            renderGroup._batchableRenderGroup = null;\n        }\n\n        instructionSet.add(renderGroup);\n    }\n\n    private _addRenderableCacheAsTexture(renderGroup: RenderGroup, instructionSet: InstructionSet): void\n    {\n        const batchableRenderGroup = renderGroup._batchableRenderGroup ??= BigPool.get(BatchableSprite);\n\n        batchableRenderGroup.renderable = renderGroup.root;\n        batchableRenderGroup.transform = renderGroup.root.relativeGroupTransform;\n        batchableRenderGroup.texture = renderGroup.texture;\n        batchableRenderGroup.bounds = renderGroup._textureBounds;\n\n        instructionSet.add(renderGroup);\n        this._renderer.renderPipes.batch.addToBatch(batchableRenderGroup, instructionSet);\n    }\n\n    private _executeCacheAsTexture(renderGroup: RenderGroup): void\n    {\n        if (renderGroup.textureNeedsUpdate)\n        {\n            renderGroup.textureNeedsUpdate = false;\n\n            const worldTransformMatrix = tempMatrix\n                .identity()\n                .translate(\n                    -renderGroup._textureBounds.x,\n                    -renderGroup._textureBounds.y\n                );\n\n            this._renderer.renderTarget.push(renderGroup.texture, true, null, renderGroup.texture.frame);\n\n            this._renderer.globalUniforms.push({\n                worldTransformMatrix,\n                worldColor: 0xFFFFFFFF,\n            });\n\n            executeInstructions(renderGroup, this._renderer.renderPipes);\n\n            this._renderer.renderTarget.finishRenderPass();\n\n            this._renderer.renderTarget.pop();\n            this._renderer.globalUniforms.pop();\n        }\n\n        renderGroup._batchableRenderGroup._batcher.updateElement(renderGroup._batchableRenderGroup);\n        renderGroup._batchableRenderGroup._batcher.geometry.buffers[0].update();\n    }\n\n    private _executeDirect(renderGroup: RenderGroup): void\n    {\n        this._renderer.globalUniforms.push({\n            worldTransformMatrix: renderGroup.inverseParentTextureTransform,\n            worldColor: renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(renderGroup, this._renderer.renderPipes);\n\n        this._renderer.globalUniforms.pop();\n    }\n}\n", "/**\n * nulls all slots in an array from a certain index.\n * assume that when a null item is hit, the rest are also null.\n * Which will be the case for where this is used!\n * @param list - the array to clean\n * @param index - the index to start from\n */\nexport function clearList(list: Array<unknown>, index?: number)\n{\n    index ||= 0;\n\n    for (let j = index; j < list.length; j++)\n    {\n        if (list[j])\n        {\n            list[j] = null;\n        }\n        else\n        {\n            break;\n        }\n    }\n}\n", "import { Container, UPDATE_BLEND, UPDATE_COLOR, UPDATE_VISIBLE } from '../Container';\nimport { clearList } from './clearList';\nimport { multiplyColors } from './multiplyColors';\n\nimport type { ViewContainer } from '../../view/ViewContainer';\nimport type { RenderGroup } from '../RenderGroup';\n\nconst tempContainer = new Container();\nconst UPDATE_BLEND_COLOR_VISIBLE = UPDATE_VISIBLE | UPDATE_COLOR | UPDATE_BLEND;\n\nexport function updateRenderGroupTransforms(renderGroup: RenderGroup, updateChildRenderGroups = false)\n{\n    updateRenderGroupTransform(renderGroup);\n\n    const childrenToUpdate = renderGroup.childrenToUpdate;\n\n    const updateTick = renderGroup.updateTick++;\n\n    for (const j in childrenToUpdate)\n    {\n        const renderGroupDepth = Number(j);\n\n        const childrenAtDepth = childrenToUpdate[j];\n\n        const list = childrenAtDepth.list;\n        const index = childrenAtDepth.index;\n\n        for (let i = 0; i < index; i++)\n        {\n            const child = list[i];\n\n            // check that these things match our layer and depth - if the renderGroup does not match,\n            // the child has been re-parented into another rendergroup since it asked to be updated so we can ignore it here\n            // secondly if the relativeRenderGroupDepth has changed, then the it means it will have been nested at a\n            // different different level in the render group - so we can wait for the update that does in fact match\n            if (child.parentRenderGroup === renderGroup && child.relativeRenderGroupDepth === renderGroupDepth)\n            {\n                updateTransformAndChildren(child, updateTick, 0);\n            }\n        }\n\n        clearList(list, index);\n\n        childrenAtDepth.index = 0;\n    }\n\n    if (updateChildRenderGroups)\n    {\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            updateRenderGroupTransforms(renderGroup.renderGroupChildren[i], updateChildRenderGroups);\n        }\n    }\n}\n\nexport function updateRenderGroupTransform(renderGroup: RenderGroup)\n{\n    const root = renderGroup.root;\n\n    let worldAlpha;\n\n    if (renderGroup.renderGroupParent)\n    {\n        const renderGroupParent = renderGroup.renderGroupParent;\n\n        renderGroup.worldTransform.appendFrom(\n            root.relativeGroupTransform,\n            renderGroupParent.worldTransform,\n        );\n\n        renderGroup.worldColor = multiplyColors(\n            root.groupColor,\n            renderGroupParent.worldColor,\n        );\n\n        worldAlpha = root.groupAlpha * renderGroupParent.worldAlpha;\n    }\n    else\n    {\n        renderGroup.worldTransform.copyFrom(root.localTransform);\n        renderGroup.worldColor = root.localColor;\n        worldAlpha = root.localAlpha;\n    }\n\n    // eslint-disable-next-line no-nested-ternary\n    worldAlpha = worldAlpha < 0 ? 0 : (worldAlpha > 1 ? 1 : worldAlpha);\n    renderGroup.worldAlpha = worldAlpha;\n\n    renderGroup.worldColorAlpha = renderGroup.worldColor\n            + (((worldAlpha * 255) | 0) << 24);\n}\n\nexport function updateTransformAndChildren(container: Container, updateTick: number, updateFlags: number)\n{\n    if (updateTick === container.updateTick) return;\n    container.updateTick = updateTick;\n\n    container.didChange = false;\n\n    const localTransform = container.localTransform;\n\n    container.updateLocalTransform();\n\n    const parent = container.parent;\n\n    if ((parent && !parent.renderGroup))\n    {\n        updateFlags |= container._updateFlags;\n\n        container.relativeGroupTransform.appendFrom(\n            localTransform,\n            parent.relativeGroupTransform,\n        );\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, parent, updateFlags);\n        }\n    }\n    else\n    {\n        updateFlags = container._updateFlags;\n\n        container.relativeGroupTransform.copyFrom(localTransform);\n\n        if (updateFlags & UPDATE_BLEND_COLOR_VISIBLE)\n        {\n            updateColorBlendVisibility(container, tempContainer, updateFlags);\n        }\n    }\n\n    // don't update children if its a layer..\n    if (!container.renderGroup)\n    {\n        const children = container.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            updateTransformAndChildren(children[i], updateTick, updateFlags);\n        }\n\n        const renderGroup = container.parentRenderGroup;\n        const renderable = container as ViewContainer;\n\n        if (renderable.renderPipeId && !renderGroup.structureDidChange)\n        {\n            renderGroup.updateRenderable(renderable);\n        }\n    }\n}\n\nfunction updateColorBlendVisibility(\n    container: Container,\n    parent: Container,\n    updateFlags: number,\n): void\n{\n    if (updateFlags & UPDATE_COLOR)\n    {\n        container.groupColor = multiplyColors(\n            container.localColor,\n            parent.groupColor\n        );\n\n        let groupAlpha = container.localAlpha * parent.groupAlpha;\n\n        // eslint-disable-next-line no-nested-ternary\n        groupAlpha = groupAlpha < 0 ? 0 : (groupAlpha > 1 ? 1 : groupAlpha);\n\n        container.groupAlpha = groupAlpha;\n        container.groupColorAlpha = container.groupColor + (((groupAlpha * 255) | 0) << 24);\n    }\n\n    if (updateFlags & UPDATE_BLEND)\n    {\n        container.groupBlendMode = container.localBlendMode === 'inherit' ? parent.groupBlendMode : container.localBlendMode;\n    }\n\n    if (updateFlags & UPDATE_VISIBLE)\n    {\n        container.globalDisplayStatus = container.localDisplayStatus & parent.globalDisplayStatus;\n    }\n\n    container._updateFlags = 0;\n}\n\n", "import type { RenderPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { RenderPipes } from '../../../rendering/renderers/types';\nimport type { RenderGroup } from '../RenderGroup';\n\nexport function validateRenderables(renderGroup: RenderGroup, renderPipes: RenderPipes): boolean\n{\n    const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n    let rebuildRequired = false;\n\n    for (let i = 0; i < index; i++)\n    {\n        const container = list[i];\n\n        // note to self: there is no need to check if container.parentRenderGroup || !container.renderGroup\n        // exist here, as this function is only called if the structure did NOT change\n        // which means they have to be valid if this function is called\n\n        const renderable = container;\n        const pipe = renderPipes[renderable.renderPipeId as keyof RenderPipes] as RenderPipe<any>;\n\n        rebuildRequired = pipe.validateRenderable(container);\n\n        if (rebuildRequired)\n        {\n            break;\n        }\n    }\n\n    renderGroup.structureDidChange = rebuildRequired;\n\n    return rebuildRequired;\n}\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { Bounds } from './bounds/Bounds';\nimport { clearList } from './utils/clearList';\nimport { executeInstructions } from './utils/executeInstructions';\nimport { updateRenderGroupTransforms } from './utils/updateRenderGroupTransforms';\nimport { validateRenderables } from './utils/validateRenderables';\n\nimport type { WebGPURenderer } from '../../rendering/renderers/gpu/WebGPURenderer';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer, RenderPipes } from '../../rendering/renderers/types';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Container } from './Container';\nimport type { RenderGroup } from './RenderGroup';\n\nconst tempMatrix = new Matrix();\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class RenderGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'renderGroup',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected render({ container, transform }: {container: Container, transform: Matrix}): void\n    {\n        // we need to save the parent and renderGroupParent, so we can restore them later\n        const parent = container.parent;\n        const renderGroupParent = container.renderGroup.renderGroupParent;\n\n        // we set the transforms and parents to null, so we can render the container without any transforms\n        container.parent = null;\n        container.renderGroup.renderGroupParent = null;\n\n        const renderer = this._renderer;\n\n        // collect all the renderGroups in the scene and then render them one by one..\n        let originalLocalTransform: Matrix = tempMatrix;\n\n        if (transform)\n        {\n            originalLocalTransform = originalLocalTransform.copyFrom(container.renderGroup.localTransform);\n            container.renderGroup.localTransform.copyFrom(transform);\n        }\n\n        //  this._assignTop(container.renderGroup, null);\n        const renderPipes = (renderer as WebGPURenderer).renderPipes;\n\n        this._updateCachedRenderGroups(container.renderGroup, null);\n\n        this._updateRenderGroups(container.renderGroup);\n\n        renderer.globalUniforms.start({\n            worldTransformMatrix: transform ? container.renderGroup.localTransform : container.renderGroup.worldTransform,\n            worldColor: container.renderGroup.worldColorAlpha,\n        });\n\n        executeInstructions(container.renderGroup, renderPipes);\n\n        // TODO need to add some events / runners for things like this to hook up to\n        if (renderPipes.uniformBatch)\n        {\n            renderPipes.uniformBatch.renderEnd();\n        }\n\n        // now return the transforms back to normal..\n        if (transform)\n        {\n            container.renderGroup.localTransform.copyFrom(originalLocalTransform);\n        }\n\n        container.parent = parent;\n        container.renderGroup.renderGroupParent = renderGroupParent;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n\n    private _updateCachedRenderGroups(renderGroup: RenderGroup, closestCacheAsTexture: RenderGroup | null): void\n    {\n        if (renderGroup.isCachedAsTexture)\n        {\n            // early out as nothing further needs to be updated!\n            if (!renderGroup.updateCacheTexture) return;\n\n            closestCacheAsTexture = renderGroup;\n        }\n\n        renderGroup._parentCacheAsTextureRenderGroup = closestCacheAsTexture;\n\n        // now check the cacheAsTexture stuff...\n        for (let i = renderGroup.renderGroupChildren.length - 1; i >= 0; i--)\n        {\n            this._updateCachedRenderGroups(renderGroup.renderGroupChildren[i], closestCacheAsTexture);\n        }\n\n        renderGroup.invalidateMatrices();\n\n        if (renderGroup.isCachedAsTexture)\n        {\n            if (renderGroup.textureNeedsUpdate)\n            {\n                // lets get the texture ready for rendering\n                // but the rendering will not happen until the renderGroup is rendered!\n                // We also want to know now, what the bounds of the texture will be.\n                // as if the texture changes, we need to invalidate the parent render group!\n                const bounds = renderGroup.root.getLocalBounds();\n\n                bounds.ceil();\n\n                const lastTexture = renderGroup.texture;\n\n                if (renderGroup.texture)\n                {\n                    TexturePool.returnTexture(renderGroup.texture);\n                }\n\n                const renderer = this._renderer;\n                const resolution = renderGroup.textureOptions.resolution || renderer.view.resolution;\n                const antialias = renderGroup.textureOptions.antialias ?? renderer.view.antialias;\n\n                renderGroup.texture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    resolution,\n                    antialias\n                );\n\n                renderGroup._textureBounds ||= new Bounds();\n                renderGroup._textureBounds.copyFrom(bounds);\n\n                if (lastTexture !== renderGroup.texture)\n                {\n                    if (renderGroup.renderGroupParent)\n                    {\n                        renderGroup.renderGroupParent.structureDidChange = true;\n                    }\n                }\n            }\n        }\n        else if (renderGroup.texture)\n        {\n            TexturePool.returnTexture(renderGroup.texture);\n            renderGroup.texture = null;\n        }\n    }\n\n    private _updateRenderGroups(renderGroup: RenderGroup): void\n    {\n        const renderer = this._renderer;\n        const renderPipes = renderer.renderPipes;\n\n        renderGroup.runOnRender(renderer);\n\n        renderGroup.instructionSet.renderPipes = renderPipes;\n\n        if (!renderGroup.structureDidChange)\n        {\n            // phase 1 - validate all the renderables\n            validateRenderables(renderGroup, renderPipes);\n        }\n        else\n        {\n            clearList(renderGroup.childrenRenderablesToUpdate.list, 0);\n        }\n\n        // phase 2 - update all the transforms\n        // including updating the renderables..\n        updateRenderGroupTransforms(renderGroup);\n\n        if (renderGroup.structureDidChange)\n        {\n            renderGroup.structureDidChange = false;\n\n            // build the renderables\n            this._buildInstructions(renderGroup, renderer);\n        }\n        else\n        {\n            // update remaining renderables\n            this._updateRenderables(renderGroup);\n        }\n\n        // reset the renderables to update\n        renderGroup.childrenRenderablesToUpdate.index = 0;\n\n        // upload all the things!\n        renderer.renderPipes.batch.upload(renderGroup.instructionSet);\n\n        // early out if it's a texture and it hasn't changed!\n        if (renderGroup.isCachedAsTexture && !renderGroup.textureNeedsUpdate) return;\n\n        for (let i = 0; i < renderGroup.renderGroupChildren.length; i++)\n        {\n            this._updateRenderGroups(renderGroup.renderGroupChildren[i]);\n        }\n    }\n\n    private _updateRenderables(renderGroup: RenderGroup)\n    {\n        const { list, index } = renderGroup.childrenRenderablesToUpdate;\n\n        for (let i = 0; i < index; i++)\n        {\n            const container = list[i];\n\n            if (container.didViewUpdate)\n            {\n                renderGroup.updateRenderable(container as ViewContainer);\n            }\n        }\n\n        clearList(list, index);\n    }\n\n    /**\n     * @param renderGroup\n     * @param renderPipes\n     * @deprecated since 8.3.0\n     */\n    private _buildInstructions(renderGroup: RenderGroup, renderPipes: RenderPipes): void;\n    private _buildInstructions(renderGroup: RenderGroup, renderer: Renderer): void;\n    private _buildInstructions(renderGroup: RenderGroup, rendererOrPipes: RenderPipes | Renderer): void\n    {\n    // rebuild the scene graph based on layers...\n        const root = renderGroup.root;\n        const instructionSet = renderGroup.instructionSet;\n\n        instructionSet.reset();\n\n        // deprecate the use of renderPipes by finding the renderer attached to the batch pipe as this is always there\n        const renderer = (rendererOrPipes as Renderer).renderPipes\n            ? (rendererOrPipes as Renderer)\n            : (rendererOrPipes as RenderPipes).batch.renderer;\n        const renderPipes = renderer.renderPipes;\n\n        // TODO add some events / runners for build start\n        renderPipes.batch.buildStart(instructionSet);\n        renderPipes.blendMode.buildStart();\n        renderPipes.colorMask.buildStart();\n\n        if (root.sortableChildren)\n        {\n            root.sortChildren();\n        }\n\n        root.collectRenderablesWithEffects(instructionSet, renderer, null);\n\n        // TODO add some events / runners for build end\n        renderPipes.batch.buildEnd(instructionSet);\n        renderPipes.blendMode.buildEnd(instructionSet);\n    }\n}\n\n", "import { ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { BatchableSprite } from './BatchableSprite';\n\nimport type { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../rendering/renderers/types';\nimport type { PoolItem } from '../../utils/pool/Pool';\nimport type { Container } from '../container/Container';\nimport type { Sprite } from './Sprite';\n\nexport class SpritePipe implements RenderPipe<Sprite>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'sprite',\n    } as const;\n\n    private _renderer: Renderer;\n    private _gpuSpriteHash: Record<number, BatchableSprite> = Object.create(null);\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_gpuSpriteHash');\n    }\n\n    public addRenderable(sprite: Sprite, instructionSet: InstructionSet)\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        // TODO visibility\n        this._renderer.renderPipes.batch.addToBatch(gpuSprite, instructionSet);\n    }\n\n    public updateRenderable(sprite: Sprite)\n    {\n        const gpuSprite = this._gpuSpriteHash[sprite.uid];\n\n        if (sprite.didViewUpdate) this._updateBatchableSprite(sprite, gpuSprite);\n\n        gpuSprite._batcher.updateElement(gpuSprite);\n    }\n\n    public validateRenderable(sprite: Sprite): boolean\n    {\n        const gpuSprite = this._getGpuSprite(sprite);\n\n        return !gpuSprite._batcher.checkAndUpdateTexture(\n            gpuSprite,\n            sprite._texture)\n        ;\n    }\n\n    public destroyRenderable(sprite: Sprite)\n    {\n        const batchableSprite = this._gpuSpriteHash[sprite.uid];\n\n        // this will call reset!\n        BigPool.return(batchableSprite as PoolItem);\n\n        this._gpuSpriteHash[sprite.uid] = null;\n\n        sprite.off('destroyed', this._destroyRenderableBound);\n    }\n\n    private _updateBatchableSprite(sprite: Sprite, batchableSprite: BatchableSprite)\n    {\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.texture = sprite._texture;\n    }\n\n    private _getGpuSprite(sprite: Sprite): BatchableSprite\n    {\n        return this._gpuSpriteHash[sprite.uid] || this._initGPUSprite(sprite);\n    }\n\n    private _initGPUSprite(sprite: Sprite): BatchableSprite\n    {\n        const batchableSprite = BigPool.get(BatchableSprite);\n\n        batchableSprite.renderable = sprite;\n\n        batchableSprite.transform = sprite.groupTransform;\n        batchableSprite.texture = sprite._texture;\n        batchableSprite.bounds = sprite.visualBounds;\n        batchableSprite.roundPixels = (this._renderer._roundPixels | sprite._roundPixels) as 0 | 1;\n\n        this._gpuSpriteHash[sprite.uid] = batchableSprite;\n\n        // TODO perhaps manage this outside this pipe? (a bit like how we update / add)\n        sprite.on('destroyed', this._destroyRenderableBound);\n\n        return batchableSprite;\n    }\n\n    public destroy()\n    {\n        for (const i in this._gpuSpriteHash)\n        {\n            BigPool.return(this._gpuSpriteHash[i] as PoolItem);\n        }\n\n        this._gpuSpriteHash = null;\n        this._renderer = null;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\n\n/**\n * Regexp for data URI.\n * Based on: {@link https://github.com/ragingwind/data-uri-regex}\n * @static\n * @type {RegExp}\n * @default /(?:^data:image\\/([\\w+]+);(?:[\\w=]+|charset=[\\w-]+)?(?:;base64)?,)/i\n * @example\n * import { DATA_URI } from 'pixi.js';\n *\n * DATA_URI.test('data:image/png;base64,foobar'); // => true\n * @memberof utils\n */\nexport const DATA_URI = /^\\s*data:(?:([\\w-]+)\\/([\\w+.-]+))?(?:;charset=([\\w-]+))?(?:;(base64))?,(.*)/i;\n\n// export the event emitter so we can use it in external modules\nexport { EventEmitter };\n\n/** The current version of PixiJS. This is automatically replaced by the build process. */\nexport const VERSION = '$_VERSION';\n", "import { type ExtensionMetadata, ExtensionType } from '../../extensions/Extensions';\nimport { VERSION } from '../const';\n\nimport type { Application } from '../../app/Application';\nimport type { System } from '../../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../../rendering/renderers/types';\n\ndeclare global\n{\n    /* eslint-disable no-var */\n    var __PIXI_APP_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    var __PIXI_RENDERER_INIT__: undefined | ((arg: Application | Renderer, version: string) => void);\n    /* eslint-enable no-var */\n}\n\n/**\n * Calls global __PIXI_APP_INIT__ hook with the application instance, after the application is initialized.\n * @memberof app\n */\nexport class ApplicationInitHook\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = ExtensionType.Application;\n    public static init(): void\n    {\n        globalThis.__PIXI_APP_INIT__?.(this as unknown as Application, VERSION);\n    }\n    public static destroy(): void\n    {\n        // nothing to do\n    }\n}\n\n/**\n * Calls global __PIXI_RENDERER_INIT__ hook with the renderer instance, after the renderer is initialized.\n * @memberof rendering\n */\nexport class RendererInitHook implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'initHook',\n        priority: -10,\n    } as const;\n\n    private _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n    public init(): void\n    {\n        globalThis.__PIXI_RENDERER_INIT__?.(this._renderer, VERSION);\n    }\n    public destroy(): void\n    {\n        this._renderer = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { DefaultBatcher } from './DefaultBatcher';\n\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { BatchPipe, InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Renderer } from '../../renderers/types';\nimport type { Batch, BatchableElement, Batcher } from './Batcher';\n\nexport interface BatcherAdaptor\n{\n    start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    init?(batchPipe: BatcherPipe): void;\n    execute(batchPipe: BatcherPipe, batch: Batch): void\n    contextChange?(): void;\n}\n\n/**\n * A pipe that batches elements into batches and sends them to the renderer.\n *\n * You can install new Batchers using ExtensionType.Batcher. Each render group will\n * have a default batcher and any required ones will be created on demand.\n * @memberof rendering\n */\nexport class BatcherPipe implements InstructionPipe<Batch>, BatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'batch',\n    } as const;\n\n    public state: State = State.for2d();\n    public renderer: Renderer;\n\n    private readonly _batchersByInstructionSet: Record<number, Record<string, Batcher>> = Object.create(null);\n\n    private _adaptor: BatcherAdaptor;\n\n    /** A record of all active batchers, keyed by their names */\n    private _activeBatches: Record<string, Batcher> = Object.create(null);\n\n    /** The currently active batcher being used to batch elements */\n    private _activeBatch: Batcher;\n\n    public static _availableBatchers: Record<string, new () => Batcher> = Object.create(null);\n\n    public static getBatcher(name: string): Batcher\n    {\n        return new this._availableBatchers[name as keyof typeof this._availableBatchers]();\n    }\n\n    constructor(renderer: Renderer, adaptor: BatcherAdaptor)\n    {\n        this.renderer = renderer;\n        this._adaptor = adaptor;\n\n        this._adaptor.init?.(this);\n    }\n\n    public buildStart(instructionSet: InstructionSet)\n    {\n        let batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        if (!batchers)\n        {\n            batchers = this._batchersByInstructionSet[instructionSet.uid] = Object.create(null);\n            batchers.default ||= new DefaultBatcher();\n        }\n\n        this._activeBatches = batchers;\n\n        this._activeBatch = this._activeBatches.default;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].begin();\n        }\n    }\n\n    public addToBatch(batchableObject: BatchableElement, instructionSet: InstructionSet)\n    {\n        if (this._activeBatch.name !== batchableObject.batcherName)\n        {\n            this._activeBatch.break(instructionSet);\n\n            let batch = this._activeBatches[batchableObject.batcherName];\n\n            if (!batch)\n            {\n                batch = this._activeBatches[batchableObject.batcherName]\n                    = BatcherPipe.getBatcher(batchableObject.batcherName);\n                batch.begin();\n            }\n\n            this._activeBatch = batch;\n        }\n\n        this._activeBatch.add(batchableObject);\n    }\n\n    public break(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n    }\n\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        this._activeBatch.break(instructionSet);\n\n        const batches = this._activeBatches;\n\n        for (const i in batches)\n        {\n            const batch = batches[i as keyof typeof batches];\n            const geometry = batch.geometry;\n\n            geometry.indexBuffer.setDataWithSize(batch.indexBuffer, batch.indexSize, true);\n\n            geometry.buffers[0].setDataWithSize(batch.attributeBuffer.float32View, batch.attributeSize, false);\n        }\n    }\n\n    public upload(instructionSet: InstructionSet)\n    {\n        const batchers = this._batchersByInstructionSet[instructionSet.uid];\n\n        for (const i in batchers)\n        {\n            const batcher = batchers[i as keyof typeof batchers];\n            const geometry = batcher.geometry;\n\n            if (batcher.dirty)\n            {\n                batcher.dirty = false;\n\n                geometry.buffers[0].update(batcher.attributeSize * 4);\n            }\n        }\n    }\n\n    public execute(batch: Batch)\n    {\n        if (batch.action === 'startBatch')\n        {\n            const batcher = batch.batcher;\n            const geometry = batcher.geometry;\n            const shader = batcher.shader;\n\n            this._adaptor.start(this, geometry, shader);\n        }\n\n        this._adaptor.execute(this, batch);\n    }\n\n    public destroy()\n    {\n        this.state = null;\n        this.renderer = null;\n\n        this._adaptor = null;\n\n        for (const i in this._activeBatches)\n        {\n            this._activeBatches[i].destroy();\n        }\n\n        this._activeBatches = null;\n    }\n}\n\nextensions.handleByMap(ExtensionType.Batcher, BatcherPipe._availableBatchers);\n\nextensions.add(DefaultBatcher);\n", "import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * Filters provide additional shading and post-processing effects to any display object and its children\n * they are attached to.\n *\n * You attached filters to a display object using its `filters` array property.\n *\n * ```js\n * import { Sprite, BlurFilter, HardMixBlend } from 'pixi.js';\n *\n * const sprite = Sprite.from('myTexture.png');\n *\n * // single filter\n * sprite.filters = new BlurFilter({ strength: 8 });\n *\n * // or multiple filters\n * sprite.filters = [new BlurFilter({ strength: 8 }), new HardMixBlend()];\n * ```\n *\n * Pixi has a number of built-in filters which can be used in your game or application:\n *\n * - {@link filters.AlphaFilter} - Applies alpha to the display object and any of its children.\n * - {@link filters.BlurFilter} - Applies a Gaussian blur to the display object.\n * - {@link filters.BlurFilterPass} - Applies a blur pass to an object.\n * - {@link filters.ColorBurnBlend} - Blend mode to add color burn to display objects.\n * - {@link filters.ColorDodgeBlend} - Blend mode to add color dodge to display objects.\n * - {@link filters.ColorMatrixFilter} - Transform the color channels by matrix multiplication.\n * - {@link filters.DarkenBlend} - Blend mode to darken display objects.\n * - {@link filters.DisplacementFilter} - Applies a displacement map to distort an object.\n * - {@link filters.DivideBlend} - Blend mode to divide display objects.\n * - {@link filters.HardMixBlend} - Blend mode to hard mix display objects.\n * - {@link filters.LinearBurnBlend} - Blend mode to add linear burn to display objects.\n * - {@link filters.LinearDodgeBlend} - Blend mode to add linear dodge to display objects.\n * - {@link filters.LinearLightBlend} - Blend mode to add linear light to display objects.\n * - {@link filters.NoiseFilter} - Applies random noise to an object.\n * - {@link filters.PinLightBlend} - Blend mode to add pin light to display objects.\n * - {@link filters.SubtractBlend} - Blend mode to subtract display objects.\n *\n * <br/>\n * For more available filters, check out the\n *  {@link https://pixijs.io/filters/docs/ pixi-filters} repository.\n *\n * You can also check out the awesome {@link https://pixijs.io/filters/examples/ Filter demo} to see\n * filters in action and combine them!\n * @namespace filters\n */\n\n/**\n * The options to use when creating a new filter.\n * @memberof filters\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (default 1)\n     * If 'inherit', the resolution of the render target is used.\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number | 'inherit';\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * If set to 'inherit', the filter will detect the antialiasing of the render target and change this automatically.\n     * Definitely don't set this to true if the render target has antialiasing set to false. As it will antialias,\n     * but you won't see the difference. (default 'off')\n     *\n     * This can be a boolean or [FilterAntialias]{@link filters.FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot of the area being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n    /**\n     * If this is set to true, the filter system will clip filter texture into viewport\n     * This is useful for filters that applied to whole texture.\n     * (default true)\n     */\n    clipToViewport?: boolean;\n}\n\n/** Filter options mixed with shader resources. A filter needs a shader and some resources to work. */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the render target settings\n * - `off` - (default) the filter is never antialiased regardless of the render target settings\n * - `inherit` - the filter uses the antialias settings of the render target\n * @memberof filters\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @class\n * @memberof filters\n */\nexport class Filter extends Shader\n{\n    /**\n     * The default filter settings\n     * @static\n     */\n    public static readonly defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n        clipToViewport: true,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number | 'inherit';\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * Clip texture into viewport or not\n     * @default true\n     */\n    public clipToViewport: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.blendMode = options.blendMode;\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n        this.clipToViewport = options.clipToViewport;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "var fragment = \"in vec2 vMaskCoord;\\nin vec2 vTextureCoord;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMaskTexture;\\n\\nuniform float uAlpha;\\nuniform vec4 uMaskClamp;\\nuniform float uInverse;\\n\\nout vec4 finalColor;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(uMaskClamp.x, vMaskCoord.x) +\\n        step(uMaskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, uMaskClamp.z) +\\n        step(vMaskCoord.y, uMaskClamp.w));\\n\\n    // TODO look into why this is needed\\n    float npmAlpha = uAlpha;\\n    vec4 original = texture(uTexture, vTextureCoord);\\n    vec4 masky = texture(uMaskTexture, vMaskCoord);\\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\\n\\n    float a = alphaMul * masky.r * npmAlpha * clip;\\n\\n    if (uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    finalColor = original * a;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=mask.frag.mjs.map\n", "var vertex = \"in vec2 aPosition;\\n\\nout vec2 vTextureCoord;\\nout vec2 vMaskCoord;\\n\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\nuniform mat3 uFilterMatrix;\\n\\nvec4 filterVertexPosition(  vec2 aPosition )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n       \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord(  vec2 aPosition )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvec2 getFilterCoord( vec2 aPosition )\\n{\\n    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}   \\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition(aPosition);\\n    vTextureCoord = filterTextureCoord(aPosition);\\n    vMaskCoord = getFilterCoord(aPosition);\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=mask.vert.mjs.map\n", "var source = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\nstruct MaskUniforms {\\n  uFilterMatrix:mat3x3<f32>,\\n  uMaskClamp:vec4<f32>,\\n  uAlpha:f32,\\n  uInverse:f32,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n@group(0) @binding(1) var uTexture: texture_2d<f32>;\\n@group(0) @binding(2) var uSampler : sampler;\\n\\n@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;\\n@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>,\\n    @location(1) filterUv : vec2<f32>,\\n};\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);\\n}\\n\\nfn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;\\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n\\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>,\\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition),\\n   getFilterCoord(aPosition)\\n  );\\n}\\n\\n@fragment\\nfn mainFragment(\\n  @location(0) uv: vec2<f32>,\\n  @location(1) filterUv: vec2<f32>,\\n  @builtin(position) position: vec4<f32>\\n) -> @location(0) vec4<f32> {\\n\\n    var maskClamp = filterUniforms.uMaskClamp;\\n    var uAlpha = filterUniforms.uAlpha;\\n\\n    var clip = step(3.5,\\n      step(maskClamp.x, filterUv.x) +\\n      step(maskClamp.y, filterUv.y) +\\n      step(filterUv.x, maskClamp.z) +\\n      step(filterUv.y, maskClamp.w));\\n\\n    var mask = textureSample(uMaskTexture, uSampler, filterUv);\\n    var source = textureSample(uTexture, uSampler, uv);\\n    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);\\n\\n    var a: f32 = alphaMul * mask.r * uAlpha * clip;\\n\\n    if (filterUniforms.uInverse == 1.0) {\\n        a = 1.0 - a;\\n    }\\n\\n    return source * a;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=mask.wgsl.mjs.map\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { GlProgram } from '../../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../../rendering/renderers/gpu/shader/GpuProgram';\nimport { UniformGroup } from '../../rendering/renderers/shared/shader/UniformGroup';\nimport { TextureMatrix } from '../../rendering/renderers/shared/texture/TextureMatrix';\nimport { Filter } from '../Filter';\nimport fragment from './mask.frag';\nimport vertex from './mask.vert';\nimport source from './mask.wgsl';\n\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { Sprite } from '../../scene/sprite/Sprite';\nimport type { FilterOptions } from '../Filter';\nimport type { FilterSystem } from '../FilterSystem';\n\nexport interface MaskFilterOptions extends FilterOptions\n{\n    sprite: Sprite,\n    inverse?: boolean;\n    scale?: number | { x: number, y: number },\n}\n\nexport class MaskFilter extends Filter\n{\n    public sprite: Sprite;\n    private readonly _textureMatrix: TextureMatrix;\n\n    constructor(options: MaskFilterOptions)\n    {\n        const { sprite, ...rest } = options;\n\n        const textureMatrix = new TextureMatrix(sprite.texture);\n\n        const filterUniforms = new UniformGroup({\n            uFilterMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uMaskClamp: { value: textureMatrix.uClampFrame, type: 'vec4<f32>' },\n            uAlpha: { value: 1, type: 'f32' },\n            uInverse: { value: options.inverse ? 1 : 0, type: 'f32' },\n        });\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'mask-filter',\n        });\n\n        super({\n            ...rest,\n            gpuProgram,\n            glProgram,\n            resources: {\n                filterUniforms,\n                uMaskTexture: sprite.texture.source,\n            },\n        });\n\n        this.sprite = sprite;\n\n        this._textureMatrix = textureMatrix;\n    }\n\n    set inverse(value: boolean)\n    {\n        this.resources.filterUniforms.uniforms.uInverse = value ? 1 : 0;\n    }\n\n    get inverse(): boolean\n    {\n        return this.resources.filterUniforms.uniforms.uInverse === 1;\n    }\n\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: Texture,\n        clearMode: boolean\n    ): void\n    {\n        // will trigger an update if the texture changed..\n        this._textureMatrix.texture = this.sprite.texture;\n\n        filterManager.calculateSpriteMatrix(\n            this.resources.filterUniforms.uniforms.uFilterMatrix as Matrix,\n            this.sprite\n        ).prepend(this._textureMatrix.mapCoord);\n\n        this.resources.uMaskTexture = this.sprite.texture.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskFilter } from '../../../filters/mask/MaskFilter';\nimport { Bounds } from '../../../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../../../scene/container/bounds/getGlobalBounds';\nimport { Sprite } from '../../../scene/sprite/Sprite';\nimport { BigPool } from '../../../utils/pool/PoolGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { TexturePool } from '../../renderers/shared/texture/TexturePool';\nimport { RendererType } from '../../renderers/types';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { PoolItem } from '../../../utils/pool/Pool';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { RenderTarget } from '../../renderers/shared/renderTarget/RenderTarget';\nimport type { Renderer } from '../../renderers/types';\nimport type { AlphaMask } from './AlphaMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nconst tempBounds = new Bounds();\n\nclass AlphaMaskEffect extends FilterEffect implements PoolItem\n{\n    constructor()\n    {\n        super();\n\n        this.filters = [new MaskFilter({\n            sprite: new Sprite(Texture.EMPTY),\n            inverse: false,\n            resolution: 'inherit',\n            antialias: 'inherit'\n        })];\n    }\n\n    get sprite(): Sprite\n    {\n        return (this.filters[0] as MaskFilter).sprite;\n    }\n\n    set sprite(value: Sprite)\n    {\n        (this.filters[0] as MaskFilter).sprite = value;\n    }\n\n    get inverse(): boolean\n    {\n        return (this.filters[0] as MaskFilter).inverse;\n    }\n\n    set inverse(value: boolean)\n    {\n        (this.filters[0] as MaskFilter).inverse = value;\n    }\n\n    public init: () => void;\n}\n\nexport interface AlphaMaskInstruction extends Instruction\n{\n    renderPipeId: 'alphaMask',\n    action: MaskMode,\n    mask: AlphaMask,\n    inverse: boolean;\n    maskedContainer: Container,\n    renderMask: boolean,\n}\n\nexport interface AlphaMaskData\n{\n    filterEffect: AlphaMaskEffect,\n    maskedContainer: Container,\n    previousRenderTarget?: RenderTarget,\n    filterTexture?: Texture,\n}\n\nexport class AlphaMaskPipe implements InstructionPipe<AlphaMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'alphaMask',\n    } as const;\n\n    private _renderer: Renderer;\n    private _activeMaskStage: AlphaMaskData[] = [];\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n            maskedContainer\n        } as AlphaMaskInstruction);\n\n        (mask as AlphaMask).inverse = maskedContainer._maskOptions.inverse;\n\n        if ((mask as AlphaMask).renderMaskToTexture)\n        {\n            const maskContainer = (mask as AlphaMask).mask;\n\n            maskContainer.includeInBuild = true;\n\n            maskContainer.collectRenderables(\n                instructionSet,\n                renderer,\n                null\n            );\n\n            maskContainer.includeInBuild = false;\n        }\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'pushMaskEnd',\n            mask,\n            maskedContainer,\n            inverse: maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public pop(mask: Effect, _maskedContainer: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'alphaMask',\n            action: 'popMaskEnd',\n            mask,\n            inverse: _maskedContainer._maskOptions.inverse,\n            canBundle: false,\n        } as AlphaMaskInstruction);\n    }\n\n    public execute(instruction: AlphaMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderMask = instruction.mask.renderMaskToTexture;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            const filterEffect = BigPool.get(AlphaMaskEffect);\n\n            filterEffect.inverse = instruction.inverse;\n\n            if (renderMask)\n            {\n                instruction.mask.mask.measurable = true;\n\n                const bounds = getGlobalBounds(instruction.mask.mask, true, tempBounds);\n\n                instruction.mask.mask.measurable = false;\n\n                bounds.ceil();\n\n                const colorTextureSource = renderer.renderTarget.renderTarget.colorTexture.source;\n                const filterTexture = TexturePool.getOptimalTexture(\n                    bounds.width,\n                    bounds.height,\n                    colorTextureSource._resolution,\n                    colorTextureSource.antialias\n                );\n\n                renderer.renderTarget.push(filterTexture, true);\n\n                renderer.globalUniforms.push({\n                    offset: bounds,\n                    worldColor: 0xFFFFFFFF\n                });\n\n                const sprite = filterEffect.sprite;\n\n                sprite.texture = filterTexture;\n\n                sprite.worldTransform.tx = bounds.minX;\n                sprite.worldTransform.ty = bounds.minY;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                    filterTexture,\n                });\n            }\n            else\n            {\n                filterEffect.sprite = instruction.mask.mask as Sprite;\n\n                this._activeMaskStage.push({\n                    filterEffect,\n                    maskedContainer: instruction.maskedContainer,\n                });\n            }\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            const maskData = this._activeMaskStage[this._activeMaskStage.length - 1];\n\n            if (renderMask)\n            {\n                // WebGPU blit's automatically, but WebGL does not!\n                if (renderer.type === RendererType.WEBGL)\n                {\n                    renderer.renderTarget.finishRenderPass();\n                }\n\n                renderer.renderTarget.pop();\n                renderer.globalUniforms.pop();\n            }\n\n            renderer.filter.push({\n                renderPipeId: 'filter',\n                action: 'pushFilter',\n                container: maskData.maskedContainer,\n                filterEffect: maskData.filterEffect,\n                canBundle: false,\n            });\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            renderer.filter.pop();\n\n            const maskData = this._activeMaskStage.pop();\n\n            if (renderMask)\n            {\n                TexturePool.returnTexture(maskData.filterTexture);\n            }\n\n            BigPool.return(maskData.filterEffect);\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this._activeMaskStage = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../../renderers/types';\nimport type { ColorMask } from './ColorMask';\n\nexport interface ColorMaskInstruction extends Instruction\n{\n    renderPipeId: 'colorMask',\n    colorMask: number,\n}\n\nexport class ColorMaskPipe implements InstructionPipe<ColorMaskInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: Renderer;\n    private _colorStack: number[] = [];\n    private _colorStackIndex = 0;\n    private _currentColor = 0;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public buildStart()\n    {\n        this._colorStack[0] = 0xF;\n        this._colorStackIndex = 1;\n        this._currentColor = 0xF;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        colorStack[this._colorStackIndex] = colorStack[this._colorStackIndex - 1] & (mask as ColorMask).mask;\n\n        const currentColor = this._colorStack[this._colorStackIndex];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n\n        this._colorStackIndex++;\n    }\n\n    public pop(_mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        const colorStack = this._colorStack;\n\n        this._colorStackIndex--;\n\n        const currentColor = colorStack[this._colorStackIndex - 1];\n\n        if (currentColor !== this._currentColor)\n        {\n            this._currentColor = currentColor;\n\n            instructionSet.add({\n                renderPipeId: 'colorMask',\n                colorMask: currentColor,\n                canBundle: false,\n            } as ColorMaskInstruction);\n        }\n    }\n\n    public execute(instruction: ColorMaskInstruction)\n    {\n        const renderer = this._renderer;\n\n        renderer.colorMask.setMask(instruction.colorMask);\n    }\n\n    public destroy()\n    {\n        this._colorStack = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { CLEAR } from '../../renderers/gl/const';\nimport { STENCIL_MODES } from '../../renderers/shared/state/const';\n\nimport type { Container } from '../../../scene/container/Container';\nimport type { Effect } from '../../../scene/container/Effect';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { InstructionPipe } from '../../renderers/shared/instructions/RenderPipe';\nimport type { Renderable } from '../../renderers/shared/Renderable';\nimport type { Renderer } from '../../renderers/types';\nimport type { StencilMask } from './StencilMask';\n\ntype MaskMode = 'pushMaskBegin' | 'pushMaskEnd' | 'popMaskBegin' | 'popMaskEnd';\n\nexport interface StencilMaskInstruction extends Instruction\n{\n    renderPipeId: 'stencilMask',\n    action: MaskMode,\n    inverse: boolean,\n    mask: StencilMask,\n}\n\nexport class StencilMaskPipe implements InstructionPipe<StencilMaskInstruction>\n{\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'stencilMask',\n    } as const;\n\n    private _renderer: Renderer;\n\n    // used when building and also when executing..\n    private _maskStackHash: Record<number, number> = {};\n\n    private _maskHash = new WeakMap<StencilMask, {\n        instructionsStart: number,\n        instructionsLength: number,\n    }>();\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public push(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskBegin',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskContainer = effect.mask;\n\n        maskContainer.includeInBuild = true;\n\n        if (!this._maskHash.has(effect))\n        {\n            this._maskHash.set(effect, {\n                instructionsStart: 0,\n                instructionsLength: 0,\n            });\n        }\n\n        const maskData = this._maskHash.get(effect);\n\n        maskData.instructionsStart = instructionSet.instructionSize;\n\n        maskContainer.collectRenderables(\n            instructionSet,\n            renderer,\n            null\n        );\n\n        maskContainer.includeInBuild = false;\n\n        renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'pushMaskEnd',\n            mask,\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const instructionsLength = instructionSet.instructionSize - maskData.instructionsStart - 1;\n\n        maskData.instructionsLength = instructionsLength;\n\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        this._maskStackHash[renderTargetUid] ??= 0;\n    }\n\n    public pop(mask: Effect, _container: Container, instructionSet: InstructionSet): void\n    {\n        const effect = mask as StencilMask;\n\n        const renderer = this._renderer;\n\n        // stencil is stored based on current render target..\n        renderer.renderPipes.batch.break(instructionSet);\n        renderer.renderPipes.blendMode.setBlendMode(effect.mask as Renderable, 'none', instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskBegin',\n            inverse: _container._maskOptions.inverse,\n            canBundle: false,\n        } as StencilMaskInstruction);\n\n        const maskData = this._maskHash.get(mask as StencilMask);\n\n        for (let i = 0; i < maskData.instructionsLength; i++)\n        {\n            // eslint-disable-next-line max-len\n            instructionSet.instructions[instructionSet.instructionSize++] = instructionSet.instructions[maskData.instructionsStart++];\n        }\n\n        instructionSet.add({\n            renderPipeId: 'stencilMask',\n            action: 'popMaskEnd',\n            canBundle: false,\n        });\n    }\n\n    public execute(instruction: StencilMaskInstruction)\n    {\n        const renderer = this._renderer;\n        const renderTargetUid = renderer.renderTarget.renderTarget.uid;\n\n        let maskStackIndex = this._maskStackHash[renderTargetUid] ??= 0;\n\n        if (instruction.action === 'pushMaskBegin')\n        {\n            // we create the depth and stencil buffers JIT\n            // as no point allocating the memory if we don't use it\n            renderer.renderTarget.ensureDepthStencil();\n\n            renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_ADD, maskStackIndex);\n\n            maskStackIndex++;\n\n            renderer.colorMask.setMask(0);\n        }\n        else if (instruction.action === 'pushMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n        else if (instruction.action === 'popMaskBegin')\n        {\n            renderer.colorMask.setMask(0);\n\n            if (maskStackIndex !== 0)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.RENDERING_MASK_REMOVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.renderTarget.clear(null, CLEAR.STENCIL);\n                renderer.stencil.setStencilMode(STENCIL_MODES.DISABLED, maskStackIndex);\n            }\n\n            maskStackIndex--;\n        }\n        else if (instruction.action === 'popMaskEnd')\n        {\n            if (instruction.inverse)\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.INVERSE_MASK_ACTIVE, maskStackIndex);\n            }\n            else\n            {\n                renderer.stencil.setStencilMode(STENCIL_MODES.MASK_ACTIVE, maskStackIndex);\n            }\n\n            renderer.colorMask.setMask(0xF);\n        }\n\n        this._maskStackHash[renderTargetUid] = maskStackIndex;\n    }\n\n    public destroy()\n    {\n        this._renderer = null;\n        this._maskStackHash = null;\n        this._maskHash = null;\n    }\n}\n", "import { Color } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { ColorSource, RgbaArray } from '../../../../color/Color';\nimport type { System } from '../system/System';\n\n/**\n * Options for the background system.\n * @property {ColorSource} [backgroundColor='black']\n * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n * @property {ColorSource} [background] - Alias for backgroundColor\n * @property {number} [backgroundAlpha=1] -\n * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n * @property {boolean} [clearBeforeRender=true] - Whether to clear the canvas before new render passes.\n * @memberof rendering\n */\nexport interface BackgroundSystemOptions\n{\n    /**\n     * The background color used to clear the canvas. See {@link ColorSource} for accepted color values.\n     * @memberof rendering.SharedRendererOptions\n     * @default 'black'\n     */\n    backgroundColor: ColorSource;\n    /**\n     * Alias for backgroundColor\n     * @memberof rendering.SharedRendererOptions\n     */\n    background?: ColorSource\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @memberof rendering.SharedRendererOptions\n     * @default 1\n     */\n    backgroundAlpha: number;\n    /**\n     * Whether to clear the canvas before new render passes.\n     * @memberof rendering.SharedRendererOptions\n     * @default true\n     */\n    clearBeforeRender: boolean;\n}\n\n/**\n * The background system manages the background color and alpha of the main view.\n * @memberof rendering\n */\nexport class BackgroundSystem implements System<BackgroundSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'background',\n        priority: 0,\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: BackgroundSystemOptions = {\n        /**\n         * {@link WebGLOptions.backgroundAlpha}\n         * @default 1\n         */\n        backgroundAlpha: 1,\n        /**\n         * {@link WebGLOptions.backgroundColor}\n         * @default 0x000000\n         */\n        backgroundColor: 0x0,\n        /**\n         * {@link WebGLOptions.clearBeforeRender}\n         * @default true\n         */\n        clearBeforeRender: true,\n    };\n\n    /**\n     * This sets if the CanvasRenderer will clear the canvas or not before the new render pass.\n     * If the scene is NOT transparent PixiJS will use a canvas sized fillRect operation every\n     * frame to set the canvas background color. If the scene is transparent PixiJS will use clearRect\n     * to clear the canvas every frame. Disable this by setting this to false. For example, if\n     * your game has a canvas filling background image you often don't need this set.\n     */\n    public clearBeforeRender: boolean;\n\n    private readonly _backgroundColor: Color;\n\n    constructor()\n    {\n        this.clearBeforeRender = true;\n\n        this._backgroundColor = new Color(0x000000);\n\n        this.color = this._backgroundColor; // run bg color setter\n        this.alpha = 1;\n    }\n\n    /**\n     * initiates the background system\n     * @param options - the options for the background colors\n     */\n    public init(options: BackgroundSystemOptions): void\n    {\n        options = { ...BackgroundSystem.defaultOptions, ...options };\n\n        this.clearBeforeRender = options.clearBeforeRender;\n        this.color = options.background || options.backgroundColor || this._backgroundColor; // run bg color setter\n        this.alpha = options.backgroundAlpha;\n\n        this._backgroundColor.setAlpha(options.backgroundAlpha);\n    }\n\n    /** The background color to fill if not transparent */\n    get color(): Color\n    {\n        return this._backgroundColor;\n    }\n\n    set color(value: ColorSource)\n    {\n        this._backgroundColor.setValue(value);\n    }\n\n    /** The background color alpha. Setting this to 0 will make the canvas transparent. */\n    get alpha(): number\n    {\n        return this._backgroundColor.alpha;\n    }\n\n    set alpha(value: number)\n    {\n        this._backgroundColor.setAlpha(value);\n    }\n\n    /** The background color as an [R, G, B, A] array. */\n    get colorRgba(): RgbaArray\n    {\n        return this._backgroundColor.toArray() as RgbaArray;\n    }\n\n    /**\n     * destroys the background system\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        // No cleanup required\n    }\n}\n", "import { extensions, ExtensionType } from '../../../../extensions/Extensions';\nimport { FilterEffect } from '../../../../filters/FilterEffect';\nimport { warn } from '../../../../utils/logging/warn';\n\nimport type { BlendModeFilter } from '../../../../filters/blend-modes/BlendModeFilter';\nimport type { FilterInstruction } from '../../../../filters/FilterSystem';\nimport type { Renderer } from '../../types';\nimport type { Instruction } from '../instructions/Instruction';\nimport type { InstructionSet } from '../instructions/InstructionSet';\nimport type { InstructionPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { BLEND_MODES } from '../state/const';\n\ninterface AdvancedBlendInstruction extends Instruction\n{\n    renderPipeId: 'blendMode',\n    blendMode: BLEND_MODES,\n    activeBlend: Renderable[],\n}\n\n// class map\nconst BLEND_MODE_FILTERS: Partial<Record<BLEND_MODES, new () => BlendModeFilter>> = {} as const;\n\nextensions.handle(ExtensionType.BlendMode, (value) =>\n{\n    if (!value.name)\n    {\n        throw new Error('BlendMode extension must have a name property');\n    }\n    BLEND_MODE_FILTERS[value.name as BLEND_MODES] = value.ref;\n}, (value) =>\n{\n    delete BLEND_MODE_FILTERS[value.name as BLEND_MODES];\n});\n\n/**\n * This Pipe handles the blend mode switching of the renderer.\n * It will insert instructions into the {@link renderers.InstructionSet} to switch the blend mode according to the\n * blend modes of the scene graph.\n *\n * This pipe is were wwe handle Advanced blend modes. Advanced blend modes essentially wrap the renderables\n * in a filter that applies the blend mode.\n *\n * You only need to use this class if you are building your own render instruction set rather than letting PixiJS build\n * the instruction set for you by traversing the scene graph\n * @memberof rendering\n */\nexport class BlendModePipe implements InstructionPipe<AdvancedBlendInstruction>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'blendMode',\n    } as const;\n\n    private _renderer: Renderer;\n\n    private _renderableList: Renderable[];\n    private _activeBlendMode: BLEND_MODES;\n\n    private _isAdvanced = false;\n\n    private _filterHash: Partial<Record<BLEND_MODES, FilterEffect>> = Object.create(null);\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        this._renderer.runners.prerender.add(this);\n    }\n\n    public prerender()\n    {\n        // make sure we reset the blend modes to normal\n        // this way the next render will register any changes\n        this._activeBlendMode = 'normal';\n        this._isAdvanced = false;\n    }\n\n    /**\n     * This ensures that a blendMode switch is added to the instruction set if the blend mode has changed.\n     * @param renderable - The renderable we are adding to the instruction set\n     * @param blendMode - The blend mode of the renderable\n     * @param instructionSet - The instruction set we are adding to\n     */\n    public setBlendMode(renderable: Renderable, blendMode: BLEND_MODES, instructionSet: InstructionSet)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            if (this._isAdvanced) this._renderableList.push(renderable);\n\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n\n        this._isAdvanced = !!BLEND_MODE_FILTERS[blendMode];\n\n        if (this._isAdvanced)\n        {\n            this._beginAdvancedBlendMode(instructionSet);\n\n            this._renderableList.push(renderable);\n        }\n    }\n\n    private _beginAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        const blendMode = this._activeBlendMode;\n\n        if (!BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS])\n        {\n            // #if _DEBUG\n            warn(`Unable to assign BlendMode: '${blendMode}'. `\n            + `You may want to include: import 'pixi.js/advanced-blend-modes'`);\n            // #endif\n\n            return;\n        }\n\n        let filterEffect = this._filterHash[blendMode];\n\n        // this does need an execute?\n        if (!filterEffect)\n        {\n            filterEffect = this._filterHash[blendMode] = new FilterEffect();\n\n            filterEffect.filters = [new BLEND_MODE_FILTERS[blendMode as keyof typeof BLEND_MODE_FILTERS]()];\n        }\n\n        const instruction: FilterInstruction = {\n            renderPipeId: 'filter',\n            action: 'pushFilter',\n            renderables: [],\n            filterEffect,\n            canBundle: false,\n        };\n\n        this._renderableList = instruction.renderables;\n        instructionSet.add(instruction);\n    }\n\n    private _endAdvancedBlendMode(instructionSet: InstructionSet)\n    {\n        this._renderableList = null;\n        this._renderer.renderPipes.batch.break(instructionSet);\n\n        instructionSet.add({\n            renderPipeId: 'filter',\n            action: 'popFilter',\n            canBundle: false,\n        });\n    }\n\n    /**\n     * called when the instruction build process is starting this will reset internally to the default blend mode\n     * @internal\n     * @ignore\n     */\n    public buildStart()\n    {\n        this._isAdvanced = false;\n    }\n\n    /**\n     * called when the instruction build process is finished, ensuring that if there is an advanced blend mode\n     * active, we add the final render instructions added to the instruction set\n     * @param instructionSet - The instruction set we are adding to\n     * @internal\n     * @ignore\n     */\n    public buildEnd(instructionSet: InstructionSet)\n    {\n        if (this._isAdvanced)\n        {\n            this._endAdvancedBlendMode(instructionSet);\n        }\n    }\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public destroy()\n    {\n        this._renderer = null;\n        this._renderableList = null;\n\n        for (const i in this._filterHash)\n        {\n            this._filterHash[i as BLEND_MODES].destroy();\n        }\n\n        this._filterHash = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Container } from '../../../../scene/container/Container';\nimport { Texture } from '../texture/Texture';\n\nimport type { ColorSource } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { GetPixelsOutput } from '../texture/GenerateCanvas';\nimport type { GenerateTextureOptions } from './GenerateTextureSystem';\n\nconst imageTypes = {\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    webp: 'image/webp',\n};\n\ntype Formats = keyof typeof imageTypes;\n\n/**\n * Options for creating an image from a renderer.\n * @memberof rendering\n */\nexport interface ImageOptions\n{\n    /** The format of the image. */\n    format?: Formats;\n    /** The quality of the image. */\n    quality?: number;\n}\n\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport interface BaseExtractOptions\n{\n    /** The target to extract. */\n    target: Container | Texture;\n    /** The region of the target to extract. */\n    frame?: Rectangle;\n    /** The resolution of the extracted content. */\n    resolution?: number;\n    /** The color used to clear the extracted content. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n}\n/**\n * Options for extracting an HTMLImage from the renderer.\n * @memberof rendering\n */\nexport type ExtractImageOptions = BaseExtractOptions & ImageOptions;\n/**\n * Options for extracting and downloading content from a renderer.\n * @memberof rendering\n */\nexport type ExtractDownloadOptions = BaseExtractOptions & {\n    /** The filename to use when downloading the content. */\n    filename: string;\n};\n/**\n * Options for extracting content from a renderer.\n * @memberof rendering\n */\nexport type ExtractOptions = BaseExtractOptions | ExtractImageOptions | ExtractDownloadOptions;\n\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.extract` property.\n * @example\n * import { Application, Graphics } from 'pixi.js';\n *\n * // Create a new application (extract will be auto-added to renderer)\n * const app = new Application();\n * await app.init();\n *\n * // Draw a red circle\n * const graphics = new Graphics()\n *     .circle(0, 0, 50);\n *     .fill(0xFF0000)\n *\n * // Render the graphics as an HTMLImageElement\n * const image = await app.renderer.extract.image(graphics);\n * document.body.appendChild(image);\n * @memberof rendering\n */\nexport class ExtractSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'extract',\n    } as const;\n\n    /** Default options for creating an image. */\n    public static defaultImageOptions: ImageOptions = {\n        /** The format of the image. */\n        format: 'png' as Formats,\n        /** The quality of the image. */\n        quality: 1,\n    };\n\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    private _normalizeOptions<T extends ExtractOptions>(\n        options: ExtractImageOptions | Container | Texture,\n        defaults: Partial<T> = {},\n    ): T\n    {\n        if (options instanceof Container || options instanceof Texture)\n        {\n            return {\n                target: options,\n                ...defaults\n            } as T;\n        }\n\n        return {\n            ...defaults,\n            ...options,\n        } as T;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     * @param options - The options for creating the image, or the target to extract\n     * @returns - HTML Image of the target\n     */\n    public async image(options: ExtractImageOptions | Container | Texture): Promise<HTMLImageElement>\n    {\n        const image = new Image();\n\n        image.src = await this.base64(options);\n\n        return image;\n    }\n\n    /**\n     * Will return a base64 encoded string of this target. It works by calling\n     * `Extract.canvas` and then running toDataURL on that.\n     * @param options - The options for creating the image, or the target to extract\n     */\n    public async base64(options: ExtractImageOptions | Container | Texture): Promise<string>\n    {\n        options = this._normalizeOptions<ExtractImageOptions>(\n            options,\n            ExtractSystem.defaultImageOptions\n        );\n\n        const { format, quality } = options;\n\n        const canvas = this.canvas(options);\n\n        if (canvas.toBlob !== undefined)\n        {\n            return new Promise<string>((resolve, reject) =>\n            {\n                canvas.toBlob!((blob) =>\n                {\n                    if (!blob)\n                    {\n                        reject(new Error('ICanvas.toBlob failed!'));\n\n                        return;\n                    }\n\n                    const reader = new FileReader();\n\n                    reader.onload = () => resolve(reader.result as string);\n                    reader.onerror = reject;\n                    reader.readAsDataURL(blob);\n                }, imageTypes[format], quality);\n            });\n        }\n        if (canvas.toDataURL !== undefined)\n        {\n            return canvas.toDataURL(imageTypes[format], quality);\n        }\n        if (canvas.convertToBlob !== undefined)\n        {\n            const blob = await canvas.convertToBlob({ type: imageTypes[format], quality });\n\n            return new Promise<string>((resolve, reject) =>\n            {\n                const reader = new FileReader();\n\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n\n        throw new Error('Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, '\n            + 'or ICanvas.convertToBlob to be implemented');\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     * @param options - The options for creating the canvas, or the target to extract\n     * @returns - A Canvas element with the texture rendered on.\n     */\n    public canvas(options: ExtractOptions | Container | Texture): ICanvas\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n\n        if (target instanceof Texture)\n        {\n            return renderer.texture.generateCanvas(target);\n        }\n\n        const texture = renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const canvas = renderer.texture.generateCanvas(texture);\n\n        texture.destroy(true);\n\n        return canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     * @param options - The options for extracting the image, or the target to extract\n     * @returns - One-dimensional array containing the pixel data of the entire texture\n     */\n    public pixels(options: ExtractOptions | Container | Texture): GetPixelsOutput\n    {\n        options = this._normalizeOptions(options);\n\n        const target = options.target;\n\n        const renderer = this._renderer;\n        const texture = target instanceof Texture\n            ? target\n            : renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n\n        const pixelInfo = renderer.texture.getPixels(texture);\n\n        if (target instanceof Container)\n        {\n            // destroy generated texture\n            texture.destroy(true);\n        }\n\n        return pixelInfo;\n    }\n\n    /**\n     * Will return a texture of the target\n     * @param options - The options for creating the texture, or the target to extract\n     * @returns - A texture of the target\n     */\n    public texture(options: ExtractOptions | Container | Texture): Texture\n    {\n        options = this._normalizeOptions(options);\n\n        if (options.target instanceof Texture) return options.target;\n\n        return this._renderer.textureGenerator.generateTexture(options as GenerateTextureOptions);\n    }\n\n    /**\n     * Will extract a HTMLImage of the target and download it\n     * @param options - The options for downloading and extracting the image, or the target to extract\n     */\n    public download(options: ExtractDownloadOptions | Container | Texture)\n    {\n        options = this._normalizeOptions<ExtractDownloadOptions>(options);\n\n        const canvas = this.canvas(options);\n\n        const link = document.createElement('a');\n\n        link.download = options.filename ?? 'image.png';\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n\n    /**\n     * Logs the target to the console as an image. This is a useful way to debug what's happening in the renderer.\n     * @param options - The options for logging the image, or the target to log\n     */\n    public log(options: (ExtractOptions & {width?: number}) | Container | Texture)\n    {\n        const width = options.width ?? 200;\n\n        options = this._normalizeOptions(options);\n\n        const canvas = this.canvas(options);\n\n        const base64 = canvas.toDataURL();\n\n        // eslint-disable-next-line no-console\n        console.log(`[Pixi Texture] ${canvas.width}px ${canvas.height}px`);\n\n        const style = [\n            'font-size: 1px;',\n            `padding: ${width}px ${300}px;`,\n            `background: url(${base64}) no-repeat;`,\n            'background-size: contain;',\n        ].join(' ');\n\n        // eslint-disable-next-line no-console\n        console.log('%c ', style);\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "import { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\n/**\n * A render texture, extends `Texture`.\n * @see {@link rendering.Texture}\n * @memberof rendering\n */\nexport class RenderTexture extends Texture\n{\n    public static create(options: TextureSourceOptions): RenderTexture\n    {\n        return new RenderTexture({\n            source: new TextureSource(options)\n        });\n    }\n\n    /**\n     * Resizes the render texture.\n     * @param width - The new width of the render texture.\n     * @param height - The new height of the render texture.\n     * @param resolution - The new resolution of the render texture.\n     * @returns This texture.\n     */\n    public resize(width: number, height: number, resolution?: number): this\n    {\n        this.source.resize(width, height, resolution);\n\n        return this;\n    }\n}\n", "import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): RenderTexture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        target.source.updateMipmaps();\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Point } from '../../../../maths/point/Point';\nimport { color32BitToUniform } from '../../../../scene/graphics/gpu/colorToUniform';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { type Renderer, RendererType } from '../../types';\nimport { UniformGroup } from '../shader/UniformGroup';\n\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { GlRenderTargetSystem } from '../../gl/renderTarget/GlRenderTargetSystem';\nimport type { GpuRenderTargetSystem } from '../../gpu/renderTarget/GpuRenderTargetSystem';\nimport type { WebGPURenderer } from '../../gpu/WebGPURenderer';\nimport type { UboSystem } from '../shader/UboSystem';\nimport type { System } from '../system/System';\n\nexport type GlobalUniformGroup = UniformGroup<{\n    uProjectionMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldTransformMatrix: { value: Matrix; type: 'mat3x3<f32>' }\n    uWorldColorAlpha: { value: Float32Array; type: 'vec4<f32>' }\n    uResolution: { value: number[]; type: 'vec2<f32>' }\n}>;\n\nexport interface GlobalUniformOptions\n{\n    size?: number[],\n    projectionMatrix?: Matrix,\n    worldTransformMatrix?: Matrix\n    worldColor?: number\n    offset?: PointData\n}\n\nexport interface GlobalUniformData\n{\n    projectionMatrix: Matrix\n    worldTransformMatrix: Matrix\n    worldColor: number\n    resolution: number[]\n    offset: PointData\n    bindGroup: BindGroup\n}\n\nexport interface GlobalUniformRenderer\n{\n    renderTarget: GlRenderTargetSystem | GpuRenderTargetSystem\n    renderPipes: Renderer['renderPipes'];\n    ubo: UboSystem;\n    type: RendererType;\n}\n\n/**\n * System plugin to the renderer to manage global uniforms for the renderer.\n * @memberof rendering\n */\nexport class GlobalUniformSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'globalUniforms',\n    } as const;\n\n    private readonly _renderer: GlobalUniformRenderer;\n\n    private _stackIndex = 0;\n    private _globalUniformDataStack: GlobalUniformData[] = [];\n\n    private readonly _uniformsPool: GlobalUniformGroup[] = [];\n    private readonly _activeUniforms: GlobalUniformGroup[] = [];\n\n    private readonly _bindGroupPool: BindGroup[] = [];\n    private readonly _activeBindGroups: BindGroup[] = [];\n\n    private _currentGlobalUniformData: GlobalUniformData;\n\n    constructor(renderer: GlobalUniformRenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public reset()\n    {\n        this._stackIndex = 0;\n\n        for (let i = 0; i < this._activeUniforms.length; i++)\n        {\n            this._uniformsPool.push(this._activeUniforms[i]);\n        }\n\n        for (let i = 0; i < this._activeBindGroups.length; i++)\n        {\n            this._bindGroupPool.push(this._activeBindGroups[i]);\n        }\n\n        this._activeUniforms.length = 0;\n        this._activeBindGroups.length = 0;\n    }\n\n    public start(options: GlobalUniformOptions): void\n    {\n        this.reset();\n\n        this.push(options);\n    }\n\n    public bind({\n        size,\n        projectionMatrix,\n        worldTransformMatrix,\n        worldColor,\n        offset,\n    }: GlobalUniformOptions)\n    {\n        const renderTarget = this._renderer.renderTarget.renderTarget;\n\n        const currentGlobalUniformData = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {\n            projectionData: renderTarget,\n            worldTransformMatrix: new Matrix(),\n            worldColor: 0xFFFFFFFF,\n            offset: new Point(),\n        };\n\n        const globalUniformData: GlobalUniformData = {\n            projectionMatrix: projectionMatrix || this._renderer.renderTarget.projectionMatrix,\n            resolution: size || renderTarget.size,\n            worldTransformMatrix: worldTransformMatrix || currentGlobalUniformData.worldTransformMatrix,\n            worldColor: worldColor || currentGlobalUniformData.worldColor,\n            offset: offset || currentGlobalUniformData.offset,\n            bindGroup: null,\n        };\n\n        const uniformGroup = this._uniformsPool.pop() || this._createUniforms();\n\n        this._activeUniforms.push(uniformGroup);\n\n        const uniforms = uniformGroup.uniforms;\n\n        uniforms.uProjectionMatrix = globalUniformData.projectionMatrix;\n\n        uniforms.uResolution = globalUniformData.resolution;\n\n        uniforms.uWorldTransformMatrix.copyFrom(globalUniformData.worldTransformMatrix);\n\n        uniforms.uWorldTransformMatrix.tx -= globalUniformData.offset.x;\n        uniforms.uWorldTransformMatrix.ty -= globalUniformData.offset.y;\n\n        color32BitToUniform(\n            globalUniformData.worldColor,\n            uniforms.uWorldColorAlpha,\n            0\n        );\n\n        uniformGroup.update();\n\n        let bindGroup: BindGroup;\n\n        if ((this._renderer as WebGPURenderer).renderPipes.uniformBatch)\n        {\n            bindGroup = (this._renderer as WebGPURenderer).renderPipes.uniformBatch.getUniformBindGroup(uniformGroup, false);\n        }\n        else\n        {\n            bindGroup = this._bindGroupPool.pop() || new BindGroup();\n            this._activeBindGroups.push(bindGroup);\n            bindGroup.setResource(uniformGroup, 0);\n        }\n\n        globalUniformData.bindGroup = bindGroup;\n\n        this._currentGlobalUniformData = globalUniformData;\n    }\n\n    public push(options: GlobalUniformOptions)\n    {\n        this.bind(options);\n\n        this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData;\n    }\n\n    public pop()\n    {\n        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1];\n\n        // for webGL we need to update the uniform group here\n        // as we are not using bind groups\n        if (this._renderer.type === RendererType.WEBGL)\n        {\n            (this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup).update();\n        }\n    }\n\n    get bindGroup(): BindGroup\n    {\n        return this._currentGlobalUniformData.bindGroup;\n    }\n\n    get globalUniformData()\n    {\n        return this._currentGlobalUniformData;\n    }\n\n    get uniformGroup()\n    {\n        return this._currentGlobalUniformData.bindGroup.resources[0] as UniformGroup;\n    }\n\n    private _createUniforms(): GlobalUniformGroup\n    {\n        const globalUniforms = new UniformGroup({\n            uProjectionMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uWorldTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            // TODO - someone smart - set this to be a unorm8x4 rather than a vec4<f32>\n            uWorldColorAlpha: { value: new Float32Array(4), type: 'vec4<f32>' },\n            uResolution: { value: [0, 0], type: 'vec2<f32>' },\n        }, {\n            isStatic: true,\n        });\n\n        return globalUniforms;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Ticker } from '../../../ticker/Ticker';\n\nimport type { System } from './system/System';\n\n// start at one too keep it positive!\nlet uid = 1;\n\n/**\n * The SchedulerSystem manages scheduled tasks with specific intervals.\n * @memberof rendering\n */\nexport class SchedulerSystem implements System<null>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'scheduler',\n        priority: 0,\n    } as const;\n\n    private readonly _tasks: {\n        func: (elapsed: number) => void;\n        duration: number;\n        offset: number\n        start: number;\n        last: number;\n        repeat: boolean;\n        id: number;\n    }[] = [];\n\n    /** a small off set to apply to the repeat schedules. This is just to make sure they run at slightly different times */\n    private _offset = 0;\n\n    /** Initializes the scheduler system and starts the ticker. */\n    public init(): void\n    {\n        Ticker.system.add(this._update, this);\n    }\n\n    /**\n     * Schedules a repeating task.\n     * @param func - The function to execute.\n     * @param duration - The interval duration in milliseconds.\n     * @param useOffset - this will spread out tasks so that they do not all run at the same time\n     * @returns The unique identifier for the scheduled task.\n     */\n    public repeat(func: (elapsed: number) => void, duration: number, useOffset = true): number\n    {\n        const id = uid++;\n\n        let offset = 0;\n\n        if (useOffset)\n        {\n            this._offset += 1000;\n            offset = this._offset;\n        }\n\n        this._tasks.push({\n            func,\n            duration,\n            start: performance.now(),\n            offset,\n            last: performance.now(),\n            repeat: true,\n            id\n        });\n\n        return id;\n    }\n\n    /**\n     * Cancels a scheduled task.\n     * @param id - The unique identifier of the task to cancel.\n     */\n    public cancel(id: number): void\n    {\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            if (this._tasks[i].id === id)\n            {\n                this._tasks.splice(i, 1);\n\n                return;\n            }\n        }\n    }\n\n    /**\n     * Updates and executes the scheduled tasks.\n     * @private\n     */\n    private _update(): void\n    {\n        const now = performance.now();\n\n        for (let i = 0; i < this._tasks.length; i++)\n        {\n            const task = this._tasks[i];\n\n            if ((now - task.offset) - task.last >= task.duration)\n            {\n                const elapsed = now - task.start;\n\n                task.func(elapsed);\n                task.last = now;\n            }\n        }\n    }\n\n    /**\n     * Destroys the scheduler system and removes all tasks.\n     * @internal\n     * @ignore\n     */\n    public destroy(): void\n    {\n        Ticker.system.remove(this._update, this);\n\n        this._tasks.length = 0;\n    }\n}\n", "import { DOMAdapter } from '../environment/adapter';\nimport { VERSION } from './const';\n\nlet saidHello = false;\n\n/**\n * Prints out the version and renderer information for this running instance of PixiJS.\n * @param type - The name of the renderer this instance is using.\n * @returns {void}\n */\nexport function sayHello(type: string): void\n{\n    if (saidHello)\n    {\n        return;\n    }\n\n    if (DOMAdapter.get().getNavigator().userAgent.toLowerCase().indexOf('chrome') > -1)\n    {\n        const args = [\n            `%c  %c  %c  %c  %c PixiJS %c v${VERSION} (${type}) http://www.pixijs.com/\\n\\n`,\n            'background: #E72264; padding:5px 0;',\n            'background: #6CA2EA; padding:5px 0;',\n            'background: #B5D33D; padding:5px 0;',\n            'background: #FED23F; padding:5px 0;',\n            'color: #FFFFFF; background: #E72264; padding:5px 0;',\n            'color: #E72264; background: #FFFFFF; padding:5px 0;',\n        ];\n\n        globalThis.console.log(...args);\n    }\n    else if (globalThis.console)\n    {\n        globalThis.console.log(`PixiJS ${VERSION} - ${type} - http://www.pixijs.com/`);\n    }\n\n    saidHello = true;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { sayHello } from '../../../../utils/sayHello';\nimport { type Renderer, RendererType } from '../../types';\n\nimport type { WebGLRenderer } from '../../gl/WebGLRenderer';\nimport type { System } from '../system/System';\n\n/**\n * Options for the startup system.\n * @property {boolean} [hello=false] - Whether to log the version and type information of renderer to console.\n * @memberof rendering\n */\nexport interface HelloSystemOptions\n{\n    /**\n     * Whether to log the version and type information of renderer to console.\n     * @memberof rendering.SharedRendererOptions\n     * @default false\n     */\n    hello: boolean;\n}\n\n/**\n * A simple system responsible for initiating the renderer.\n * @memberof rendering\n */\nexport class HelloSystem implements System<HelloSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'hello',\n        priority: -2,\n    } as const;\n\n    /** The default options for the system. */\n    public static defaultOptions: HelloSystemOptions = {\n        /** {@link WebGLOptions.hello} */\n        hello: false,\n    };\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * It all starts here! This initiates every system, passing in the options for any system by name.\n     * @param options - the config for the renderer and all its systems\n     */\n    public init(options: HelloSystemOptions): void\n    {\n        if (options.hello)\n        {\n            let name = this._renderer.name;\n\n            if (this._renderer.type === RendererType.WEBGL)\n            {\n                name += ` ${(this._renderer as WebGLRenderer).context.webGLVersion}`;\n            }\n\n            sayHello(name);\n        }\n    }\n}\n", "/**\n * Takes a hash and removes all the `undefined`/`null` values from it.\n * In PixiJS, we tend to null properties instead of using 'delete' for performance reasons.\n * However, in some cases, this could be a problem if the hash grows too large over time,\n * this function can be used to clean a hash.\n * @param hash - The hash to clean.\n * @returns A new hash with all the `undefined`/`null` values removed.\n * @memberof utils\n */\nexport function cleanHash<T>(hash: Record<string, T>): Record<string, T>\n{\n    let clean = false;\n\n    for (const i in hash)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (hash[i] == undefined)\n        {\n            clean = true;\n            break;\n        }\n    }\n\n    if (!clean) return hash;\n\n    const cleanHash = Object.create(null);\n\n    for (const i in hash)\n    {\n        const value = hash[i];\n\n        if (value)\n        {\n            cleanHash[i] = value;\n        }\n    }\n\n    return cleanHash;\n}\n\n/**\n * Removes all `undefined`/`null` elements from the given array and compacts the array.\n *\n * This function iterates through the array, shifting non-undefined elements to the left\n * to fill gaps created by `undefined` elements. The length of the array is then adjusted\n * to remove the trailing `undefined` elements.\n * @param arr - The array to be cleaned.\n * @returns The cleaned array with all `undefined` elements removed.\n * @example\n * // Example usage:\n * const arr = [1, undefined, 2, undefined, 3];\n * const cleanedArr = cleanArray(arr);\n * console.log(cleanedArr); // Output: [1, 2, 3]\n * @memberof utils\n */\nexport function cleanArray<T>(arr: T[]): T[]\n{\n    let offset = 0;\n\n    for (let i = 0; i < arr.length; i++)\n    {\n        // eslint-disable-next-line eqeqeq\n        if (arr[i] == undefined)\n        {\n            offset++;\n        }\n        else\n        {\n            arr[i - offset] = arr[i];\n        }\n    }\n\n    arr.length -= offset;\n\n    return arr;\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { type RenderGroup } from '../../../../scene/container/RenderGroup';\nimport { cleanArray, cleanHash } from '../../../../utils/data/clean';\nimport { type RenderOptions } from '../system/AbstractRenderer';\n\nimport type { Container } from '../../../../scene/container/Container';\nimport type { Renderer } from '../../types';\nimport type { RenderPipe } from '../instructions/RenderPipe';\nimport type { Renderable } from '../Renderable';\nimport type { System } from '../system/System';\n\nlet renderableGCTick = 0;\n\n/**\n * Options for the {@link RenderableGCSystem}.\n * @memberof rendering\n * @property {boolean} [renderableGCActive=true] - If set to true, this will enable the garbage collector on the renderables.\n * @property {number} [renderableGCAMaxIdle=60000] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [renderableGCCheckCountMax=60000] - time between two garbage collections.\n */\nexport interface RenderableGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCActive: boolean;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCMaxUnusedTime: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    renderableGCFrequency: number;\n}\n\n/**\n * The RenderableGCSystem is responsible for cleaning up GPU resources that are no longer being used.\n *\n * When rendering objects like sprites, text, etc - GPU resources are created and managed by the renderer.\n * If these objects are no longer needed but not properly destroyed (via sprite.destroy()), their GPU resources\n * would normally leak. This system prevents that by automatically cleaning up unused GPU resources.\n *\n * Key features:\n * - Runs every 30 seconds by default to check for unused resources\n * - Cleans up resources not rendered for over 1 minute\n * - Works independently of rendering - will clean up even when not actively rendering\n * - When cleaned up resources are needed again, new GPU objects are quickly assigned from a pool\n * - Can be disabled with renderableGCActive:false for manual control\n *\n * Best practices:\n * - Always call destroy() explicitly when done with renderables (e.g. sprite.destroy())\n * - This system is a safety net, not a replacement for proper cleanup\n * - Adjust frequency and timeouts via options if needed\n *\n * Example:\n * ```js\n * // Sprite created but reference lost without destroy\n * let sprite = new Sprite(texture);\n *\n * // internally the renderer will assign a resource to the sprite\n * renderer.render(sprite);\n *\n * sprite = null; // Reference lost but GPU resources still exist\n *\n * // After 1 minute of not being rendered:\n * // - RenderableGC will clean up the sprite's GPU resources\n * // - JS garbage collector can then clean up the sprite itself\n * ```\n * @implements {System<RenderableGCSystemOptions>}\n */\nexport class RenderableGCSystem implements System<RenderableGCSystemOptions>\n{\n    /**\n     * Extension metadata for registering this system with the renderer.\n     * @ignore\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'renderableGC',\n        priority: 0\n    } as const;\n\n    /**\n     * Default configuration options for the garbage collection system.\n     * These can be overridden when initializing the renderer.\n     */\n    public static defaultOptions: RenderableGCSystemOptions = {\n        /** Enable/disable the garbage collector */\n        renderableGCActive: true,\n        /** Time in ms before an unused resource is collected (default 1 minute) */\n        renderableGCMaxUnusedTime: 60000,\n        /** How often to run garbage collection in ms (default 30 seconds) */\n        renderableGCFrequency: 30000,\n    };\n\n    /** Maximum time in ms a resource can be unused before being garbage collected */\n    public maxUnusedTime: number;\n\n    /** Reference to the renderer this system belongs to */\n    private _renderer: Renderer;\n\n    /** Array of renderables being tracked for garbage collection */\n    private readonly _managedRenderables: Renderable[] = [];\n    /** ID of the main GC scheduler handler */\n    private _handler: number;\n    /** How frequently GC runs in ms */\n    private _frequency: number;\n    /** Current timestamp used for age calculations */\n    private _now: number;\n\n    /** Array of hash objects being tracked for cleanup */\n    private readonly _managedHashes: {context: any, hash: string}[] = [];\n    /** ID of the hash cleanup scheduler handler */\n    private _hashHandler: number;\n\n    /** Array of arrays being tracked for cleanup */\n    private readonly _managedArrays: {context: any, hash: string}[] = [];\n    /** ID of the array cleanup scheduler handler */\n    private _arrayHandler: number;\n\n    /**\n     * Creates a new RenderableGCSystem instance.\n     * @param renderer - The renderer this garbage collection system works for\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * Initializes the garbage collection system with the provided options.\n     * @param options - Configuration options for the renderer\n     */\n    public init(options: RenderableGCSystemOptions): void\n    {\n        options = { ...RenderableGCSystem.defaultOptions, ...options };\n\n        this.maxUnusedTime = options.renderableGCMaxUnusedTime;\n        this._frequency = options.renderableGCFrequency;\n\n        this.enabled = options.renderableGCActive;\n    }\n\n    /**\n     * Gets whether the garbage collection system is currently enabled.\n     * @returns True if GC is enabled, false otherwise\n     */\n    get enabled(): boolean\n    {\n        return !!this._handler;\n    }\n\n    /**\n     * Enables or disables the garbage collection system.\n     * When enabled, schedules periodic cleanup of resources.\n     * When disabled, cancels all scheduled cleanups.\n     */\n    set enabled(value: boolean)\n    {\n        if (this.enabled === value) return;\n\n        if (value)\n        {\n            // Schedule periodic garbage collection\n            this._handler = this._renderer.scheduler.repeat(\n                () => this.run(),\n                this._frequency,\n                false\n            );\n\n            // Schedule periodic hash table cleanup\n            this._hashHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const hash of this._managedHashes)\n                    {\n                        hash.context[hash.hash] = cleanHash(hash.context[hash.hash]);\n                    }\n                },\n                this._frequency\n            );\n\n            // Schedule periodic array cleanup\n            this._arrayHandler = this._renderer.scheduler.repeat(\n                () =>\n                {\n                    for (const array of this._managedArrays)\n                    {\n                        cleanArray(array.context[array.hash]);\n                    }\n                },\n                this._frequency\n            );\n        }\n        else\n        {\n            // Cancel all scheduled cleanups\n            this._renderer.scheduler.cancel(this._handler);\n            this._renderer.scheduler.cancel(this._hashHandler);\n            this._renderer.scheduler.cancel(this._arrayHandler);\n        }\n    }\n\n    /**\n     * Adds a hash table to be managed by the garbage collector.\n     * @param context - The object containing the hash table\n     * @param hash - The property name of the hash table\n     */\n    public addManagedHash<T>(context: T, hash: string): void\n    {\n        this._managedHashes.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Adds an array to be managed by the garbage collector.\n     * @param context - The object containing the array\n     * @param hash - The property name of the array\n     */\n    public addManagedArray<T>(context: T, hash: string): void\n    {\n        this._managedArrays.push({ context, hash: hash as string });\n    }\n\n    /**\n     * Updates the GC timestamp and tracking before rendering.\n     * @param options - The render options\n     * @param options.container - The container to render\n     */\n    public prerender({\n        container\n    }: RenderOptions): void\n    {\n        this._now = performance.now();\n\n        // The gcTick is a monotonically increasing counter that tracks render cycles\n        // Each time we render, we increment the global renderableGCTick counter\n        // and assign the new tick value to the render group being rendered.\n        // This lets us know which render groups were rendered in the current frame\n        // versus ones that haven't been rendered recently.\n        // The instruction set also gets updated with this tick value to track\n        // when its renderables were last used.\n        container.renderGroup.gcTick = renderableGCTick++;\n\n        this._updateInstructionGCTick(container.renderGroup, container.renderGroup.gcTick);\n    }\n\n    /**\n     * Starts tracking a renderable for garbage collection.\n     * @param renderable - The renderable to track\n     */\n    public addRenderable(renderable: Renderable): void\n    {\n        if (!this.enabled) return;\n\n        if (renderable._lastUsed === -1)\n        {\n            this._managedRenderables.push(renderable);\n            renderable.once('destroyed', this._removeRenderable, this);\n        }\n\n        renderable._lastUsed = this._now;\n    }\n\n    /**\n     * Performs garbage collection by cleaning up unused renderables.\n     * Removes renderables that haven't been used for longer than maxUnusedTime.\n     */\n    public run(): void\n    {\n        const now = this._now;\n        const managedRenderables = this._managedRenderables;\n        const renderPipes = this._renderer.renderPipes;\n        let offset = 0;\n\n        for (let i = 0; i < managedRenderables.length; i++)\n        {\n            const renderable = managedRenderables[i];\n\n            if (renderable === null)\n            {\n                offset++;\n                continue;\n            }\n\n            const renderGroup = renderable.renderGroup ?? renderable.parentRenderGroup;\n            const currentTick = renderGroup?.instructionSet?.gcTick ?? -1;\n\n            // Update last used time if the renderable's group was rendered this tick\n            if ((renderGroup?.gcTick ?? 0) === currentTick)\n            {\n                renderable._lastUsed = now;\n            }\n\n            // Clean up if unused for too long\n            if (now - renderable._lastUsed > this.maxUnusedTime)\n            {\n                if (!renderable.destroyed)\n                {\n                    const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n                    if (renderGroup)renderGroup.structureDidChange = true;\n\n                    rp[renderable.renderPipeId].destroyRenderable(renderable);\n                }\n\n                renderable._lastUsed = -1;\n                offset++;\n                renderable.off('destroyed', this._removeRenderable, this);\n            }\n            else\n            {\n                managedRenderables[i - (offset)] = renderable;\n            }\n        }\n\n        managedRenderables.length -= offset;\n    }\n\n    /** Cleans up the garbage collection system. Disables GC and removes all tracked resources. */\n    public destroy(): void\n    {\n        this.enabled = false;\n        this._renderer = null as any as Renderer;\n        this._managedRenderables.length = 0;\n        this._managedHashes.length = 0;\n        this._managedArrays.length = 0;\n    }\n\n    /**\n     * Removes a renderable from being tracked when it's destroyed.\n     * @param renderable - The renderable to stop tracking\n     */\n    private _removeRenderable(renderable: Container): void\n    {\n        const index = this._managedRenderables.indexOf(renderable as Renderable);\n\n        if (index >= 0)\n        {\n            renderable.off('destroyed', this._removeRenderable, this);\n            this._managedRenderables[index] = null;\n        }\n    }\n\n    /**\n     * Updates the GC tick counter for a render group and its children.\n     * @param renderGroup - The render group to update\n     * @param gcTick - The new tick value\n     */\n    private _updateInstructionGCTick(renderGroup: RenderGroup, gcTick: number): void\n    {\n        renderGroup.instructionSet.gcTick = gcTick;\n\n        for (const child of renderGroup.renderGroupChildren)\n        {\n            this._updateInstructionGCTick(child, gcTick);\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\n\n/**\n * Options for the {@link TextureGCSystem}.\n * @memberof rendering\n * @property {boolean} [textureGCActive=true] - If set to true, this will enable the garbage collector on the GPU.\n * @property {number} [textureGCAMaxIdle=60 * 60] -\n * The maximum idle frames before a texture is destroyed by garbage collection.\n * @property {number} [textureGCCheckCountMax=600] - Frames between two garbage collections.\n */\nexport interface TextureGCSystemOptions\n{\n    /**\n     * If set to true, this will enable the garbage collector on the GPU.\n     * @default true\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCActive: boolean;\n    /**\n     * @deprecated since 8.3.0\n     * @see {@link TextureGCSystem.textureGCMaxIdle}\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCAMaxIdle: number;\n    /**\n     * The maximum idle frames before a texture is destroyed by garbage collection.\n     * @default 60 * 60\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCMaxIdle: number;\n    /**\n     * Frames between two garbage collections.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    textureGCCheckCountMax: number;\n}\n/**\n * System plugin to the renderer to manage texture garbage collection on the GPU,\n * ensuring that it does not get clogged up with textures that are no longer being used.\n * @memberof rendering\n */\nexport class TextureGCSystem implements System<TextureGCSystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGC',\n    } as const;\n\n    /** default options for the TextureGCSystem */\n    public static defaultOptions: TextureGCSystemOptions = {\n        /**\n         * If set to true, this will enable the garbage collector on the GPU.\n         * @default true\n         */\n        textureGCActive: true,\n        /**\n         * @deprecated since 8.3.0\n         * @see {@link TextureGCSystem.textureGCMaxIdle}\n         */\n        textureGCAMaxIdle: null,\n        /**\n         * The maximum idle frames before a texture is destroyed by garbage collection.\n         * @default 60 * 60\n         */\n        textureGCMaxIdle: 60 * 60,\n        /**\n         * Frames between two garbage collections.\n         * @default 600\n         */\n        textureGCCheckCountMax: 600,\n    };\n\n    /**\n     * Frame count since started.\n     * @readonly\n     */\n    public count: number;\n\n    /**\n     * Frame count since last garbage collection.\n     * @readonly\n     */\n    public checkCount: number;\n\n    /**\n     * Maximum idle frames before a texture is destroyed by garbage collection.\n     * @see TextureGCSystem.defaultMaxIdle\n     */\n    public maxIdle: number;\n\n    /**\n     * Frames between two garbage collections.\n     * @see TextureGCSystem.defaultCheckCountMax\n     */\n    public checkCountMax: number;\n\n    /**\n     * Current garbage collection mode.\n     * @see TextureGCSystem.defaultMode\n     */\n    public active: boolean;\n    private _renderer: Renderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n    }\n\n    public init(options: TextureGCSystemOptions): void\n    {\n        options = { ...TextureGCSystem.defaultOptions, ...options };\n\n        this.checkCountMax = options.textureGCCheckCountMax;\n        this.maxIdle = options.textureGCAMaxIdle ?? options.textureGCMaxIdle;\n        this.active = options.textureGCActive;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    protected postrender(): void\n    {\n        if (!this._renderer.renderingToScreen)\n        {\n            return;\n        }\n\n        this.count++;\n\n        if (!this.active) return;\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used.\n     * If the texture has not been used for a specified amount of time, it will be removed from the GPU.\n     */\n    public run(): void\n    {\n        const managedTextures = this._renderer.texture.managedTextures;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // Only supports non generated textures at the moment!\n            if (\n                texture.autoGarbageCollect\n                && texture.resource\n                && texture._touched > -1\n                && this.count - texture._touched > this.maxIdle\n            )\n            {\n                texture._touched = -1;\n                texture.unload();\n            }\n        }\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null as any as Renderer;\n    }\n}\n", "// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    /** unique id for this render target */\n    public readonly uid: number = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n    /** if true, then when the render target is destroyed, it will destroy all the textures that were created for it. */\n    private readonly _managedColorTextures: boolean = false;\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            this._managedColorTextures = true;\n\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this._managedColorTextures)\n        {\n            this.colorTextures.forEach((texture) =>\n            {\n                texture.destroy();\n            });\n        }\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n", "import { CanvasSource } from '../sources/CanvasSource';\nimport { Texture } from '../Texture';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { CanvasSourceOptions } from '../sources/CanvasSource';\n\nconst canvasCache: Map<ICanvas, Texture<CanvasSource>> = new Map();\n\nexport function getCanvasTexture(canvas: ICanvas, options?: CanvasSourceOptions): Texture<CanvasSource>\n{\n    if (!canvasCache.has(canvas))\n    {\n        const texture = new Texture({\n            source: new CanvasSource({\n                resource: canvas,\n                ...options,\n            })\n        });\n\n        const onDestroy = () =>\n        {\n            if (canvasCache.get(canvas) === texture)\n            {\n                canvasCache.delete(canvas);\n            }\n        };\n\n        texture.once('destroy', onDestroy);\n        texture.source.once('destroy', onDestroy);\n\n        canvasCache.set(canvas, texture);\n    }\n\n    return canvasCache.get(canvas);\n}\n\nexport function hasCachedCanvasTexture(canvas: ICanvas): boolean\n{\n    return canvasCache.has(canvas);\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { RenderTarget } from '../renderTarget/RenderTarget';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { TypeOrBool } from '../../../../scene/container/destroyTypes';\nimport type { System } from '../system/System';\nimport type { CanvasSource } from '../texture/sources/CanvasSource';\nimport type { Texture } from '../texture/Texture';\n\n/**\n * Options passed to the ViewSystem\n * @memberof rendering\n * @property {number} [width=800] - The width of the screen.\n * @property {number} [height=600] - The height of the screen.\n * @property {ICanvas} [canvas] - The canvas to use as a view, optional.\n * @property {boolean} [autoDensity=false] - Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n *  This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n * @property {number} [resolution] - The resolution / device pixel ratio of the renderer.\n * @property {boolean} [antialias=false] - Whether to enable anti-aliasing. This may affect performance.\n * @property {boolean} [depth] -\n * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n * @property {boolean} [multiView] - TODO: multiView\n * @property {number} [backgroundAlpha] - The alpha of the background.\n */\nexport interface ViewSystemOptions\n{\n    /**\n     * The width of the screen.\n     * @default 800\n     * @memberof rendering.SharedRendererOptions\n     */\n    width?: number;\n    /**\n     * The height of the screen.\n     * @default 600\n     * @memberof rendering.SharedRendererOptions\n     */\n    height?: number;\n    /**\n     * The canvas to use as a view, optional.\n     * @memberof rendering.SharedRendererOptions\n     */\n    canvas?: ICanvas;\n    /** @deprecated */\n    view?: ICanvas;\n    /**\n     * Resizes renderer view in CSS pixels to allow for resolutions other than 1.\n     *\n     * This is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     * @memberof rendering.SharedRendererOptions\n     */\n    autoDensity?: boolean;\n    /**\n     * The resolution / device pixel ratio of the renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    resolution?: number;\n    /**\n     * Whether to enable anti-aliasing. This may affect performance.\n     * @memberof rendering.SharedRendererOptions\n     */\n    antialias?: boolean;\n    /**\n     * Whether to ensure the main view has can make use of the depth buffer. Always true for WebGL renderer.\n     * @memberof rendering.SharedRendererOptions\n     */\n    depth?: boolean;\n\n    /**\n     * Transparency of the background color, value from `0` (fully transparent) to `1` (fully opaque).\n     * @default 1\n     */\n    backgroundAlpha?: number;\n}\n\nexport interface ViewSystemDestroyOptions\n{\n    /** Whether to remove the view element from the DOM. Defaults to `false`. */\n    removeView?: boolean;\n}\n\n/**\n * The view system manages the main canvas that is attached to the DOM.\n * This main role is to deal with how the holding the view reference and dealing with how it is resized.\n * @memberof rendering\n */\nexport class ViewSystem implements System<ViewSystemOptions, TypeOrBool<ViewSystemDestroyOptions>>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n            ExtensionType.CanvasSystem,\n        ],\n        name: 'view',\n        priority: 0,\n    } as const;\n\n    /** The default options for the view system. */\n    public static defaultOptions: ViewSystemOptions = {\n        /**\n         * {@link WebGLOptions.width}\n         * @default 800\n         */\n        width: 800,\n        /**\n         * {@link WebGLOptions.height}\n         * @default 600\n         */\n        height: 600,\n        /**\n         * {@link WebGLOptions.autoDensity}\n         * @default false\n         */\n        autoDensity: false,\n        /**\n         * {@link WebGLOptions.antialias}\n         * @default false\n         */\n        antialias: false,\n    };\n\n    /** The canvas element that everything is drawn to. */\n    public canvas!: ICanvas;\n\n    /** The texture that is used to draw the canvas to the screen. */\n    public texture: Texture<CanvasSource>;\n\n    /**\n     * Whether CSS dimensions of canvas view should be resized to screen dimensions automatically.\n     * This is only supported for HTMLCanvasElement and will be ignored if the canvas is an OffscreenCanvas.\n     * @member {boolean}\n     */\n    public get autoDensity(): boolean\n    {\n        return this.texture.source.autoDensity;\n    }\n    public set autoDensity(value: boolean)\n    {\n        this.texture.source.autoDensity = value;\n    }\n\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    public antialias: boolean;\n\n    /**\n     * Measurements of the screen. (0, 0, screenWidth, screenHeight).\n     *\n     * Its safe to use as filterArea or hitArea for the whole stage.\n     */\n    public screen: Rectangle;\n    /** The render target that the view is drawn to. */\n    public renderTarget: RenderTarget;\n\n    /** The resolution / device pixel ratio of the renderer. */\n    get resolution(): number\n    {\n        return this.texture.source._resolution;\n    }\n\n    set resolution(value: number)\n    {\n        this.texture.source.resize(\n            this.texture.source.width,\n            this.texture.source.height,\n            value\n        );\n    }\n\n    /**\n     * initiates the view system\n     * @param options - the options for the view\n     */\n    public init(options: ViewSystemOptions): void\n    {\n        options = {\n            ...ViewSystem.defaultOptions,\n            ...options,\n        };\n\n        if (options.view)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'ViewSystem.view has been renamed to ViewSystem.canvas');\n            // #endif\n\n            options.canvas = options.view;\n        }\n\n        this.screen = new Rectangle(0, 0, options.width, options.height);\n        this.canvas = options.canvas || DOMAdapter.get().createCanvas();\n        this.antialias = !!options.antialias;\n        this.texture = getCanvasTexture(this.canvas, options);\n        this.renderTarget = new RenderTarget({\n            colorTextures: [this.texture],\n            depth: !!options.depth,\n            isRoot: true,\n        });\n\n        this.texture.source.transparent = options.backgroundAlpha < 1;\n        this.resolution = options.resolution;\n    }\n\n    /**\n     * Resizes the screen and canvas to the specified dimensions.\n     * @param desiredScreenWidth - The new width of the screen.\n     * @param desiredScreenHeight - The new height of the screen.\n     * @param resolution\n     */\n    public resize(desiredScreenWidth: number, desiredScreenHeight: number, resolution: number): void\n    {\n        this.texture.source.resize(desiredScreenWidth, desiredScreenHeight, resolution);\n\n        this.screen.width = this.texture.frame.width;\n        this.screen.height = this.texture.frame.height;\n    }\n\n    /**\n     * Destroys this System and optionally removes the canvas from the dom.\n     * @param {options | false} options - The options for destroying the view, or \"false\".\n     * @param options.removeView - Whether to remove the view element from the DOM. Defaults to `false`.\n     */\n    public destroy(options: TypeOrBool<ViewSystemDestroyOptions> = false): void\n    {\n        const removeView = typeof options === 'boolean' ? options : !!options?.removeView;\n\n        if (removeView && this.canvas.parentNode)\n        {\n            this.canvas.parentNode.removeChild(this.canvas);\n        }\n\n        // note: don't nullify the element\n        //       other systems may need to unbind from it during the destroy iteration (eg. GLContextSystem)\n    }\n}\n", "import { CustomRenderPipe } from '../../../../scene/container/CustomRenderPipe';\nimport { RenderGroupPipe } from '../../../../scene/container/RenderGroupPipe';\nimport { RenderGroupSystem } from '../../../../scene/container/RenderGroupSystem';\nimport { SpritePipe } from '../../../../scene/sprite/SpritePipe';\nimport { RendererInitHook } from '../../../../utils/global/globalHooks';\nimport { BatcherPipe } from '../../../batcher/shared/BatcherPipe';\nimport { AlphaMaskPipe } from '../../../mask/alpha/AlphaMaskPipe';\nimport { ColorMaskPipe } from '../../../mask/color/ColorMaskPipe';\nimport { StencilMaskPipe } from '../../../mask/stencil/StencilMaskPipe';\nimport { BackgroundSystem } from '../background/BackgroundSystem';\nimport { BlendModePipe } from '../blendModes/BlendModePipe';\nimport { ExtractSystem } from '../extract/ExtractSystem';\nimport { GenerateTextureSystem } from '../extract/GenerateTextureSystem';\nimport { GlobalUniformSystem } from '../renderTarget/GlobalUniformSystem';\nimport { SchedulerSystem } from '../SchedulerSystem';\nimport { HelloSystem } from '../startup/HelloSystem';\nimport { RenderableGCSystem } from '../texture/RenderableGCSystem';\nimport { TextureGCSystem } from '../texture/TextureGCSystem';\nimport { ViewSystem } from '../view/ViewSystem';\n\nimport type { ExtractRendererOptions } from './utils/typeUtils';\n\nexport const SharedSystems = [\n    BackgroundSystem,\n    GlobalUniformSystem,\n    HelloSystem,\n    ViewSystem,\n    RenderGroupSystem,\n    TextureGCSystem,\n    GenerateTextureSystem,\n    ExtractSystem,\n    RendererInitHook,\n    RenderableGCSystem,\n    SchedulerSystem,\n];\n\nexport const SharedRenderPipes = [\n    BlendModePipe,\n    BatcherPipe,\n    SpritePipe,\n    RenderGroupPipe,\n    AlphaMaskPipe,\n    StencilMaskPipe,\n    ColorMaskPipe,\n    CustomRenderPipe\n];\n\n/**\n * Options for the shared systems of a renderer.\n * @memberof rendering\n */\nexport interface SharedRendererOptions extends ExtractRendererOptions<typeof SharedSystems>, PixiMixins.RendererOptions\n{\n    /**\n     * Whether to stop PixiJS from dynamically importing default extensions for the renderer.\n     * It is false by default, and means PixiJS will load all the default extensions, based\n     * on the environment e.g browser/webworker.\n     * If you set this to true, then you will need to manually import the systems and extensions you need.\n     *\n     * e.g.\n     * ```js\n     * import 'accessibility';\n     * import 'app';\n     * import 'events';\n     * import 'spritesheet';\n     * import 'graphics';\n     * import 'mesh';\n     * import 'text';\n     * import 'text-bitmap';\n     * import 'text-html';\n     * import { autoDetectRenderer } from 'pixi.js';\n     *\n     * const renderer = await autoDetectRenderer({\n     *   width: 800,\n     *   height: 600,\n     *   skipExtensionImports: true,\n     * });\n     * ```\n     * @default false\n     */\n    skipExtensionImports?: boolean;\n    /**\n     * @default true\n     * @deprecated since 8.1.6\n     * @see `skipExtensionImports`\n     */\n    manageImports?: boolean;\n}\n", "export const textureBit = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* wgsl */`\n\n        struct TextureUniforms {\n            uTextureMatrix:mat3x3<f32>,\n        }\n\n        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;\n        `,\n        main: /* wgsl */`\n            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            @group(2) @binding(0) var uTexture: texture_2d<f32>;\n            @group(2) @binding(1) var uSampler: sampler;\n\n         \n        `,\n        main: /* wgsl */`\n            outColor = textureSample(uTexture, uSampler, vUV);\n        `\n    }\n};\n\nexport const textureBitGl = {\n    name: 'texture-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTextureMatrix;\n        `,\n        main: /* glsl */`\n            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n        uniform sampler2D uTexture;\n\n         \n        `,\n        main: /* glsl */`\n            outColor = texture(uTexture, vUV);\n        `\n    }\n};\n\n", "import { unsafeEvalSupported } from '../../../../utils/browser/unsafeEvalSupported';\nimport { Buffer } from '../buffer/Buffer';\nimport { BufferUsage } from '../buffer/const';\n\nimport type { System } from '../system/System';\nimport type { UboElement, UboLayout, UniformData, UniformsSyncCallback } from './types';\nimport type { UniformGroup } from './UniformGroup';\n\nexport interface UboAdaptor\n{\n    createUboElements: (uniformData: UniformData[]) => UboLayout;\n    generateUboSync: (uboElements: UboElement[]) => UniformsSyncCallback;\n}\n\n/**\n * System plugin to the renderer to manage uniform buffers.\n * @memberof rendering\n */\nexport class UboSystem implements System\n{\n    /** Cache of uniform buffer layouts and sync functions, so we don't have to re-create them */\n    private _syncFunctionHash: Record<string, {\n        layout: UboLayout,\n        syncFunction: (uniforms: Record<string, any>, data: Float32Array, dataInt32: Int32Array, offset: number) => void\n    }> = Object.create(null);\n\n    private readonly _adaptor: UboAdaptor;\n\n    constructor(adaptor: UboAdaptor)\n    {\n        this._adaptor = adaptor;\n\n        // Validation check that this environment support `new Function`\n        this._systemCheck();\n    }\n\n    /**\n     * Overridable function by `pixi.js/unsafe-eval` to silence\n     * throwing an error if platform doesn't support unsafe-evals.\n     * @private\n     */\n    private _systemCheck(): void\n    {\n        if (!unsafeEvalSupported())\n        {\n            throw new Error('Current environment does not allow unsafe-eval, '\n                 + 'please use pixi.js/unsafe-eval module to enable support.');\n        }\n    }\n\n    public ensureUniformGroup(uniformGroup: UniformGroup): void\n    {\n        const uniformData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n    }\n\n    public getUniformGroupData(uniformGroup: UniformGroup)\n    {\n        return this._syncFunctionHash[uniformGroup._signature] || this._initUniformGroup(uniformGroup);\n    }\n\n    private _initUniformGroup(uniformGroup: UniformGroup)\n    {\n        const uniformGroupSignature = uniformGroup._signature;\n\n        let uniformData = this._syncFunctionHash[uniformGroupSignature];\n\n        if (!uniformData)\n        {\n            const elements = Object.keys(uniformGroup.uniformStructures).map((i) => uniformGroup.uniformStructures[i]);\n\n            const layout = this._adaptor.createUboElements(elements);\n\n            const syncFunction = this._generateUboSync(layout.uboElements);\n\n            uniformData = this._syncFunctionHash[uniformGroupSignature] = {\n                layout,\n                syncFunction\n            };\n        }\n\n        return this._syncFunctionHash[uniformGroupSignature];\n    }\n\n    private _generateUboSync(\n        uboElements: UboElement[],\n    ): UniformsSyncCallback\n    {\n        return this._adaptor.generateUboSync(uboElements);\n    }\n\n    public syncUniformGroup(uniformGroup: UniformGroup, data?: Float32Array, offset?: number): boolean\n    {\n        const uniformGroupData = this.getUniformGroupData(uniformGroup);\n\n        uniformGroup.buffer ||= new Buffer({\n            data: new Float32Array(uniformGroupData.layout.size / 4),\n            usage: BufferUsage.UNIFORM | BufferUsage.COPY_DST,\n        });\n\n        let dataInt32: Int32Array = null;\n\n        if (!data)\n        {\n            data = uniformGroup.buffer.data as Float32Array;\n            dataInt32 = uniformGroup.buffer.dataInt32;\n        }\n        offset ||= 0;\n\n        uniformGroupData.syncFunction(uniformGroup.uniforms, data, dataInt32, offset);\n\n        return true;\n    }\n\n    public updateUniformGroup(uniformGroup: UniformGroup): boolean\n    {\n        if (uniformGroup.isStatic && !uniformGroup._dirtyId) return false;\n        uniformGroup._dirtyId = 0;\n\n        const synced = this.syncUniformGroup(uniformGroup);\n\n        uniformGroup.buffer.update();\n\n        return synced;\n    }\n\n    public destroy(): void\n    {\n        this._syncFunctionHash = null;\n    }\n}\n", "// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\nexport interface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: `\n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n", "import { uniformParsers } from './uniformParsers';\n\nimport type { UboElement, UNIFORM_TYPES_SINGLE, UniformsSyncCallback } from '../types';\n\nexport function createUboSyncFunction(\n    uboElements: UboElement[],\n    parserCode: 'uboWgsl' | 'uboStd40',\n    arrayGenerationFunction: (uboElement: UboElement, offsetToAdd: number) => string,\n    singleSettersMap: Record<UNIFORM_TYPES_SINGLE, string>,\n): UniformsSyncCallback\n{\n    const funcFragments = [`\n        var v = null;\n        var v2 = null;\n        var t = 0;\n        var index = 0;\n        var name = null;\n        var arrayOffset = null;\n    `];\n\n    let prev = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        const name = uboElement.data.name;\n\n        let parsed = false;\n        let offset = 0;\n\n        for (let j = 0; j < uniformParsers.length; j++)\n        {\n            const uniformParser = uniformParsers[j];\n\n            if (uniformParser.test(uboElement.data))\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(\n                    `name = \"${name}\";`,\n                    `offset += ${offset - prev};`,\n                    uniformParsers[j][parserCode] || uniformParsers[j].ubo);\n                parsed = true;\n\n                break;\n            }\n        }\n\n        if (!parsed)\n        {\n            if (uboElement.data.size > 1)\n            {\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(arrayGenerationFunction(uboElement, offset - prev));\n            }\n            else\n            {\n                const template = singleSettersMap[uboElement.data.type as UNIFORM_TYPES_SINGLE];\n\n                offset = uboElement.offset / 4;\n\n                funcFragments.push(/* wgsl */`\n                    v = uv.${name};\n                    offset += ${offset - prev};\n                    ${template};\n                `);\n            }\n        }\n\n        prev = offset;\n    }\n\n    const fragmentSrc = funcFragments.join('\\n');\n\n    // eslint-disable-next-line no-new-func\n    return new Function(\n        'uv',\n        'data',\n        'dataInt32',\n        'offset',\n        fragmentSrc,\n    ) as UniformsSyncCallback;\n}\n", "import type { UNIFORM_TYPES_SINGLE } from '../types';\n\nfunction loopMatrix(col: number, row: number)\n{\n    const total = col * row;\n\n    return `\n        for (let i = 0; i < ${total}; i++) {\n            data[offset + (((i / ${col})|0) * 4) + (i % ${col})] = v[i];\n        }\n    `;\n}\n\nexport const uboSyncFunctionsSTD40: Record<UNIFORM_TYPES_SINGLE, string> = {\n    f32: `\n        data[offset] = v;`,\n    i32: `\n        dataInt32[offset] = v;`,\n    'vec2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];`,\n    'vec3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];`,\n    'vec4<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];`,\n    'vec2<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];`,\n    'vec3<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];`,\n    'vec4<i32>': `\n        dataInt32[offset] = v[0];\n        dataInt32[offset + 1] = v[1];\n        dataInt32[offset + 2] = v[2];\n        dataInt32[offset + 3] = v[3];`,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 4] = v[2];\n        data[offset + 5] = v[3];`,\n    'mat3x3<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 4] = v[3];\n        data[offset + 5] = v[4];\n        data[offset + 6] = v[5];\n        data[offset + 8] = v[6];\n        data[offset + 9] = v[7];\n        data[offset + 10] = v[8];`,\n    'mat4x4<f32>': `\n        for (let i = 0; i < 16; i++) {\n            data[offset + i] = v[i];\n        }`,\n    'mat3x2<f32>': loopMatrix(3, 2),\n    'mat4x2<f32>': loopMatrix(4, 2),\n    'mat2x3<f32>': loopMatrix(2, 3),\n    'mat4x3<f32>': loopMatrix(4, 3),\n    'mat2x4<f32>': loopMatrix(2, 4),\n    'mat3x4<f32>': loopMatrix(3, 4),\n};\n\nexport const uboSyncFunctionsWGSL: Record<UNIFORM_TYPES_SINGLE, string> = {\n    ...uboSyncFunctionsSTD40,\n    'mat2x2<f32>': `\n        data[offset] = v[0];\n        data[offset + 1] = v[1];\n        data[offset + 2] = v[2];\n        data[offset + 3] = v[3];\n    `,\n};\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from './Buffer';\n\n/**\n * A resource that can be bound to a bind group and used in a shader.\n * Whilst a buffer can be used as a resource, this class allows you to specify an offset and size of the buffer to use.\n * This is useful if you have a large buffer and only part of it is used in a shader.\n *\n * This resource, will listen for changes on the underlying buffer and emit a itself if the buffer changes shape.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array(1000),\n *    usage: BufferUsage.UNIFORM,\n * });\n * // Create a buffer resource that uses the first 100 bytes of a buffer\n * const bufferResource = new BufferResource({\n *    buffer,\n *    offset: 0,\n *    size: 100,\n * });\n * @memberof rendering\n */\nexport class BufferResource extends EventEmitter<{\n    change: BindResource,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'bufferResource';\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /** the underlying buffer that this resource is using */\n    public buffer: Buffer;\n    /** the offset of the buffer this resource is using. If not provided, then it will use the offset of the buffer. */\n    public readonly offset: number;\n    /** the size of the buffer this resource is using. If not provided, then it will use the size of the buffer. */\n    public readonly size: number;\n    /**\n     * A cheeky hint to the GL renderer to let it know this is a BufferResource\n     * @internal\n     * @ignore\n     */\n    public readonly _bufferResource = true;\n\n    /**\n     * Has the Buffer resource been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Create a new Buffer Resource.\n     * @param options - The options for the buffer resource\n     * @param options.buffer - The underlying buffer that this resource is using\n     * @param options.offset - The offset of the buffer this resource is using.\n     * If not provided, then it will use the offset of the buffer.\n     * @param options.size - The size of the buffer this resource is using.\n     * If not provided, then it will use the size of the buffer.\n     */\n    constructor({ buffer, offset, size }: { buffer: Buffer; offset?: number; size?: number; })\n    {\n        super();\n\n        this.buffer = buffer;\n        this.offset = offset | 0;\n        this.size = size;\n\n        this.buffer.on('change', this.onBufferChange, this);\n    }\n\n    protected onBufferChange(): void\n    {\n        this._resourceId = uid('resource');\n\n        this.emit('change', this);\n    }\n\n    /**\n     * Destroys this resource. Make sure the underlying buffer is not used anywhere else\n     * if you want to destroy it as well, or code will explode\n     * @param destroyBuffer - Should the underlying buffer be destroyed as well?\n     */\n    public destroy(destroyBuffer = false): void\n    {\n        this.destroyed = true;\n\n        if (destroyBuffer)\n        {\n            this.buffer.destroy();\n        }\n\n        this.emit('change', this);\n\n        this.buffer = null;\n    }\n}\n", "import { warn } from '../../../../../utils/logging/warn';\nimport { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { Geometry } from '../../../shared/geometry/Geometry';\nimport type { ExtractedAttributeData } from './extractAttributesFromGlProgram';\n\n/**\n * This function looks at the attribute information provided to the geometry and attempts\n * to fill in an gaps. WE do this by looking at the extracted data from the shader and\n * making best guesses.\n *\n * Most of th etime users don't need to provide all the attribute info beyond the data itself, so we\n * can fill in the gaps for them. If you are using attributes in a more advanced way, you can\n * don't forget to add all the info at creation!\n * @param geometry - the geometry to ensure attributes for\n * @param extractedData - the extracted data from the shader\n */\nexport function ensureAttributes(\n    geometry: Geometry,\n    extractedData: Record<string, ExtractedAttributeData>\n): void\n{\n    for (const i in geometry.attributes)\n    {\n        const attribute = geometry.attributes[i];\n        const attributeData = extractedData[i];\n\n        if (attributeData)\n        {\n            attribute.format ??= attributeData.format;\n            attribute.offset ??= attributeData.offset;\n            attribute.instance ??= attributeData.instance;\n        }\n        else\n        {\n            // eslint-disable-next-line max-len\n            warn(`Attribute ${i} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`);\n        }\n    }\n\n    ensureStartAndStride(geometry);\n}\n\nfunction ensureStartAndStride(geometry: Geometry): void\n{\n    const { buffers, attributes } = geometry;\n\n    const tempStride: Record<string, number> = {};\n    const tempStart: Record<string, number> = {};\n\n    for (const j in buffers)\n    {\n        const buffer = buffers[j];\n\n        tempStride[buffer.uid] = 0;\n        tempStart[buffer.uid] = 0;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        tempStride[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n\n    for (const j in attributes)\n    {\n        const attribute = attributes[j];\n\n        attribute.stride ??= tempStride[attribute.buffer.uid];\n\n        attribute.start ??= tempStart[attribute.buffer.uid];\n\n        tempStart[attribute.buffer.uid] += getAttributeInfoFromFormat(attribute.format).stride;\n    }\n}\n", "import { STENCIL_MODES } from '../../shared/state/const';\n\nexport interface StencilState\n{\n    stencilWriteMask?: number\n    stencilReadMask?: number;\n    stencilFront?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    },\n    stencilBack?: {\n        compare: 'always' | 'equal' | 'not-equal';\n        passOp: 'increment-clamp' | 'decrement-clamp' | 'keep' | 'replace';\n    }\n}\n\nexport const GpuStencilModesToPixi: StencilState[] = [];\n\nGpuStencilModesToPixi[STENCIL_MODES.NONE] = undefined;\n\nGpuStencilModesToPixi[STENCIL_MODES.DISABLED] = {\n    stencilWriteMask: 0,\n    stencilReadMask: 0,\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_ADD] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'increment-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.RENDERING_MASK_REMOVE] = {\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'decrement-clamp',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n    stencilBack: {\n        compare: 'equal',\n        passOp: 'keep',\n    },\n};\n\nGpuStencilModesToPixi[STENCIL_MODES.INVERSE_MASK_ACTIVE] = {\n    stencilWriteMask: 0,\n    stencilFront: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n    stencilBack: {\n        compare: 'not-equal',\n        passOp: 'replace',\n    },\n};\n", "import type { Matrix } from '../../../../maths/matrix/Matrix';\n\nexport function calculateProjection(\n    pm: Matrix,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    flipY: boolean\n): Matrix\n{\n    const sign = flipY ? 1 : -1;\n\n    pm.identity();\n\n    pm.a = (1 / width * 2);\n    pm.d = sign * (1 / height * 2);\n\n    pm.tx = -1 - (x * pm.a);\n    pm.ty = -sign - (y * pm.d);\n\n    return pm;\n}\n", "import type { RenderTarget } from './RenderTarget';\n\n/**\n * Checks if the render target is viewable on the screen\n * Basically, is it a canvas element and is that canvas element in the DOM\n * @param renderTarget - the render target to check\n * @returns true if the render target is viewable on the screen\n */\nexport function isRenderingToScreen(renderTarget: RenderTarget): boolean\n{\n    const resource = renderTarget.colorTexture.source.resource;\n\n    return ((globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement) && document.body.contains(resource));\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { CLEAR } from '../../gl/const';\nimport { calculateProjection } from '../../gpu/renderTarget/calculateProjection';\nimport { SystemRunner } from '../system/SystemRunner';\nimport { CanvasSource } from '../texture/sources/CanvasSource';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\nimport { getCanvasTexture } from '../texture/utils/getCanvasTexture';\nimport { isRenderingToScreen } from './isRenderingToScreen';\nimport { RenderTarget } from './RenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { GlRenderTarget } from '../../gl/GlRenderTarget';\nimport type { GpuRenderTarget } from '../../gpu/renderTarget/GpuRenderTarget';\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * A render surface is a texture, canvas, or render target\n * @memberof rendering\n * @see environment.ICanvas\n * @see rendering.Texture\n * @see rendering.RenderTarget\n */\nexport type RenderSurface = ICanvas | BindableTexture | RenderTarget;\n\n/**\n * stores a render target and its frame\n * @ignore\n */\ninterface RenderTargetAndFrame\n{\n    /** the render target */\n    renderTarget: RenderTarget;\n    /** the frame to use when using the render target */\n    frame: Rectangle\n}\n\n/**\n * An adaptor interface for RenderTargetSystem to support WebGL and WebGPU.\n * This is used internally by the renderer, and is not intended to be used directly.\n * @ignore\n */\nexport interface RenderTargetAdaptor<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget>\n{\n    init(\n        /** the renderer */\n        renderer: Renderer,\n        /** the render target system */\n        renderTargetSystem: RenderTargetSystem<RENDER_TARGET>\n    ): void\n\n    /** A function copies the contents of a render surface to a texture */\n    copyToTexture(\n        /** the render surface to copy from  */\n        sourceRenderSurfaceTexture: RenderTarget,\n        /** the texture to copy to */\n        destinationTexture: Texture,\n        /** the origin of the copy */\n        originSrc: { x: number; y: number },\n        /** the size of the copy */\n        size: { width: number; height: number },\n        /** the destination origin (top left to paste from!) */\n        originDest?: { x: number; y: number },\n    ): Texture\n\n    /** starts a render pass on the render target */\n    startRenderPass(\n        /** the render target to start the render pass on */\n        renderTarget: RenderTarget,\n        /* the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111* */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** clears the current render target to the specified color */\n    clear(\n        /** the render target to clear */\n        renderTarget: RenderTarget,\n        /** the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111 */\n        clear: CLEAR_OR_BOOL,\n        /** the color to clear to   */\n        clearColor?: RgbaArray,\n        /** the viewport to use */\n        viewport?: Rectangle\n    ): void\n\n    /** finishes the current render pass */\n    finishRenderPass(renderTarget: RenderTarget): void\n\n    /** called after the render pass is finished */\n    postrender?(renderTarget: RenderTarget): void;\n\n    /** called before the render main pass is started */\n    prerender?(renderTarget: RenderTarget): void;\n\n    /**\n     * initializes a gpu render target. Both renderers use this function to initialize a gpu render target\n     * Its different type of object depending on the renderer.\n     */\n    initGpuRenderTarget(\n        /** the render target to initialize */\n        renderTarget: RenderTarget\n    ): RENDER_TARGET\n\n    /** called when a render target is resized */\n    resizeGpuRenderTarget(\n        /** the render target to resize */\n        renderTarget: RenderTarget\n    ): void\n\n    /** destroys the gpu render target */\n    destroyGpuRenderTarget(\n        /** the render target to destroy */\n        gpuRenderTarget: RENDER_TARGET\n    ): void\n}\n\n/**\n * A system that manages render targets. A render target is essentially a place where the shaders can color in the pixels.\n * The render target system is responsible for binding the render target to the renderer, and managing the viewport.\n * Render targets can be pushed and popped.\n *\n * To make it easier, you can also bind textures and canvases too. This will automatically create a render target for you.\n * The render target itself is a lot more powerful than just a texture or canvas,\n * as it can have multiple textures attached to it.\n * It will also give ou fine grain control over the stencil buffer / depth texture.\n * @example\n *\n * ```js\n *\n * // create a render target\n * const renderTarget = new RenderTarget({\n *   colorTextures: [new TextureSource({ width: 100, height: 100 })],\n * });\n *\n * // bind the render target\n * renderer.renderTarget.bind(renderTarget);\n *\n * // draw something!\n * ```\n * @memberof rendering\n */\nexport class RenderTargetSystem<RENDER_TARGET extends GlRenderTarget | GpuRenderTarget> implements System\n{\n    /** When rendering of a scene begins, this is where the root render surface is stored */\n    public rootRenderTarget: RenderTarget;\n    /** This is the root viewport for the render pass*/\n    public rootViewPort = new Rectangle();\n    /** A boolean that lets the dev know if the current render pass is rendering to the screen. Used by some plugins */\n    public renderingToScreen: boolean;\n    /** the current active render target */\n    public renderTarget: RenderTarget;\n    /** the current active render surface that the render target is created from */\n    public renderSurface: RenderSurface;\n    /** the current viewport that the gpu is using */\n    public readonly viewport = new Rectangle();\n    /**\n     * a runner that lets systems know if the active render target has changed.\n     * Eg the Stencil System needs to know so it can manage the stencil buffer\n     */\n    public readonly onRenderTargetChange = new SystemRunner('onRenderTargetChange');\n    /** the projection matrix that is used by the shaders based on the active render target and the viewport */\n    public readonly projectionMatrix = new Matrix();\n    /** the default clear color for render targets */\n    public readonly defaultClearColor: RgbaArray = [0, 0, 0, 0];\n    /** a reference to the adaptor that interfaces with WebGL / WebGP */\n    public readonly adaptor: RenderTargetAdaptor<RENDER_TARGET>;\n    /**\n     * a hash that stores the render target for a given render surface. When you pass in a texture source,\n     * a render target is created for it. This map stores and makes it easy to retrieve the render target\n     */\n    private readonly _renderSurfaceToRenderTargetHash: Map<RenderSurface, RenderTarget>\n        = new Map();\n    /** A hash that stores a gpu render target for a given render target. */\n    private _gpuRenderTargetHash: Record<number, RENDER_TARGET> = Object.create(null);\n    /**\n     * A stack that stores the render target and frame that is currently being rendered to.\n     * When push is called, the current render target is stored in this stack.\n     * When pop is called, the previous render target is restored.\n     */\n    private readonly _renderTargetStack: RenderTargetAndFrame[] = [];\n    /** A reference to the renderer */\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuRenderTargetHash');\n    }\n\n    /** called when dev wants to finish a render pass */\n    public finishRenderPass()\n    {\n        this.adaptor.finishRenderPass(this.renderTarget);\n    }\n\n    /**\n     * called when the renderer starts to render a scene.\n     * @param options\n     * @param options.target - the render target to render to\n     * @param options.clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param options.clearColor - the color to clear to\n     * @param options.frame - the frame to render to\n     */\n    public renderStart({\n        target,\n        clear,\n        clearColor,\n        frame\n    }: {\n        target: RenderSurface;\n        clear: CLEAR_OR_BOOL;\n        clearColor: RgbaArray;\n        frame?: Rectangle\n    }): void\n    {\n        // TODO no need to reset this - use optimised index instead\n        this._renderTargetStack.length = 0;\n\n        this.push(\n            target,\n            clear,\n            clearColor,\n            frame\n        );\n\n        this.rootViewPort.copyFrom(this.viewport);\n        this.rootRenderTarget = this.renderTarget;\n        this.renderingToScreen = isRenderingToScreen(this.rootRenderTarget);\n\n        this.adaptor.prerender?.(this.rootRenderTarget);\n    }\n\n    public postrender()\n    {\n        this.adaptor.postrender?.(this.rootRenderTarget);\n    }\n\n    /**\n     * Binding a render surface! This is the main function of the render target system.\n     * It will take the RenderSurface (which can be a texture, canvas, or render target) and bind it to the renderer.\n     * Once bound all draw calls will be rendered to the render surface.\n     *\n     * If a frame is not provide and the render surface is a texture, the frame of the texture will be used.\n     * @param renderSurface - the render surface to bind\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to render to\n     * @returns the render target that was bound\n     */\n    public bind(\n        renderSurface: RenderSurface,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    ): RenderTarget\n    {\n        const renderTarget = this.getRenderTarget(renderSurface);\n\n        const didChange = this.renderTarget !== renderTarget;\n\n        this.renderTarget = renderTarget;\n        this.renderSurface = renderSurface;\n\n        const gpuRenderTarget = this.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.pixelWidth !== gpuRenderTarget.width\n            || renderTarget.pixelHeight !== gpuRenderTarget.height)\n        {\n            this.adaptor.resizeGpuRenderTarget(renderTarget);\n\n            gpuRenderTarget.width = renderTarget.pixelWidth;\n            gpuRenderTarget.height = renderTarget.pixelHeight;\n        }\n\n        const source = renderTarget.colorTexture;\n        const viewport = this.viewport;\n\n        const pixelWidth = source.pixelWidth;\n        const pixelHeight = source.pixelHeight;\n\n        if (!frame && renderSurface instanceof Texture)\n        {\n            frame = renderSurface.frame;\n        }\n\n        if (frame)\n        {\n            const resolution = source._resolution;\n\n            viewport.x = ((frame.x * resolution) + 0.5) | 0;\n            viewport.y = ((frame.y * resolution) + 0.5) | 0;\n            viewport.width = ((frame.width * resolution) + 0.5) | 0;\n            viewport.height = ((frame.height * resolution) + 0.5) | 0;\n        }\n        else\n        {\n            viewport.x = 0;\n            viewport.y = 0;\n            viewport.width = pixelWidth;\n            viewport.height = pixelHeight;\n        }\n\n        calculateProjection(\n            this.projectionMatrix,\n            0, 0,\n            viewport.width / source.resolution,\n            viewport.height / source.resolution,\n            !renderTarget.isRoot\n        );\n\n        this.adaptor.startRenderPass(renderTarget, clear, clearColor, viewport);\n\n        if (didChange)\n        {\n            this.onRenderTargetChange.emit(renderTarget);\n        }\n\n        return renderTarget;\n    }\n\n    public clear(\n        target?: RenderSurface,\n        clear: CLEAR_OR_BOOL = CLEAR.ALL,\n        clearColor?: RgbaArray,\n    )\n    {\n        if (!clear) return;\n\n        if (target)\n        {\n            target = this.getRenderTarget(target);\n        }\n\n        this.adaptor.clear(\n            (target as RenderTarget) || this.renderTarget,\n            clear,\n            clearColor,\n            this.viewport\n        );\n    }\n\n    protected contextChange(): void\n    {\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    /**\n     * Push a render surface to the renderer. This will bind the render surface to the renderer,\n     * @param renderSurface - the render surface to push\n     * @param clear - the clear mode to use. Can be true or a CLEAR number 'COLOR | DEPTH | STENCIL' 0b111\n     * @param clearColor - the color to clear to\n     * @param frame - the frame to use when rendering to the render surface\n     */\n    public push(\n        renderSurface: RenderSurface,\n        clear: CLEAR | boolean = CLEAR.ALL,\n        clearColor?: RgbaArray,\n        frame?: Rectangle\n    )\n    {\n        const renderTarget = this.bind(renderSurface, clear, clearColor, frame);\n\n        this._renderTargetStack.push({\n            renderTarget,\n            frame,\n        });\n\n        return renderTarget;\n    }\n\n    /** Pops the current render target from the renderer and restores the previous render target. */\n    public pop()\n    {\n        this._renderTargetStack.pop();\n\n        const currentRenderTargetData = this._renderTargetStack[this._renderTargetStack.length - 1];\n\n        this.bind(currentRenderTargetData.renderTarget, false, null, currentRenderTargetData.frame);\n    }\n\n    /**\n     * Gets the render target from the provide render surface. Eg if its a texture,\n     * it will return the render target for the texture.\n     * If its a render target, it will return the same render target.\n     * @param renderSurface - the render surface to get the render target for\n     * @returns the render target for the render surface\n     */\n    public getRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        if (((renderSurface as Texture).isTexture))\n        {\n            renderSurface = (renderSurface as Texture).source;\n        }\n\n        return this._renderSurfaceToRenderTargetHash.get(renderSurface)\n        ?? this._initRenderTarget(renderSurface);\n    }\n\n    /**\n     * Copies a render surface to another texture.\n     *\n     * NOTE:\n     * for sourceRenderSurfaceTexture, The render target must be something that is written too by the renderer\n     *\n     * The following is not valid:\n     * @example\n     * const canvas = document.createElement('canvas')\n     * canvas.width = 200;\n     * canvas.height = 200;\n     *\n     * const ctx = canvas2.getContext('2d')!\n     * ctx.fillStyle = 'red'\n     * ctx.fillRect(0, 0, 200, 200);\n     *\n     * const texture = RenderTexture.create({\n     *   width: 200,\n     *   height: 200,\n     * })\n     * const renderTarget = renderer.renderTarget.getRenderTarget(canvas2);\n     *\n     * renderer.renderTarget.copyToTexture(renderTarget,texture, {x:0,y:0},{width:200,height:200},{x:0,y:0});\n     *\n     * The best way to copy a canvas is to create a texture from it. Then render with that.\n     *\n     * Parsing in a RenderTarget canvas context (with a 2d context)\n     * @param sourceRenderSurfaceTexture - the render surface to copy from\n     * @param destinationTexture - the texture to copy to\n     * @param originSrc - the origin of the copy\n     * @param originSrc.x - the x origin of the copy\n     * @param originSrc.y - the y origin of the copy\n     * @param size - the size of the copy\n     * @param size.width - the width of the copy\n     * @param size.height - the height of the copy\n     * @param originDest - the destination origin (top left to paste from!)\n     * @param originDest.x - the x origin of the paste\n     * @param originDest.y - the y origin of the paste\n     */\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number },\n        size: { width: number; height: number },\n        originDest: { x: number; y: number; },\n    )\n    {\n        // fit the size to the source we don't want to go out of bounds\n\n        if (originSrc.x < 0)\n        {\n            size.width += originSrc.x;\n            originDest.x -= originSrc.x;\n            originSrc.x = 0;\n        }\n\n        if (originSrc.y < 0)\n        {\n            size.height += originSrc.y;\n            originDest.y -= originSrc.y;\n            originSrc.y = 0;\n        }\n\n        const { pixelWidth, pixelHeight } = sourceRenderSurfaceTexture;\n\n        size.width = Math.min(size.width, pixelWidth - originSrc.x);\n        size.height = Math.min(size.height, pixelHeight - originSrc.y);\n\n        return this.adaptor.copyToTexture(\n            sourceRenderSurfaceTexture,\n            destinationTexture,\n            originSrc,\n            size,\n            originDest\n        );\n    }\n\n    /**\n     * ensures that we have a depth stencil buffer available to render to\n     * This is used by the mask system to make sure we have a stencil buffer.\n     */\n    public ensureDepthStencil()\n    {\n        if (!this.renderTarget.stencil)\n        {\n            this.renderTarget.stencil = true;\n\n            this.adaptor.startRenderPass(this.renderTarget, false, null, this.viewport);\n        }\n    }\n\n    /** nukes the render target system */\n    public destroy()\n    {\n        (this._renderer as null) = null;\n\n        this._renderSurfaceToRenderTargetHash.forEach((renderTarget, key) =>\n        {\n            if (renderTarget !== key)\n            {\n                renderTarget.destroy();\n            }\n        });\n\n        this._renderSurfaceToRenderTargetHash.clear();\n\n        this._gpuRenderTargetHash = Object.create(null);\n    }\n\n    private _initRenderTarget(renderSurface: RenderSurface): RenderTarget\n    {\n        let renderTarget: RenderTarget = null;\n\n        if (CanvasSource.test(renderSurface))\n        {\n            renderSurface = getCanvasTexture(renderSurface as ICanvas).source;\n        }\n\n        if (renderSurface instanceof RenderTarget)\n        {\n            renderTarget = renderSurface;\n        }\n        else if (renderSurface instanceof TextureSource)\n        {\n            renderTarget = new RenderTarget({\n                colorTextures: [renderSurface],\n            });\n\n            if (CanvasSource.test(renderSurface.source.resource))\n            {\n                renderTarget.isRoot = true;\n            }\n\n            // TODO add a test for this\n            renderSurface.once('destroy', () =>\n            {\n                renderTarget.destroy();\n\n                this._renderSurfaceToRenderTargetHash.delete(renderSurface);\n\n                const gpuRenderTarget = this._gpuRenderTargetHash[renderTarget.uid];\n\n                if (gpuRenderTarget)\n                {\n                    this._gpuRenderTargetHash[renderTarget.uid] = null;\n                    this.adaptor.destroyGpuRenderTarget(gpuRenderTarget);\n                }\n            });\n        }\n\n        this._renderSurfaceToRenderTargetHash.set(renderSurface, renderTarget);\n\n        return renderTarget;\n    }\n\n    public getGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        return this._gpuRenderTargetHash[renderTarget.uid]\n        || (this._gpuRenderTargetHash[renderTarget.uid] = this.adaptor.initGpuRenderTarget(renderTarget));\n    }\n\n    public resetState(): void\n    {\n        this.renderTarget = null;\n        this.renderSurface = null;\n    }\n}\n"],
  "mappings": "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",
  "names": ["environments", "extensions", "ExtensionType", "loadEnvironmentExtensions", "skip", "i", "env", "unsafeEval", "unsafeEvalSupported", "CLEAR", "SystemRunner", "name", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "items", "i", "len", "item", "index", "defaultRunners", "_AbstractRenderer", "eventemitter3_default", "config", "combinedRunners", "options", "skip", "loadEnvironmentExtensions", "systemName", "i", "args", "deprecated", "Container", "deprecation", "v8_0_0", "isRGBAArray", "Color", "desiredScreenWidth", "desiredScreenHeight", "resolution", "previousResolution", "renderer", "CLEAR", "clear", "clearColor", "target", "value", "runnerIds", "runnerId", "SystemRunner", "systems", "val", "ClassRef", "name", "system", "pipes", "pipeAdaptors", "adaptors", "acc", "adaptor", "pipe", "PipeClass", "Adaptor", "runner", "unsafeEvalSupported", "AbstractRenderer", "CustomRenderPipe", "renderer", "container", "instructionSet", "ExtensionType", "executeInstructions", "renderGroup", "renderer", "instructionSet", "instructions", "i", "instruction", "tempMatrix", "Matrix", "RenderGroupPipe", "renderer", "renderGroup", "instructionSet", "BigPool", "batchableRenderGroup", "BatchableSprite", "worldTransformMatrix", "executeInstructions", "ExtensionType", "clearList", "list", "index", "j", "tempContainer", "Container", "UPDATE_BLEND_COLOR_VISIBLE", "UPDATE_VISIBLE", "UPDATE_COLOR", "UPDATE_BLEND", "updateRenderGroupTransforms", "renderGroup", "updateChildRenderGroups", "updateRenderGroupTransform", "childrenToUpdate", "updateTick", "j", "renderGroupDepth", "childrenAtDepth", "list", "index", "i", "child", "updateTransformAndChildren", "clearList", "root", "worldAlpha", "renderGroupParent", "multiplyColors", "container", "updateFlags", "localTransform", "parent", "updateColorBlendVisibility", "children", "length", "renderable", "groupAlpha", "validateRenderables", "renderGroup", "renderPipes", "list", "index", "rebuildRequired", "container", "tempMatrix", "Matrix", "RenderGroupSystem", "renderer", "container", "transform", "parent", "renderGroupParent", "originalLocalTransform", "renderPipes", "executeInstructions", "renderGroup", "closestCacheAsTexture", "i", "bounds", "lastTexture", "TexturePool", "resolution", "antialias", "Bounds", "clearList", "validateRenderables", "updateRenderGroupTransforms", "list", "index", "rendererOrPipes", "root", "instructionSet", "ExtensionType", "SpritePipe", "renderer", "sprite", "instructionSet", "gpuSprite", "batchableSprite", "BigPool", "BatchableSprite", "i", "ExtensionType", "VERSION", "ApplicationInitHook", "VERSION", "ExtensionType", "RendererInitHook", "renderer", "_BatcherPipe", "renderer", "adaptor", "State", "name", "instructionSet", "batchers", "DefaultBatcher", "i", "batchableObject", "batch", "batches", "geometry", "batcher", "shader", "ExtensionType", "BatcherPipe", "extensions", "_Filter", "Shader", "options", "State", "filterManager", "input", "output", "clearMode", "value", "gpu", "gl", "rest", "gpuProgram", "glProgram", "GpuProgram", "GlProgram", "Filter", "fragment", "vertex", "source", "MaskFilter", "Filter", "options", "sprite", "rest", "textureMatrix", "TextureMatrix", "filterUniforms", "UniformGroup", "Matrix", "gpuProgram", "GpuProgram", "source", "glProgram", "GlProgram", "vertex", "fragment", "value", "filterManager", "input", "output", "clearMode", "tempBounds", "Bounds", "AlphaMaskEffect", "FilterEffect", "MaskFilter", "Sprite", "Texture", "value", "AlphaMaskPipe", "renderer", "mask", "maskedContainer", "instructionSet", "maskContainer", "_maskedContainer", "instruction", "renderMask", "filterEffect", "BigPool", "bounds", "getGlobalBounds", "colorTextureSource", "filterTexture", "TexturePool", "sprite", "maskData", "RendererType", "ExtensionType", "ColorMaskPipe", "renderer", "mask", "_container", "instructionSet", "colorStack", "currentColor", "_mask", "instruction", "ExtensionType", "StencilMaskPipe", "renderer", "mask", "_container", "instructionSet", "_a", "effect", "maskContainer", "maskData", "instructionsLength", "renderTargetUid", "i", "instruction", "maskStackIndex", "STENCIL_MODES", "CLEAR", "ExtensionType", "_BackgroundSystem", "Color", "options", "value", "ExtensionType", "BackgroundSystem", "BLEND_MODE_FILTERS", "extensions", "ExtensionType", "value", "BlendModePipe", "renderer", "renderable", "blendMode", "instructionSet", "warn", "filterEffect", "FilterEffect", "instruction", "i", "imageTypes", "_ExtractSystem", "renderer", "options", "defaults", "Container", "Texture", "image", "format", "quality", "canvas", "resolve", "reject", "blob", "reader", "target", "texture", "pixelInfo", "link", "width", "base64", "style", "ExtensionType", "ExtractSystem", "RenderTexture", "_RenderTexture", "Texture", "options", "TextureSource", "width", "height", "resolution", "tempRect", "Rectangle", "tempBounds", "Bounds", "noColor", "GenerateTextureSystem", "renderer", "options", "Container", "resolution", "antialias", "container", "clearColor", "Color", "region", "getLocalBounds", "target", "RenderTexture", "transform", "Matrix", "ExtensionType", "GlobalUniformSystem", "renderer", "i", "options", "size", "projectionMatrix", "worldTransformMatrix", "worldColor", "offset", "renderTarget", "currentGlobalUniformData", "Matrix", "Point", "globalUniformData", "uniformGroup", "uniforms", "color32BitToUniform", "bindGroup", "BindGroup", "RendererType", "UniformGroup", "ExtensionType", "uid", "SchedulerSystem", "Ticker", "func", "duration", "useOffset", "id", "offset", "i", "now", "task", "elapsed", "ExtensionType", "saidHello", "sayHello", "type", "DOMAdapter", "args", "VERSION", "HelloSystem", "renderer", "options", "name", "RendererType", "sayHello", "ExtensionType", "cleanHash", "hash", "clean", "i", "value", "cleanArray", "arr", "offset", "renderableGCTick", "_RenderableGCSystem", "renderer", "options", "value", "hash", "cleanHash", "array", "cleanArray", "context", "container", "renderable", "now", "managedRenderables", "renderPipes", "offset", "renderGroup", "currentTick", "rp", "index", "gcTick", "child", "ExtensionType", "RenderableGCSystem", "_TextureGCSystem", "renderer", "options", "managedTextures", "i", "texture", "ExtensionType", "TextureGCSystem", "_RenderTarget", "descriptor", "uid", "i", "TextureSource", "texture", "colorSource", "Texture", "_size", "source", "width", "height", "resolution", "skipColorTexture", "colorTexture", "RenderTarget", "canvasCache", "getCanvasTexture", "canvas", "options", "texture", "Texture", "CanvasSource", "onDestroy", "_ViewSystem", "value", "options", "deprecation", "v8_0_0", "Rectangle", "DOMAdapter", "getCanvasTexture", "RenderTarget", "desiredScreenWidth", "desiredScreenHeight", "resolution", "ExtensionType", "ViewSystem", "SharedSystems", "BackgroundSystem", "GlobalUniformSystem", "HelloSystem", "ViewSystem", "RenderGroupSystem", "TextureGCSystem", "GenerateTextureSystem", "ExtractSystem", "RendererInitHook", "RenderableGCSystem", "SchedulerSystem", "SharedRenderPipes", "BlendModePipe", "BatcherPipe", "SpritePipe", "RenderGroupPipe", "AlphaMaskPipe", "StencilMaskPipe", "ColorMaskPipe", "CustomRenderPipe", "textureBit", "textureBitGl", "UboSystem", "adaptor", "unsafeEvalSupported", "uniformGroup", "uniformData", "Buffer", "BufferUsage", "uniformGroupSignature", "elements", "i", "layout", "syncFunction", "uboElements", "data", "offset", "uniformGroupData", "dataInt32", "synced", "uniformParsers", "data", "createUboSyncFunction", "uboElements", "parserCode", "arrayGenerationFunction", "singleSettersMap", "funcFragments", "prev", "i", "uboElement", "name", "parsed", "offset", "j", "uniformParsers", "template", "fragmentSrc", "loopMatrix", "col", "row", "uboSyncFunctionsSTD40", "uboSyncFunctionsWGSL", "BufferResource", "eventemitter3_default", "buffer", "offset", "size", "uid", "destroyBuffer", "ensureAttributes", "geometry", "extractedData", "i", "attribute", "attributeData", "warn", "ensureStartAndStride", "buffers", "attributes", "tempStride", "tempStart", "j", "buffer", "getAttributeInfoFromFormat", "GpuStencilModesToPixi", "STENCIL_MODES", "calculateProjection", "pm", "x", "y", "width", "height", "flipY", "sign", "isRenderingToScreen", "renderTarget", "resource", "RenderTargetSystem", "renderer", "Rectangle", "SystemRunner", "Matrix", "target", "clear", "clearColor", "frame", "isRenderingToScreen", "renderSurface", "renderTarget", "didChange", "gpuRenderTarget", "source", "viewport", "pixelWidth", "pixelHeight", "Texture", "resolution", "calculateProjection", "CLEAR", "currentRenderTargetData", "sourceRenderSurfaceTexture", "destinationTexture", "originSrc", "size", "originDest", "key", "CanvasSource", "getCanvasTexture", "RenderTarget", "TextureSource"]
}
