{
  "version": 3,
  "sources": ["../../../node_modules/pixi.js/node_modules/eventemitter3/index.js", "../../../node_modules/pixi.js/src/extensions/Extensions.ts", "../../../node_modules/pixi.js/node_modules/eventemitter3/index.mjs", "../../../node_modules/@pixi/colord/index.mjs", "../../../node_modules/@pixi/colord/plugins/names.mjs", "../../../node_modules/pixi.js/src/color/Color.ts", "../../../node_modules/pixi.js/src/culling/cullingMixin.ts", "../../../node_modules/pixi.js/src/maths/misc/const.ts", "../../../node_modules/pixi.js/src/maths/point/Point.ts", "../../../node_modules/pixi.js/src/maths/matrix/Matrix.ts", "../../../node_modules/pixi.js/src/maths/point/ObservablePoint.ts", "../../../node_modules/pixi.js/src/utils/data/uid.ts", "../../../node_modules/pixi.js/src/utils/logging/deprecation.ts", "../../../node_modules/pixi.js/src/utils/pool/Pool.ts", "../../../node_modules/pixi.js/src/utils/pool/PoolGroup.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/cacheAsTextureMixin.ts", "../../../node_modules/pixi.js/src/utils/data/removeItems.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/childrenHelperMixin.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/collectRenderablesMixin.ts", "../../../node_modules/pixi.js/src/filters/FilterEffect.ts", "../../../node_modules/pixi.js/src/rendering/mask/MaskEffectManager.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/effectsMixin.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/findMixin.ts", "../../../node_modules/pixi.js/src/maths/shapes/Rectangle.ts", "../../../node_modules/pixi.js/src/scene/container/bounds/Bounds.ts", "../../../node_modules/pixi.js/src/scene/container/bounds/utils/matrixAndBoundsPool.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/getFastGlobalBoundsMixin.ts", "../../../node_modules/pixi.js/src/scene/container/bounds/getGlobalBounds.ts", "../../../node_modules/pixi.js/src/scene/container/utils/multiplyHexColors.ts", "../../../node_modules/pixi.js/src/scene/container/utils/multiplyColors.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/getGlobalMixin.ts", "../../../node_modules/pixi.js/src/utils/logging/warn.ts", "../../../node_modules/pixi.js/src/scene/container/bounds/getLocalBounds.ts", "../../../node_modules/pixi.js/src/scene/container/utils/checkChildrenDidChange.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/measureMixin.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/onRenderMixin.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/sortMixin.ts", "../../../node_modules/pixi.js/src/scene/container/container-mixins/toLocalGlobalMixin.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/instructions/InstructionSet.ts", "../../../node_modules/pixi.js/src/maths/misc/pow2.ts", "../../../node_modules/pixi.js/src/scene/container/utils/definedProps.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureStyle.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/TextureSource.ts", "../../../node_modules/pixi.js/src/maths/matrix/groupD8.ts", "../../../node_modules/pixi.js/src/utils/misc/NOOP.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/BufferImageSource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/TextureMatrix.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/Texture.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/TexturePool.ts", "../../../node_modules/pixi.js/src/scene/container/RenderGroup.ts", "../../../node_modules/pixi.js/src/scene/container/utils/assignWithIgnore.ts", "../../../node_modules/pixi.js/src/scene/container/Container.ts", "../../../node_modules/pixi.js/src/rendering/renderers/types.ts", "../../../node_modules/pixi.js/src/ticker/const.ts", "../../../node_modules/pixi.js/src/ticker/TickerListener.ts", "../../../node_modules/pixi.js/src/ticker/Ticker.ts", "../../../node_modules/pixi.js/src/scene/view/ViewContainer.ts", "../../../node_modules/pixi.js/src/environment-browser/BrowserAdapter.ts", "../../../node_modules/pixi.js/src/environment/adapter.ts", "../../../node_modules/pixi.js/src/utils/data/updateQuadBounds.ts", "../../../node_modules/pixi.js/src/scene/sprite/Sprite.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/sources/CanvasSource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/BindGroup.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getTestContext.ts", "../../../node_modules/pixi.js/src/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.ts", "../../../node_modules/pixi.js/src/rendering/batcher/gl/utils/maxRecommendedTextures.ts", "../../../node_modules/pixi.js/src/utils/data/ViewableBuffer.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/buffer/utils/fastCopy.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/state/const.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/state/getAdjustedBlendModeBlend.ts", "../../../node_modules/pixi.js/src/rendering/batcher/shared/BatchTextureArray.ts", "../../../node_modules/pixi.js/src/rendering/batcher/shared/Batcher.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/buffer/const.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/buffer/Buffer.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/ensureIsBuffer.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getGeometryBounds.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/geometry/Geometry.ts", "../../../node_modules/pixi.js/src/rendering/batcher/shared/BatchGeometry.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/utils/createIdFromString.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/insertVersion.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/setProgramName.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/program/preprocessors/stripVersion.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/GlProgram.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/extractStructAndGroups.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/const.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateLayoutHash.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuProgram.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/addBits.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileHooks.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileInputs.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/compileOutputs.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compiler/utils/injectBits.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compiler/compileHighShader.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/defaultProgramTemplate.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/globalUniformsBit.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/compileHighShaderToProgram.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/colorBit.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/roundPixelsBit.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/types.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/utils/getDefaultUniformValue.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/UniformGroup.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gl/shader/getBatchSamplersUniformGroup.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/shader/Shader.ts", "../../../node_modules/pixi.js/src/rendering/batcher/shared/DefaultShader.ts", "../../../node_modules/pixi.js/src/rendering/batcher/shared/DefaultBatcher.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/state/State.ts", "../../../node_modules/pixi.js/src/scene/graphics/gpu/colorToUniform.ts", "../../../node_modules/pixi.js/src/scene/sprite/BatchableSprite.ts", "../../../node_modules/pixi.js/src/rendering/high-shader/shader-bits/localUniformBit.ts"],
  "sourcesContent": ["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n", "/**\n * `extensions` is a global object that holds all the extensions registered with PixiJS.\n * PixiJS uses a this extensions architecture a lot to make the library more modular and\n * flexible.\n *\n * For example, if you want to add load a new type of asset, you can register a new\n * {@link assets.LoaderParser} with the `extensions` object.\n *\n * ```js\n * import { extensions, ExtensionType } from 'pixi.js';\n *\n * // create a custom asset loader\n * const customAssetLoader = {\n *    extension: {\n *        type: ExtensionType.LoadParser,\n *        name: 'custom-asset-loader',\n *    },\n *    test(url) {\n *       // check if this new loader should be used...\n *    },\n *    load(url) {\n *        // load the asset...\n *    },\n * };\n *\n * // add the custom asset loader to pixi\n * extensions.add(customAssetLoader);\n * ```\n *\n * This would add the `customAssetLoader` to the list of available loaders that PixiJS can use.\n *\n * There are many different types of extensions, which are listed in {@link extensions.ExtensionType}.\n * @namespace extensions\n */\n\n/**\n * Collection of valid extension types.\n * @memberof extensions\n */\nenum ExtensionType\n{\n    /** extensions that are registered as Application plugins */\n    Application = 'application',\n\n    /** extensions that are registered as WebGL render pipes */\n    WebGLPipes = 'webgl-pipes',\n    /** extensions that are registered as WebGL render pipes adaptors */\n    WebGLPipesAdaptor = 'webgl-pipes-adaptor',\n    /** extensions that are registered as WebGL render systems */\n    WebGLSystem = 'webgl-system',\n\n    /** extensions that are registered as WebGPU render pipes */\n    WebGPUPipes = 'webgpu-pipes',\n    /** extensions that are registered as WebGPU render pipes adaptors */\n    WebGPUPipesAdaptor = 'webgpu-pipes-adaptor',\n    /** extensions that are registered as WebGPU render systems */\n    WebGPUSystem = 'webgpu-system',\n\n    /** extensions that are registered as Canvas render pipes */\n    CanvasSystem = 'canvas-system',\n    /** extensions that are registered as Canvas render pipes adaptors */\n    CanvasPipesAdaptor = 'canvas-pipes-adaptor',\n    /** extensions that are registered as Canvas render systems */\n    CanvasPipes = 'canvas-pipes',\n\n    /** extensions that combine the other Asset extensions */\n    Asset = 'asset',\n    /** extensions that are used to load assets through Assets */\n    LoadParser = 'load-parser',\n    /** extensions that are used to resolve asset urls through Assets */\n    ResolveParser = 'resolve-parser',\n    /** extensions that are used to handle how urls are cached by Assets */\n    CacheParser = 'cache-parser',\n    /** extensions that are used to add/remove available resources from Assets */\n    DetectionParser = 'detection-parser',\n\n    /** extensions that are registered with the MaskEffectManager */\n    MaskEffect = 'mask-effect',\n\n    /** A type of extension for creating a new advanced blend mode */\n    BlendMode = 'blend-mode',\n\n    /** A type of extension that will be used to auto detect a resource type */\n    TextureSource = 'texture-source',\n\n    /** A type of extension that will be used to auto detect an environment */\n    Environment = 'environment',\n\n    /** A type of extension for building and triangulating custom shapes used in graphics. */\n    ShapeBuilder = 'shape-builder',\n\n    /** A type of extension for creating custom batchers used in rendering. */\n    Batcher = 'batcher',\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n * @ignore\n */\ninterface ExtensionMetadataDetails\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, to make them more easily accessible */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n}\n\n/**\n * The metadata for an extension.\n * @memberof extensions\n */\ntype ExtensionMetadata = ExtensionType | ExtensionMetadataDetails;\n\n/**\n * Format when registering an extension. Generally, the extension\n * should have these values as `extension` static property,\n * but you can override name or type by providing an object.\n * @memberof extensions\n */\ninterface ExtensionFormat\n{\n    /** The extension type, can be multiple types */\n    type: ExtensionType | ExtensionType[];\n    /** Optional. Some plugins provide an API name/property, such as Renderer plugins */\n    name?: string;\n    /** Optional, used for sorting the plugins in a particular order */\n    priority?: number;\n    /** Reference to the plugin object/class */\n    ref: any;\n}\n\n/**\n * Extension format that is used internally for registrations.\n * @memberof extensions\n * @ignore\n */\ninterface StrictExtensionFormat extends ExtensionFormat\n{\n    /** The extension type, always expressed as multiple, even if a single */\n    type: ExtensionType[];\n}\n\ntype ExtensionHandler = (extension: StrictExtensionFormat) => void;\n\n/**\n * Convert input into extension format data.\n * @ignore\n */\nconst normalizeExtension = (ext: ExtensionFormat | any): StrictExtensionFormat =>\n{\n    // Class/Object submission, use extension object\n    if (typeof ext === 'function' || (typeof ext === 'object' && ext.extension))\n    {\n        // #if _DEBUG\n        if (!ext.extension)\n        {\n            throw new Error('Extension class must have an extension object');\n        }\n        // #endif\n        const metadata: ExtensionMetadataDetails = (typeof ext.extension !== 'object')\n            ? { type: ext.extension }\n            : ext.extension;\n\n        ext = { ...metadata, ref: ext };\n    }\n    if (typeof ext === 'object')\n    {\n        ext = { ...ext };\n    }\n    else\n    {\n        throw new Error('Invalid extension type');\n    }\n\n    if (typeof ext.type === 'string')\n    {\n        ext.type = [ext.type];\n    }\n\n    return ext;\n};\n\n/**\n * Get the priority for an extension.\n * @ignore\n * @param ext - Any extension\n * @param defaultPriority - Fallback priority if none is defined.\n * @returns The priority for the extension.\n * @memberof extensions\n */\nexport const normalizeExtensionPriority = (ext: ExtensionFormat | any, defaultPriority: number): number =>\n    normalizeExtension(ext).priority ?? defaultPriority;\n\n/**\n * Global registration of all PixiJS extensions. One-stop-shop for extensibility.\n *\n * Import the `extensions` object and use it to register new functionality via the described methods below.\n * ```js\n * import { extensions } from 'pixi.js';\n *\n * // register a new extension\n * extensions.add(myExtension);\n * ```\n * @property {Function} remove - Remove extensions from PixiJS.\n * @property {Function} add - Register new extensions with PixiJS.\n * @property {Function} handle - Internal method to handle extensions by name.\n * @property {Function} handleByMap - Handle a type, but using a map by `name` property.\n * @property {Function} handleByNamedList - Handle a type, but using a list of extensions with a `name` property.\n * @property {Function} handleByList - Handle a type, but using a list of extensions.\n * @memberof extensions\n */\nconst extensions = {\n\n    /** @ignore */\n    _addHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _removeHandlers: {} as Partial<Record<ExtensionType, ExtensionHandler>>,\n\n    /** @ignore */\n    _queue: {} as Partial<Record<ExtensionType, StrictExtensionFormat[]>>,\n\n    /**\n     * Remove extensions from PixiJS.\n     * @param extensions - Extensions to be removed.\n     * @returns {extensions} For chaining.\n     */\n    remove(...extensions: Array<ExtensionFormat | any>)\n    {\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) => this._removeHandlers[type]?.(ext));\n        });\n\n        return this;\n    },\n\n    /**\n     * Register new extensions with PixiJS.\n     * @param extensions - The spread of extensions to add to PixiJS.\n     * @returns {extensions} For chaining.\n     */\n    add(...extensions: Array<ExtensionFormat | any>)\n    {\n        // Handle any extensions either passed as class w/ data or as data\n        extensions.map(normalizeExtension).forEach((ext) =>\n        {\n            ext.type.forEach((type) =>\n            {\n                const handlers = this._addHandlers;\n                const queue = this._queue;\n\n                if (!handlers[type])\n                {\n                    queue[type] = queue[type] || [];\n                    queue[type]?.push(ext);\n                }\n                else\n                {\n                    handlers[type]?.(ext);\n                }\n            });\n        });\n\n        return this;\n    },\n\n    /**\n     * Internal method to handle extensions by name.\n     * @param type - The extension type.\n     * @param onAdd  - Function handler when extensions are added/registered {@link StrictExtensionFormat}.\n     * @param onRemove  - Function handler when extensions are removed/unregistered {@link StrictExtensionFormat}.\n     * @returns {extensions} For chaining.\n     */\n    handle(type: ExtensionType, onAdd: ExtensionHandler, onRemove: ExtensionHandler)\n    {\n        const addHandlers = this._addHandlers;\n        const removeHandlers = this._removeHandlers;\n\n        // #if _DEBUG\n        if (addHandlers[type] || removeHandlers[type])\n        {\n            throw new Error(`Extension type ${type} already has a handler`);\n        }\n        // #endif\n\n        addHandlers[type] = onAdd;\n        removeHandlers[type] = onRemove;\n\n        // Process the queue\n        const queue = this._queue;\n\n        // Process any plugins that have been registered before the handler\n        if (queue[type])\n        {\n            queue[type]?.forEach((ext) => onAdd(ext));\n            delete queue[type];\n        }\n\n        return this;\n    },\n\n    /**\n     * Handle a type, but using a map by `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The object map of named extensions.\n     * @returns {extensions} For chaining.\n     */\n    handleByMap(type: ExtensionType, map: Record<string, any>)\n    {\n        return this.handle(type,\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    map[extension.name] = extension.ref;\n                }\n            },\n            (extension) =>\n            {\n                if (extension.name)\n                {\n                    delete map[extension.name];\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions with a `name` property.\n     * @param type - Type of extension to handle.\n     * @param map - The array of named extensions.\n     * @param defaultPriority - Fallback priority if none is defined.\n     * @returns {extensions} For chaining.\n     */\n    handleByNamedList(type: ExtensionType, map: {name: string, value: any}[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index >= 0) return;\n\n                map.push({ name: extension.name, value: extension.ref });\n                map.sort((a, b) =>\n                    normalizeExtensionPriority(b.value, defaultPriority)\n                    - normalizeExtensionPriority(a.value, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = map.findIndex((item) => item.name === extension.name);\n\n                if (index !== -1)\n                {\n                    map.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Handle a type, but using a list of extensions.\n     * @param type - Type of extension to handle.\n     * @param list - The list of extensions.\n     * @param defaultPriority - The default priority to use if none is specified.\n     * @returns {extensions} For chaining.\n     */\n    handleByList(type: ExtensionType, list: any[], defaultPriority = -1)\n    {\n        return this.handle(\n            type,\n            (extension) =>\n            {\n                if (list.includes(extension.ref))\n                {\n                    return;\n                }\n\n                list.push(extension.ref);\n                list.sort((a, b) =>\n                    normalizeExtensionPriority(b, defaultPriority) - normalizeExtensionPriority(a, defaultPriority));\n            },\n            (extension) =>\n            {\n                const index = list.indexOf(extension.ref);\n\n                if (index !== -1)\n                {\n                    list.splice(index, 1);\n                }\n            }\n        );\n    },\n\n    /**\n     * Mixin the source object into the target object.\n     * @param Target - The target object to mix into.\n     * @param sources - The source(s) object to mix from\n     */\n    mixin(Target: any, ...sources: Parameters<typeof Object.getOwnPropertyDescriptors>[0][])\n    {\n        // Apply each source's properties to the target prototype\n        for (const source of sources)\n        {\n            Object.defineProperties(Target.prototype, Object.getOwnPropertyDescriptors(source));\n        }\n    }\n};\n\nexport {\n    extensions,\n    ExtensionType,\n};\nexport type {\n    StrictExtensionFormat as ExtensionFormat,\n    ExtensionFormat as ExtensionFormatLoose,\n    ExtensionHandler,\n    ExtensionMetadata,\n    ExtensionMetadataDetails\n};\n", "import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n", "var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return\"string\"==typeof r?r.length>0:\"number\"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},a=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},o=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},i=/^#([0-9a-f]{3,8})$/i,s=function(r){var t=r.toString(16);return t.length<2?\"0\"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,a=Math.max(t,n,e),o=a-Math.min(t,n,e),i=o?a===t?(n-e)/o:a===n?2+(e-t)/o:4+(t-n)/o:0;return{h:60*(i<0?i+6:i),s:a?o/a*100:0,v:a/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var a=Math.floor(t),o=e*(1-n),i=e*(1-(t-a)*n),s=e*(1-(1-t+a)*n),h=a%6;return{r:255*[e,i,o,o,s,e][h],g:255*[s,e,e,i,o,o][h],b:255*[o,o,s,e,e,i][h],a:u}},g=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},d=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));var t,n,e},c=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};var t,n,e,u},l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,p=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=i.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},\"hex\"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:a({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},\"rgb\"],[function(t){var n=l.exec(t)||p.exec(t);if(!n)return null;var e,u,a=g({h:(e=n[1],u=n[2],void 0===u&&(u=\"deg\"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(a)},\"hsl\"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,o=r.a,i=void 0===o?1:o;return t(n)&&t(e)&&t(u)?a({r:Number(n),g:Number(e),b:Number(u),a:Number(i)}):null},\"rgb\"],[function(r){var n=r.h,e=r.s,u=r.l,a=r.a,o=void 0===a?1:a;if(!t(n)||!t(e)||!t(u))return null;var i=g({h:Number(n),s:Number(e),l:Number(u),a:Number(o)});return f(i)},\"hsl\"],[function(r){var n=r.h,a=r.s,o=r.v,i=r.a,s=void 0===i?1:i;if(!t(n)||!t(a)||!t(o))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(a),v:Number(o),a:Number(s)});return b(h)},\"hsv\"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return\"string\"==typeof r?N(r.trim(),y.string):\"object\"==typeof r&&null!==r?N(r,y.object):[null,void 0]},I=function(r){return x(r)[1]},M=function(r,t){var n=c(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},H=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},$=function(r,t){var n=c(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},j=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(H(this.rgba),2)},r.prototype.isDark=function(){return H(this.rgba)<.5},r.prototype.isLight=function(){return H(this.rgba)>=.5},r.prototype.toHex=function(){return r=o(this.rgba),t=r.r,e=r.g,u=r.b,i=(a=r.a)<1?s(n(255*a)):\"\",\"#\"+s(t)+s(e)+s(u)+i;var r,t,e,u,a,i},r.prototype.toRgb=function(){return o(this.rgba)},r.prototype.toRgbString=function(){return r=o(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?\"rgba(\"+t+\", \"+n+\", \"+e+\", \"+u+\")\":\"rgb(\"+t+\", \"+n+\", \"+e+\")\";var r,t,n,e,u},r.prototype.toHsl=function(){return d(c(this.rgba))},r.prototype.toHslString=function(){return r=d(c(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?\"hsla(\"+t+\", \"+n+\"%, \"+e+\"%, \"+u+\")\":\"hsl(\"+t+\", \"+n+\"%, \"+e+\"%)\";var r,t,n,e,u},r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};var r},r.prototype.invert=function(){return w({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});var r},r.prototype.saturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),w(M(this.rgba,-r))},r.prototype.grayscale=function(){return w(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),w($(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),w($(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return\"number\"==typeof r?w({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);var t},r.prototype.hue=function(r){var t=c(this.rgba);return\"number\"==typeof r?w({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===w(r).toHex()},r}(),w=function(r){return r instanceof j?r:new j(r)},S=[],k=function(r){r.forEach(function(r){S.indexOf(r)<0&&(r(j,y),S.push(r))})},E=function(){return new j({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};export{j as Colord,w as colord,k as extend,I as getFormat,E as random};\n", "export default function(e,f){var a={white:\"#ffffff\",bisque:\"#ffe4c4\",blue:\"#0000ff\",cadetblue:\"#5f9ea0\",chartreuse:\"#7fff00\",chocolate:\"#d2691e\",coral:\"#ff7f50\",antiquewhite:\"#faebd7\",aqua:\"#00ffff\",azure:\"#f0ffff\",whitesmoke:\"#f5f5f5\",papayawhip:\"#ffefd5\",plum:\"#dda0dd\",blanchedalmond:\"#ffebcd\",black:\"#000000\",gold:\"#ffd700\",goldenrod:\"#daa520\",gainsboro:\"#dcdcdc\",cornsilk:\"#fff8dc\",cornflowerblue:\"#6495ed\",burlywood:\"#deb887\",aquamarine:\"#7fffd4\",beige:\"#f5f5dc\",crimson:\"#dc143c\",cyan:\"#00ffff\",darkblue:\"#00008b\",darkcyan:\"#008b8b\",darkgoldenrod:\"#b8860b\",darkkhaki:\"#bdb76b\",darkgray:\"#a9a9a9\",darkgreen:\"#006400\",darkgrey:\"#a9a9a9\",peachpuff:\"#ffdab9\",darkmagenta:\"#8b008b\",darkred:\"#8b0000\",darkorchid:\"#9932cc\",darkorange:\"#ff8c00\",darkslateblue:\"#483d8b\",gray:\"#808080\",darkslategray:\"#2f4f4f\",darkslategrey:\"#2f4f4f\",deeppink:\"#ff1493\",deepskyblue:\"#00bfff\",wheat:\"#f5deb3\",firebrick:\"#b22222\",floralwhite:\"#fffaf0\",ghostwhite:\"#f8f8ff\",darkviolet:\"#9400d3\",magenta:\"#ff00ff\",green:\"#008000\",dodgerblue:\"#1e90ff\",grey:\"#808080\",honeydew:\"#f0fff0\",hotpink:\"#ff69b4\",blueviolet:\"#8a2be2\",forestgreen:\"#228b22\",lawngreen:\"#7cfc00\",indianred:\"#cd5c5c\",indigo:\"#4b0082\",fuchsia:\"#ff00ff\",brown:\"#a52a2a\",maroon:\"#800000\",mediumblue:\"#0000cd\",lightcoral:\"#f08080\",darkturquoise:\"#00ced1\",lightcyan:\"#e0ffff\",ivory:\"#fffff0\",lightyellow:\"#ffffe0\",lightsalmon:\"#ffa07a\",lightseagreen:\"#20b2aa\",linen:\"#faf0e6\",mediumaquamarine:\"#66cdaa\",lemonchiffon:\"#fffacd\",lime:\"#00ff00\",khaki:\"#f0e68c\",mediumseagreen:\"#3cb371\",limegreen:\"#32cd32\",mediumspringgreen:\"#00fa9a\",lightskyblue:\"#87cefa\",lightblue:\"#add8e6\",midnightblue:\"#191970\",lightpink:\"#ffb6c1\",mistyrose:\"#ffe4e1\",moccasin:\"#ffe4b5\",mintcream:\"#f5fffa\",lightslategray:\"#778899\",lightslategrey:\"#778899\",navajowhite:\"#ffdead\",navy:\"#000080\",mediumvioletred:\"#c71585\",powderblue:\"#b0e0e6\",palegoldenrod:\"#eee8aa\",oldlace:\"#fdf5e6\",paleturquoise:\"#afeeee\",mediumturquoise:\"#48d1cc\",mediumorchid:\"#ba55d3\",rebeccapurple:\"#663399\",lightsteelblue:\"#b0c4de\",mediumslateblue:\"#7b68ee\",thistle:\"#d8bfd8\",tan:\"#d2b48c\",orchid:\"#da70d6\",mediumpurple:\"#9370db\",purple:\"#800080\",pink:\"#ffc0cb\",skyblue:\"#87ceeb\",springgreen:\"#00ff7f\",palegreen:\"#98fb98\",red:\"#ff0000\",yellow:\"#ffff00\",slateblue:\"#6a5acd\",lavenderblush:\"#fff0f5\",peru:\"#cd853f\",palevioletred:\"#db7093\",violet:\"#ee82ee\",teal:\"#008080\",slategray:\"#708090\",slategrey:\"#708090\",aliceblue:\"#f0f8ff\",darkseagreen:\"#8fbc8f\",darkolivegreen:\"#556b2f\",greenyellow:\"#adff2f\",seagreen:\"#2e8b57\",seashell:\"#fff5ee\",tomato:\"#ff6347\",silver:\"#c0c0c0\",sienna:\"#a0522d\",lavender:\"#e6e6fa\",lightgreen:\"#90ee90\",orange:\"#ffa500\",orangered:\"#ff4500\",steelblue:\"#4682b4\",royalblue:\"#4169e1\",turquoise:\"#40e0d0\",yellowgreen:\"#9acd32\",salmon:\"#fa8072\",saddlebrown:\"#8b4513\",sandybrown:\"#f4a460\",rosybrown:\"#bc8f8f\",darksalmon:\"#e9967a\",lightgoldenrodyellow:\"#fafad2\",snow:\"#fffafa\",lightgrey:\"#d3d3d3\",lightgray:\"#d3d3d3\",dimgray:\"#696969\",dimgrey:\"#696969\",olivedrab:\"#6b8e23\",olive:\"#808000\"},r={};for(var d in a)r[a[d]]=d;var l={};e.prototype.toName=function(f){if(!(this.rgba.a||this.rgba.r||this.rgba.g||this.rgba.b))return\"transparent\";var d,i,n=r[this.toHex()];if(n)return n;if(null==f?void 0:f.closest){var o=this.toRgb(),t=1/0,b=\"black\";if(!l.length)for(var c in a)l[c]=new e(a[c]).toRgb();for(var g in a){var u=(d=o,i=l[g],Math.pow(d.r-i.r,2)+Math.pow(d.g-i.g,2)+Math.pow(d.b-i.b,2));u<t&&(t=u,b=g)}return b}};f.string.push([function(f){var r=f.toLowerCase(),d=\"transparent\"===r?\"#0000\":a[r];return d?new e(d).toRgb():null},\"name\"])}\n", "import { colord, extend } from '@pixi/colord';\nimport namesPlugin from '@pixi/colord/plugins/names';\n\nimport type { AnyColor, HslaColor, HslColor, HsvaColor, HsvColor, RgbaColor, RgbColor } from '@pixi/colord';\n\nextend([namesPlugin]);\n\n/**\n * Pixi supports multiple color formats, including CSS color strings, hex, numbers, and arrays.\n *\n * When providing values for any of the color properties, you can use any of the {@link color.ColorSource} formats.\n * ```typescript\n * import { Color } from 'pixi.js';\n *\n * // All of these are valid:\n * sprite.tint = 'red';\n * sprite.tint = 0xff0000;\n * sprite.tint = '#ff0000';\n * sprite.tint = new Color('red');\n *\n * // Same for graphics fill/stroke colors and other  color values:\n * graphics.fill({ color: 'red' });\n * graphics.fill({ color: 0xff0000 });\n * graphics.stroke({ color: '#ff0000' });\n * graphics.stroke({ color: new Color('red')};\n * ```\n * @namespace color\n */\n\n/**\n * RGBA color array.\n *\n * `[number, number, number, number]`\n * @memberof color\n */\nexport type RgbaArray = [number, number, number, number];\n\n/**\n * Valid formats to use when defining any color properties, also valid for the {@link color.Color} constructor.\n *\n * These types are extended from [colord](https://www.npmjs.com/package/colord) with some PixiJS-specific extensions.\n *\n * Possible value types are:\n * - [Color names](https://www.w3.org/TR/css-color-4/#named-colors):\n *   `'red'`, `'green'`, `'blue'`, `'white'`, etc.\n * - RGB hex integers (`0xRRGGBB`):\n *   `0xff0000`, `0x00ff00`, `0x0000ff`, etc.\n * - [RGB(A) hex strings](https://www.w3.org/TR/css-color-4/#hex-notation):\n *   - 6 digits (`RRGGBB`): `'ff0000'`, `'#00ff00'`, `'0x0000ff'`, etc.\n *   - 3 digits (`RGB`): `'f00'`, `'#0f0'`, `'0x00f'`, etc.\n *   - 8 digits (`RRGGBBAA`): `'ff000080'`, `'#00ff0080'`, `'0x0000ff80'`, etc.\n *   - 4 digits (`RGBA`): `'f008'`, `'#0f08'`, `'0x00f8'`, etc.\n * - RGB(A) objects:\n *   `{ r: 255, g: 0, b: 0 }`, `{ r: 255, g: 0, b: 0, a: 0.5 }`, etc.\n * - [RGB(A) strings](https://www.w3.org/TR/css-color-4/#rgb-functions):\n *   `'rgb(255, 0, 0)'`, `'rgb(100% 0% 0%)'`, `'rgba(255, 0, 0, 0.5)'`, `'rgba(100% 0% 0% / 50%)'`, etc.\n * - RGB(A) arrays:\n *   `[1, 0, 0]`, `[1, 0, 0, 0.5]`, etc.\n * - RGB(A) Float32Array:\n *   `new Float32Array([1, 0, 0])`, `new Float32Array([1, 0, 0, 0.5])`, etc.\n * - RGB(A) Uint8Array:\n *   `new Uint8Array([255, 0, 0])`, `new Uint8Array([255, 0, 0, 128])`, etc.\n * - RGB(A) Uint8ClampedArray:\n *   `new Uint8ClampedArray([255, 0, 0])`, `new Uint8ClampedArray([255, 0, 0, 128])`, etc.\n * - HSL(A) objects:\n *   `{ h: 0, s: 100, l: 50 }`, `{ h: 0, s: 100, l: 50, a: 0.5 }`, etc.\n * - [HSL(A) strings](https://www.w3.org/TR/css-color-4/#the-hsl-notation):\n *   `'hsl(0, 100%, 50%)'`, `'hsl(0deg 100% 50%)'`, `'hsla(0, 100%, 50%, 0.5)'`, `'hsla(0deg 100% 50% / 50%)'`, etc.\n * - HSV(A) objects:\n *   `{ h: 0, s: 100, v: 100 }`, `{ h: 0, s: 100, v: 100, a: 0.5 }`, etc.\n * - {@link color.Color} objects.\n * @since 7.2.0\n * @memberof color\n */\nexport type ColorSource =\n    | string\n    | number\n    | number[]\n    | Float32Array\n    | Uint8Array\n    | Uint8ClampedArray\n    | HslColor\n    | HslaColor\n    | HsvColor\n    | HsvaColor\n    | RgbColor\n    | RgbaColor\n    | Color\n    | number;\n\ntype ColorSourceTypedArray = Float32Array | Uint8Array | Uint8ClampedArray;\n\n/**\n * Color utility class. Can accept any {@link color.ColorSource} format in its constructor.\n * ```js\n * import { Color } from 'pixi.js';\n *\n * new Color('red').toArray(); // [1, 0, 0, 1]\n * new Color(0xff0000).toArray(); // [1, 0, 0, 1]\n * new Color('ff0000').toArray(); // [1, 0, 0, 1]\n * new Color('#f00').toArray(); // [1, 0, 0, 1]\n * new Color('0xff0000ff').toArray(); // [1, 0, 0, 1]\n * new Color('#f00f').toArray(); // [1, 0, 0, 1]\n * new Color({ r: 255, g: 0, b: 0, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('rgb(255, 0, 0, 0.5)').toArray(); // [1, 0, 0, 0.5]\n * new Color([1, 1, 1]).toArray(); // [1, 1, 1, 1]\n * new Color([1, 0, 0, 0.5]).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Float32Array([1, 0, 0, 0.5])).toArray(); // [1, 0, 0, 0.5]\n * new Color(new Uint8Array([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color(new Uint8ClampedArray([255, 0, 0, 255])).toArray(); // [1, 0, 0, 1]\n * new Color({ h: 0, s: 100, l: 50, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * new Color('hsl(0, 100%, 50%, 50%)').toArray(); // [1, 0, 0, 0.5]\n * new Color({ h: 0, s: 100, v: 100, a: 0.5 }).toArray(); // [1, 0, 0, 0.5]\n * ```\n * @since 7.2.0\n * @memberof color\n */\nexport class Color\n{\n    /**\n     * Default Color object for static uses\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.shared.setValue(0xffffff).toHex(); // '#ffffff'\n     */\n    public static readonly shared = new Color();\n\n    /**\n     * Temporary Color object for static uses internally.\n     * As to not conflict with Color.shared.\n     * @ignore\n     */\n    private static readonly _temp = new Color();\n\n    /** Pattern for hex strings */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    private static readonly HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;\n\n    /** Internal color source, from constructor or set value */\n    private _value: Exclude<ColorSource, Color> | null;\n\n    /** Normalized rgba component, floats from 0-1 */\n    private _components: Float32Array;\n\n    /** Cache color as number */\n    private _int: number;\n\n    /** An array of the current Color. Only populated when `toArray` functions are called */\n    private _arrayRgba: number[] | null;\n    private _arrayRgb: number[] | null;\n\n    /**\n     * @param {ColorSource} value - Optional value to use, if not provided, white is used.\n     */\n    constructor(value: ColorSource = 0xffffff)\n    {\n        this._value = null;\n        this._components = new Float32Array(4);\n        this._components.fill(1);\n        this._int = 0xffffff;\n        this.value = value;\n    }\n\n    /** Get red component (0 - 1) */\n    get red(): number\n    {\n        return this._components[0];\n    }\n\n    /** Get green component (0 - 1) */\n    get green(): number\n    {\n        return this._components[1];\n    }\n\n    /** Get blue component (0 - 1) */\n    get blue(): number\n    {\n        return this._components[2];\n    }\n\n    /** Get alpha component (0 - 1) */\n    get alpha(): number\n    {\n        return this._components[3];\n    }\n\n    /**\n     * Set the value, suitable for chaining\n     * @param value\n     * @see Color.value\n     */\n    public setValue(value: ColorSource): this\n    {\n        this.value = value;\n\n        return this;\n    }\n\n    /**\n     * The current color source.\n     *\n     * When setting:\n     * - Setting to an instance of `Color` will copy its color source and components.\n     * - Otherwise, `Color` will try to normalize the color source and set the components.\n     *   If the color source is invalid, an `Error` will be thrown and the `Color` will left unchanged.\n     *\n     * Note: The `null` in the setter's parameter type is added to match the TypeScript rule: return type of getter\n     * must be assignable to its setter's parameter type. Setting `value` to `null` will throw an `Error`.\n     *\n     * When getting:\n     * - A return value of `null` means the previous value was overridden (e.g., {@link Color.multiply multiply},\n     *   {@link Color.premultiply premultiply} or {@link Color.round round}).\n     * - Otherwise, the color source used when setting is returned.\n     */\n    set value(value: ColorSource | null)\n    {\n        // Support copying from other Color objects\n        if (value instanceof Color)\n        {\n            this._value = this._cloneSource(value._value);\n            this._int = value._int;\n            this._components.set(value._components);\n        }\n        else if (value === null)\n        {\n            throw new Error('Cannot set Color#value to null');\n        }\n        else if (this._value === null || !this._isSourceEqual(this._value, value))\n        {\n            this._value = this._cloneSource(value);\n            this._normalize(this._value);\n        }\n    }\n    get value(): Exclude<ColorSource, Color> | null\n    {\n        return this._value;\n    }\n\n    /**\n     * Copy a color source internally.\n     * @param value - Color source\n     */\n    private _cloneSource(value: Exclude<ColorSource, Color> | null): Exclude<ColorSource, Color> | null\n    {\n        if (typeof value === 'string' || typeof value === 'number' || value instanceof Number || value === null)\n        {\n            return value;\n        }\n        else if (Array.isArray(value) || ArrayBuffer.isView(value))\n        {\n            return value.slice(0);\n        }\n        else if (typeof value === 'object' && value !== null)\n        {\n            return { ...value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Equality check for color sources.\n     * @param value1 - First color source\n     * @param value2 - Second color source\n     * @returns `true` if the color sources are equal, `false` otherwise.\n     */\n    private _isSourceEqual(value1: Exclude<ColorSource, Color>, value2: Exclude<ColorSource, Color>): boolean\n    {\n        const type1 = typeof value1;\n        const type2 = typeof value2;\n\n        // Mismatched types\n        if (type1 !== type2)\n        {\n            return false;\n        }\n        // Handle numbers/strings and things that extend Number\n        // important to do the instanceof Number first, as this is \"object\" type\n        else if (type1 === 'number' || type1 === 'string' || value1 instanceof Number)\n        {\n            return value1 === value2;\n        }\n        // Handle Arrays and TypedArrays\n        else if (\n            (Array.isArray(value1) && Array.isArray(value2))\n            || (ArrayBuffer.isView(value1) && ArrayBuffer.isView(value2))\n        )\n        {\n            if (value1.length !== value2.length)\n            {\n                return false;\n            }\n\n            return value1.every((v, i) => v === value2[i]);\n        }\n        // Handle Objects\n        else if (value1 !== null && value2 !== null)\n        {\n            const keys1 = Object.keys(value1) as (keyof typeof value1)[];\n            const keys2 = Object.keys(value2) as (keyof typeof value2)[];\n\n            if (keys1.length !== keys2.length)\n            {\n                return false;\n            }\n\n            return keys1.every((key) => value1[key] === value2[key]);\n        }\n\n        return value1 === value2;\n    }\n\n    /**\n     * Convert to a RGBA color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1, a: 1 }\n     */\n    public toRgba(): RgbaColor\n    {\n        const [r, g, b, a] = this._components;\n\n        return { r, g, b, a };\n    }\n\n    /**\n     * Convert to a RGB color object.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgb(); // returns { r: 1, g: 1, b: 1 }\n     */\n    public toRgb(): RgbColor\n    {\n        const [r, g, b] = this._components;\n\n        return { r, g, b };\n    }\n\n    /** Convert to a CSS-style rgba string: `rgba(255,255,255,1.0)`. */\n    public toRgbaString(): string\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return `rgba(${r},${g},${b},${this.alpha})`;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of clamped uint8 values (0 to 255).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toUint8RgbArray(); // returns [255, 255, 255]\n     * @param {number[]|Uint8Array|Uint8ClampedArray} [out] - Output array\n     */\n    public toUint8RgbArray(): number[];\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out: T): T;\n    public toUint8RgbArray<T extends number[] | Uint8Array | Uint8ClampedArray>(out?: T): T\n    {\n        const [r, g, b] = this._components;\n\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n\n        out[0] = Math.round(r * 255);\n        out[1] = Math.round(g * 255);\n        out[2] = Math.round(b * 255);\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B, A] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toArray(); // returns [1, 1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toArray(): number[];\n    public toArray<T extends number[] | Float32Array>(out: T): T;\n    public toArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgba)\n        {\n            this._arrayRgba = [];\n        }\n\n        out ||= this._arrayRgba as T;\n        const [r, g, b, a] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n        out[3] = a;\n\n        return out;\n    }\n\n    /**\n     * Convert to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toRgbArray(); // returns [1, 1, 1]\n     * @param {number[]|Float32Array} [out] - Output array\n     */\n    public toRgbArray(): number[];\n    public toRgbArray<T extends number[] | Float32Array>(out: T): T;\n    public toRgbArray<T extends number[] | Float32Array>(out?: T): T\n    {\n        if (!this._arrayRgb)\n        {\n            this._arrayRgb = [];\n        }\n\n        out ||= this._arrayRgb as T;\n        const [r, g, b] = this._components;\n\n        out[0] = r;\n        out[1] = g;\n        out[2] = b;\n\n        return out;\n    }\n\n    /**\n     * Convert to a hexadecimal number.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toNumber(); // returns 16777215\n     */\n    public toNumber(): number\n    {\n        return this._int;\n    }\n\n    /**\n     * Convert to a BGR number\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toBgrNumber(); // returns 0x99ccff\n     */\n    public toBgrNumber(): number\n    {\n        const [r, g, b] = this.toUint8RgbArray();\n\n        return (b << 16) + (g << 8) + r;\n    }\n\n    /**\n     * Convert to a hexadecimal number in little endian format (e.g., BBGGRR).\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color(0xffcc99).toLittleEndianNumber(); // returns 0x99ccff\n     * @returns {number} - The color as a number in little endian format.\n     */\n    public toLittleEndianNumber(): number\n    {\n        const value = this._int;\n\n        return (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n    }\n\n    /**\n     * Multiply with another color. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param {ColorSource} value - The color to multiply by.\n     */\n    public multiply(value: ColorSource): this\n    {\n        const [r, g, b, a] = Color._temp.setValue(value)._components;\n\n        this._components[0] *= r;\n        this._components[1] *= g;\n        this._components[2] *= b;\n        this._components[3] *= a;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Converts color to a premultiplied alpha format. This action is destructive, and will\n     * override the previous `value` property to be `null`.\n     * @param alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {Color} - Itself.\n     */\n    public premultiply(alpha: number, applyToRGB = true): this\n    {\n        if (applyToRGB)\n        {\n            this._components[0] *= alpha;\n            this._components[1] *= alpha;\n            this._components[2] *= alpha;\n        }\n        this._components[3] = alpha;\n\n        this._refreshInt();\n        this._value = null;\n\n        return this;\n    }\n\n    /**\n     * Premultiplies alpha with current color.\n     * @param {number} alpha - The alpha to multiply by.\n     * @param {boolean} [applyToRGB=true] - Whether to premultiply RGB channels.\n     * @returns {number} tint multiplied by alpha\n     */\n    public toPremultiplied(alpha: number, applyToRGB = true): number\n    {\n        if (alpha === 1.0)\n        {\n            return (0xff << 24) + this._int;\n        }\n        if (alpha === 0.0)\n        {\n            return applyToRGB ? 0 : this._int;\n        }\n        let r = (this._int >> 16) & 0xff;\n        let g = (this._int >> 8) & 0xff;\n        let b = this._int & 0xff;\n\n        if (applyToRGB)\n        {\n            r = ((r * alpha) + 0.5) | 0;\n            g = ((g * alpha) + 0.5) | 0;\n            b = ((b * alpha) + 0.5) | 0;\n        }\n\n        return ((alpha * 255) << 24) + (r << 16) + (g << 8) + b;\n    }\n\n    /**\n     * Convert to a hexadecimal string.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHex(); // returns \"#ffffff\"\n     */\n    public toHex(): string\n    {\n        const hexString = this._int.toString(16);\n\n        return `#${'000000'.substring(0, 6 - hexString.length) + hexString}`;\n    }\n\n    /**\n     * Convert to a hexadecimal string with alpha.\n     * @example\n     * import { Color } from 'pixi.js';\n     * new Color('white').toHexa(); // returns \"#ffffffff\"\n     */\n    public toHexa(): string\n    {\n        const alphaValue = Math.round(this._components[3] * 255);\n        const alphaString = alphaValue.toString(16);\n\n        return this.toHex() + '00'.substring(0, 2 - alphaString.length) + alphaString;\n    }\n\n    /**\n     * Set alpha, suitable for chaining.\n     * @param alpha\n     */\n    public setAlpha(alpha: number): this\n    {\n        this._components[3] = this._clamp(alpha);\n\n        return this;\n    }\n\n    /**\n     * Normalize the input value into rgba\n     * @param value - Input value\n     */\n    private _normalize(value: Exclude<ColorSource, Color>): void\n    {\n        let r: number | undefined;\n        let g: number | undefined;\n        let b: number | undefined;\n        let a: number | undefined;\n\n        // Number is a primitive so typeof works fine, but in the case\n        // that someone creates a class that extends Number, we also\n        // need to check for instanceof Number\n        if (\n            (typeof value === 'number' || value instanceof Number)\n            && (value as number) >= 0\n            && (value as number) <= 0xffffff\n        )\n        {\n            const int = value as number; // cast required because instanceof Number is ambiguous for TS\n\n            r = ((int >> 16) & 0xff) / 255;\n            g = ((int >> 8) & 0xff) / 255;\n            b = (int & 0xff) / 255;\n            a = 1.0;\n        }\n        else if (\n            (Array.isArray(value) || value instanceof Float32Array)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 1\n            value = this._clamp(value);\n            [r, g, b, a = 1.0] = value;\n        }\n        else if (\n            (value instanceof Uint8Array || value instanceof Uint8ClampedArray)\n            // Can be rgb or rgba\n            && value.length >= 3\n            && value.length <= 4\n        )\n        {\n            // make sure all values are 0 - 255\n            value = this._clamp(value, 0, 255);\n            [r, g, b, a = 255] = value;\n            r /= 255;\n            g /= 255;\n            b /= 255;\n            a /= 255;\n        }\n        else if (typeof value === 'string' || typeof value === 'object')\n        {\n            if (typeof value === 'string')\n            {\n                const match = Color.HEX_PATTERN.exec(value);\n\n                if (match)\n                {\n                    // Normalize hex string, remove 0x or # prefix\n                    value = `#${match[2]}`;\n                }\n            }\n\n            const color = colord(value as AnyColor);\n\n            if (color.isValid())\n            {\n                ({ r, g, b, a } = color.rgba);\n                r /= 255;\n                g /= 255;\n                b /= 255;\n            }\n        }\n\n        // Cache normalized values for rgba and hex integer\n        if (r !== undefined)\n        {\n            this._components[0] = r as number;\n            this._components[1] = g as number;\n            this._components[2] = b as number;\n            this._components[3] = a as number;\n            this._refreshInt();\n        }\n        else\n        {\n            throw new Error(`Unable to convert color ${value}`);\n        }\n    }\n\n    /** Refresh the internal color rgb number */\n    private _refreshInt(): void\n    {\n        // Clamp values to 0 - 1\n        this._clamp(this._components);\n\n        const [r, g, b] = this._components;\n\n        this._int = ((r * 255) << 16) + ((g * 255) << 8) + ((b * 255) | 0);\n    }\n\n    /**\n     * Clamps values to a range. Will override original values\n     * @param value - Value(s) to clamp\n     * @param min - Minimum value\n     * @param max - Maximum value\n     */\n    private _clamp<T extends number | number[] | ColorSourceTypedArray>(value: T, min = 0, max = 1): T\n    {\n        if (typeof value === 'number')\n        {\n            return Math.min(Math.max(value, min), max) as T;\n        }\n\n        value.forEach((v, i) =>\n        {\n            value[i] = Math.min(Math.max(v, min), max);\n        });\n\n        return value;\n    }\n\n    /**\n     * Check if the value is a color-like object\n     * @param value - Value to check\n     * @returns True if the value is a color-like object\n     * @static\n     * @example\n     * import { Color } from 'pixi.js';\n     * Color.isColorLike('white'); // returns true\n     * Color.isColorLike(0xffffff); // returns true\n     * Color.isColorLike([1, 1, 1]); // returns true\n     */\n    public static isColorLike(value: unknown): value is ColorSource\n    {\n        return (\n            typeof value === 'number'\n            || typeof value === 'string'\n            || value instanceof Number\n            || value instanceof Color\n            || Array.isArray(value)\n            || value instanceof Uint8Array\n            || value instanceof Uint8ClampedArray\n            || value instanceof Float32Array\n            || ((value as RgbColor).r !== undefined\n                && (value as RgbColor).g !== undefined\n                && (value as RgbColor).b !== undefined)\n            || ((value as RgbaColor).r !== undefined\n                && (value as RgbaColor).g !== undefined\n                && (value as RgbaColor).b !== undefined\n                && (value as RgbaColor).a !== undefined)\n            || ((value as HslColor).h !== undefined\n                && (value as HslColor).s !== undefined\n                && (value as HslColor).l !== undefined)\n            || ((value as HslaColor).h !== undefined\n                && (value as HslaColor).s !== undefined\n                && (value as HslaColor).l !== undefined\n                && (value as HslaColor).a !== undefined)\n            || ((value as HsvColor).h !== undefined\n                && (value as HsvColor).s !== undefined\n                && (value as HsvColor).v !== undefined)\n            || ((value as HsvaColor).h !== undefined\n                && (value as HsvaColor).s !== undefined\n                && (value as HsvaColor).v !== undefined\n                && (value as HsvaColor).a !== undefined)\n        );\n    }\n}\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\n\nexport interface CullingMixinConstructor\n{\n    /**\n     * If set, this shape is used for culling instead of the bounds of this object.\n     * It can improve the culling performance of objects with many children.\n     * The culling area is defined in local space.\n     * @memberof scene.Container#\n     */\n    cullArea: Rectangle,\n    /**\n     * Should this object be rendered if the bounds of this object are out of frame?\n     *\n     * Culling has no effect on whether updateTransform is called.\n     * @default false\n     * @memberof scene.Container#\n     */\n    cullable: boolean,\n    /**\n     * Determines if the children to the container can be culled\n     * Setting this to false allows PixiJS to bypass a recursive culling function\n     * Which can help to optimize very complex scenes\n     * @default true\n     * @memberof scene.Container#\n     */\n    cullableChildren: boolean,\n}\n\nexport const cullingMixin: CullingMixinConstructor = {\n    cullArea: null,\n    cullable: false,\n    cullableChildren: true,\n};\n", "/**\n * Two Pi.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const PI_2 = Math.PI * 2;\n\n/**\n * Conversion factor for converting radians to degrees.\n * @static\n * @member {number} RAD_TO_DEG\n * @memberof maths\n */\nexport const RAD_TO_DEG = 180 / Math.PI;\n\n/**\n * Conversion factor for converting degrees to radians.\n * @static\n * @member {number}\n * @memberof maths\n */\nexport const DEG_TO_RAD = Math.PI / 180;\n\n/**\n * Constants that identify shapes, mainly to prevent `instanceof` calls.\n * @memberof maths\n */\nexport type SHAPE_PRIMITIVE =\n    | 'polygon'\n    | 'rectangle'\n    | 'circle'\n    | 'ellipse'\n    | 'triangle'\n    | 'roundedRectangle';\n\n/**\n * The `maths` folder contains utility classes and functions for mathematical operations used throughout the project.\n * This includes constants such as conversion factors for radians and degrees, as well as shapes such as polygons,\n * rectangles, circles, ellipses, triangles, and rounded rectangles.\n * ```js\n * import { RAD_TO_DEG, Circle } from 'pixi.js';\n *\n * // Convert 180 degrees to radians\n * const radians = 180 * RAD_TO_DEG;\n *\n * // test if a point is inside a circle\n * const isPointInCircle = new Circle(0, 0, 10).contains(0, 0); // true\n * ```\n * @namespace maths\n */\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Point extends PixiMixins.Point { }\n\n/**\n * The Point object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n * <br/>\n * Many Pixi functions accept the `PointData` type as an alternative to `Point`,\n * which only requires `x` and `y` properties.\n * @class\n * @implements {PointLike}\n * @memberof maths\n */\nexport class Point implements PointLike\n{\n    /** Position of the point on the x axis */\n    public x = 0;\n    /** Position of the point on the y axis */\n    public y = 0;\n\n    /**\n     * Creates a new `Point`\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(x = 0, y = 0)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    /**\n     * Creates a clone of this point\n     * @returns A clone of this point\n     */\n    public clone(): Point\n    {\n        return new Point(this.x, this.y);\n    }\n\n    /**\n     * Copies `x` and `y` from the given point into this point\n     * @param p - The point to copy from\n     * @returns The point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        this.set(p.x, p.y);\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into the given point (`p`).\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this.x, this.y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this.x) && (p.y === this.y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the `x` axis\n     * @param {number} [y=x] - position of the point on the `y` axis\n     * @returns The point instance itself\n     */\n    public set(x = 0, y: number = x): this\n    {\n        this.x = x;\n        this.y = y;\n\n        return this;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`;\n    }\n    // #endif\n\n    /**\n     * A static Point object with `x` and `y` values of `0`. Can be used to avoid creating new objects multiple times.\n     * @readonly\n     */\n    static get shared(): Point\n    {\n        tempPoint.x = 0;\n        tempPoint.y = 0;\n\n        return tempPoint;\n    }\n}\n\nconst tempPoint = new Point();\n", "/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { PI_2 } from '../misc/const';\nimport { Point } from '../point/Point';\n\nimport type { PointData } from '../point/PointData';\n\ninterface TransformableObject\n{\n    position: PointData;\n    scale: PointData;\n    pivot: PointData;\n    skew: PointData;\n    rotation: number;\n}\n\n/**\n * A fast matrix for 2D transformations.\n * ```js\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n * ```\n * @memberof maths\n */\nexport class Matrix\n{\n    /** @default 1 */\n    public a: number;\n\n    /** @default 0 */\n    public b: number;\n\n    /** @default 0 */\n    public c: number;\n\n    /** @default 1 */\n    public d: number;\n\n    /** @default 0 */\n    public tx: number;\n\n    /** @default 0 */\n    public ty: number;\n\n    /** An array of the current matrix. Only populated when `toArray` is called */\n    public array: Float32Array | null = null;\n\n    /**\n     * @param a - x scale\n     * @param b - y skew\n     * @param c - x skew\n     * @param d - y scale\n     * @param tx - x translation\n     * @param ty - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     * @param array - The array that the matrix will be populated from.\n     */\n    public fromArray(array: number[]): void\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * Sets the matrix properties.\n     * @param a - Matrix component\n     * @param b - Matrix component\n     * @param c - Matrix component\n     * @param d - Matrix component\n     * @param tx - Matrix component\n     * @param ty - Matrix component\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public set(a: number, b: number, c: number, d: number, tx: number, ty: number): this\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     * @param transpose - Whether we need to transpose the matrix or not\n     * @param [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @returns The newly created array which contains the matrix\n     */\n    public toArray(transpose?: boolean, out?: Float32Array): Float32Array\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, transformed through this matrix\n     */\n    public apply<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     * @param pos - The origin\n     * @param {Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @returns {Point} The new point, inverse-transformed through this matrix\n     */\n    public applyInverse<P extends PointData = Point>(pos: PointData, newPos?: P): P\n    {\n        newPos = (newPos || new Point()) as P;\n\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const tx = this.tx;\n        const ty = this.ty;\n\n        const id = 1 / ((a * d) + (c * -b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (d * id * x) + (-c * id * y) + (((ty * c) - (tx * d)) * id);\n        newPos.y = (a * id * y) + (-b * id * x) + (((-ty * a) + (tx * b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y.\n     * @param x - How much to translate x by\n     * @param y - How much to translate y by\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public translate(x: number, y: number): this\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     * @param x - The amount to scale horizontally\n     * @param y - The amount to scale vertically\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public scale(x: number, y: number): this\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     * @param angle - The angle in radians.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public rotate(angle: number): this\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     * @param matrix - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public append(matrix: Matrix): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Appends two matrix's and sets the result to this matrix. AB = A * B\n     * @param a - The matrix to append.\n     * @param b - The matrix to append.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public appendFrom(a: Matrix, b: Matrix): this\n    {\n        const a1 = a.a;\n        const b1 = a.b;\n        const c1 = a.c;\n        const d1 = a.d;\n        const tx = a.tx;\n        const ty = a.ty;\n\n        const a2 = b.a;\n        const b2 = b.b;\n        const c2 = b.c;\n        const d2 = b.d;\n\n        this.a = (a1 * a2) + (b1 * c2);\n        this.b = (a1 * b2) + (b1 * d2);\n        this.c = (c1 * a2) + (d1 * c2);\n        this.d = (c1 * b2) + (d1 * d2);\n        this.tx = (tx * a2) + (ty * c2) + b.tx;\n        this.ty = (tx * b2) + (ty * d2) + b.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties\n     * @param x - Position on the x axis\n     * @param y - Position on the y axis\n     * @param pivotX - Pivot on the x axis\n     * @param pivotY - Pivot on the y axis\n     * @param scaleX - Scale on the x axis\n     * @param scaleY - Scale on the y axis\n     * @param rotation - Rotation in radians\n     * @param skewX - Skew on the x axis\n     * @param skewY - Skew on the y axis\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public setTransform(x: number, y: number, pivotX: number, pivotY: number, scaleX: number,\n        scaleY: number, rotation: number, skewX: number, skewY: number): this\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     * @param matrix - The matrix to prepend\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public prepend(matrix: Matrix): this\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     * @param transform - The transform to apply the properties to.\n     * @returns The transform with the newly applied properties\n     */\n    public decompose(transform: TransformableObject): TransformableObject\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n        const pivot = transform.pivot;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx + ((pivot.x * a) + (pivot.y * c));\n        transform.position.y = this.ty + ((pivot.x * b) + (pivot.y * d));\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public invert(): this\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /** Checks if this matrix is an identity matrix */\n    public isIdentity(): boolean\n    {\n        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0;\n    }\n\n    /**\n     * Resets this Matrix to an identity (default) matrix.\n     * @returns This matrix. Good for chaining method calls.\n     */\n    public identity(): this\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     * @returns A copy of this matrix. Good for chaining method calls.\n     */\n    public clone(): Matrix\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     * @param matrix - The matrix to copy to.\n     * @returns The matrix given in parameter with its values updated.\n     */\n    public copyTo(matrix: Matrix): Matrix\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the matrix to be the same as the ones in given matrix\n     * @param matrix - The matrix to copy from.\n     * @returns this\n     */\n    public copyFrom(matrix: Matrix): this\n    {\n        this.a = matrix.a;\n        this.b = matrix.b;\n        this.c = matrix.c;\n        this.d = matrix.d;\n        this.tx = matrix.tx;\n        this.ty = matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * check to see if two matrices are the same\n     * @param matrix - The matrix to compare to.\n     */\n    public equals(matrix: Matrix)\n    {\n        return matrix.a === this.a && matrix.b === this.b\n            && matrix.c === this.c && matrix.d === this.d\n            && matrix.tx === this.tx && matrix.ty === this.ty;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`;\n    }\n    // #endif\n\n    /**\n     * A default (identity) matrix.\n     *\n     * This is a shared object, if you want to modify it consider creating a new `Matrix`\n     * @readonly\n     */\n    static get IDENTITY(): Readonly<Matrix>\n    {\n        return identityMatrix.identity();\n    }\n\n    /**\n     * A static Matrix that can be used to avoid creating new objects.\n     * Will always ensure the matrix is reset to identity when requested.\n     * Use this object for fast but temporary calculations, as it may be mutated later on.\n     * This is a different object to the `IDENTITY` object and so can be modified without changing `IDENTITY`.\n     * @readonly\n     */\n    static get shared(): Matrix\n    {\n        return tempMatrix.identity();\n    }\n}\n\nconst tempMatrix = new Matrix();\nconst identityMatrix = new Matrix();\n", "import type { PointData } from './PointData';\nimport type { PointLike } from './PointLike';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface ObservablePoint extends PixiMixins.ObservablePoint { }\n\n/**\n * Observer used to listen for observable point changes.\n * @memberof maths\n */\nexport interface Observer<T>\n{\n    /** Callback to call when the point has updated. */\n    _onUpdate: (point?: T) => void;\n}\n\n/**\n * The ObservablePoint object represents a location in a two-dimensional coordinate system, where `x` represents\n * the position on the horizontal axis and `y` represents the position on the vertical axis.\n *\n * An `ObservablePoint` is a point that triggers the `onUpdate` method on an observer when the point's position is changed.\n * @memberof maths\n */\nexport class ObservablePoint implements PointLike\n{\n    /** @ignore */\n    public _x: number;\n    /** @ignore */\n    public _y: number;\n\n    /** This object used to call the `onUpdate` callback when the point changes. */\n    private readonly _observer: Observer<ObservablePoint>;\n\n    /**\n     * Creates a new `ObservablePoint`\n     * @param observer - Observer to pass to listen for change events.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=0] - position of the point on the y axis\n     */\n    constructor(observer: Observer<ObservablePoint>, x?: number, y?: number)\n    {\n        this._x = x || 0;\n        this._y = y || 0;\n\n        this._observer = observer;\n    }\n\n    /**\n     * Creates a clone of this point.\n     * @param observer - Optional observer to pass to the new observable point.\n     * @returns a copy of this observable point\n     */\n    public clone(observer?: Observer<ObservablePoint>): ObservablePoint\n    {\n        return new ObservablePoint(observer ?? this._observer, this._x, this._y);\n    }\n\n    /**\n     * Sets the point to a new `x` and `y` position.\n     * If `y` is omitted, both `x` and `y` will be set to `x`.\n     * @param {number} [x=0] - position of the point on the x axis\n     * @param {number} [y=x] - position of the point on the y axis\n     * @returns The observable point instance itself\n     */\n    public set(x = 0, y = x): this\n    {\n        if (this._x !== x || this._y !== y)\n        {\n            this._x = x;\n            this._y = y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies x and y from the given point (`p`)\n     * @param p - The point to copy from. Can be any of type that is or extends `PointData`\n     * @returns The observable point instance itself\n     */\n    public copyFrom(p: PointData): this\n    {\n        if (this._x !== p.x || this._y !== p.y)\n        {\n            this._x = p.x;\n            this._y = p.y;\n            this._observer._onUpdate(this);\n        }\n\n        return this;\n    }\n\n    /**\n     * Copies this point's x and y into that of the given point (`p`)\n     * @param p - The point to copy to. Can be any of type that is or extends `PointData`\n     * @returns The point (`p`) with values updated\n     */\n    public copyTo<T extends PointLike>(p: T): T\n    {\n        p.set(this._x, this._y);\n\n        return p;\n    }\n\n    /**\n     * Accepts another point (`p`) and returns `true` if the given point is equal to this point\n     * @param p - The point to check\n     * @returns Returns `true` if both `x` and `y` are equal\n     */\n    public equals(p: PointData): boolean\n    {\n        return (p.x === this._x) && (p.y === this._y);\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:ObservablePoint x=${0} y=${0} scope=${this._observer}]`;\n    }\n    // #endif\n\n    /** Position of the observable point on the x axis. */\n    get x(): number\n    {\n        return this._x;\n    }\n\n    set x(value: number)\n    {\n        if (this._x !== value)\n        {\n            this._x = value;\n            this._observer._onUpdate(this);\n        }\n    }\n\n    /** Position of the observable point on the y axis. */\n    get y(): number\n    {\n        return this._y;\n    }\n\n    set y(value: number)\n    {\n        if (this._y !== value)\n        {\n            this._y = value;\n            this._observer._onUpdate(this);\n        }\n    }\n}\n", "const uidCache: Record<string, number> = {\n    default: -1,\n};\n\ntype UIDNames =\n    | 'default'\n    | 'resource'\n    | 'texture'\n    | 'textureSource'\n    | 'textureResource'\n    | 'batcher' //\n    | 'graphicsContext' //\n    | 'graphicsView' //\n    | 'graphicsPath' //\n    | 'fillGradient' //\n    | 'fillPattern' //\n    | 'meshView' //\n    | 'renderable' //\n    | 'buffer' //\n    | 'bufferResource' //\n    | 'geometry'\n    | 'instructionSet' //\n    | 'renderTarget' //\n    | 'uniform' //\n    | 'spriteView' //\n    | 'textView' //\n    | 'tilingSpriteView' //\n    | 'shader';\n\n/**\n * Gets the next unique identifier\n * @param name - The name of the identifier.\n * @function uid\n * @returns {number} The next unique identifier to use.\n * @memberof utils\n */\nexport function uid(name: UIDNames = 'default'): number\n{\n    if (uidCache[name] === undefined)\n    {\n        uidCache[name] = -1;\n    }\n\n    return ++uidCache[name];\n}\n\n/** Resets the next unique identifier to 0. This is used for some tests, dont touch or things WILL explode :) */\nexport function resetUids(): void\n{\n    for (const key in uidCache)\n    {\n        delete uidCache[key];\n    }\n}\n", "import type { Dict } from '../types';\n\n// A map of warning messages already fired\nconst warnings: Dict<boolean> = {};\n\n/**\n * deprecation name for version 8.0.0\n * @ignore\n */\nexport const v8_0_0 = '8.0.0';\nexport const v8_3_4 = '8.3.4';\n\n/**\n * Helper for warning developers about deprecated features & settings.\n * A stack track for warnings is given; useful for tracking-down where\n * deprecated methods/properties/classes are being used within the code.\n * @memberof utils\n * @ignore\n * @function deprecation\n * @param {string} version - The version where the feature became deprecated\n * @param {string} message - Message should include what is deprecated, where, and the new solution\n * @param {number} [ignoreDepth=3] - The number of steps to ignore at the top of the error stack\n *        this is mostly to ignore internal deprecation calls.\n */\nexport function deprecation(version: string, message: string, ignoreDepth = 3): void\n{\n    // Ignore duplicate\n    if (warnings[message])\n    {\n        return;\n    }\n\n    /* eslint-disable no-console */\n    let stack = new Error().stack;\n\n    // Handle IE < 10 and Safari < 6\n    if (typeof stack === 'undefined')\n    {\n        console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n    }\n    else\n    {\n        // chop off the stack trace which includes PixiJS internal calls\n        stack = stack.split('\\n').splice(ignoreDepth).join('\\n');\n\n        if (console.groupCollapsed)\n        {\n            console.groupCollapsed(\n                '%cPixiJS Deprecation Warning: %c%s',\n                'color:#614108;background:#fffbe6',\n                'font-weight:normal;color:#614108;background:#fffbe6',\n                `${message}\\nDeprecated since v${version}`\n            );\n            console.warn(stack);\n            console.groupEnd();\n        }\n        else\n        {\n            console.warn('PixiJS Deprecation Warning: ', `${message}\\nDeprecated since v${version}`);\n            console.warn(stack);\n        }\n    }\n    /* eslint-enable no-console */\n\n    warnings[message] = true;\n}\n", "/**\n * A generic class for managing a pool of items.\n * @template T The type of items in the pool. Must implement {@link utils.PoolItem}.\n * @memberof utils\n */\nexport class Pool<T extends PoolItem>\n{\n    public readonly _classType: PoolItemConstructor<T>;\n    private readonly _pool: T[] = [];\n    private _count = 0;\n    private _index = 0;\n\n    /**\n     * Constructs a new Pool.\n     * @param ClassType - The constructor of the items in the pool.\n     * @param {number} [initialSize] - The initial size of the pool.\n     */\n    constructor(ClassType: PoolItemConstructor<T>, initialSize?: number)\n    {\n        this._classType = ClassType;\n\n        if (initialSize)\n        {\n            this.prepopulate(initialSize);\n        }\n    }\n\n    /**\n     * Prepopulates the pool with a given number of items.\n     * @param total - The number of items to add to the pool.\n     */\n    public prepopulate(total: number): void\n    {\n        for (let i = 0; i < total; i++)\n        {\n            this._pool[this._index++] = new this._classType();\n        }\n\n        this._count += total;\n    }\n\n    /**\n     * Gets an item from the pool. Calls the item's `init` method if it exists.\n     * If there are no items left in the pool, a new one will be created.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get(data?: unknown): T\n    {\n        let item;\n\n        if (this._index > 0)\n        {\n            item = this._pool[--this._index];\n        }\n        else\n        {\n            item = new this._classType();\n        }\n\n        item.init?.(data);\n\n        return item;\n    }\n\n    /**\n     * Returns an item to the pool. Calls the item's `reset` method if it exists.\n     * @param {T} item - The item to return to the pool.\n     */\n    public return(item: T): void\n    {\n        item.reset?.();\n\n        this._pool[this._index++] = item;\n    }\n\n    /**\n     * Gets the number of items in the pool.\n     * @readonly\n     * @member {number}\n     */\n    get totalSize(): number\n    {\n        return this._count;\n    }\n\n    /**\n     * Gets the number of items in the pool that are free to use without needing to create more.\n     * @readonly\n     * @member {number}\n     */\n    get totalFree(): number\n    {\n        return this._index;\n    }\n\n    /**\n     * Gets the number of items in the pool that are currently in use.\n     * @readonly\n     * @member {number}\n     */\n    get totalUsed(): number\n    {\n        return this._count - this._index;\n    }\n\n    /** clears the pool - mainly used for debugging! */\n    public clear()\n    {\n        this._pool.length = 0;\n        this._index = 0;\n    }\n}\n\n/**\n * An object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItem = {\n    init?: (data?: any) => void;\n    reset?: () => void;\n    [key: string]: any;\n};\n\n/**\n * The constructor of an object that can be stored in a {@link utils.Pool}.\n * @typeParam K - The type of the object that can be stored in a {@link utils.Pool}.\n * @memberof utils\n */\nexport type PoolItemConstructor<K extends PoolItem> = new () => K;\n", "import { Pool } from './Pool';\n\nimport type { PoolItem, PoolItemConstructor } from './Pool';\n\n/**\n * A type alias for a constructor of a Pool.\n * @template T The type of items in the pool. Must extend PoolItem.\n * @memberof utils\n */\nexport type PoolConstructor<T extends PoolItem> = new () => Pool<T>;\n\n/**\n * A group of pools that can be used to store objects of different types.\n * @memberof utils\n */\nexport class PoolGroupClass\n{\n    /**\n     * A map to store the pools by their class type.\n     * @private\n     */\n    private readonly _poolsByClass: Map<PoolItemConstructor<PoolItem>, Pool<PoolItem>> = new Map();\n\n    /**\n     * Prepopulates a specific pool with a given number of items.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {number} total - The number of items to add to the pool.\n     */\n    public prepopulate<T extends PoolItem>(Class: PoolItemConstructor<T>, total: number): void\n    {\n        const classPool = this.getPool(Class);\n\n        classPool.prepopulate(total);\n    }\n\n    /**\n     * Gets an item from a specific pool.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} Class - The constructor of the items in the pool.\n     * @param {unknown} [data] - Optional data to pass to the item's constructor.\n     * @returns {T} The item from the pool.\n     */\n    public get<T extends PoolItem>(Class: PoolItemConstructor<T>, data?: unknown): T\n    {\n        const pool = this.getPool(Class);\n\n        return pool.get(data) as T;\n    }\n\n    /**\n     * Returns an item to its respective pool.\n     * @param {PoolItem} item - The item to return to the pool.\n     */\n    public return(item: PoolItem): void\n    {\n        const pool = this.getPool(item.constructor as PoolItemConstructor<PoolItem>);\n\n        pool.return(item);\n    }\n\n    /**\n     * Gets a specific pool based on the class type.\n     * @template T The type of items in the pool. Must extend PoolItem.\n     * @param {PoolItemConstructor<T>} ClassType - The constructor of the items in the pool.\n     * @returns {Pool<T>} The pool of the given class type.\n     */\n    public getPool<T extends PoolItem>(ClassType: PoolItemConstructor<T>): Pool<T>\n    {\n        if (!this._poolsByClass.has(ClassType))\n        {\n            this._poolsByClass.set(ClassType, new Pool(ClassType));\n        }\n\n        return this._poolsByClass.get(ClassType) as Pool<T>;\n    }\n\n    /** gets the usage stats of each pool in the system */\n    public stats(): Record<string, {free: number; used: number; size: number}>\n    {\n        const stats = {} as Record<string, {free: number; used: number; size: number}>;\n\n        this._poolsByClass.forEach((pool) =>\n        {\n            // TODO: maybe we should allow the name to be set when `createEntity` is called\n            const name = stats[pool._classType.name]\n                ? pool._classType.name + (pool._classType as any).ID : pool._classType.name;\n\n            stats[name] = {\n                free: pool.totalFree,\n                used: pool.totalUsed,\n                size: pool.totalSize,\n            };\n        });\n\n        return stats;\n    }\n}\n\nexport const BigPool = new PoolGroupClass();\n", "import { deprecation } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\nimport type { CacheAsTextureOptions } from '../RenderGroup';\n\nexport interface CacheAsTextureMixinConstructor\n{\n    cacheAsTexture?: (val: boolean | CacheAsTextureOptions) => void;\n}\n\nexport interface CacheAsTextureMixin extends Required<CacheAsTextureMixinConstructor>\n{\n    /**\n     * Caches this container as a texture. This allows the container to be rendered as a single texture,\n     * which can improve performance for complex static containers.\n     * @param val - If true, enables caching with default options. If false, disables caching.\n     * Can also pass options object to configure caching behavior.\n     * @memberof scene.Container#\n     */\n    cacheAsTexture: (val: boolean | CacheAsTextureOptions) => void;\n\n    /**\n     * Updates the cached texture of this container. This will flag the container's cached texture\n     * to be redrawn on the next render.\n     * @memberof scene.Container#\n     */\n    updateCacheTexture: () => void;\n\n    /**\n     * Legacy property for backwards compatibility with PixiJS v7 and below.\n     * Use `cacheAsTexture` instead.\n     * @deprecated Since PixiJS v8\n     * @memberof scene.Container#\n     */\n    cacheAsBitmap: boolean;\n\n    /**\n     * Whether this container is currently cached as a texture.\n     * @readonly\n     * @memberof scene.Container#\n     */\n    readonly isCachedAsTexture: boolean;\n}\n\nexport const cacheAsTextureMixin: Partial<Container> = {\n    /**\n     * Is this container cached as a texture?\n     * @readonly\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    get isCachedAsTexture(): boolean\n    {\n        return !!this.renderGroup?.isCachedAsTexture;\n    },\n\n    cacheAsTexture(val: boolean | CacheAsTextureOptions): void\n    {\n        if (typeof val === 'boolean' && val === false)\n        {\n            this.disableRenderGroup();\n        }\n        else\n        {\n            this.enableRenderGroup();\n            this.renderGroup.enableCacheAsTexture(val === true ? {} : val);\n        }\n    },\n\n    /**\n     * Updates the cached texture. Will flag that this container's cached texture needs to be redrawn.\n     * This will happen on the next render.\n     * @memberof scene.Container#\n     */\n    updateCacheTexture(): void\n    {\n        this.renderGroup?.updateCacheTexture();\n    },\n\n    /**\n     * Allows backwards compatibility with pixi.js below version v8. Use `cacheAsTexture` instead.\n     * @deprecated\n     */\n    get cacheAsBitmap(): boolean\n    {\n        return this.isCachedAsTexture;\n    },\n\n    /**\n     * @deprecated\n     */\n    set cacheAsBitmap(val: boolean)\n    {\n        // #if _DEBUG\n        deprecation('v8.6.0', 'cacheAsBitmap is deprecated, use cacheAsTexture instead.');\n        // #endif\n        this.cacheAsTexture(val);\n    },\n} as Container;\n", "/**\n * Remove items from a javascript array without generating garbage\n * @function removeItems\n * @memberof utils\n * @param {Array<any>} arr - Array to remove elements from\n * @param {number} startIdx - starting index\n * @param {number} removeCount - how many to remove\n */\nexport function removeItems(arr: any[], startIdx: number, removeCount: number): void\n{\n    const length = arr.length;\n    let i;\n\n    if (startIdx >= length || removeCount === 0)\n    {\n        return;\n    }\n\n    removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);\n\n    const len = length - removeCount;\n\n    for (i = startIdx; i < len; ++i)\n    {\n        arr[i] = arr[i + removeCount];\n    }\n\n    arr.length = len;\n}\n", "import { removeItems } from '../../../utils/data/removeItems';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { IRenderLayer } from '../../layers/RenderLayer';\nimport type { Container, ContainerChild } from '../Container';\n\nexport interface ChildrenHelperMixin<C = ContainerChild>\n{\n    allowChildren: boolean;\n    addChild<U extends(C | IRenderLayer)[]>(...children: U): U[0];\n    removeChild<U extends(C | IRenderLayer)[]>(...children: U): U[0];\n    removeChildren(beginIndex?: number, endIndex?: number): C[];\n    removeChildAt<U extends(C | IRenderLayer)>(index: number): U;\n    getChildAt<U extends(C | IRenderLayer)>(index: number): U;\n    setChildIndex(child: C | IRenderLayer, index: number): void;\n    getChildIndex(child: C | IRenderLayer): number;\n    addChildAt<U extends(C | IRenderLayer)>(child: U, index: number): U;\n    swapChildren<U extends(C | IRenderLayer)>(child: U, child2: U): void;\n    removeFromParent(): void;\n\n    reparentChild<U extends C[]>(...child: U): U[0];\n    reparentChildAt<U extends C>(child: U, index: number): U;\n}\n\nexport const childrenHelperMixin: ChildrenHelperMixin<ContainerChild> = {\n\n    allowChildren: true,\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     * @param beginIndex - The beginning position.\n     * @param endIndex - The ending position. Default value is size of the container.\n     * @returns - List of removed children\n     * @memberof scene.Container#\n     */\n    removeChildren(beginIndex = 0, endIndex?: number): ContainerChild[]\n    {\n        const end = endIndex ?? this.children.length;\n        const range = end - beginIndex;\n        const removed: ContainerChild[] = [];\n\n        if (range > 0 && range <= end)\n        {\n            for (let i = end - 1; i >= beginIndex; i--)\n            {\n                const child = this.children[i];\n\n                if (!child) continue;\n                removed.push(child);\n                child.parent = null;\n            }\n\n            removeItems(this.children, beginIndex, end);\n\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            if (renderGroup)\n            {\n                renderGroup.removeChildren(removed);\n            }\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                this.emit('childRemoved', removed[i], this, i);\n                removed[i].emit('removed', this);\n            }\n\n            if (removed.length > 0)\n            {\n                this._didViewChangeTick++;\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return removed;\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    },\n\n    /**\n     * Removes a child from the specified index position.\n     * @param index - The index to get the child from\n     * @returns The child that was removed.\n     * @memberof scene.Container#\n     */\n    removeChildAt<U extends(ContainerChild | IRenderLayer)>(index: number): U\n    {\n        const child = this.getChildAt<U>(index);\n\n        return this.removeChild(child);\n    },\n\n    /**\n     * Returns the child at the specified index\n     * @param index - The index to get the child at\n     * @returns - The child at the given index, if any.\n     * @memberof scene.Container#\n     */\n    getChildAt<U extends(ContainerChild | IRenderLayer)>(index: number): U\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index] as U;\n    },\n\n    /**\n     * Changes the position of an existing child in the container\n     * @param child - The child Container instance for which you want to change the index number\n     * @param index - The resulting index number for the child container\n     * @memberof scene.Container#\n     */\n    setChildIndex(child: ContainerChild | IRenderLayer, index: number): void\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        this.getChildIndex(child); // check if child exists\n        this.addChildAt(child, index);\n    },\n\n    /**\n     * Returns the index position of a child Container instance\n     * @param child - The Container instance to identify\n     * @returns - The index position of the child container to identify\n     * @memberof scene.Container#\n     */\n    getChildIndex(child: ContainerChild | IRenderLayer): number\n    {\n        const index = this.children.indexOf(child as ContainerChild);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied Container must be a child of the caller');\n        }\n\n        return index;\n    },\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown.\n     * If the child is already in this container, it will be moved to the specified index.\n     * @param {Container} child - The child to add.\n     * @param {number} index - The absolute index where the child will be positioned at the end of the operation.\n     * @returns {Container} The child that was added.\n     * @memberof scene.Container#\n     */\n    addChildAt<U extends(ContainerChild | IRenderLayer)>(child: U, index: number): U\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChildAt: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        const { children } = this;\n\n        if (index < 0 || index > children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${children.length}`);\n        }\n\n        // TODO - check if child is already in the list?\n        // we should be able to optimise this!\n\n        if (child.parent)\n        {\n            const currentIndex = child.parent.children.indexOf(child as ContainerChild);\n\n            // If this child is in the container and in the same position, do nothing\n            if (child.parent === this && currentIndex === index)\n            {\n                return child;\n            }\n\n            if (currentIndex !== -1)\n            {\n                child.parent.children.splice(currentIndex, 1);\n            }\n        }\n\n        if (index === children.length)\n        {\n            children.push(child as ContainerChild);\n        }\n        else\n        {\n            children.splice(index, 0, child as ContainerChild);\n        }\n\n        child.parent = this;\n        child.didChange = true;\n        child._updateFlags = 0b1111;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child as ContainerChild);\n        }\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        this.emit('childAdded', child as ContainerChild, this, index);\n        child.emit('added', this);\n\n        return child;\n    },\n    /**\n     * Swaps the position of 2 Containers within this container.\n     * @param child - First container to swap\n     * @param child2 - Second container to swap\n     * @memberof scene.Container#\n     */\n    swapChildren<U extends(ContainerChild | IRenderLayer)>(child: U, child2: U): void\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2 as ContainerChild;\n        this.children[index2] = child as ContainerChild;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n\n        this._didContainerChangeTick++;\n    },\n    /**\n     * Remove the Container from its parent Container. If the Container has no parent, do nothing.\n     * @memberof scene.Container#\n     */\n    removeFromParent()\n    {\n        this.parent?.removeChild(this);\n    },\n\n    /**\n     * Reparent the child to this container, keeping the same worldTransform.\n     * @param child - The child to reparent\n     * @returns The first child that was reparented.\n     * @memberof scene.Container#\n     */\n    reparentChild<U extends ContainerChild[]>(...child: U): U[0]\n    {\n        if (child.length === 1)\n        {\n            return this.reparentChildAt(child[0], this.children.length);\n        }\n\n        child.forEach((c) => this.reparentChildAt(c, this.children.length));\n\n        return child[0];\n    },\n\n    /**\n     * Reparent the child to this container at the specified index, keeping the same worldTransform.\n     * @param child - The child to reparent\n     * @param index - The index to reparent the child to\n     * @memberof scene.Container#\n     */\n    reparentChildAt<U extends ContainerChild>(child: U, index: number): U\n    {\n        if (child.parent === this)\n        {\n            this.setChildIndex(child, index);\n\n            return child;\n        }\n\n        const childMat = child.worldTransform.clone();\n\n        child.removeFromParent();\n        this.addChildAt(child, index);\n\n        const newMatrix = this.worldTransform.clone();\n\n        newMatrix.invert();\n        childMat.prepend(newMatrix);\n\n        child.setFromMatrix(childMat);\n\n        return child;\n    }\n} as Container;\n", "import { type InstructionSet } from '../../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type InstructionPipe } from '../../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer, type RenderPipes } from '../../../rendering/renderers/types';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\n\nimport type { Container } from '../Container';\n\n/**\n * The CollectRenderablesMixin interface defines methods for collecting renderable objects\n * from a container and its children. These methods add the renderables to an instruction set,\n * which is used by the renderer to process and display the scene.\n */\nexport interface CollectRenderablesMixin\n{\n    /**\n     * Collects all renderables from the container and its children, adding them to the instruction set.\n     * This method decides whether to use a simple or advanced collection method based on the container's properties.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void;\n\n    /**\n     * Collects renderables using a simple method, suitable for containers marked as simple.\n     * This method iterates over the container's children and adds their renderables to the instruction set.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesSimple(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void;\n\n    /**\n     * Collects renderables using an advanced method, suitable for containers with complex processing needs.\n     * This method handles additional effects and transformations that may be applied to the renderables.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * The collectRenderablesMixin provides implementations for the methods defined in the CollectRenderablesMixin interface.\n * It includes logic to determine the appropriate method for collecting renderables based on the container's properties.\n */\nexport const collectRenderablesMixin: Partial<Container> = {\n\n    /**\n     * Main method to collect renderables from the container and its children.\n     * It checks the container's properties to decide whether to use a simple or advanced collection method.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderables(instructionSet: InstructionSet, renderer: Renderer, currentLayer: IRenderLayer): void\n    {\n        // Skip processing if the container is not in the current render layer or is not fully visible.\n        if ((this.parentRenderLayer && this.parentRenderLayer !== currentLayer)\n            || this.globalDisplayStatus < 0b111 || !this.includeInBuild) return;\n\n        // Sort children if the container has sortable children.\n        if (this.sortableChildren)\n        {\n            this.sortChildren();\n        }\n\n        // Choose the appropriate method for collecting renderables based on the container's properties.\n        if (this.isSimple)\n        {\n            this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n        }\n        else if (this.renderGroup)\n        {\n            renderer.renderPipes.renderGroup.addRenderGroup(this.renderGroup, instructionSet);\n        }\n        else\n        {\n            this.collectRenderablesWithEffects(instructionSet, renderer, currentLayer);\n        }\n    },\n\n    /**\n     * Simple method for collecting renderables from the container's children.\n     * This method is efficient and used when the container is marked as simple.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const children = this.children;\n        const length = children.length;\n\n        // Iterate over each child and collect their renderables.\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    },\n\n    /**\n     * Advanced method for collecting renderables, which handles additional effects.\n     * This method is used when the container has complex processing needs.\n     * @param {InstructionSet} instructionSet - The set of instructions to which the renderables will be added.\n     * @param {Renderer} renderer - The renderer responsible for rendering the scene.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    collectRenderablesWithEffects(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes } = renderer;\n\n        // Apply each effect to the renderables before collecting them.\n        for (let i = 0; i < this.effects.length; i++)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.push(effect, this, instructionSet);\n        }\n\n        // Collect renderables using the simple method after applying effects.\n        this.collectRenderablesSimple(instructionSet, renderer, currentLayer);\n\n        // Remove effects from the renderables after collection, processing in reverse order.\n        for (let i = this.effects.length - 1; i >= 0; i--)\n        {\n            const effect = this.effects[i];\n            const pipe = renderPipes[effect.pipe as keyof RenderPipes] as InstructionPipe<any>;\n\n            pipe.pop(effect, this, instructionSet);\n        }\n    }\n} as Container;\n", "import type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { Effect } from '../scene/container/Effect';\nimport type { Filter } from './Filter';\n\n/**\n * A filter effect is an effect that can be applied to a container that involves applying special pixel effects\n * to that container as it is rendered. Used internally when the filters property is modified on a container\n */\nexport class FilterEffect implements Effect\n{\n    /** read only filters array - to modify, set it again! */\n    public filters: readonly Filter[];\n    /**\n     * If specified, rather than calculating the bounds of the container that the filter\n     * will apply to, we use this rect instead. This is a local rect - so will have the containers transform\n     * applied to it\n     */\n    public filterArea?: Rectangle;\n\n    /** the pipe that knows how to handle this effect */\n    public pipe = 'filter';\n    /** the priority of this effect */\n    public priority = 1;\n\n    public destroy(): void\n    {\n        for (let i = 0; i < this.filters.length; i++)\n        {\n            this.filters[i].destroy();\n        }\n\n        this.filters = null;\n        this.filterArea = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../extensions/Extensions';\nimport { BigPool } from '../../utils/pool/PoolGroup';\n\nimport type { Effect, EffectConstructor } from '../../scene/container/Effect';\nimport type { PoolItem, PoolItemConstructor } from '../../utils/pool/Pool';\n\ninterface MaskConversionTest\n{\n    test: (item: any) => boolean;\n    maskClass: new (item: any) => Effect & PoolItem;\n}\n\nexport type MaskEffect = {mask: unknown} & Effect;\n\n/**\n * A class that manages the conversion of masks to mask effects.\n * @memberof rendering\n * @ignore\n */\nexport class MaskEffectManagerClass\n{\n    /**\n     * @private\n     */\n    public readonly _effectClasses: EffectConstructor[] = [];\n    private readonly _tests: MaskConversionTest[] = [];\n    private _initialized = false;\n\n    public init()\n    {\n        if (this._initialized) return;\n\n        this._initialized = true;\n\n        this._effectClasses.forEach((test) =>\n        {\n            this.add({\n                test: test.test,\n                maskClass: test\n            });\n        });\n    }\n\n    public add(test: MaskConversionTest)\n    {\n        this._tests.push(test);\n    }\n\n    public getMaskEffect(item: any): MaskEffect\n    {\n        if (!this._initialized) this.init();\n\n        for (let i = 0; i < this._tests.length; i++)\n        {\n            const test = this._tests[i];\n\n            if (test.test(item))\n            {\n                return BigPool.get(test.maskClass as PoolItemConstructor<MaskEffect & PoolItem>, item);\n            }\n        }\n\n        return item;\n    }\n\n    public returnMaskEffect(effect: Effect & PoolItem)\n    {\n        BigPool.return(effect);\n    }\n}\n\nexport const MaskEffectManager = new MaskEffectManagerClass();\n\n// Handle registration of extensions\nextensions\n    .handleByList(ExtensionType.MaskEffect, MaskEffectManager._effectClasses);\n", "import { FilterEffect } from '../../../filters/FilterEffect';\nimport { MaskEffectManager } from '../../../rendering/mask/MaskEffectManager';\n\nimport type { Filter } from '../../../filters/Filter';\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { MaskEffect } from '../../../rendering/mask/MaskEffectManager';\nimport type { Container } from '../Container';\nimport type { Effect } from '../Effect';\n\nexport interface EffectsMixinConstructor\n{\n    mask?: Mask;\n    setMask?: (options: Partial<MaskOptionsAndMask>) => void;\n    filters?: Filter | Filter[];\n}\n\nexport type Mask = number | Container | null;\n\nexport interface MaskOptions\n{\n    inverse: boolean;\n}\n\nexport interface MaskOptionsAndMask extends MaskOptions\n{\n    mask: Mask;\n}\n\nexport interface EffectsMixin extends Required<EffectsMixinConstructor>\n{\n    _maskEffect?: MaskEffect;\n    _maskOptions?: MaskOptions;\n    _filterEffect?: FilterEffect,\n\n    filterArea?: Rectangle,\n    effects?: Effect[];\n\n    _markStructureAsChanged(): void;\n    addEffect(effect: Effect): void;\n    removeEffect(effect: Effect): void;\n}\n\nexport const effectsMixin: Partial<Container> = {\n    _maskEffect: null,\n    _maskOptions: {\n        inverse: false,\n    },\n    _filterEffect: null,\n\n    /**\n     * @todo Needs docs.\n     * @memberof scene.Container#\n     * @type {Array<Effect>}\n     */\n    effects: [],\n\n    _markStructureAsChanged()\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.structureDidChange = true;\n        }\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to add.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    addEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index !== -1) return; // already exists!\n\n        this.effects.push(effect);\n\n        this.effects.sort((a, b) => a.priority - b.priority);\n\n        this._markStructureAsChanged();\n\n        // if (this.renderGroup)\n        // {\n        //     this.renderGroup.structureDidChange = true;\n        // }\n\n        this._updateIsSimple();\n    },\n    /**\n     * @todo Needs docs.\n     * @param effect - The effect to remove.\n     * @memberof scene.Container#\n     * @ignore\n     */\n    removeEffect(effect: Effect)\n    {\n        const index = this.effects.indexOf(effect);\n\n        if (index === -1) return; // already exists!\n\n        this.effects.splice(index, 1);\n\n        this._markStructureAsChanged();\n\n        this._updateIsSimple();\n    },\n\n    set mask(value: Mask)\n    {\n        const effect = this._maskEffect;\n\n        if (effect?.mask === value) return;\n\n        if (effect)\n        {\n            this.removeEffect(effect);\n\n            MaskEffectManager.returnMaskEffect(effect);\n\n            this._maskEffect = null;\n        }\n\n        if (value === null || value === undefined) return;\n\n        this._maskEffect = MaskEffectManager.getMaskEffect(value);\n\n        this.addEffect(this._maskEffect);\n    },\n\n    /**\n     * Used to set mask and control mask options.\n     * @param options\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.setMask({\n     *     mask: graphics,\n     *     inverse: true,\n     * });\n     * @memberof scene.Container#\n     */\n    setMask(options: Partial<MaskOptionsAndMask>)\n    {\n        this._maskOptions = {\n            ...this._maskOptions,\n            ...options,\n        };\n\n        if (options.mask)\n        {\n            this.mask = options.mask;\n        }\n\n        this._markStructureAsChanged();\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a\n     * {@link Graphics} or a {@link Sprite} object. This allows for much faster masking in canvas as it\n     * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.\n     * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.\n     * To remove a mask, set this property to `null`.\n     *\n     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.\n     * @example\n     * import { Graphics, Sprite } from 'pixi.js';\n     *\n     * const graphics = new Graphics();\n     * graphics.beginFill(0xFF3300);\n     * graphics.drawRect(50, 250, 100, 100);\n     * graphics.endFill();\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.mask = graphics;\n     * @memberof scene.Container#\n     */\n    get mask(): unknown\n    {\n        return this._maskEffect?.mask;\n    },\n\n    set filters(value: Filter | Filter[] | null | undefined)\n    {\n        if (!Array.isArray(value) && value) value = [value];\n\n        const effect = this._filterEffect ||= new FilterEffect();\n\n        // Ignore the Filter type\n        value = value as Filter[] | null | undefined;\n\n        const hasFilters = value?.length > 0;\n        const hadFilters = effect.filters?.length > 0;\n\n        const didChange = hasFilters !== hadFilters;\n\n        // Clone the filters array so we don't freeze the user-input\n        value = Array.isArray(value) ? value.slice(0) : value;\n\n        // Ensure filters are immutable via filters getter\n        effect.filters = Object.freeze(value);\n\n        if (didChange)\n        {\n            if (hasFilters)\n            {\n                this.addEffect(effect);\n            }\n            else\n            {\n                this.removeEffect(effect);\n\n                // sets the empty array...\n                effect.filters = value ?? null;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to `'null'`.\n     * @memberof scene.Container#\n     */\n    get filters(): readonly Filter[]\n    {\n        return this._filterEffect?.filters;\n    },\n\n    set filterArea(value: Rectangle)\n    {\n        this._filterEffect ||= new FilterEffect();\n\n        this._filterEffect.filterArea = value;\n    },\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimization\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.\n     *\n     * Also works as an interaction mask.\n     * @memberof scene.Container#\n     */\n    get filterArea(): Rectangle\n    {\n        return this._filterEffect?.filterArea;\n    },\n\n} as Container;\n", "import { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\n\nimport type { Container } from '../Container';\n\nexport interface FindMixinConstructor\n{\n    label?: string;\n}\nexport interface FindMixin extends Required<FindMixinConstructor>\n{\n    /**\n     * @deprecated since 8.0.0\n     * @see Container#label\n     */\n    name: string;\n    getChildByName(label: RegExp | string, deep?: boolean): Container | null;\n    getChildByLabel(label: RegExp | string, deep?: boolean): Container | null;\n    getChildrenByLabel(label: RegExp | string, deep?: boolean, out?: Container[]): Container[];\n}\n\nexport const findMixin: Partial<Container> = {\n    /**\n     * The instance label of the object.\n     * @memberof scene.Container#\n     * @member {string} label\n     */\n    label: null,\n\n    /**\n     * The instance name of the object.\n     * @deprecated since 8.0.0\n     * @see scene.Container#label\n     * @member {string} name\n     * @memberof scene.Container#\n     */\n    get name(): string\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        return this.label;\n    },\n    set name(value: string)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Container.name property has been removed, use Container.label instead');\n        // #endif\n\n        this.label = value;\n    },\n\n    /**\n     * @method getChildByName\n     * @deprecated since 8.0.0\n     * @param {string} name - Instance name.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified name.\n     * @see scene.Container#getChildByLabel\n     * @memberof scene.Container#\n     */\n    getChildByName(name: string, deep = false): Container | null\n    {\n        return this.getChildByLabel(name, deep);\n    },\n    /**\n     * Returns the first child in the container with the specified label.\n     *\n     * Recursive searches are done in a pre-order traversal.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @returns {Container} The child with the specified label.\n     */\n    getChildByLabel(label: string | RegExp, deep = false): Container | null\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label))) return child;\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                const child = children[i];\n                const found = child.getChildByLabel(label, true);\n\n                if (found)\n                {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    },\n\n    /**\n     * Returns all children in the container with the specified label.\n     * @memberof scene.Container#\n     * @param {string|RegExp} label - Instance label.\n     * @param {boolean}[deep=false] - Whether to search recursively\n     * @param {Container[]} [out=[]] - The array to store matching children in.\n     * @returns {Container[]} An array of children with the specified label.\n     */\n    getChildrenByLabel(label: string | RegExp, deep = false, out = []): Container[]\n    {\n        const children = this.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            if (child.label === label || (label instanceof RegExp && label.test(child.label)))\n            {\n                out.push(child);\n            }\n        }\n\n        if (deep)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i].getChildrenByLabel(label, true, out);\n            }\n        }\n\n        return out;\n    },\n} as Container;\n", "// import { SHAPES } from '../const';\nimport { Point } from '../point/Point';\n\nimport type { Bounds } from '../../scene/container/bounds/Bounds';\nimport type { Matrix } from '../matrix/Matrix';\nimport type { SHAPE_PRIMITIVE } from '../misc/const';\nimport type { ShapePrimitive } from './ShapePrimitive';\n\nconst tempPoints = [new Point(), new Point(), new Point(), new Point()];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Rectangle extends PixiMixins.Rectangle { }\n\n/**\n * The `Rectangle` object is an area defined by its position, as indicated by its top-left corner\n * point (`x`, `y`) and by its `width` and its `height`.\n *\n * It also provides convenience methods to get and set the position and size of the rectangle such as\n * {@link maths.Rectangle#bottom|bottom}, {@link maths.Rectangle#right|right} and {@link maths.Rectangle#isEmpty|isEmpty}.\n * @memberof maths\n */\nexport class Rectangle implements ShapePrimitive\n{\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     * @default 'rectangle'\n     */\n    public readonly type: SHAPE_PRIMITIVE = 'rectangle';\n\n    /**\n     * The X coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public x: number;\n\n    /**\n     * The Y coordinate of the upper-left corner of the rectangle\n     * @default 0\n     */\n    public y: number;\n\n    /**\n     * The overall width of this rectangle\n     *  @default 0\n     */\n    public width: number;\n\n    /**\n     * The overall height of this rectangle\n     * @default 0\n     */\n    public height: number;\n\n    /**\n     * @param x - The X coordinate of the upper-left corner of the rectangle\n     * @param y - The Y coordinate of the upper-left corner of the rectangle\n     * @param width - The overall width of the rectangle\n     * @param height - The overall height of the rectangle\n     */\n    constructor(x: string | number = 0, y: string | number = 0, width: string | number = 0, height: string | number = 0)\n    {\n        this.x = Number(x);\n        this.y = Number(y);\n        this.width = Number(width);\n        this.height = Number(height);\n    }\n\n    /** Returns the left edge of the rectangle. */\n    get left(): number\n    {\n        return this.x;\n    }\n\n    /** Returns the right edge of the rectangle. */\n    get right(): number\n    {\n        return this.x + this.width;\n    }\n\n    /** Returns the top edge of the rectangle. */\n    get top(): number\n    {\n        return this.y;\n    }\n\n    /** Returns the bottom edge of the rectangle. */\n    get bottom(): number\n    {\n        return this.y + this.height;\n    }\n\n    /** Determines whether the Rectangle is empty. */\n    public isEmpty(): boolean\n    {\n        return this.left === this.right || this.top === this.bottom;\n    }\n\n    /** A constant empty rectangle. This is a new object every time the property is accessed */\n    static get EMPTY(): Rectangle\n    {\n        return new Rectangle(0, 0, 0, 0);\n    }\n\n    /**\n     * Creates a clone of this Rectangle\n     * @returns a copy of the rectangle\n     */\n    public clone(): Rectangle\n    {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n\n    /**\n     * Converts a Bounds object to a Rectangle object.\n     * @param bounds - The bounds to copy and convert to a rectangle.\n     * @returns Returns itself.\n     */\n    public copyFromBounds(bounds: Bounds): this\n    {\n        this.x = bounds.minX;\n        this.y = bounds.minY;\n        this.width = bounds.maxX - bounds.minX;\n        this.height = bounds.maxY - bounds.minY;\n\n        return this;\n    }\n\n    /**\n     * Copies another rectangle to this one.\n     * @param rectangle - The rectangle to copy from.\n     * @returns Returns itself.\n     */\n    public copyFrom(rectangle: Rectangle): Rectangle\n    {\n        this.x = rectangle.x;\n        this.y = rectangle.y;\n        this.width = rectangle.width;\n        this.height = rectangle.height;\n\n        return this;\n    }\n\n    /**\n     * Copies this rectangle to another one.\n     * @param rectangle - The rectangle to copy to.\n     * @returns Returns given parameter.\n     */\n    public copyTo(rectangle: Rectangle): Rectangle\n    {\n        rectangle.copyFrom(this);\n\n        return rectangle;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this Rectangle\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @returns Whether the x/y coordinates are within this Rectangle\n     */\n    public contains(x: number, y: number): boolean\n    {\n        if (this.width <= 0 || this.height <= 0)\n        {\n            return false;\n        }\n\n        if (x >= this.x && x < this.x + this.width)\n        {\n            if (y >= this.y && y < this.y + this.height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the x and y coordinates given are contained within this rectangle including the stroke.\n     * @param x - The X coordinate of the point to test\n     * @param y - The Y coordinate of the point to test\n     * @param strokeWidth - The width of the line to check\n     * @param alignment - The alignment of the stroke, 0.5 by default\n     * @returns Whether the x/y coordinates are within this rectangle\n     */\n    public strokeContains(x: number, y: number, strokeWidth: number, alignment: number = 0.5): boolean\n    {\n        const { width, height } = this;\n\n        if (width <= 0 || height <= 0) return false;\n\n        const _x = this.x;\n        const _y = this.y;\n\n        const strokeWidthOuter = strokeWidth * (1 - alignment);\n        const strokeWidthInner = strokeWidth - strokeWidthOuter;\n\n        const outerLeft = _x - strokeWidthOuter;\n        const outerRight = _x + width + strokeWidthOuter;\n        const outerTop = _y - strokeWidthOuter;\n        const outerBottom = _y + height + strokeWidthOuter;\n\n        const innerLeft = _x + strokeWidthInner;\n        const innerRight = _x + width - strokeWidthInner;\n        const innerTop = _y + strokeWidthInner;\n        const innerBottom = _y + height - strokeWidthInner;\n\n        return (x >= outerLeft && x <= outerRight && y >= outerTop && y <= outerBottom)\n            && !(x > innerLeft && x < innerRight && y > innerTop && y < innerBottom);\n    }\n    /**\n     * Determines whether the `other` Rectangle transformed by `transform` intersects with `this` Rectangle object.\n     * Returns true only if the area of the intersection is >0, this means that Rectangles\n     * sharing a side are not overlapping. Another side effect is that an arealess rectangle\n     * (width or height equal to zero) can't intersect any other rectangle.\n     * @param {Rectangle} other - The Rectangle to intersect with `this`.\n     * @param {Matrix} transform - The transformation matrix of `other`.\n     * @returns {boolean} A value of `true` if the transformed `other` Rectangle intersects with `this`; otherwise `false`.\n     */\n    public intersects(other: Rectangle, transform?: Matrix): boolean\n    {\n        if (!transform)\n        {\n            const x0 = this.x < other.x ? other.x : this.x;\n            const x1 = this.right > other.right ? other.right : this.right;\n\n            if (x1 <= x0)\n            {\n                return false;\n            }\n\n            const y0 = this.y < other.y ? other.y : this.y;\n            const y1 = this.bottom > other.bottom ? other.bottom : this.bottom;\n\n            return y1 > y0;\n        }\n\n        const x0 = this.left;\n        const x1 = this.right;\n        const y0 = this.top;\n        const y1 = this.bottom;\n\n        if (x1 <= x0 || y1 <= y0)\n        {\n            return false;\n        }\n\n        const lt = tempPoints[0].set(other.left, other.top);\n        const lb = tempPoints[1].set(other.left, other.bottom);\n        const rt = tempPoints[2].set(other.right, other.top);\n        const rb = tempPoints[3].set(other.right, other.bottom);\n\n        if (rt.x <= lt.x || lb.y <= lt.y)\n        {\n            return false;\n        }\n\n        const s = Math.sign((transform.a * transform.d) - (transform.b * transform.c));\n\n        if (s === 0)\n        {\n            return false;\n        }\n\n        transform.apply(lt, lt);\n        transform.apply(lb, lb);\n        transform.apply(rt, rt);\n        transform.apply(rb, rb);\n\n        if (Math.max(lt.x, lb.x, rt.x, rb.x) <= x0\n            || Math.min(lt.x, lb.x, rt.x, rb.x) >= x1\n            || Math.max(lt.y, lb.y, rt.y, rb.y) <= y0\n            || Math.min(lt.y, lb.y, rt.y, rb.y) >= y1)\n        {\n            return false;\n        }\n\n        const nx = s * (lb.y - lt.y);\n        const ny = s * (lt.x - lb.x);\n        const n00 = (nx * x0) + (ny * y0);\n        const n10 = (nx * x1) + (ny * y0);\n        const n01 = (nx * x0) + (ny * y1);\n        const n11 = (nx * x1) + (ny * y1);\n\n        if (Math.max(n00, n10, n01, n11) <= (nx * lt.x) + (ny * lt.y)\n            || Math.min(n00, n10, n01, n11) >= (nx * rb.x) + (ny * rb.y))\n        {\n            return false;\n        }\n\n        const mx = s * (lt.y - rt.y);\n        const my = s * (rt.x - lt.x);\n        const m00 = (mx * x0) + (my * y0);\n        const m10 = (mx * x1) + (my * y0);\n        const m01 = (mx * x0) + (my * y1);\n        const m11 = (mx * x1) + (my * y1);\n\n        if (Math.max(m00, m10, m01, m11) <= (mx * lt.x) + (my * lt.y)\n            || Math.min(m00, m10, m01, m11) >= (mx * rb.x) + (my * rb.y))\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Pads the rectangle making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     * @returns Returns itself.\n     */\n    public pad(paddingX = 0, paddingY = paddingX): this\n    {\n        this.x -= paddingX;\n        this.y -= paddingY;\n\n        this.width += paddingX * 2;\n        this.height += paddingY * 2;\n\n        return this;\n    }\n\n    /**\n     * Fits this rectangle around the passed one.\n     * @param rectangle - The rectangle to fit.\n     * @returns Returns itself.\n     */\n    public fit(rectangle: Rectangle): this\n    {\n        const x1 = Math.max(this.x, rectangle.x);\n        const x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.max(this.y, rectangle.y);\n        const y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = Math.max(x2 - x1, 0);\n        this.y = y1;\n        this.height = Math.max(y2 - y1, 0);\n\n        return this;\n    }\n\n    /**\n     * Enlarges rectangle that way its corners lie on grid\n     * @param resolution - resolution\n     * @param eps - precision\n     * @returns Returns itself.\n     */\n    public ceil(resolution = 1, eps = 0.001): this\n    {\n        const x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;\n        const y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;\n\n        this.x = Math.floor((this.x + eps) * resolution) / resolution;\n        this.y = Math.floor((this.y + eps) * resolution) / resolution;\n\n        this.width = x2 - this.x;\n        this.height = y2 - this.y;\n\n        return this;\n    }\n\n    /**\n     * Enlarges this rectangle to include the passed rectangle.\n     * @param rectangle - The rectangle to include.\n     * @returns Returns itself.\n     */\n    public enlarge(rectangle: Rectangle): this\n    {\n        const x1 = Math.min(this.x, rectangle.x);\n        const x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);\n        const y1 = Math.min(this.y, rectangle.y);\n        const y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);\n\n        this.x = x1;\n        this.width = x2 - x1;\n        this.y = y1;\n        this.height = y2 - y1;\n\n        return this;\n    }\n\n    /**\n     * Returns the framing rectangle of the rectangle as a Rectangle object\n     * @param out - optional rectangle to store the result\n     * @returns The framing rectangle\n     */\n    public getBounds(out?: Rectangle): Rectangle\n    {\n        out ||= new Rectangle();\n        out.copyFrom(this);\n\n        return out;\n    }\n\n    /**\n     * Checks if this rectangle fully contains another rectangle.\n     *\n     * A rectangle contains another rectangle if all four corners of the other rectangle\n     * lie within the bounds of this rectangle.\n     *\n     * ```ts\n     * const container = new Rectangle(0, 0, 100, 100);\n     * const inside = new Rectangle(25, 25, 50, 50);\n     * const partial = new Rectangle(75, 75, 50, 50);\n     *\n     * container.containsRect(inside); // Returns true\n     * container.containsRect(partial); // Returns false - partial overlap\n     * ```\n     *\n     * Note: If either rectangle has a width or height of 0, this method returns false\n     * since a zero-area rectangle cannot meaningfully contain another rectangle.\n     * @param other - The rectangle to check if it is contained within this one\n     * @returns True if the other rectangle is fully contained within this one\n     */\n    public containsRect(other: Rectangle): boolean\n    {\n        if (this.width <= 0 || this.height <= 0) return false;\n\n        const x1 = other.x;\n        const y1 = other.y;\n        const x2 = other.x + other.width;\n        const y2 = other.y + other.height;\n\n        return x1 >= this.x && x1 < this.x + this.width\n            && y1 >= this.y && y1 < this.y + this.height\n            && x2 >= this.x && x2 < this.x + this.width\n            && y2 >= this.y && y2 < this.y + this.height;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`;\n    }\n    // #endif\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../maths/shapes/Rectangle';\n\n/**\n * Simple bounds implementation instead of more ambiguous [number, number, number, number]\n * @memberof rendering\n */\nexport interface BoundsData\n{\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n}\n\nconst defaultMatrix = new Matrix();\n\n// TODO optimisations\n// 1 - get rectangle could use a dirty flag, rather than setting the data each time is called\n// 2- getFrame ALWAYS assumes a matrix, could be optimised to avoid the matrix calculation if not needed\n\n/**\n * A representation of an AABB bounding box.\n * @memberof rendering\n */\nexport class Bounds\n{\n    /** @default Infinity */\n    public minX = Infinity;\n\n    /** @default Infinity */\n    public minY = Infinity;\n\n    /** @default -Infinity */\n    public maxX = -Infinity;\n\n    /** @default -Infinity */\n    public maxY = -Infinity;\n\n    public matrix = defaultMatrix;\n\n    private _rectangle: Rectangle;\n\n    constructor(minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity)\n    {\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if bounds are empty.\n     * @returns - True if empty.\n     */\n    public isEmpty(): boolean\n    {\n        return this.minX > this.maxX || this.minY > this.maxY;\n    }\n\n    /** The bounding rectangle of the bounds. */\n    get rectangle(): Rectangle\n    {\n        if (!this._rectangle)\n        {\n            this._rectangle = new Rectangle();\n        }\n\n        const rectangle = this._rectangle;\n\n        if (this.minX > this.maxX || this.minY > this.maxY)\n        {\n            rectangle.x = 0;\n            rectangle.y = 0;\n            rectangle.width = 0;\n            rectangle.height = 0;\n        }\n        else\n        {\n            rectangle.copyFromBounds(this);\n        }\n\n        return rectangle;\n    }\n\n    /** Clears the bounds and resets. */\n    public clear(): this\n    {\n        this.minX = Infinity;\n        this.minY = Infinity;\n        this.maxX = -Infinity;\n        this.maxY = -Infinity;\n\n        this.matrix = defaultMatrix;\n\n        return this;\n    }\n\n    /**\n     * Sets the bounds.\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     */\n    public set(x0: number, y0: number, x1: number, y1: number)\n    {\n        this.minX = x0;\n        this.minY = y0;\n        this.maxX = x1;\n        this.maxY = y1;\n    }\n\n    /**\n     * Adds sprite frame\n     * @param x0 - left X of frame\n     * @param y0 - top Y of frame\n     * @param x1 - right X of frame\n     * @param y1 - bottom Y of frame\n     * @param matrix\n     */\n    public addFrame(x0: number, y0: number, x1: number, y1: number, matrix?: Matrix): void\n    {\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        let x = (a * x0) + (c * y0) + tx;\n        let y = (b * x0) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y0) + tx;\n        y = (b * x1) + (d * y0) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x0) + (c * y1) + tx;\n        y = (b * x0) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        x = (a * x1) + (c * y1) + tx;\n        y = (b * x1) + (d * y1) + ty;\n\n        if (x < minX) minX = x;\n        if (y < minY) minY = y;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Adds a rectangle to the bounds.\n     * @param rect - The rectangle to be added.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public addRect(rect: Rectangle, matrix?: Matrix)\n    {\n        this.addFrame(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height, matrix);\n    }\n\n    /**\n     * Adds other {@link Bounds}.\n     * @param bounds - The Bounds to be added\n     * @param matrix\n     */\n    public addBounds(bounds: BoundsData, matrix?: Matrix)\n    {\n        this.addFrame(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY, matrix);\n    }\n\n    /**\n     * Adds other Bounds, masked with Bounds.\n     * @param mask - The Bounds to be added.\n     */\n    public addBoundsMask(mask: Bounds): void\n    {\n        this.minX = this.minX > mask.minX ? this.minX : mask.minX;\n        this.minY = this.minY > mask.minY ? this.minY : mask.minY;\n        this.maxX = this.maxX < mask.maxX ? this.maxX : mask.maxX;\n        this.maxY = this.maxY < mask.maxY ? this.maxY : mask.maxY;\n    }\n\n    /**\n     * Adds other Bounds, multiplied with matrix.\n     * @param matrix - The matrix to apply to the bounds.\n     */\n    public applyMatrix(matrix: Matrix): void\n    {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        // multiple bounds by matrix\n        const { a, b, c, d, tx, ty } = matrix;\n\n        let x = (a * minX) + (c * minY) + tx;\n        let y = (b * minX) + (d * minY) + ty;\n\n        this.minX = x;\n        this.minY = y;\n        this.maxX = x;\n        this.maxY = y;\n\n        x = (a * maxX) + (c * minY) + tx;\n        y = (b * maxX) + (d * minY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * minX) + (c * maxY) + tx;\n        y = (b * minX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n\n        x = (a * maxX) + (c * maxY) + tx;\n        y = (b * maxX) + (d * maxY) + ty;\n        this.minX = x < this.minX ? x : this.minX;\n        this.minY = y < this.minY ? y : this.minY;\n        this.maxX = x > this.maxX ? x : this.maxX;\n        this.maxY = y > this.maxY ? y : this.maxY;\n    }\n\n    /**\n     * Resizes the bounds object to include the given rectangle.\n     * @param rect - The rectangle to be included.\n     */\n    public fit(rect: Rectangle): this\n    {\n        if (this.minX < rect.left) this.minX = rect.left;\n        if (this.maxX > rect.right) this.maxX = rect.right;\n\n        if (this.minY < rect.top) this.minY = rect.top;\n        if (this.maxY > rect.bottom) this.maxY = rect.bottom;\n\n        return this;\n    }\n\n    /**\n     * Resizes the bounds object to include the given bounds.\n     * @param left - The left value of the bounds.\n     * @param right - The right value of the bounds.\n     * @param top - The top value of the bounds.\n     * @param bottom - The bottom value of the bounds.\n     */\n    public fitBounds(left: number, right: number, top: number, bottom: number): this\n    {\n        if (this.minX < left) this.minX = left;\n        if (this.maxX > right) this.maxX = right;\n\n        if (this.minY < top) this.minY = top;\n        if (this.maxY > bottom) this.maxY = bottom;\n\n        return this;\n    }\n\n    /**\n     * Pads bounds object, making it grow in all directions.\n     * If paddingY is omitted, both paddingX and paddingY will be set to paddingX.\n     * @param paddingX - The horizontal padding amount.\n     * @param paddingY - The vertical padding amount.\n     */\n    public pad(paddingX: number, paddingY: number = paddingX): this\n    {\n        this.minX -= paddingX;\n        this.maxX += paddingX;\n\n        this.minY -= paddingY;\n        this.maxY += paddingY;\n\n        return this;\n    }\n\n    /** Ceils the bounds. */\n    public ceil(): this\n    {\n        this.minX = Math.floor(this.minX);\n        this.minY = Math.floor(this.minY);\n        this.maxX = Math.ceil(this.maxX);\n        this.maxY = Math.ceil(this.maxY);\n\n        return this;\n    }\n\n    /** Clones the bounds. */\n    public clone(): Bounds\n    {\n        return new Bounds(this.minX, this.minY, this.maxX, this.maxY);\n    }\n\n    /**\n     * Scales the bounds by the given values\n     * @param x - The X value to scale by.\n     * @param y - The Y value to scale by.\n     */\n    public scale(x: number, y: number = x): this\n    {\n        this.minX *= x;\n        this.minY *= y;\n        this.maxX *= x;\n        this.maxY *= y;\n\n        return this;\n    }\n\n    /** the x value of the bounds. */\n    get x(): number\n    {\n        return this.minX;\n    }\n    set x(value: number)\n    {\n        const width = this.maxX - this.minX;\n\n        this.minX = value;\n        this.maxX = value + width;\n    }\n\n    /** the y value of the bounds. */\n    get y(): number\n    {\n        return this.minY;\n    }\n\n    set y(value: number)\n    {\n        const height = this.maxY - this.minY;\n\n        this.minY = value;\n        this.maxY = value + height;\n    }\n\n    /** the width value of the bounds. */\n    get width(): number\n    {\n        return this.maxX - this.minX;\n    }\n\n    set width(value: number)\n    {\n        this.maxX = this.minX + value;\n    }\n\n    /** the height value of the bounds. */\n    get height(): number\n    {\n        return this.maxY - this.minY;\n    }\n\n    set height(value: number)\n    {\n        this.maxY = this.minY + value;\n    }\n\n    /** the left value of the bounds. */\n    get left(): number\n    {\n        return this.minX;\n    }\n\n    /** the right value of the bounds. */\n    get right(): number\n    {\n        return this.maxX;\n    }\n\n    /** the top value of the bounds. */\n    get top(): number\n    {\n        return this.minY;\n    }\n\n    /** the bottom value of the bounds. */\n    get bottom(): number\n    {\n        return this.maxY;\n    }\n\n    /** Is the bounds positive. */\n    get isPositive(): boolean\n    {\n        return (this.maxX - this.minX > 0) && (this.maxY - this.minY > 0);\n    }\n\n    get isValid(): boolean\n    {\n        return (this.minX + this.minY !== Infinity);\n    }\n\n    /**\n     * Adds screen vertices from array\n     * @param vertexData - calculated vertices\n     * @param beginOffset - begin offset\n     * @param endOffset - end offset, excluded\n     * @param matrix\n     */\n    public addVertexData(vertexData: Float32Array, beginOffset: number, endOffset: number, matrix?: Matrix): void\n    {\n        let minX = this.minX;\n        let minY = this.minY;\n        let maxX = this.maxX;\n        let maxY = this.maxY;\n\n        matrix ||= this.matrix;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        for (let i = beginOffset; i < endOffset; i += 2)\n        {\n            const localX = vertexData[i];\n            const localY = vertexData[i + 1];\n\n            const x = (a * localX) + (c * localY) + tx;\n            const y = (b * localX) + (d * localY) + ty;\n\n            minX = x < minX ? x : minX;\n            minY = y < minY ? y : minY;\n            maxX = x > maxX ? x : maxX;\n            maxY = y > maxY ? y : maxY;\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /**\n     * Checks if the point is contained within the bounds.\n     * @param x - x coordinate\n     * @param y - y coordinate\n     */\n    public containsPoint(x: number, y: number): boolean\n    {\n        if (this.minX <= x && this.minY <= y && this.maxX >= x && this.maxY >= y)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    public toString(): string\n    {\n        // eslint-disable-next-line max-len\n        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`;\n    }\n\n    /**\n     * Copies the bounds from another bounds object.\n     * @param bounds - The bounds to copy from.\n     * @returns - This bounds object.\n     */\n    public copyFrom(bounds: Bounds): this\n    {\n        this.minX = bounds.minX;\n        this.minY = bounds.minY;\n        this.maxX = bounds.maxX;\n        this.maxY = bounds.maxY;\n\n        return this;\n    }\n}\n\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Pool } from '../../../../utils/pool/Pool';\nimport { Bounds } from '../Bounds';\n\nimport type { PoolItem } from '../../../../utils/pool/Pool';\n\ntype MatrixPoolItem = Matrix & PoolItem;\ntype BoundsPoolItem = Bounds & PoolItem;\nexport const matrixPool = new Pool<MatrixPoolItem>(Matrix);\nexport const boundsPool = new Pool<BoundsPoolItem>(Bounds);\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { type Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport { type IRenderLayer } from '../../layers/RenderLayer';\nimport { Bounds } from '../bounds/Bounds';\nimport { boundsPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { Container } from '../Container';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Interface for the GetFastGlobalBoundsMixin, which provides methods to compute\n * an approximate global bounding box for a container and its children.\n */\nexport interface GetFastGlobalBoundsMixin\n{\n    /**\n     * Computes an approximate global bounding box for the container and its children.\n     * This method is optimized for speed by using axis-aligned bounding boxes (AABBs),\n     * and uses the last render results from when it updated the transforms. This function does not update them.\n     * which may result in slightly larger bounds but never smaller than the actual bounds.\n     *\n     * for accurate (but less performant) results use `container.getGlobalBounds`\n     * @param {boolean} [factorRenderLayers] - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The output bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @memberof scene.Container#\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds;\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * This method is used internally by getFastGlobalBounds to traverse the scene graph.\n     * @param {boolean} factorRenderLayers - A flag indicating whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    ): void;\n}\n\n/**\n * Mixin providing the implementation of the GetFastGlobalBoundsMixin interface.\n * It includes methods to compute and recursively calculate global bounds for containers.\n */\nexport const getFastGlobalBoundsMixin: Partial<Container> = {\n    /**\n     * Computes the global bounds for the container, considering its children and optionally\n     * factoring in render layers. It starts by clearing the provided bounds object, then\n     * recursively calculates the bounds, and finally applies the world transformation.\n     * @param {boolean} [factorRenderLayers] - Whether to consider render layers in the calculation.\n     * @param {Bounds} [bounds] - The bounds object to store the result. If not provided, a new one is created.\n     * @returns {Bounds} The computed bounds.\n     * @memberof scene.Container#\n     */\n    getFastGlobalBounds(factorRenderLayers?: boolean, bounds?: Bounds): Bounds\n    {\n        bounds ||= new Bounds();\n\n        // Initialize the bounds for fresh calculations.\n        bounds.clear();\n\n        // Calculate bounds recursively, starting from the current container.\n        this._getGlobalBoundsRecursive(!!factorRenderLayers, bounds, this.parentRenderLayer);\n\n        // Validate the calculated bounds, resetting if invalid.\n        if (!bounds.isValid)\n        {\n            bounds.set(0, 0, 0, 0);\n        }\n\n        // Apply the world transformation to the bounds.\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        bounds.applyMatrix(renderGroup.worldTransform);\n\n        return bounds;\n    },\n\n    /**\n     * Recursively calculates the global bounds for the container and its children.\n     * It considers visibility, measurability, and effects, and applies transformations\n     * as necessary to compute the bounds accurately.\n     * @param {boolean} factorRenderLayers - Whether to consider render layers in the calculation.\n     * @param {Bounds} bounds - The bounds object to update with the calculated values.\n     * @param {IRenderLayer} currentLayer - The current render layer being processed.\n     * @memberof scene.Container#\n     */\n    _getGlobalBoundsRecursive(\n        factorRenderLayers: boolean,\n        bounds: Bounds,\n        currentLayer: IRenderLayer,\n    )\n    {\n        let localBounds = bounds;\n\n        // Skip if the container is not in the current render layer when factoring render layers.\n        if (factorRenderLayers && this.parentRenderLayer && this.parentRenderLayer !== currentLayer) return;\n\n        // Skip if the container is not fully visible or not measurable.\n        if (this.localDisplayStatus !== 0b111 || (!this.measurable))\n        {\n            return;\n        }\n\n        // Determine if effects need to be managed, requiring separate bounds handling.\n        const manageEffects = !!this.effects.length;\n\n        // Use a temporary bounds object if the container is a render group or has effects.\n        if (this.renderGroup || manageEffects)\n        {\n            localBounds = boundsPool.get().clear();\n        }\n\n        // Add the container's own bounds area to the bounds if it exists.\n        if (this.boundsArea)\n        {\n            bounds.addRect(this.boundsArea, this.worldTransform);\n        }\n        else\n        {\n            // If the container is renderable, add its bounds to the local bounds.\n            if (this.renderPipeId)\n            {\n                const viewBounds = (this as Renderable).bounds;\n\n                localBounds.addFrame(\n                    viewBounds.minX,\n                    viewBounds.minY,\n                    viewBounds.maxX,\n                    viewBounds.maxY,\n                    this.groupTransform\n                );\n            }\n\n            // Recursively process each child to include their bounds.\n            const children = this.children;\n\n            for (let i = 0; i < children.length; i++)\n            {\n                children[i]._getGlobalBoundsRecursive(factorRenderLayers, localBounds, currentLayer);\n            }\n        }\n\n        // If effects are managed, apply them to the bounds.\n        if (manageEffects)\n        {\n            let advanced = false;\n            const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n            // Apply each effect that modifies bounds.\n            for (let i = 0; i < this.effects.length; i++)\n            {\n                if (this.effects[i].addBounds)\n                {\n                    if (!advanced)\n                    {\n                        advanced = true;\n                        localBounds.applyMatrix(renderGroup.worldTransform);\n                    }\n                    this.effects[i].addBounds(localBounds, true);\n                }\n            }\n\n            // Adjust bounds back to the local coordinate space if advanced bounds were calculated.\n            if (advanced)\n            {\n                localBounds.applyMatrix(renderGroup.worldTransform.copyTo(tempMatrix).invert());\n                bounds.addBounds(localBounds, this.relativeGroupTransform);\n            }\n\n            // Add the local bounds to the final bounds and return the temporary bounds object.\n            bounds.addBounds(localBounds);\n            boundsPool.return(localBounds);\n        }\n        else if (this.renderGroup)\n        {\n            // If the container is a render group, add its local bounds to the final bounds.\n            bounds.addBounds(localBounds, this.relativeGroupTransform);\n            boundsPool.return(localBounds);\n        }\n    }\n\n} as Container;\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getGlobalBounds(target: Container, skipUpdateTransform: boolean, bounds: Bounds): Bounds\n{\n    bounds.clear();\n\n    let parentTransform;\n    let pooledMatrix;\n\n    if (target.parent)\n    {\n        if (!skipUpdateTransform)\n        {\n            pooledMatrix = matrixPool.get().identity();\n            parentTransform = updateTransformBackwards(target, pooledMatrix);\n        }\n        else\n        {\n            parentTransform = target.parent.worldTransform;\n        }\n    }\n    else\n    {\n        parentTransform = Matrix.IDENTITY;\n    }\n\n    // then collect them...\n\n    _getGlobalBounds(target, bounds, parentTransform, skipUpdateTransform);\n\n    if (pooledMatrix)\n    {\n        matrixPool.return(pooledMatrix);\n    }\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nexport function _getGlobalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    skipUpdateTransform: boolean,\n): void\n{\n    if (!target.visible || !target.measurable) return;\n\n    let worldTransform: Matrix;\n\n    if (!skipUpdateTransform)\n    {\n        target.updateLocalTransform();\n\n        worldTransform = matrixPool.get();\n\n        worldTransform.appendFrom(target.localTransform, parentTransform);\n    }\n    else\n    {\n        worldTransform = target.worldTransform;\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, worldTransform);\n    }\n    else\n    {\n        if ((target as Renderable).bounds)\n        {\n            // save a copy\n            bounds.matrix = worldTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        for (let i = 0; i < target.children.length; i++)\n        {\n            _getGlobalBounds(target.children[i], bounds, worldTransform, skipUpdateTransform);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addBounds?.(bounds);\n        }\n\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    if (!skipUpdateTransform)\n    {\n        matrixPool.return(worldTransform);\n    }\n}\n\nexport function updateTransformBackwards(target: Container, parentTransform: Matrix)\n{\n    const parent = target.parent;\n\n    if (parent)\n    {\n        updateTransformBackwards(parent, parentTransform);\n\n        parent.updateLocalTransform();\n\n        parentTransform.append(parent.localTransform);\n    }\n\n    return parentTransform;\n}\n", "export function multiplyHexColors(color1: number, color2: number): number\n{\n    if (color1 === 0xFFFFFF || !color2) return color2;\n    if (color2 === 0xFFFFFF || !color1) return color1;\n\n    const r1 = (color1 >> 16) & 0xFF;\n    const g1 = (color1 >> 8) & 0xFF;\n    const b1 = color1 & 0xFF;\n\n    const r2 = (color2 >> 16) & 0xFF;\n    const g2 = (color2 >> 8) & 0xFF;\n    const b2 = color2 & 0xFF;\n\n    const r = ((r1 * r2) / 255) | 0;\n    const g = ((g1 * g2) / 255) | 0;\n    const b = ((b1 * b2) / 255) | 0;\n\n    return (r << 16) + (g << 8) + b;\n}\n", "import { multiplyHexColors } from './multiplyHexColors';\n\nconst WHITE_BGR = 0xFFFFFF;\n\nexport function multiplyColors(localBGRColor: number, parentBGRColor: number)\n{\n    if (localBGRColor === WHITE_BGR)\n    {\n        return parentBGRColor;\n    }\n\n    if (parentBGRColor === WHITE_BGR)\n    {\n        return localBGRColor;\n    }\n\n    return multiplyHexColors(localBGRColor, parentBGRColor);\n}\n", "import { updateTransformBackwards } from '../bounds/getGlobalBounds';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\nimport { multiplyColors } from '../utils/multiplyColors';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Container } from '../Container';\n\nexport function bgr2rgb(color: number): number\n{\n    return ((color & 0xFF) << 16) + (color & 0xFF00) + ((color >> 16) & 0xFF);\n}\n\nexport interface GetGlobalMixin\n{\n    getGlobalAlpha(skipUpdate: boolean): number;\n    getGlobalTransform(matrix: Matrix, skipUpdate: boolean): Matrix;\n    getGlobalTint(skipUpdate?: boolean): number;\n}\n\nexport const getGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global (compound) alpha of the container within the scene.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire alpha chain through parents for accuracy\n     *   - If true: Uses cached worldAlpha from the last render pass for better performance\n     * @returns The resulting alpha value (between 0 and 1)\n     * @example\n     * // Accurate but slower - recalculates entire alpha chain\n     * const preciseAlpha = container.getGlobalAlpha();\n     *\n     * // Faster but may be outdated - uses cached alpha\n     * const cachedAlpha = container.getGlobalAlpha(true);\n     */\n    getGlobalAlpha(skipUpdate: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return this.renderGroup.worldAlpha;\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return this.parentRenderGroup.worldAlpha * this.alpha;\n            }\n\n            return this.alpha;\n        }\n\n        let alpha = this.alpha;\n        let current = this.parent;\n\n        while (current)\n        {\n            alpha *= current.alpha;\n            current = current.parent;\n        }\n\n        return alpha;\n    },\n\n    /**\n     * Returns the global transform matrix of the container within the scene.\n     * @param matrix - Optional matrix to store the result. If not provided, a new Matrix will be created.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire transform chain for accuracy\n     *   - If true: Uses cached worldTransform from the last render pass for better performance\n     * @returns The resulting transformation matrix (either the input matrix or a new one)\n     * @example\n     * // Accurate but slower - recalculates entire transform chain\n     * const preciseTransform = container.getGlobalTransform();\n     *\n     * // Faster but may be outdated - uses cached transform\n     * const cachedTransform = container.getGlobalTransform(undefined, true);\n     *\n     * // Reuse existing matrix\n     * const existingMatrix = new Matrix();\n     * container.getGlobalTransform(existingMatrix);\n     */\n    getGlobalTransform(matrix: Matrix, skipUpdate: boolean): Matrix\n    {\n        if (skipUpdate)\n        {\n            return matrix.copyFrom(this.worldTransform);\n        }\n\n        this.updateLocalTransform();\n\n        const parentTransform = updateTransformBackwards(this, matrixPool.get().identity());\n\n        matrix.appendFrom(this.localTransform, parentTransform);\n        matrixPool.return(parentTransform);\n\n        return matrix;\n    },\n\n    /**\n     * Returns the global (compound) tint color of the container within the scene.\n     * @param skipUpdate - Performance optimization flag:\n     *   - If false (default): Recalculates the entire tint chain through parents for accuracy\n     *   - If true: Uses cached worldColor from the last render pass for better performance\n     * @returns The resulting tint color as a 24-bit RGB number (0xRRGGBB)\n     * @example\n     * // Accurate but slower - recalculates entire tint chain\n     * const preciseTint = container.getGlobalTint();\n     *\n     * // Faster but may be outdated - uses cached tint\n     * const cachedTint = container.getGlobalTint(true);\n     */\n    getGlobalTint(skipUpdate?: boolean): number\n    {\n        if (skipUpdate)\n        {\n            if (this.renderGroup)\n            {\n                return bgr2rgb(this.renderGroup.worldColor);\n            }\n\n            if (this.parentRenderGroup)\n            {\n                return bgr2rgb(\n                    multiplyColors(this.localColor, this.parentRenderGroup.worldColor)\n                );\n            }\n\n            return this.tint;\n        }\n\n        let color = this.localColor;\n        let parent = this.parent;\n\n        while (parent)\n        {\n            color = multiplyColors(color, parent.localColor);\n            parent = parent.parent;\n        }\n\n        return bgr2rgb(color);\n    }\n\n} as Container;\n", "let warnCount = 0;\nconst maxWarnings = 500;\n\n/**\n * Logs a PixiJS warning message to the console. Stops logging after 500 warnings have been logged.\n * @param args - The warning message(s) to log\n * @returns {void}\n * @memberof utils\n * @ignore\n */\nexport function warn(...args: any[])\n{\n    if (warnCount === maxWarnings) return;\n\n    warnCount++;\n\n    if (warnCount === maxWarnings)\n    {\n        console.warn('PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.');\n    }\n    else\n    {\n        console.warn('PixiJS Warning: ', ...args);\n    }\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { warn } from '../../../utils/logging/warn';\nimport { boundsPool, matrixPool } from './utils/matrixAndBoundsPool';\n\nimport type { Renderable } from '../../../rendering/renderers/shared/Renderable';\nimport type { Container } from '../Container';\nimport type { Bounds } from './Bounds';\n\nexport function getLocalBounds(target: Container, bounds: Bounds, relativeMatrix?: Matrix): Bounds\n{\n    bounds.clear();\n\n    relativeMatrix ||= Matrix.IDENTITY;\n\n    _getLocalBounds(target, bounds, relativeMatrix, target, true);\n\n    if (!bounds.isValid)\n    {\n        bounds.set(0, 0, 0, 0);\n    }\n\n    return bounds;\n}\n\nfunction _getLocalBounds(\n    target: Container,\n    bounds: Bounds,\n    parentTransform: Matrix,\n    rootContainer: Container,\n    isRoot: boolean\n): void\n{\n    let relativeTransform: Matrix;\n\n    if (!isRoot)\n    {\n        if (!target.visible || !target.measurable) return;\n\n        target.updateLocalTransform();\n\n        const localTransform = target.localTransform;\n\n        relativeTransform = matrixPool.get();\n        relativeTransform.appendFrom(localTransform, parentTransform);\n    }\n    else\n    {\n        relativeTransform = matrixPool.get();\n        relativeTransform = parentTransform.copyTo(relativeTransform);\n    }\n\n    const parentBounds = bounds;\n    const preserveBounds = !!target.effects.length;\n\n    if (preserveBounds)\n    {\n        bounds = boundsPool.get().clear();\n    }\n\n    if (target.boundsArea)\n    {\n        bounds.addRect(target.boundsArea, relativeTransform);\n    }\n    else\n    {\n        if (target.renderPipeId)\n        {\n            bounds.matrix = relativeTransform;\n            bounds.addBounds((target as Renderable).bounds);\n        }\n\n        const children = target.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            _getLocalBounds(children[i], bounds, relativeTransform, rootContainer, false);\n        }\n    }\n\n    if (preserveBounds)\n    {\n        for (let i = 0; i < target.effects.length; i++)\n        {\n            target.effects[i].addLocalBounds?.(bounds, rootContainer);\n        }\n\n        // TODO - make a add transformed bounds?\n        parentBounds.addBounds(bounds, Matrix.IDENTITY);\n\n        boundsPool.return(bounds);\n    }\n\n    matrixPool.return(relativeTransform);\n}\n\nexport function getParent(target: Container, root: Container, matrix: Matrix)\n{\n    const parent = target.parent;\n\n    if (!parent)\n    {\n        // we have reach the top of the tree!\n        // #if _DEBUG\n        warn('Item is not inside the root container');\n        // #endif\n\n        return;\n    }\n\n    if (parent !== root)\n    {\n        getParent(parent, root, matrix);\n\n        parent.updateLocalTransform();\n        matrix.append(parent.localTransform);\n    }\n}\n\n", "import type { Container } from '../Container';\n\n/**\n * This function will crawl through the container essentially check if the children have changed.\n *\n * This function checkChildrenDidChange recursively checks if any child in a Container\n * or its children has changed. It does this by comparing a generated changeId for each\n * child against a stored value in previousData.\n * The changeId is a combination of the child's uid and _didChangeId, bitwise manipulated for uniqueness.\n * If a change is detected, it updates previousData and sets didChange to true.\n * The function returns a boolean indicating if any change was detected in the entire hierarchy of children.\n * @param container - the container to check for changes\n * @param previousData - the previous data from the last check made\n * @param previousData.data - the data array\n * @param previousData.index - the index of the data array\n * @param previousData.didChange - did the data change\n */\nexport function checkChildrenDidChange(\n    container: Container,\n    previousData: {\n        data: number[];\n        index: number;\n        didChange: boolean;\n    })\n{\n    const children = container.children;\n\n    for (let i = 0; i < children.length; i++)\n    {\n        const child = children[i];\n\n        const uid = child.uid;\n        const didChange = ((child._didViewChangeTick & 0xffff) << 16) | (child._didContainerChangeTick & 0xffff);\n\n        const index = previousData.index;\n\n        if (previousData.data[index] !== uid || previousData.data[index + 1] !== didChange)\n        {\n            previousData.data[previousData.index] = uid;\n            previousData.data[previousData.index + 1] = didChange;\n\n            previousData.didChange = true;\n        }\n\n        previousData.index = index + 2;\n\n        if (child.children.length)\n        {\n            checkChildrenDidChange(child, previousData);\n        }\n    }\n\n    return previousData.didChange;\n}\n", "import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Bounds } from '../bounds/Bounds';\nimport { getGlobalBounds } from '../bounds/getGlobalBounds';\nimport { getLocalBounds } from '../bounds/getLocalBounds';\nimport { checkChildrenDidChange } from '../utils/checkChildrenDidChange';\n\nimport type { Size } from '../../../maths/misc/Size';\nimport type { Container } from '../Container';\n\nexport type Optional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nexport interface MeasureMixinConstructor\n{\n    width?: number;\n    height?: number;\n}\nexport interface MeasureMixin extends Required<MeasureMixinConstructor>\n{\n    getSize(out?: Size): Size;\n    setSize(width: number, height?: number): void;\n    setSize(value: Optional<Size, 'height'>): void;\n    getLocalBounds(bounds?: Bounds): Bounds;\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds;\n    _localBoundsCacheData: LocalBoundsCacheData;\n    _localBoundsCacheId: number;\n    _setWidth(width: number, localWidth: number): void;\n    _setHeight(height: number, localHeight: number): void;\n}\n\ninterface LocalBoundsCacheData\n{\n    data: number[];\n    index: number;\n    didChange: boolean;\n    localBounds: Bounds;\n}\n\nconst tempMatrix = new Matrix();\n\nexport const measureMixin: Partial<Container> = {\n\n    _localBoundsCacheId: -1,\n    _localBoundsCacheData: null,\n\n    _setWidth(value: number, localWidth: number)\n    {\n        const sign = Math.sign(this.scale.x) || 1;\n\n        if (localWidth !== 0)\n        {\n            this.scale.x = (value / localWidth) * sign;\n        }\n        else\n        {\n            this.scale.x = sign;\n        }\n    },\n\n    _setHeight(value: number, localHeight: number)\n    {\n        const sign = Math.sign(this.scale.y) || 1;\n\n        if (localHeight !== 0)\n        {\n            this.scale.y = (value / localHeight) * sign;\n        }\n        else\n        {\n            this.scale.y = sign;\n        }\n    },\n\n    /**\n     * Retrieves the local bounds of the container as a Bounds object.\n     * @returns - The bounding area.\n     * @memberof scene.Container#\n     */\n    getLocalBounds(): Bounds\n    {\n        if (!this._localBoundsCacheData)\n        {\n            this._localBoundsCacheData = {\n                data: [],\n                index: 1,\n                didChange: false,\n                localBounds: new Bounds()\n            };\n        }\n\n        const localBoundsCacheData = this._localBoundsCacheData;\n\n        localBoundsCacheData.index = 1;\n        localBoundsCacheData.didChange = false;\n\n        if (localBoundsCacheData.data[0] !== this._didViewChangeTick)\n        {\n            localBoundsCacheData.didChange = true;\n            localBoundsCacheData.data[0] = this._didViewChangeTick;\n        }\n\n        checkChildrenDidChange(this, localBoundsCacheData);\n\n        if (localBoundsCacheData.didChange)\n        {\n            getLocalBounds(this, localBoundsCacheData.localBounds, tempMatrix);\n        }\n\n        return localBoundsCacheData.localBounds;\n    },\n\n    /**\n     * Calculates and returns the (world) bounds of the display object as a [Rectangle]{@link Rectangle}.\n     * @param skipUpdate - Setting to `true` will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost.\n     * @param bounds - Optional bounds to store the result of the bounds calculation.\n     * @returns - The minimum axis-aligned rectangle in world space that fits around this object.\n     * @memberof scene.Container#\n     */\n    getBounds(skipUpdate?: boolean, bounds?: Bounds): Bounds\n    {\n        return getGlobalBounds(this, skipUpdate, bounds || new Bounds());\n    },\n} as Container;\n", "import type { Renderer } from '../../../rendering/renderers/types';\nimport type { Container } from '../Container';\n\nexport interface OnRenderMixinConstructor\n{\n    onRender?: ((renderer: Renderer) => void | null);\n}\nexport interface OnRenderMixin extends Required<OnRenderMixinConstructor>\n{\n    _onRender: ((renderer: Renderer) => void) | null;\n}\n\nexport const onRenderMixin: Partial<Container> = {\n    _onRender: null,\n\n    set onRender(func: (renderer: Renderer) => void)\n    {\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (!func)\n        {\n            if (this._onRender)\n            {\n                renderGroup?.removeOnRender(this);\n            }\n\n            this._onRender = null;\n\n            return;\n        }\n\n        if (!this._onRender)\n        {\n            renderGroup?.addOnRender(this);\n        }\n\n        this._onRender = func;\n    },\n\n    /**\n     * This callback is used when the container is rendered. This is where you should add your custom\n     * logic that is needed to be run every frame.\n     *\n     * In v7 many users used `updateTransform` for this, however the way v8 renders objects is different\n     * and \"updateTransform\" is no longer called every frame\n     * @example\n     * const container = new Container();\n     * container.onRender = () => {\n     *    container.rotation += 0.01;\n     * };\n     * @memberof scene.Container#\n     */\n    get onRender(): (renderer: Renderer) => void\n    {\n        return this._onRender;\n    }\n} as Container;\n", "import type { Container } from '../Container';\n\nexport interface SortMixinConstructor\n{\n    zIndex?: number;\n    sortDirty?: boolean;\n    sortableChildren?: boolean;\n}\nexport interface SortMixin extends Required<SortMixinConstructor>\n{\n    _zIndex: number;\n\n    sortChildren: () => void;\n    depthOfChildModified: () => void;\n}\n\nexport const sortMixin: Partial<Container> = {\n    _zIndex: 0,\n    /**\n     * Should children be sorted by zIndex at the next render call.\n     *\n     * Will get automatically set to true if a new child is added, or if a child's zIndex changes.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortDirty: false,\n    /**\n     * If set to true, the container will sort its children by `zIndex` value\n     * when the next render is called, or manually if `sortChildren()` is called.\n     *\n     * This actually changes the order of elements in the array, so should be treated\n     * as a basic solution that is not performant compared to other solutions,\n     * such as {@link https://github.com/pixijs/layers PixiJS Layers}\n     *\n     * Also be aware of that this may not work nicely with the `addChildAt()` function,\n     * as the `zIndex` sorting may cause the child to automatically sorted to another position.\n     * @type {boolean}\n     * @memberof scene.Container#\n     */\n    sortableChildren: false,\n\n    /**\n     * The zIndex of the container.\n     *\n     * Setting this value, will automatically set the parent to be sortable. Children will be automatically\n     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,\n     * and thus rendered on top of other display objects within the same container.\n     * @see scene.Container#sortableChildren\n     * @memberof scene.Container#\n     */\n    get zIndex()\n    {\n        return this._zIndex;\n    },\n\n    set zIndex(value: number)\n    {\n        if (this._zIndex === value) return;\n\n        this._zIndex = value;\n\n        this.depthOfChildModified();\n    },\n\n    depthOfChildModified()\n    {\n        if (this.parent)\n        {\n            this.parent.sortableChildren = true;\n            this.parent.sortDirty = true;\n        }\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n    },\n\n    /**\n     * Sorts children by zIndex.\n     * @memberof scene.Container#\n     */\n    sortChildren()\n    {\n        if (!this.sortDirty) return;\n\n        this.sortDirty = false;\n\n        this.children.sort(sortChildren);\n    },\n} as Container;\n\nfunction sortChildren(a: Container, b: Container): number\n{\n    return a._zIndex - b._zIndex;\n}\n", "import { Point } from '../../../maths/point/Point';\nimport { matrixPool } from '../bounds/utils/matrixAndBoundsPool';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.apply(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        const globalMatrix = this.getGlobalTransform(matrixPool.get(), skipUpdate);\n\n        // simply apply the matrix..\n        point = globalMatrix.applyInverse(position, point);\n\n        matrixPool.return(globalMatrix);\n\n        return point;\n    }\n} as Container;\n", "import { uid } from '../../../../utils/data/uid';\n\nimport type { Renderable } from '../Renderable';\nimport type { Instruction } from './Instruction';\n\n/**\n * A set of instructions that can be executed by the renderer.\n * Basically wraps an array, but with some extra properties that help the renderer\n * to keep things nice and optimised.\n *\n * Note:\n * InstructionSet.instructions contains all the instructions, but does not resize (for performance).\n * So for the true length of the instructions you need to use InstructionSet.instructionSize\n * @memberof rendering\n */\nexport class InstructionSet\n{\n    /** a unique id for this instruction set used through the renderer */\n    public readonly uid: number = uid('instructionSet');\n    /** the array of instructions */\n    public readonly instructions: Instruction[] = [];\n    /** the actual size of the array (any instructions passed this should be ignored) */\n    public instructionSize = 0;\n    /** allows for access to the render pipes of the renderer */\n    public renderPipes: any;\n\n    public renderables: Renderable[] = [];\n    /** used by the garbage collector to track when the instruction set was last used */\n    public gcTick = 0;\n\n    /** reset the instruction set so it can be reused set size back to 0 */\n    public reset()\n    {\n        this.instructionSize = 0;\n    }\n\n    /**\n     * Add an instruction to the set\n     * @param instruction - add an instruction to the set\n     */\n    public add(instruction: Instruction)\n    {\n        this.instructions[this.instructionSize++] = instruction;\n    }\n\n    /**\n     * Log the instructions to the console (for debugging)\n     * @internal\n     * @ignore\n     */\n    public log()\n    {\n        this.instructions.length = this.instructionSize;\n        // eslint-disable-next-line no-console\n        console.table(this.instructions, ['type', 'action']);\n    }\n}\n", "// Taken from the bit-twiddle package\n\n/**\n * Rounds to next power of two.\n * @function nextPow2\n * @param {number} v - input value\n * @returns {number} - next rounded power of two\n * @memberof maths\n */\nexport function nextPow2(v: number): number\n{\n    v += v === 0 ? 1 : 0;\n    --v;\n    v |= v >>> 1;\n    v |= v >>> 2;\n    v |= v >>> 4;\n    v |= v >>> 8;\n    v |= v >>> 16;\n\n    return v + 1;\n}\n\n/**\n * Checks if a number is a power of two.\n * @function isPow2\n * @param {number} v - input value\n * @returns {boolean} `true` if value is power of two\n * @memberof maths\n */\nexport function isPow2(v: number): boolean\n{\n    return !(v & (v - 1)) && (!!v);\n}\n\n/**\n * Computes ceil of log base 2\n * @function log2\n * @param {number} v - input value\n * @returns {number} logarithm base 2\n * @memberof maths\n */\nexport function log2(v: number): number\n{\n    let r = (v > 0xFFFF ? 1 : 0) << 4;\n\n    v >>>= r;\n\n    let shift = (v > 0xFF ? 1 : 0) << 3;\n\n    v >>>= shift; r |= shift;\n    shift = (v > 0xF ? 1 : 0) << 2;\n    v >>>= shift; r |= shift;\n    shift = (v > 0x3 ? 1 : 0) << 1;\n    v >>>= shift; r |= shift;\n\n    return r | (v >> 1);\n}\n", "/**\n * Returns a new object with all properties from the input object that have defined values.\n * @template T - The type of the input object.\n * @param {T} obj - The input object.\n * @returns {T} - A new object with only the defined properties from the input object.\n * @memberof utils\n * @ignore\n */\nexport function definedProps<T extends Record<string, any>>(obj: T): T\n{\n    const result: Partial<T> = {};\n\n    for (const key in obj)\n    {\n        if (obj[key] !== undefined)\n        {\n            result[key] = obj[key];\n        }\n    }\n\n    return result as T;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { COMPARE_FUNCTION, SCALE_MODE, WRAP_MODE } from './const';\n\nconst idHash: Record<string, number> = Object.create(null);\n\n/**\n * This takes a shader string and maps it to a resource id.\n * This is a little different than regular resource ids as these ids\n * are not unique to the resource. But must not overlap with other (non sampler) resources Ids.\n * @param value - the string to turn into a resource id\n * @returns a unique resource id\n */\nfunction createResourceIdFromString(value: string): number\n{\n    const id = idHash[value];\n\n    if (id === undefined)\n    {\n        idHash[value] = uid('resource');\n    }\n\n    return id;\n}\n\nexport interface TextureStyleOptions extends Partial<TextureStyle>\n{\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    addressMode?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeU?: WRAP_MODE;\n    /** specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    addressModeW?: WRAP_MODE;\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    scaleMode?: SCALE_MODE;\n\n    /** specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    magFilter?: SCALE_MODE;\n    /** specifies the sampling behavior when the sample footprint is larger than one texel. */\n    minFilter?: SCALE_MODE;\n    /** specifies behavior for sampling between mipmap levels. */\n    mipmapFilter?: SCALE_MODE;\n\n    /** specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     *\n     * setting this to anything higher than 1 will set scale modes to 'linear'\n     */\n    maxAnisotropy?: number;\n}\n\n/**\n * A texture style describes how a texture should be sampled by a shader.\n * @memberof rendering\n */\nexport class TextureStyle extends EventEmitter<{\n    change: TextureStyle,\n    destroy: TextureStyle,\n}> implements BindResource\n{\n    public _resourceType = 'textureSampler';\n    public _touched = 0;\n    private _sharedResourceId: number;\n\n    /** default options for the style */\n    public static readonly defaultOptions: TextureStyleOptions = {\n        addressMode: 'clamp-to-edge',\n        scaleMode: 'linear'\n    };\n\n    /** */\n    public addressModeU?: WRAP_MODE;\n    /** */\n    public addressModeV?: WRAP_MODE;\n    /** Specifies the {{GPUAddressMode|address modes}} for the texture width, height, and depth coordinates, respectively. */\n    public addressModeW?: WRAP_MODE;\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    public magFilter?: SCALE_MODE;\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    public minFilter?: SCALE_MODE;\n    /** Specifies behavior for sampling between mipmap levels. */\n    public mipmapFilter?: SCALE_MODE;\n    /** */\n    public lodMinClamp?: number;\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    public lodMaxClamp?: number;\n    /**\n     * When provided the sampler will be a comparison sampler with the specified\n     * {@link GPUCompareFunction}.\n     * Note: Comparison samplers may use filtering, but the sampling results will be\n     * implementation-dependent and may differ from the normal filtering rules.\n     */\n    public compare?: COMPARE_FUNCTION;\n    /**\n     * Specifies the maximum anisotropy value clamp used by the sampler.\n     * Note: Most implementations support {@link GPUSamplerDescriptor#maxAnisotropy} values in range\n     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor#maxAnisotropy} will\n     * be clamped to the maximum value that the platform supports.\n     * @internal\n     * @ignore\n     */\n    public _maxAnisotropy?: number = 1;\n\n    /**\n     * Has the style been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * @param options - options for the style\n     */\n    constructor(options: TextureStyleOptions = {})\n    {\n        super();\n\n        options = { ...TextureStyle.defaultOptions, ...options };\n\n        this.addressMode = options.addressMode;\n\n        this.addressModeU = options.addressModeU ?? this.addressModeU;\n        this.addressModeV = options.addressModeV ?? this.addressModeV;\n        this.addressModeW = options.addressModeW ?? this.addressModeW;\n\n        this.scaleMode = options.scaleMode;\n\n        this.magFilter = options.magFilter ?? this.magFilter;\n        this.minFilter = options.minFilter ?? this.minFilter;\n        this.mipmapFilter = options.mipmapFilter ?? this.mipmapFilter;\n\n        this.lodMinClamp = options.lodMinClamp;\n        this.lodMaxClamp = options.lodMaxClamp;\n\n        this.compare = options.compare;\n\n        this.maxAnisotropy = options.maxAnisotropy ?? 1;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this.addressModeU = value;\n        this.addressModeV = value;\n        this.addressModeW = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this.addressModeU;\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'TextureStyle.wrapMode is now TextureStyle.addressMode');\n        // #endif\n\n        this.addressMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this.addressMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this.magFilter = value;\n        this.minFilter = value;\n        this.mipmapFilter = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this.magFilter;\n    }\n\n    /** Specifies the maximum anisotropy value clamp used by the sampler. */\n    set maxAnisotropy(value: number)\n    {\n        this._maxAnisotropy = Math.min(value, 16);\n\n        if (this._maxAnisotropy > 1)\n        {\n            this.scaleMode = 'linear';\n        }\n    }\n\n    get maxAnisotropy(): number\n    {\n        return this._maxAnisotropy;\n    }\n\n    // TODO - move this to WebGL?\n    get _resourceId(): number\n    {\n        return this._sharedResourceId || this._generateResourceId();\n    }\n\n    public update()\n    {\n        // manage the resource..\n        this.emit('change', this);\n        this._sharedResourceId = null;\n    }\n\n    private _generateResourceId(): number\n    {\n        // eslint-disable-next-line max-len\n        const bigKey = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;\n\n        this._sharedResourceId = createResourceIdFromString(bigKey);\n\n        return this._resourceId;\n    }\n\n    /** Destroys the style */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this.removeAllListeners();\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\nimport type { TextureResourceOrOptions } from '../utils/textureFrom';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid: number = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be uploaded to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no need to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution ||= this._resolution;\n        width ||= this.width;\n        height ||= this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n\n    /**\n     * A helper function that creates a new TextureSource based on the resource you provide.\n     * @param resource - The resource to create the texture source from.\n     */\n    public static from: (resource: TextureResourceOrOptions) => TextureSource;\n}\n", "// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group\n//\n// This file implements the dihedral group of order 16, also called\n// of degree 8. That's why its called groupD8.\n\nimport { Matrix } from './Matrix';\n\n/*\n * Transform matrix for operation n is:\n * | ux | vx |\n * | uy | vy |\n */\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\n\n/**\n * [Cayley Table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n * for the composition of each rotation in the dihederal group D8.\n * @type {number[][]}\n * @private\n */\nconst rotationCayley: number[][] = [];\n\n/**\n * Matrices for each `GD8Symmetry` rotation.\n * @type {Matrix[]}\n * @private\n */\nconst rotationMatrices: Matrix[] = [];\n\n/*\n * Alias for {@code Math.sign}.\n */\nconst signum = Math.sign;\n\n/*\n * Initializes `rotationCayley` and `rotationMatrices`. It is called\n * only once below.\n */\nfunction init(): void\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row: number[] = [];\n\n        rotationCayley.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            /* Multiplies rotation matrices i and j. */\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            /* Finds rotation matrix matching the product and pushes it. */\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy\n                      && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        rotationMatrices.push(mat);\n    }\n}\n\ninit();\n\ntype GD8Symmetry = number;\n/**\n * @typedef {number} GD8Symmetry\n * @see groupD8\n */\n\n/**\n * Implements the dihedral group D8, which is similar to\n * [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html};\n * D8 is the same but with diagonals, and it is used for texture\n * rotations.\n *\n * The directions the U- and V- axes after rotation\n * of an angle of `a: GD8Constant` are the vectors `(uX(a), uY(a))`\n * and `(vX(a), vY(a))`. These aren't necessarily unit vectors.\n *\n * **Origin:**<br>\n *  This is the small part of gameofbombs.com portal system. It works.\n * @see maths.groupD8.E\n * @see maths.groupD8.SE\n * @see maths.groupD8.S\n * @see maths.groupD8.SW\n * @see maths.groupD8.W\n * @see maths.groupD8.NW\n * @see maths.groupD8.N\n * @see maths.groupD8.NE\n * @author Ivan @ivanpopelyshev\n * @namespace maths.groupD8\n */\nexport const groupD8 = {\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 0       | East      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    E: 0,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 45     | Southeast |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SE: 1,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 90     | South     |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    S: 2,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 135    | Southwest |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    SW: 3,\n\n    /**\n     * | Rotation | Direction |\n     * |----------|-----------|\n     * | 180     | West      |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    W: 4,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -135/225 | Northwest    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NW: 5,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -90/270  | North        |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    N: 6,\n\n    /**\n     * | Rotation    | Direction    |\n     * |-------------|--------------|\n     * | -45/315  | Northeast    |\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    NE: 7,\n\n    /**\n     * Reflection about Y-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_VERTICAL: 8,\n\n    /**\n     * Reflection about the main diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MAIN_DIAGONAL: 10,\n\n    /**\n     * Reflection about X-axis.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    MIRROR_HORIZONTAL: 12,\n\n    /**\n     * Reflection about reverse diagonal.\n     * @memberof maths.groupD8\n     * @constant {GD8Symmetry}\n     */\n    REVERSE_DIAGONAL: 14,\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the U-axis\n     *    after rotating the axes.\n     */\n    uX: (ind: GD8Symmetry): GD8Symmetry => ux[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the U-axis\n     *    after rotating the axes.\n     */\n    uY: (ind: GD8Symmetry): GD8Symmetry => uy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The X-component of the V-axis\n     *    after rotating the axes.\n     */\n    vX: (ind: GD8Symmetry): GD8Symmetry => vx[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} ind - sprite rotation angle.\n     * @returns {GD8Symmetry} The Y-component of the V-axis\n     *    after rotating the axes.\n     */\n    vY: (ind: GD8Symmetry): GD8Symmetry => vy[ind],\n\n    /**\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - symmetry whose opposite\n     *   is needed. Only rotations have opposite symmetries while\n     *   reflections don't.\n     * @returns {GD8Symmetry} The opposite symmetry of `rotation`\n     */\n    inv: (rotation: GD8Symmetry): GD8Symmetry =>\n    {\n        if (rotation & 8)// true only if between 8 & 15 (reflections)\n        {\n            return rotation & 15;// or rotation % 16\n        }\n\n        return (-rotation) & 7;// or (8 - rotation) % 8\n    },\n\n    /**\n     * Composes the two D8 operations.\n     *\n     * Taking `^` as reflection:\n     *\n     * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |\n     * |-------|-----|-----|-----|-----|------|-------|-------|-------|\n     * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |\n     * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |\n     * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |\n     * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |\n     * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |\n     * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |\n     * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |\n     * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |\n     *\n     * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation, which\n     *   is the row in the above cayley table.\n     * @param {GD8Symmetry} rotationFirst - First operation, which\n     *   is the column in the above cayley table.\n     * @returns {GD8Symmetry} Composed operation\n     */\n    add: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][rotationFirst]\n    ),\n\n    /**\n     * Reverse of `add`.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotationSecond - Second operation\n     * @param {GD8Symmetry} rotationFirst - First operation\n     * @returns {GD8Symmetry} Result\n     */\n    sub: (rotationSecond: GD8Symmetry, rotationFirst: GD8Symmetry): GD8Symmetry => (\n        rotationCayley[rotationSecond][groupD8.inv(rotationFirst)]\n    ),\n\n    /**\n     * Adds 180 degrees to rotation, which is a commutative\n     * operation.\n     * @memberof maths.groupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} Rotated number\n     */\n    rotate180: (rotation: number): number => rotation ^ 4,\n\n    /**\n     * Checks if the rotation angle is vertical, i.e. south\n     * or north. It doesn't work for reflections.\n     * @memberof maths.groupD8\n     * @param {GD8Symmetry} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation: GD8Symmetry): boolean => (rotation & 3) === 2, // rotation % 4 === 2\n\n    /**\n     * Approximates the vector `V(dx,dy)` into one of the\n     * eight directions provided by `groupD8`.\n     * @memberof maths.groupD8\n     * @param {number} dx - X-component of the vector\n     * @param {number} dy - Y-component of the vector\n     * @returns {GD8Symmetry} Approximation of the vector into\n     *  one of the eight symmetries.\n     */\n    byDirection: (dx: number, dy: number): GD8Symmetry =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return groupD8.S;\n            }\n\n            return groupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return groupD8.E;\n            }\n\n            return groupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return groupD8.SE;\n            }\n\n            return groupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return groupD8.NE;\n        }\n\n        return groupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     * @memberof maths.groupD8\n     * @param {Matrix} matrix - sprite world matrix\n     * @param {GD8Symmetry} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix: Matrix, rotation: GD8Symmetry, tx = 0, ty = 0): void =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat: Matrix = rotationMatrices[groupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n", "export const NOOP = () =>\n{\n    // empty!\n};\n", "import { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface BufferSourceOptions extends TextureSourceOptions<TypedArray | ArrayBuffer>\n{\n    width: number;\n    height: number;\n}\n\nexport class BufferImageSource extends TextureSource<TypedArray | ArrayBuffer>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'buffer';\n\n    constructor(options: BufferSourceOptions)\n    {\n        const buffer = options.resource || new Float32Array(options.width * options.height * 4);\n        let format = options.format;\n\n        if (!format)\n        {\n            if (buffer instanceof Float32Array)\n            {\n                format = 'rgba32float';\n            }\n            else if (buffer instanceof Int32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Uint32Array)\n            {\n                format = 'rgba32uint';\n            }\n            else if (buffer instanceof Int16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Uint16Array)\n            {\n                format = 'rgba16uint';\n            }\n            else if (buffer instanceof Int8Array)\n            {\n                format = 'bgra8unorm';\n            }\n            else\n            {\n                format = 'bgra8unorm';\n            }\n        }\n\n        super({\n            ...options,\n            resource: buffer,\n            format,\n        });\n    }\n\n    public static test(resource: any): resource is TypedArray | ArrayBuffer\n    {\n        return resource instanceof Int8Array\n        || resource instanceof Uint8Array\n        || resource instanceof Uint8ClampedArray\n        || resource instanceof Int16Array\n        || resource instanceof Uint16Array\n        || resource instanceof Int32Array\n        || resource instanceof Uint32Array\n        || resource instanceof Float32Array;\n    }\n}\n", "import { Matrix } from '../../../../maths/matrix/Matrix';\n\nimport type { Texture } from './Texture';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv mapping from Texture normal space to BaseTexture normal space.\n *\n * Takes `trim` and `rotate` into account. May contain clamp settings for Meshes and TilingSprite.\n *\n * Can be used in Texture `uvMatrix` field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * Takes track of Texture changes through `_lastTextureID` private field.\n * Use `update()` method call to track it from outside.\n * @see Texture\n * @see Mesh\n * @see TilingSprite\n * @memberof rendering\n */\nexport class TextureMatrix\n{\n    /**\n     * Matrix operation that converts texture region coords to texture coords\n     * @readonly\n     */\n    public mapCoord: Matrix;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     * @default 0\n     */\n    public clampOffset: number;\n\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     */\n    public clampMargin: number;\n\n    /**\n     * Clamp region for normalized coords, left-top pixel center in xy , bottom-right in zw.\n     * Calculated based on clampOffset.\n     */\n    public readonly uClampFrame: Float32Array;\n\n    /** Normalized clamp offset. Calculated based on clampOffset. */\n    public readonly uClampOffset: Float32Array;\n\n    /**\n     * Tracks Texture frame changes.\n     * @ignore\n     */\n    public _updateID: number;\n\n    /**\n     * Tracks Texture frame changes.\n     * @protected\n     */\n    protected _textureID: number;\n\n    protected _texture: Texture;\n\n    /**\n     * If texture size is the same as baseTexture.\n     * @default false\n     * @readonly\n     */\n    public isSimple: boolean;\n\n    /**\n     * @param texture - observed texture\n     * @param clampMargin - Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     */\n    constructor(texture: Texture, clampMargin?: number)\n    {\n        this.mapCoord = new Matrix();\n        this.uClampFrame = new Float32Array(4);\n        this.uClampOffset = new Float32Array(2);\n        this._textureID = -1;\n        this._updateID = 0;\n\n        this.clampOffset = 0;\n\n        if ((typeof clampMargin === 'undefined'))\n        {\n            this.clampMargin = (texture.width < 10) ? 0 : 0.5;\n        }\n        else\n        {\n            this.clampMargin = clampMargin;\n        }\n\n        this.isSimple = false;\n\n        this.texture = texture;\n    }\n\n    /** Texture property. */\n    get texture(): Texture\n    {\n        return this._texture;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this.texture === value) return;\n\n        this._texture?.removeListener('update', this.update, this);\n        this._texture = value;\n        this._texture.addListener('update', this.update, this);\n\n        this.update();\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param uvs - mesh uvs\n     * @param [out=uvs] - output\n     * @returns - output\n     */\n    public multiplyUvs(uvs: Float32Array, out?: Float32Array): Float32Array\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * Updates matrices if texture was changed\n     * @returns - whether or not it was updated\n     */\n    public update(): boolean\n    {\n        const tex = this._texture;\n\n        this._updateID++;\n\n        const uvs = tex.uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(\n                orig.width / trim.width,\n                0, 0, orig.height / trim.height,\n                -trim.x / trim.width,\n                -trim.y / trim.height\n            );\n\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.source;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase._resolution;\n        const offset = this.clampOffset / texBase._resolution;\n\n        frame[0] = (tex.frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex.frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex.frame.x + tex.frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex.frame.y + tex.frame.height - margin + offset) / texBase.height;\n\n        this.uClampOffset[0] = this.clampOffset / texBase.pixelWidth;\n        this.uClampOffset[1] = this.clampOffset / texBase.pixelHeight;\n\n        this.isSimple = tex.frame.width === texBase.width\n            && tex.frame.height === texBase.height\n            && tex.rotate === 0;\n\n        return true;\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferImageSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions<TextureSourceType extends TextureSource = TextureSource>\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSourceType;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n    /**\n     * Set to true if you plan on modifying this texture's frame, UVs, or swapping its source at runtime.\n     * This is false by default as it improves performance. Generally, it's recommended to create new\n     * textures and swap those rather than modifying an existing texture's properties unless you are\n     * working with a dynamic frames.\n     * Not setting this to true when modifying the texture can lead to visual artifacts.\n     *\n     * If this is false and you modify the texture, you can manually update the sprite's texture by calling\n     * `sprite.onViewUpdate()`.\n     */\n    dynamic?: boolean;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load a texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Assets.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to access the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Assets.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture<TextureSourceType extends TextureSource = TextureSource> extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public readonly uid: number = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSourceType;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link maths.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see scene.NineSliceSprite\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    /**\n     * Set to true if you plan on modifying the uvs of this texture.\n     * When this is the case, sprites and other objects using the texture will\n     * make sure to listen for changes to the uvs and update their vertices accordingly.\n     */\n    public dynamic = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {rendering.TextureOptions} options - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate,\n        dynamic\n    }: TextureOptions<TextureSourceType> = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = (source?.source ?? new TextureSource()) as TextureSourceType;\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n        this.dynamic = dynamic || false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSourceType)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSourceType\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /**\n     * Call this if you have modified the `texture outside` of the constructor.\n     *\n     * If you have modified this texture's source, you must separately call `texture.source.update()` to see those changes.\n     */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture<BufferImageSource>;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n", "import { nextPow2 } from '../../../../maths/misc/pow2';\nimport { TextureSource } from './sources/TextureSource';\nimport { Texture } from './Texture';\n\nimport type { TextureSourceOptions } from './sources/TextureSource';\n\nlet count = 0;\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in default pool\n * @memberof rendering\n * @name TexturePool\n */\nexport class TexturePoolClass\n{\n    /** The default options for texture pool */\n    public textureOptions: TextureSourceOptions;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n\n    private _texturePool: {[x in string | number]: Texture[]};\n    private _poolKeyHash: Record<number, number> = Object.create(null);\n\n    /**\n     * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n     * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n     */\n    constructor(textureOptions?: TextureSourceOptions)\n    {\n        this._texturePool = {};\n        this.textureOptions = textureOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     * @param antialias\n     */\n    public createTexture(pixelWidth: number, pixelHeight: number, antialias: boolean): Texture\n    {\n        const textureSource = new TextureSource({\n            ...this.textureOptions,\n\n            width: pixelWidth,\n            height: pixelHeight,\n            resolution: 1,\n            antialias,\n            autoGarbageCollect: false,\n        });\n\n        return new Texture({\n            source: textureSource,\n            label: `texturePool_${count++}`,\n        });\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param frameWidth - The minimum width of the render texture.\n     * @param frameHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @param antialias\n     * @returns The new render texture.\n     */\n    public getOptimalTexture(frameWidth: number, frameHeight: number, resolution = 1, antialias: boolean): Texture\n    {\n        let po2Width = Math.ceil((frameWidth * resolution) - 1e-6);\n        let po2Height = Math.ceil((frameHeight * resolution) - 1e-6);\n\n        po2Width = nextPow2(po2Width);\n        po2Height = nextPow2(po2Height);\n\n        const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n\n        if (!this._texturePool[key])\n        {\n            this._texturePool[key] = [];\n        }\n\n        let texture = this._texturePool[key].pop();\n\n        if (!texture)\n        {\n            texture = this.createTexture(po2Width, po2Height, antialias);\n        }\n\n        texture.source._resolution = resolution;\n        texture.source.width = po2Width / resolution;\n        texture.source.height = po2Height / resolution;\n        texture.source.pixelWidth = po2Width;\n        texture.source.pixelHeight = po2Height;\n\n        // fit the layout to the requested original size\n        texture.frame.x = 0;\n        texture.frame.y = 0;\n        texture.frame.width = frameWidth;\n        texture.frame.height = frameHeight;\n\n        texture.updateUvs();\n\n        this._poolKeyHash[texture.uid] = key;\n\n        return texture;\n    }\n\n    /**\n     * Gets extra texture of the same size as input renderTexture\n     * @param texture - The texture to check what size it is.\n     * @param antialias - Whether to use antialias.\n     * @returns A texture that is a power of two\n     */\n    public getSameSizeTexture(texture: Texture, antialias = false)\n    {\n        const source = texture.source;\n\n        return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param renderTexture - The renderTexture to free\n     */\n    public returnTexture(renderTexture: Texture): void\n    {\n        const key = this._poolKeyHash[renderTexture.uid];\n\n        this._texturePool[key].push(renderTexture);\n    }\n\n    /**\n     * Clears the pool.\n     * @param destroyTextures - Destroy all stored textures.\n     */\n    public clear(destroyTextures?: boolean): void\n    {\n        destroyTextures = destroyTextures !== false;\n        if (destroyTextures)\n        {\n            for (const i in this._texturePool)\n            {\n                const textures = this._texturePool[i];\n\n                if (textures)\n                {\n                    for (let j = 0; j < textures.length; j++)\n                    {\n                        textures[j].destroy(true);\n                    }\n                }\n            }\n        }\n\n        this._texturePool = {};\n    }\n}\n\nexport const TexturePool = new TexturePoolClass();\n", "import { Matrix } from '../../maths/matrix/Matrix';\nimport { InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { TexturePool } from '../../rendering/renderers/shared/texture/TexturePool';\nimport { type Renderer } from '../../rendering/renderers/types';\n\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BatchableSprite } from '../sprite/BatchableSprite';\nimport type { ViewContainer } from '../view/ViewContainer';\nimport type { Bounds } from './bounds/Bounds';\nimport type { Container } from './Container';\n\n/**\n * Options for caching a container as a texture.\n * @memberof rendering\n * @see {@link RenderGroup#textureOptions}\n */\nexport interface CacheAsTextureOptions\n{\n    /**\n     * If true, the texture will be antialiased. This smooths out the edges of the texture.\n     * @default false\n     */\n    antialias?: boolean;\n    /**\n     * The resolution of the texture. A higher resolution means a sharper texture but uses more memory.\n     * By default the resolution is 1 which is the same as the rendererers resolution.\n     */\n    resolution?: number;\n}\n\n/**\n * A RenderGroup is a class that is responsible for I generating a set of instructions that are used to render the\n * root container and its children. It also watches for any changes in that container or its children,\n * these changes are analysed and either the instruction set is rebuild or the instructions data is updated.\n * @memberof rendering\n */\nexport class RenderGroup implements Instruction\n{\n    public renderPipeId = 'renderGroup';\n    public root: Container = null;\n\n    public canBundle = false;\n\n    public renderGroupParent: RenderGroup = null;\n    public renderGroupChildren: RenderGroup[] = [];\n\n    public worldTransform: Matrix = new Matrix();\n    public worldColorAlpha = 0xffffffff;\n    public worldColor = 0xffffff;\n    public worldAlpha = 1;\n\n    // these updates are transform changes..\n    public readonly childrenToUpdate: Record<number, { list: Container[]; index: number; }> = Object.create(null);\n    public updateTick = 0;\n    public gcTick = 0;\n\n    // these update are renderable changes..\n    public readonly childrenRenderablesToUpdate: { list: Container[]; index: number; } = { list: [], index: 0 };\n\n    // other\n    public structureDidChange = true;\n\n    public instructionSet: InstructionSet = new InstructionSet();\n\n    private readonly _onRenderContainers: Container[] = [];\n\n    /**\n     * Indicates if the cached texture needs to be updated.\n     * @default true\n     */\n    public textureNeedsUpdate = true;\n\n    /**\n     * Indicates if the container should be cached as a texture.\n     * @default false\n     */\n    public isCachedAsTexture = false;\n\n    /**\n     * The texture used for caching the container. this is only set if isCachedAsTexture is true.\n     * It can only be accessed after a render pass.\n     * @type {Texture | undefined}\n     */\n    public texture?: Texture;\n\n    /**\n     * The bounds of the cached texture.\n     * @type {Bounds | undefined}\n     * @ignore\n     */\n    public _textureBounds?: Bounds;\n\n    /**\n     * The options for caching the container as a texture.\n     * @type {CacheAsTextureOptions}\n     */\n    public textureOptions: CacheAsTextureOptions;\n\n    /**\n     *  holds a reference to the batchable render sprite\n     *  @ignore\n     */\n    public _batchableRenderGroup: BatchableSprite;\n\n    /**\n     * Holds a reference to the closest parent RenderGroup that has isCachedAsTexture enabled.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @type {RenderGroup | null}\n     * @ignore\n     */\n    public _parentCacheAsTextureRenderGroup: RenderGroup;\n\n    private _inverseWorldTransform: Matrix;\n    private _textureOffsetInverseTransform: Matrix;\n    private _inverseParentTextureTransform: Matrix;\n\n    private _matrixDirty = 0b111;\n\n    public init(root: Container)\n    {\n        this.root = root;\n\n        if (root._onRender) this.addOnRender(root);\n\n        root.didChange = true;\n\n        const children = root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            const child = children[i];\n\n            // make sure the children are all updated on the first pass..\n            child._updateFlags = 0b1111;\n\n            this.addChild(child);\n        }\n    }\n\n    public enableCacheAsTexture(options: CacheAsTextureOptions = {}): void\n    {\n        this.textureOptions = options;\n        this.isCachedAsTexture = true;\n        this.textureNeedsUpdate = true;\n    }\n\n    public disableCacheAsTexture(): void\n    {\n        this.isCachedAsTexture = false;\n        if (this.texture)\n        {\n            TexturePool.returnTexture(this.texture);\n            this.texture = null;\n        }\n    }\n\n    public updateCacheTexture(): void\n    {\n        this.textureNeedsUpdate = true;\n    }\n\n    public reset()\n    {\n        this.renderGroupChildren.length = 0;\n\n        for (const i in this.childrenToUpdate)\n        {\n            const childrenAtDepth = this.childrenToUpdate[i];\n\n            childrenAtDepth.list.fill(null);\n            childrenAtDepth.index = 0;\n        }\n\n        this.childrenRenderablesToUpdate.index = 0;\n        this.childrenRenderablesToUpdate.list.fill(null);\n\n        this.root = null;\n        this.updateTick = 0;\n        this.structureDidChange = true;\n\n        this._onRenderContainers.length = 0;\n        this.renderGroupParent = null;\n\n        this.disableCacheAsTexture();\n    }\n\n    get localTransform()\n    {\n        return this.root.localTransform;\n    }\n\n    public addRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        if (renderGroupChild.renderGroupParent)\n        {\n            renderGroupChild.renderGroupParent._removeRenderGroupChild(renderGroupChild);\n        }\n\n        renderGroupChild.renderGroupParent = this;\n\n        this.renderGroupChildren.push(renderGroupChild);\n    }\n\n    private _removeRenderGroupChild(renderGroupChild: RenderGroup)\n    {\n        const index = this.renderGroupChildren.indexOf(renderGroupChild);\n\n        if (index > -1)\n        {\n            this.renderGroupChildren.splice(index, 1);\n        }\n\n        renderGroupChild.renderGroupParent = null;\n    }\n\n    public addChild(child: Container)\n    {\n        this.structureDidChange = true;\n\n        child.parentRenderGroup = this;\n\n        child.updateTick = -1;\n\n        if (child.parent === this.root)\n        {\n            child.relativeRenderGroupDepth = 1;\n        }\n        else\n        {\n            child.relativeRenderGroupDepth = child.parent.relativeRenderGroupDepth + 1;\n        }\n\n        child.didChange = true;\n        this.onChildUpdate(child);\n\n        if (child.renderGroup)\n        {\n            this.addRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        if (child._onRender) this.addOnRender(child);\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.addChild(children[i]);\n        }\n    }\n\n    public removeChild(child: Container)\n    {\n        // remove all the children...\n        this.structureDidChange = true;\n\n        if (child._onRender)\n        {\n            // Remove the child to the onRender list under the following conditions:\n            // 1. If the child is not a render group.\n            // 2. If the child is a render group root of this render group - which it can't be removed from in this case.\n            if (!child.renderGroup)\n            {\n                this.removeOnRender(child);\n            }\n        }\n\n        child.parentRenderGroup = null;\n\n        if (child.renderGroup)\n        {\n            this._removeRenderGroupChild(child.renderGroup);\n\n            return;\n        }\n\n        const children = child.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public removeChildren(children: Container[])\n    {\n        for (let i = 0; i < children.length; i++)\n        {\n            this.removeChild(children[i]);\n        }\n    }\n\n    public onChildUpdate(child: Container)\n    {\n        let childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth];\n\n        if (!childrenToUpdate)\n        {\n            childrenToUpdate = this.childrenToUpdate[child.relativeRenderGroupDepth] = {\n                index: 0,\n                list: [],\n            };\n        }\n\n        childrenToUpdate.list[childrenToUpdate.index++] = child;\n    }\n\n    public updateRenderable(renderable: ViewContainer)\n    {\n        if (renderable.globalDisplayStatus < 0b111) return;\n        this.instructionSet.renderPipes[renderable.renderPipeId].updateRenderable(renderable);\n        renderable.didViewUpdate = false;\n    }\n\n    public onChildViewUpdate(child: Container)\n    {\n        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = child;\n    }\n\n    get isRenderable(): boolean\n    {\n        return (this.root.localDisplayStatus === 0b111 && this.worldAlpha > 0);\n    }\n\n    /**\n     * adding a container to the onRender list will make sure the user function\n     * passed in to the user defined 'onRender` callBack\n     * @param container - the container to add to the onRender list\n     */\n    public addOnRender(container: Container)\n    {\n        this._onRenderContainers.push(container);\n    }\n\n    public removeOnRender(container: Container)\n    {\n        this._onRenderContainers.splice(this._onRenderContainers.indexOf(container), 1);\n    }\n\n    public runOnRender(renderer: Renderer)\n    {\n        for (let i = 0; i < this._onRenderContainers.length; i++)\n        {\n            this._onRenderContainers[i]._onRender(renderer);\n        }\n    }\n\n    public destroy()\n    {\n        this.disableCacheAsTexture();\n\n        this.renderGroupParent = null;\n        this.root = null;\n        (this.childrenRenderablesToUpdate as any) = null;\n        (this.childrenToUpdate as any) = null;\n        (this.renderGroupChildren as any) = null;\n        (this._onRenderContainers as any) = null;\n        this.instructionSet = null;\n    }\n\n    public getChildren(out: Container[] = []): Container[]\n    {\n        const children = this.root.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    private _getChildren(container: Container, out: Container[] = []): Container[]\n    {\n        out.push(container);\n\n        if (container.renderGroup) return out;\n\n        const children = container.children;\n\n        for (let i = 0; i < children.length; i++)\n        {\n            this._getChildren(children[i], out);\n        }\n\n        return out;\n    }\n\n    public invalidateMatrices()\n    {\n        this._matrixDirty = 0b111;\n    }\n\n    /**\n     * Returns the inverse of the world transform matrix.\n     * @returns {Matrix} The inverse of the world transform matrix.\n     */\n    public get inverseWorldTransform()\n    {\n        if ((this._matrixDirty & 0b001) === 0) return this._inverseWorldTransform;\n\n        this._matrixDirty &= ~0b001;\n\n        // TODO - add dirty flag\n        this._inverseWorldTransform ||= new Matrix();\n\n        return this._inverseWorldTransform\n            .copyFrom(this.worldTransform)\n            .invert();\n    }\n\n    /**\n     * Returns the inverse of the texture offset transform matrix.\n     * @returns {Matrix} The inverse of the texture offset transform matrix.\n     */\n    public get textureOffsetInverseTransform()\n    {\n        if ((this._matrixDirty & 0b010) === 0) return this._textureOffsetInverseTransform;\n\n        this._matrixDirty &= ~0b010;\n\n        this._textureOffsetInverseTransform ||= new Matrix();\n\n        // TODO shared.. bad!\n        return this._textureOffsetInverseTransform\n            .copyFrom(this.inverseWorldTransform)\n            .translate(\n                -this._textureBounds.x,\n                -this._textureBounds.y\n            );\n    }\n\n    /**\n     * Returns the inverse of the parent texture transform matrix.\n     * This is used to properly transform coordinates when rendering into cached textures.\n     * @returns {Matrix} The inverse of the parent texture transform matrix.\n     */\n    public get inverseParentTextureTransform()\n    {\n        if ((this._matrixDirty & 0b100) === 0) return this._inverseParentTextureTransform;\n\n        this._matrixDirty &= ~0b100;\n\n        const parentCacheAsTexture = this._parentCacheAsTextureRenderGroup;\n\n        if (parentCacheAsTexture)\n        {\n            this._inverseParentTextureTransform ||= new Matrix();\n\n            // Get relative transform by removing parent's world transform\n            return this._inverseParentTextureTransform\n                .copyFrom(this.worldTransform)\n                .prepend(parentCacheAsTexture.inverseWorldTransform)\n                // Offset by texture bounds\n                .translate(\n                    -parentCacheAsTexture._textureBounds.x,\n                    -parentCacheAsTexture._textureBounds.y\n                );\n        }\n\n        return this.worldTransform;\n    }\n\n    /**\n     * Returns a matrix that transforms coordinates to the correct coordinate space of the texture being rendered to.\n     * This is the texture offset inverse transform of the closest parent RenderGroup that is cached as a texture.\n     * @returns {Matrix | null} The transform matrix for the cached texture coordinate space,\n     * or null if no parent is cached as texture.\n     */\n    public get cacheToLocalTransform()\n    {\n        if (!this._parentCacheAsTextureRenderGroup) return null;\n\n        return this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform;\n    }\n}\n", "/**\n * Assigns properties from one object to another, using an optional array of property names to ignore.\n * @param target - The target object to assign properties to.\n * @param options - The object to assign properties from.\n * @param ignore - An object of property names to ignore ({ propToIgnore: true }).\n */\nexport function assignWithIgnore<T extends Record<string, any>>(\n    target: T,\n    options: T,\n    ignore: Record<string, boolean> = {}\n)\n{\n    for (const key in options)\n    {\n        if (!ignore[key] && options[key] !== undefined)\n        {\n            target[key] = options[key];\n        }\n    }\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Color, type ColorSource } from '../../color/Color';\nimport { cullingMixin } from '../../culling/cullingMixin';\nimport { extensions } from '../../extensions/Extensions';\nimport { Matrix } from '../../maths/matrix/Matrix';\nimport { DEG_TO_RAD, RAD_TO_DEG } from '../../maths/misc/const';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { uid } from '../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { BigPool } from '../../utils/pool/PoolGroup';\nimport { type IRenderLayer } from '../layers/RenderLayer';\nimport { cacheAsTextureMixin } from './container-mixins/cacheAsTextureMixin';\nimport { childrenHelperMixin } from './container-mixins/childrenHelperMixin';\nimport { collectRenderablesMixin } from './container-mixins/collectRenderablesMixin';\nimport { effectsMixin } from './container-mixins/effectsMixin';\nimport { findMixin } from './container-mixins/findMixin';\nimport { getFastGlobalBoundsMixin } from './container-mixins/getFastGlobalBoundsMixin';\nimport { bgr2rgb, getGlobalMixin } from './container-mixins/getGlobalMixin';\nimport { measureMixin } from './container-mixins/measureMixin';\nimport { onRenderMixin } from './container-mixins/onRenderMixin';\nimport { sortMixin } from './container-mixins/sortMixin';\nimport { toLocalGlobalMixin } from './container-mixins/toLocalGlobalMixin';\nimport { RenderGroup } from './RenderGroup';\nimport { assignWithIgnore } from './utils/assignWithIgnore';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Rectangle } from '../../maths/shapes/Rectangle';\nimport type { BLEND_MODES } from '../../rendering/renderers/shared/state/const';\nimport type { Dict } from '../../utils/types';\nimport type { Optional } from './container-mixins/measureMixin';\nimport type { DestroyOptions } from './destroyTypes';\n\nexport type ContainerChild = Container;\n\n/**\n * This is where you'll find all the display objects available in Pixi.\n *\n * All display objects inherit from the {@link scene.Container} class. You can use a `Container` for simple grouping of\n * other display objects. Here's all the available display object classes.\n *\n * - {@link scene.Container} is the base class for all display objects that act as a container for other objects.\n *   - {@link scene.Sprite} is a display object that uses a texture\n *      - {@link scene.AnimatedSprite} is a sprite that can play animations\n *   - {@link scene.TilingSprite} a fast way of rendering a tiling image\n *   - {@link scene.NineSliceSprite} allows you to stretch a texture using 9-slice scaling\n *   - {@link scene.Graphics} is a graphic object that can be drawn to the screen.\n *   - {@link scene.Mesh} empowers you to have maximum flexibility to render any kind of visuals you can think of\n *      - {@link scene.MeshSimple} mimics Mesh, providing easy-to-use constructor arguments\n *      - {@link scene.MeshPlane} allows you to draw a texture across several points and then manipulate these points\n *      - {@link scene.MeshRope} allows you to draw a texture across several points and then manipulate these points\n *   - {@link scene.Text} render text using custom fonts\n *      - {@link scene.BitmapText} render text using a bitmap font\n *      - {@link scene.HTMLText} render text using HTML and CSS\n * @namespace scene\n */\n\n// as pivot and skew are the least used properties of a container, we can use this optimisation\n// to avoid allocating lots of unnecessary objects for them.\nconst defaultSkew = new ObservablePoint(null);\nconst defaultPivot = new ObservablePoint(null);\nconst defaultScale = new ObservablePoint(null, 1, 1);\n\nexport interface ContainerEvents<C extends ContainerChild> extends PixiMixins.ContainerEvents\n{\n    added: [container: Container];\n    childAdded: [child: C, container: Container, index: number];\n    removed: [container: Container];\n    childRemoved: [child: C, container: Container, index: number];\n    destroyed: [container: Container];\n}\n\ntype AnyEvent = {\n    // The following is a hack to allow any custom event while maintaining type safety.\n    // For some reason, the tsc compiler gets angry about error TS1023\n    // \"An index signature parameter type must be either 'string' or 'number'.\"\n    // This is really odd since ({}&string) should interpret as string, but then again\n    // there is some black magic behind why this works in the first place.\n    // Closest thing to an explanation:\n    // https://stackoverflow.com/questions/70144348/why-does-a-union-of-type-literals-and-string-cause-ide-code-completion-wh\n    //\n    // Side note, we disable @typescript-eslint/ban-types since {}&string is the only syntax that works.\n    // Nor of the Record/unknown/never alternatives work.\n    [K: ({} & string) | ({} & symbol)]: any;\n};\n\nexport const UPDATE_COLOR = 0b0001;\nexport const UPDATE_BLEND = 0b0010;\nexport const UPDATE_VISIBLE = 0b0100;\nexport const UPDATE_TRANSFORM = 0b1000;\n\nexport interface UpdateTransformOptions\n{\n    x: number;\n    y: number;\n    scaleX: number;\n    scaleY: number;\n    rotation: number;\n    skewX: number;\n    skewY: number;\n    pivotX: number;\n    pivotY: number;\n}\n\n/**\n * Constructor options used for `Container` instances.\n * ```js\n * const container = new Container({\n *    position: new Point(100, 200),\n *    scale: new Point(2, 2),\n *    rotation: Math.PI / 2,\n * });\n * ```\n * @memberof scene\n * @see scene.Container\n */\nexport interface ContainerOptions<C extends ContainerChild = ContainerChild> extends PixiMixins.ContainerOptions\n{\n    /** @see scene.Container#isRenderGroup */\n    isRenderGroup?: boolean;\n\n    /** @see scene.Container#blendMode */\n    blendMode?: BLEND_MODES;\n    /** @see scene.Container#tint */\n    tint?: ColorSource;\n\n    /** @see scene.Container#alpha */\n    alpha?: number;\n    /** @see scene.Container#angle */\n    angle?: number;\n    /** @see scene.Container#children */\n    children?: C[];\n    /** @see scene.Container#parent */\n    parent?: Container;\n    /** @see scene.Container#renderable */\n    renderable?: boolean;\n    /** @see scene.Container#rotation */\n    rotation?: number;\n    /** @see scene.Container#scale */\n    scale?: PointData | number;\n    /** @see scene.Container#pivot */\n    pivot?: PointData | number;\n    /** @see scene.Container#position */\n    position?: PointData;\n    /** @see scene.Container#skew */\n    skew?: PointData;\n    /** @see scene.Container#visible */\n    visible?: boolean;\n    /** @see scene.Container#x */\n    x?: number;\n    /** @see scene.Container#y */\n    y?: number;\n    /** @see scene.Container#boundArea */\n    boundsArea?: Rectangle;\n}\n\nexport interface Container<C extends ContainerChild>\n    extends PixiMixins.Container<C>, EventEmitter<ContainerEvents<C> & AnyEvent> {}\n\n/**\n * Container is a general-purpose display object that holds children. It also adds built-in support for advanced\n * rendering features like masking and filtering.\n *\n * It is the base class of all display objects that act as a container for other objects, including Graphics\n * and Sprite.\n *\n * <details id=\"transforms\">\n *\n * <summary>Transforms</summary>\n *\n * The [transform]{@link scene.Container#transform} of a display object describes the projection from its\n * local coordinate space to its parent's local coordinate space. The following properties are derived\n * from the transform:\n *\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Property</th>\n *       <th>Description</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>[pivot]{@link scene.Container#pivot}</td>\n *       <td>\n *         Invariant under rotation, scaling, and skewing. The projection of into the parent's space of the pivot\n *         is equal to position, regardless of the other three transformations. In other words, It is the center of\n *         rotation, scaling, and skewing.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[position]{@link scene.Container#position}</td>\n *       <td>\n *         Translation. This is the position of the [pivot]{@link scene.Container#pivot} in the parent's local\n *         space. The default value of the pivot is the origin (0,0). If the top-left corner of your display object\n *         is (0,0) in its local space, then the position will be its top-left corner in the parent's local space.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[scale]{@link scene.Container#scale}</td>\n *       <td>\n *         Scaling. This will stretch (or compress) the display object's projection. The scale factors are along the\n *         local coordinate axes. In other words, the display object is scaled before rotated or skewed. The center\n *         of scaling is the [pivot]{@link scene.Container#pivot}.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[rotation]{@link scene.Container#rotation}</td>\n *       <td>\n *          Rotation. This will rotate the display object's projection by this angle (in radians).\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[skew]{@link scene.Container#skew}</td>\n *       <td>\n *         <p>Skewing. This can be used to deform a rectangular display object into a parallelogram.</p>\n *         <p>\n *         In PixiJS, skew has a slightly different behaviour than the conventional meaning. It can be\n *         thought of the net rotation applied to the coordinate axes (separately). For example, if \"skew.x\" is\n *          and \"skew.y\" is , then the line x = 0 will be rotated by  (y = -x*cot) and the line y = 0 will be\n *         rotated by  (y = x*tan). A line y = x*tan (i.e. a line at angle  to the x-axis in local-space) will\n *         be rotated by an angle between  and .\n *         </p>\n *         <p>\n *         It can be observed that if skew is applied equally to both axes, then it will be equivalent to applying\n *         a rotation. Indeed, if \"skew.x\" = - and \"skew.y\" = , it will produce an equivalent of \"rotation\" = .\n *         </p>\n *         <p>\n *         Another quite interesting observation is that \"skew.x\", \"skew.y\", rotation are commutative operations. Indeed,\n *         because rotation is essentially a careful combination of the two.\n *         </p>\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[angle]{@link scene.Container#angle}</td>\n *       <td>Rotation. This is an alias for [rotation]{@link scene.Container#rotation}, but in degrees.</td>\n *     </tr>\n *     <tr>\n *       <td>[x]{@link scene.Container#x}</td>\n *       <td>Translation. This is an alias for position.x!</td>\n *     </tr>\n *     <tr>\n *       <td>[y]{@link scene.Container#y}</td>\n *       <td>Translation. This is an alias for position.y!</td>\n *     </tr>\n *     <tr>\n *       <td>[width]{@link scene.Container#width}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The width property calculates scale.x by dividing\n *         the \"requested\" width by the local bounding box width. It is indirectly an abstraction over scale.x, and there\n *         is no concept of user-defined width.\n *       </td>\n *     </tr>\n *     <tr>\n *       <td>[height]{@link scene.Container#height}</td>\n *       <td>\n *         Implemented in [Container]{@link scene.Container}. Scaling. The height property calculates scale.y by dividing\n *         the \"requested\" height by the local bounding box height. It is indirectly an abstraction over scale.y, and there\n *         is no concept of user-defined height.\n *       </td>\n *     </tr>\n *   </tbody>\n * </table>\n * </details>\n *\n * <details id=\"alpha\">\n * <summary>Alpha</summary>\n *\n * This alpha sets a display object's **relative opacity** w.r.t its parent. For example, if the alpha of a display\n * object is 0.5 and its parent's alpha is 0.5, then it will be rendered with 25% opacity (assuming alpha is not\n * applied on any ancestor further up the chain).\n * </details>\n *\n * <details id=\"visible\">\n * <summary>Renderable vs Visible</summary>\n *\n * The `renderable` and `visible` properties can be used to prevent a display object from being rendered to the\n * screen. However, there is a subtle difference between the two. When using `renderable`, the transforms  of the display\n * object (and its children subtree) will continue to be calculated. When using `visible`, the transforms will not\n * be calculated.\n * ```ts\n * import { BlurFilter, Container, Graphics, Sprite } from 'pixi.js';\n *\n * const container = new Container();\n * const sprite = Sprite.from('https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/IaUrttj.png');\n *\n * sprite.width = 512;\n * sprite.height = 512;\n *\n * // Adds a sprite as a child to this container. As a result, the sprite will be rendered whenever the container\n * // is rendered.\n * container.addChild(sprite);\n *\n * // Blurs whatever is rendered by the container\n * container.filters = [new BlurFilter()];\n *\n * // Only the contents within a circle at the center should be rendered onto the screen.\n * container.mask = new Graphics()\n *     .beginFill(0xffffff)\n *     .drawCircle(sprite.width / 2, sprite.height / 2, Math.min(sprite.width, sprite.height) / 2)\n *     .endFill();\n * ```\n *\n * </details>\n *\n * <details id=\"renderGroup\">\n * <summary>RenderGroup</summary>\n *\n * In PixiJS v8, containers can be set to operate in 'render group mode',\n * transforming them into entities akin to a stage in traditional rendering paradigms.\n * A render group is a root renderable entity, similar to a container,\n * but it's rendered in a separate pass with its own unique set of rendering instructions.\n * This approach enhances rendering efficiency and organization, particularly in complex scenes.\n *\n * You can enable render group mode on any container using container.enableRenderGroup()\n * or by initializing a new container with the render group property set to true (new Container({isRenderGroup: true})).\n *  The method you choose depends on your specific use case and setup requirements.\n *\n * An important aspect of PixiJSs rendering process is the automatic treatment of rendered scenes as render groups.\n * This conversion streamlines the rendering process, but understanding when and how this happens is crucial\n * to fully leverage its benefits.\n *\n * One of the key advantages of using render groups is the performance efficiency in moving them. Since transformations\n *  are applied at the GPU level, moving a render group, even one with complex and numerous children,\n * doesn't require recalculating the rendering instructions or performing transformations on each child.\n * This makes operations like panning a large game world incredibly efficient.\n *\n * However, it's crucial to note that render groups do not batch together.\n * This means that turning every container into a render group could actually slow things down,\n * as each render group is processed separately. It's best to use render groups judiciously, at a broader level,\n * rather than on a per-child basis.\n * This approach ensures you get the performance benefits without overburdening the rendering process.\n *\n * RenderGroups maintain their own set of rendering instructions,\n * ensuring that changes or updates within a render group don't affect the rendering\n * instructions of its parent or other render groups.\n *  This isolation ensures more stable and predictable rendering behavior.\n *\n * Additionally, renderGroups can be nested, allowing for powerful options in organizing different aspects of your scene.\n * This feature is particularly beneficial for separating complex game graphics from UI elements,\n * enabling intricate and efficient scene management in complex applications.\n *\n * This means that Containers have 3 levels of matrix to be mindful of:\n *\n * 1. localTransform, this is the transform of the container based on its own properties\n * 2. groupTransform, this it the transform of the container relative to the renderGroup it belongs too\n * 3. worldTransform, this is the transform of the container relative to the Scene being rendered\n * </details>\n * @memberof scene\n */\nexport class Container<C extends ContainerChild = ContainerChild> extends EventEmitter<ContainerEvents<C> & AnyEvent>\n{\n    /**\n     * Mixes all enumerable properties and methods from a source object to Container.\n     * @param source - The source of properties and methods to mix in.\n     * @deprecated since 8.8.0\n     */\n    public static mixin(source: Dict<any>): void\n    {\n        // #if _DEBUG\n        deprecation('8.8.0', 'Container.mixin is deprecated, please use extensions.mixin instead.');\n        // #endif\n        extensions.mixin(Container, source);\n    }\n\n    /** unique id for this container */\n    public readonly uid: number = uid('renderable');\n\n    /** @private */\n    public _updateFlags = 0b1111;\n\n    // the render group this container owns\n    /** @private */\n    public renderGroup: RenderGroup = null;\n    // the render group this container belongs to\n    /** @private */\n    public parentRenderGroup: RenderGroup = null;\n    // the index of the container in the render group\n    /** @private */\n    public parentRenderGroupIndex: number = 0;\n\n    // set to true if the container has changed. It is reset once the changes have been applied\n    // by the transform system\n    // its here to stop ensure that when things change, only one update gets registers with the transform system\n    /** @private */\n    public didChange = false;\n    // same as above, but for the renderable\n    /** @private */\n    public didViewUpdate = false;\n\n    // how deep is the container relative to its render group..\n    // unless the element is the root render group - it will be relative to its parent\n    /** @private */\n    public relativeRenderGroupDepth = 0;\n\n    /**\n     * The array of children of this container.\n     * @readonly\n     */\n    public children: C[] = [];\n    /** The display object container that contains this display object. */\n    public parent: Container = null;\n\n    // used internally for changing up the render order.. mainly for masks and filters\n    // TODO setting this should cause a rebuild??\n    /** @private */\n    public includeInBuild = true;\n    /** @private */\n    public measurable = true;\n    /** @private */\n    public isSimple = true;\n\n    /**\n     * The RenderLayer this container belongs to, if any.\n     * If it belongs to a RenderLayer, it will be rendered from the RenderLayer's position in the scene.\n     * @readonly\n     */\n    public parentRenderLayer: IRenderLayer;\n\n    // / /////////////Transform related props//////////////\n\n    // used by the transform system to check if a container needs to be updated that frame\n    // if the tick matches the current transform system tick, it is not updated again\n    /**\n     * @internal\n     * @ignore\n     */\n    public updateTick = -1;\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff.\n     * @readonly\n     */\n    public localTransform: Matrix = new Matrix();\n    /**\n     * The relative group transform is a transform relative to the render group it belongs too. It will include all parent\n     * transforms and up to the render group (think of it as kind of like a stage - but the stage can be nested).\n     * If this container is is self a render group matrix will be relative to its parent render group\n     * @readonly\n     */\n    public relativeGroupTransform: Matrix = new Matrix();\n    /**\n     * The group transform is a transform relative to the render group it belongs too.\n     * If this container is render group then this will be an identity matrix. other wise it\n     * will be the same as the relativeGroupTransform.\n     * Use this value when actually rendering things to the screen\n     * @readonly\n     */\n    public groupTransform: Matrix = this.relativeGroupTransform;\n\n    // the global transform taking into account the render group and all parents\n    private _worldTransform: Matrix;\n\n    /** If the object has been destroyed via destroy(). If true, it should not be used. */\n    public destroyed = false;\n\n    // transform data..\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @internal\n     * @ignore\n     */\n    public _position: ObservablePoint = new ObservablePoint(this, 0, 0);\n\n    /**\n     * The scale factor of the object.\n     * @internal\n     * @ignore\n     */\n    public _scale: ObservablePoint = defaultScale;\n\n    /**\n     * The pivot point of the container that it rotates around.\n     * @internal\n     * @ignore\n     */\n    public _pivot: ObservablePoint = defaultPivot;\n\n    /**\n     * The skew amount, on the x and y axis.\n     * @internal\n     * @ignore\n     */\n    public _skew: ObservablePoint = defaultSkew;\n\n    /**\n     * The X-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cx = 1;\n\n    /**\n     * The Y-coordinate value of the normalized local X axis,\n     * the first column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sx = 0;\n\n    /**\n     * The X-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _cy = 0;\n\n    /**\n     * The Y-coordinate value of the normalized local Y axis,\n     * the second column of the local transformation matrix without a scale.\n     * @internal\n     * @ignore\n     */\n    public _sy = 1;\n\n    /**\n     * The rotation amount.\n     * @internal\n     * @ignore\n     */\n    private _rotation = 0;\n\n    // / COLOR related props //////////////\n\n    // color stored as ABGR\n    public localColor = 0xFFFFFF;\n    public localAlpha = 1;\n\n    public groupAlpha = 1; // A\n    public groupColor = 0xFFFFFF; // BGR\n    public groupColorAlpha = 0xFFFFFFFF; // ABGR\n\n    // / BLEND related props //////////////\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public localBlendMode: BLEND_MODES = 'inherit';\n    /**\n     * @internal\n     * @ignore\n     */\n    public groupBlendMode: BLEND_MODES = 'normal';\n\n    // / VISIBILITY related props //////////////\n\n    // visibility\n    // 0b11\n    // first bit is visible, second bit is renderable\n    /**\n     * This property holds three bits: culled, visible, renderable\n     * the third bit represents culling (0 = culled, 1 = not culled) 0b100\n     * the second bit represents visibility (0 = not visible, 1 = visible) 0b010\n     * the first bit represents renderable (0 = not renderable, 1 = renderable) 0b001\n     * @internal\n     * @ignore\n     */\n    public localDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n    /**\n     * @internal\n     * @ignore\n     */\n    public globalDisplayStatus = 0b111; // 0b11 | 0b10 | 0b01 | 0b00\n\n    public readonly renderPipeId: string;\n\n    /**\n     * An optional bounds area for this container. Setting this rectangle will stop the renderer\n     * from recursively measuring the bounds of each children and instead use this single boundArea.\n     * This is great for optimisation! If for example you have a 1000 spinning particles and you know they all sit\n     * within a specific bounds, then setting it will mean the renderer will not need to measure the\n     * 1000 children to find the bounds. Instead it will just use the bounds you set.\n     */\n    public boundsArea: Rectangle;\n\n    /**\n     * A value that increments each time the containe is modified\n     * eg children added, removed etc\n     * @ignore\n     */\n    public _didContainerChangeTick = 0;\n    /**\n     * A value that increments each time the container view is modified\n     * eg texture swap, geometry change etc\n     * @ignore\n     */\n    public _didViewChangeTick = 0;\n\n    public layerParentId: string;// = 'default';\n    /**\n     * We now use the _didContainerChangeTick and _didViewChangeTick to track changes\n     * @deprecated since 8.2.6\n     * @ignore\n     */\n    set _didChangeId(value: number)\n    {\n        this._didViewChangeTick = (value >> 12) & 0xFFF; // Extract the upper 12 bits\n        this._didContainerChangeTick = value & 0xFFF; // Extract the lower 12 bits\n    }\n\n    get _didChangeId(): number\n    {\n        return (this._didContainerChangeTick & 0xfff) | ((this._didViewChangeTick & 0xfff) << 12);\n    }\n\n    /**\n     * property that tracks if the container transform has changed\n     * @ignore\n     */\n    private _didLocalTransformChangeId = -1;\n\n    constructor(options: ContainerOptions<C> = {})\n    {\n        super();\n\n        this.effects = [];\n        assignWithIgnore(this, options, {\n            children: true,\n            parent: true,\n            effects: true,\n        });\n\n        options.children?.forEach((child) => this.addChild(child));\n        options.parent?.addChild(this);\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     * @param {...Container} children - The Container(s) to add to the container\n     * @returns {Container} - The first child that was added.\n     */\n    public addChild<U extends(C | IRenderLayer)[]>(...children: U): U[0]\n    {\n        // #if _DEBUG\n        if (!this.allowChildren)\n        {\n            deprecation(v8_0_0, 'addChild: Only Containers will be allowed to add children in v8.0.0');\n        }\n        // #endif\n\n        if (children.length > 1)\n        {\n            // loop through the array and add all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.addChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0] as C;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (child.parent === this)\n        {\n            this.children.splice(this.children.indexOf(child), 1);\n            this.children.push(child);\n\n            if (renderGroup)\n            {\n                renderGroup.structureDidChange = true;\n            }\n\n            return child;\n        }\n\n        if (child.parent)\n        {\n            // TODO Optimisation...if the parent has the same render group, this does not need to change!\n            child.parent.removeChild(child);\n        }\n\n        this.children.push(child);\n\n        if (this.sortableChildren) this.sortDirty = true;\n\n        child.parent = this;\n\n        child.didChange = true;\n\n        // TODO - OPtimise this? could check what the parent has set?\n        child._updateFlags = 0b1111;\n\n        if (renderGroup)\n        {\n            renderGroup.addChild(child);\n        }\n\n        this.emit('childAdded', child, this, this.children.length - 1);\n        child.emit('added', this);\n\n        this._didViewChangeTick++;\n\n        if (child._zIndex !== 0)\n        {\n            child.depthOfChildModified();\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes one or more children from the container.\n     * @param {...Container} children - The Container(s) to remove\n     * @returns {Container} The first child that was removed.\n     */\n    public removeChild<U extends(C | IRenderLayer)[]>(...children: U): U[0]\n    {\n        // if there is only one argument we can bypass looping through the them\n        if (children.length > 1)\n        {\n            // loop through the arguments property and remove all children\n            for (let i = 0; i < children.length; i++)\n            {\n                this.removeChild(children[i]);\n            }\n\n            return children[0];\n        }\n\n        const child = children[0] as C;\n\n        const index = this.children.indexOf(child);\n\n        if (index > -1)\n        {\n            this._didViewChangeTick++;\n\n            this.children.splice(index, 1);\n\n            if (this.renderGroup)\n            {\n                this.renderGroup.removeChild(child);\n            }\n            else if (this.parentRenderGroup)\n            {\n                this.parentRenderGroup.removeChild(child);\n            }\n\n            if (child.parentRenderLayer)\n            {\n                child.parentRenderLayer.detach(child);\n            }\n\n            child.parent = null;\n            this.emit('childRemoved', child, this, index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /** @ignore */\n    public _onUpdate(point?: ObservablePoint)\n    {\n        if (point)\n        {\n            //   this.updateFlags |= UPDATE_TRANSFORM;\n\n            if (point === this._skew)\n            {\n                this._updateSkew();\n            }\n        }\n\n        this._didContainerChangeTick++;\n\n        if (this.didChange) return;\n        this.didChange = true;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.onChildUpdate(this);\n        }\n    }\n\n    set isRenderGroup(value: boolean)\n    {\n        if (!!this.renderGroup === value) return;\n\n        if (value)\n        {\n            this.enableRenderGroup();\n        }\n        else\n        {\n            this.disableRenderGroup();\n        }\n    }\n\n    /**\n     * Returns true if this container is a render group.\n     * This means that it will be rendered as a separate pass, with its own set of instructions\n     */\n    get isRenderGroup(): boolean\n    {\n        return !!this.renderGroup;\n    }\n\n    /**\n     * Calling this enables a render group for this container.\n     * This means it will be rendered as a separate set of instructions.\n     * The transform of the container will also be handled on the GPU rather than the CPU.\n     */\n    public enableRenderGroup(): void\n    {\n        if (this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        this.renderGroup = BigPool.get(RenderGroup, this);\n\n        // this group matrix will now be an identity matrix,\n        // as its own transform will be passed to the GPU\n        this.groupTransform = Matrix.IDENTITY;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** This will disable the render group for this container. */\n    public disableRenderGroup(): void\n    {\n        if (!this.renderGroup) return;\n\n        const parentRenderGroup = this.parentRenderGroup;\n\n        parentRenderGroup?.removeChild(this);\n\n        BigPool.return(this.renderGroup);\n\n        this.renderGroup = null;\n        this.groupTransform = this.relativeGroupTransform;\n\n        parentRenderGroup?.addChild(this);\n\n        this._updateIsSimple();\n    }\n\n    /** @ignore */\n    public _updateIsSimple()\n    {\n        this.isSimple = !(this.renderGroup) && (this.effects.length === 0);\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors.\n     * @readonly\n     */\n    get worldTransform()\n    {\n        this._worldTransform ||= new Matrix();\n\n        if (this.renderGroup)\n        {\n            this._worldTransform.copyFrom(this.renderGroup.worldTransform);\n        }\n        else if (this.parentRenderGroup)\n        {\n            this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform);\n        }\n\n        return this._worldTransform;\n    }\n\n    /**\n     * The position of the container on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     */\n    get x(): number\n    {\n        return this._position.x;\n    }\n\n    set x(value: number)\n    {\n        this._position.x = value;\n    }\n\n    /**\n     * The position of the container on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     */\n    get y(): number\n    {\n        return this._position.y;\n    }\n\n    set y(value: number)\n    {\n        this._position.y = value;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * @since 4.0.0\n     */\n    get position(): ObservablePoint\n    {\n        return this._position;\n    }\n\n    set position(value: PointData)\n    {\n        this._position.copyFrom(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get rotation(): number\n    {\n        return this._rotation;\n    }\n\n    set rotation(value: number)\n    {\n        if (this._rotation !== value)\n        {\n            this._rotation = value;\n            this._onUpdate(this._skew);\n        }\n    }\n\n    /**\n     * The angle of the object in degrees.\n     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.\n     */\n    get angle(): number\n    {\n        return this.rotation * RAD_TO_DEG;\n    }\n\n    set angle(value: number)\n    {\n        this.rotation = value * DEG_TO_RAD;\n    }\n\n    /**\n     * The center of rotation, scaling, and skewing for this display object in its local space. The `position`\n     * is the projection of `pivot` in the parent's local space.\n     *\n     * By default, the pivot is the origin (0, 0).\n     * @since 4.0.0\n     */\n    get pivot(): ObservablePoint\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._pivot;\n    }\n\n    set pivot(value: PointData | number)\n    {\n        if (this._pivot === defaultPivot)\n        {\n            this._pivot = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._pivot.set(value) : this._pivot.copyFrom(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * @since 4.0.0\n     */\n    get skew(): ObservablePoint\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        return this._skew;\n    }\n\n    set skew(value: PointData)\n    {\n        if (this._skew === defaultSkew)\n        {\n            this._skew = new ObservablePoint(this, 0, 0);\n        }\n\n        this._skew.copyFrom(value);\n    }\n\n    /**\n     * The scale factors of this object along the local coordinate axes.\n     *\n     * The default scale is (1, 1).\n     * @since 4.0.0\n     */\n    get scale(): ObservablePoint\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 1, 1);\n        }\n\n        return this._scale;\n    }\n\n    set scale(value: PointData | number)\n    {\n        if (this._scale === defaultScale)\n        {\n            this._scale = new ObservablePoint(this, 0, 0);\n        }\n\n        typeof value === 'number' ? this._scale.set(value) : this._scale.copyFrom(value);\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get width(): number\n    {\n        return Math.abs(this.scale.x * this.getLocalBounds().width);\n    }\n\n    set width(value: number)\n    {\n        const localWidth = this.getLocalBounds().width;\n\n        this._setWidth(value, localWidth);\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set.\n     * @memberof scene.Container#\n     */\n    get height(): number\n    {\n        return Math.abs(this.scale.y * this.getLocalBounds().height);\n    }\n\n    set height(value: number)\n    {\n        const localHeight = this.getLocalBounds().height;\n\n        this._setHeight(value, localHeight);\n    }\n\n    /**\n     * Retrieves the size of the container as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the container.\n     * @memberof scene.Container#\n     */\n    public getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        const bounds = this.getLocalBounds();\n\n        out.width = Math.abs(this.scale.x * bounds.width);\n        out.height = Math.abs(this.scale.y * bounds.height);\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the container to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     * @memberof scene.Container#\n     */\n    public setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        const size = this.getLocalBounds();\n\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, size.width);\n        height !== undefined && this._setHeight(height, size.height);\n    }\n\n    /** Called when the skew or the rotation changes. */\n    private _updateSkew(): void\n    {\n        const rotation = this._rotation;\n        const skew = this._skew;\n\n        this._cx = Math.cos(rotation + skew._y);\n        this._sx = Math.sin(rotation + skew._y);\n        this._cy = -Math.sin(rotation - skew._x); // cos, added PI/2\n        this._sy = Math.cos(rotation - skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates the transform properties of the container (accepts partial values).\n     * @param {object} opts - The options for updating the transform.\n     * @param {number} opts.x - The x position of the container.\n     * @param {number} opts.y - The y position of the container.\n     * @param {number} opts.scaleX - The scale factor on the x-axis.\n     * @param {number} opts.scaleY - The scale factor on the y-axis.\n     * @param {number} opts.rotation - The rotation of the container, in radians.\n     * @param {number} opts.skewX - The skew factor on the x-axis.\n     * @param {number} opts.skewY - The skew factor on the y-axis.\n     * @param {number} opts.pivotX - The x coordinate of the pivot point.\n     * @param {number} opts.pivotY - The y coordinate of the pivot point.\n     */\n    public updateTransform(opts: Partial<UpdateTransformOptions>): this\n    {\n        this.position.set(\n            typeof opts.x === 'number' ? opts.x : this.position.x,\n            typeof opts.y === 'number' ? opts.y : this.position.y\n        );\n        this.scale.set(\n            typeof opts.scaleX === 'number' ? opts.scaleX || 1 : this.scale.x,\n            typeof opts.scaleY === 'number' ? opts.scaleY || 1 : this.scale.y\n        );\n        this.rotation = typeof opts.rotation === 'number' ? opts.rotation : this.rotation;\n        this.skew.set(\n            typeof opts.skewX === 'number' ? opts.skewX : this.skew.x,\n            typeof opts.skewY === 'number' ? opts.skewY : this.skew.y\n        );\n        this.pivot.set(\n            typeof opts.pivotX === 'number' ? opts.pivotX : this.pivot.x,\n            typeof opts.pivotY === 'number' ? opts.pivotY : this.pivot.y\n        );\n\n        return this;\n    }\n\n    /**\n     * Updates the local transform using the given matrix.\n     * @param matrix - The matrix to use for updating the transform.\n     */\n    public setFromMatrix(matrix: Matrix): void\n    {\n        matrix.decompose(this);\n    }\n\n    /** Updates the local transform. */\n    public updateLocalTransform(): void\n    {\n        const localTransformChangeId = this._didContainerChangeTick;\n\n        if (this._didLocalTransformChangeId === localTransformChangeId) return;\n\n        this._didLocalTransformChangeId = localTransformChangeId;\n        //   this.didChange = false;\n\n        const lt = this.localTransform;\n        const scale = this._scale;\n        const pivot = this._pivot;\n        const position = this._position;\n\n        const sx = scale._x;\n        const sy = scale._y;\n\n        const px = pivot._x;\n        const py = pivot._y;\n\n        // get the matrix values of the container based on its this properties..\n        lt.a = this._cx * sx;\n        lt.b = this._sx * sx;\n        lt.c = this._cy * sy;\n        lt.d = this._sy * sy;\n\n        lt.tx = position._x - ((px * lt.a) + (py * lt.c));\n        lt.ty = position._y - ((px * lt.b) + (py * lt.d));\n    }\n\n    // / ///// color related stuff\n\n    set alpha(value: number)\n    {\n        if (value === this.localAlpha) return;\n\n        this.localAlpha = value;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /** The opacity of the object. */\n    get alpha(): number\n    {\n        return this.localAlpha;\n    }\n\n    set tint(value: ColorSource)\n    {\n        const tempColor = Color.shared.setValue(value ?? 0xFFFFFF);\n        const bgr = tempColor.toBgrNumber();\n\n        if (bgr === this.localColor) return;\n\n        this.localColor = bgr;\n\n        this._updateFlags |= UPDATE_COLOR;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The tint applied to the sprite. This is a hex value.\n     *\n     * A value of 0xFFFFFF will remove any tint effect.\n     * @default 0xFFFFFF\n     */\n    get tint(): number\n    {\n        // convert bgr to rgb..\n        return bgr2rgb(this.localColor);\n    }\n\n    // / //////////////// blend related stuff\n\n    set blendMode(value: BLEND_MODES)\n    {\n        if (this.localBlendMode === value) return;\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_BLEND;\n\n        this.localBlendMode = value;\n\n        this._onUpdate();\n    }\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `'normal'` to reset the blend mode.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this.localBlendMode;\n    }\n\n    // / ///////// VISIBILITY / RENDERABLE /////////////////\n\n    /** The visibility of the object. If false the object will not be drawn, and the transform will not be updated. */\n    get visible()\n    {\n        return !!(this.localDisplayStatus & 0b010);\n    }\n\n    set visible(value: boolean)\n    {\n        const valueNumber = value ? 0b010 : 0;\n\n        if ((this.localDisplayStatus & 0b010) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n\n        this.localDisplayStatus ^= 0b010;\n\n        this._onUpdate();\n    }\n\n    /** @ignore */\n    get culled()\n    {\n        return !(this.localDisplayStatus & 0b100);\n    }\n\n    /** @ignore */\n    set culled(value: boolean)\n    {\n        const valueNumber = value ? 0 : 0b100;\n\n        if ((this.localDisplayStatus & 0b100) === valueNumber) return;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b100;\n\n        this._onUpdate();\n    }\n\n    /** Can this object be rendered, if false the object will not be drawn but the transform will still be updated. */\n    get renderable()\n    {\n        return !!(this.localDisplayStatus & 0b001);\n    }\n\n    set renderable(value: boolean)\n    {\n        const valueNumber = value ? 0b001 : 0;\n\n        if ((this.localDisplayStatus & 0b001) === valueNumber) return;\n\n        this._updateFlags |= UPDATE_VISIBLE;\n        this.localDisplayStatus ^= 0b001;\n\n        if (this.parentRenderGroup)\n        {\n            this.parentRenderGroup.structureDidChange = true;\n        }\n\n        this._onUpdate();\n    }\n\n    /** Whether or not the object should be rendered. */\n    get isRenderable(): boolean\n    {\n        return (this.localDisplayStatus === 0b111 && this.groupAlpha > 0);\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites. If options.children\n     * is set to true it should destroy the texture of the child sprite\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true it should destroy the texture source of the child sprite\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true it should destroy the context of the child graphics\n     */\n    public destroy(options: DestroyOptions = false): void\n    {\n        if (this.destroyed) return;\n        this.destroyed = true;\n\n        // remove children is faster than removeChild..\n\n        let oldChildren: ContainerChild[];\n\n        // we add this check as calling removeChildren on particle container will throw an error\n        // As we know it does cannot have any children, check before calling the function.\n        if (this.children.length)\n        {\n            oldChildren = this.removeChildren(0, this.children.length);\n        }\n\n        this.removeFromParent();\n        this.parent = null;\n        this._maskEffect = null;\n        this._filterEffect = null;\n        this.effects = null;\n        this._position = null;\n        this._scale = null;\n        this._pivot = null;\n        this._skew = null;\n\n        this.emit('destroyed', this);\n\n        this.removeAllListeners();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options?.children;\n\n        if (destroyChildren && oldChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n\n        this.renderGroup?.destroy();\n        this.renderGroup = null;\n    }\n}\n\nextensions.mixin(\n    Container,\n    childrenHelperMixin,\n    getFastGlobalBoundsMixin,\n    toLocalGlobalMixin,\n    onRenderMixin,\n    measureMixin,\n    effectsMixin,\n    findMixin,\n    sortMixin,\n    cullingMixin,\n    cacheAsTextureMixin,\n    getGlobalMixin,\n    collectRenderablesMixin,\n);\n", "import type { ICanvas } from '../../environment/canvas/ICanvas';\nimport type { WebGLOptions, WebGLPipes, WebGLRenderer } from './gl/WebGLRenderer';\nimport type { WebGPUOptions, WebGPUPipes, WebGPURenderer } from './gpu/WebGPURenderer';\n\n/** A generic renderer. */\n/**\n * @memberof rendering\n * @extends rendering.WebGLRenderer\n * @extends rendering.WebGPURenderer\n */\nexport type Renderer<T extends ICanvas = HTMLCanvasElement> = WebGLRenderer<T> | WebGPURenderer<T>;\nexport type RenderPipes = WebGLPipes | WebGPUPipes;\n/**\n * @extends rendering.WebGLOptions\n * @extends rendering.WebGPUOptions\n */\nexport interface RendererOptions extends WebGLOptions, WebGPUOptions {}\n\n/**\n * Ids for the different render types.\n * The idea is that you can use bitwise operations to filter whether or not you want to do something\n * in a certain render type.\n * Filters for example can be compatible for both webGL or WebGPU but not compatible with canvas.\n * So internally if it works with both we set filter.compatibleRenderers = RendererType.WEBGL | RendererType.WEBGPU\n * if it only works with webgl we set filter.compatibleRenderers = RendererType.WEBGL\n *\n */\nexport enum RendererType\n{\n    WEBGL = 0b01,\n    WEBGPU = 0b10,\n    BOTH = 0b11\n}\n\nexport type GpuPowerPreference = 'low-power' | 'high-performance';\n", "/**\n * Represents the update priorities used by internal Pixi classes when registered with\n * the {@link ticker.Ticker} object. Higher priority items are updated first and lower\n * priority items, such as render, should go later.\n * @static\n * @enum {number}\n * @memberof ticker\n */\nexport enum UPDATE_PRIORITY\n{\n    /**\n     * Highest priority used for interaction events in {@link EventSystem}\n     * @default 50\n     */\n    INTERACTION = 50,\n    /**\n     * High priority updating, used by {@link AnimatedSprite}\n     * @default 25\n     */\n    HIGH = 25,\n    /**\n     * Default priority for ticker events, see {@link Ticker#add}.\n     * @default 0\n     */\n    NORMAL = 0,\n    /**\n     * Low priority used for {@link Application} rendering.\n     * @default -25\n     */\n    LOW = -25,\n    /**\n     * Lowest priority used for {@link BasePrepare} utility.\n     * @default -50\n     */\n    UTILITY = -50,\n}\n", "import type { Ticker, TickerCallback } from './Ticker';\n\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n * @private\n * @class\n */\nexport class TickerListener<T = any>\n{\n    /** The current priority. */\n    public priority: number;\n    /** The next item in chain. */\n    public next: TickerListener = null;\n    /** The previous item in chain. */\n    public previous: TickerListener = null;\n\n    /** The handler function to execute. */\n    private _fn: TickerCallback<T>;\n    /** The calling to execute. */\n    private _context: T;\n    /** If this should only execute once. */\n    private readonly _once: boolean;\n    /** `true` if this listener has been destroyed already. */\n    private _destroyed = false;\n\n    /**\n     * Constructor\n     * @private\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param priority - The priority for emitting\n     * @param once - If the handler should fire once\n     */\n    constructor(fn: TickerCallback<T>, context: T = null, priority = 0, once = false)\n    {\n        this._fn = fn;\n        this._context = context;\n        this.priority = priority;\n        this._once = once;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @returns `true` if the listener match the arguments\n     */\n    public match(fn: TickerCallback<T>, context: any = null): boolean\n    {\n        return this._fn === fn && this._context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param ticker - The ticker emitting.\n     * @returns Next ticker\n     */\n    public emit(ticker: Ticker): TickerListener\n    {\n        if (this._fn)\n        {\n            if (this._context)\n            {\n                this._fn.call(this._context, ticker);\n            }\n            else\n            {\n                (this as TickerListener<any>)._fn(ticker);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this._once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param previous - Input node, previous listener\n     */\n    public connect(previous: TickerListener): void\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param hard - `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @returns The listener to redirect while emitting or removing.\n     */\n    public destroy(hard = false): TickerListener\n    {\n        this._destroyed = true;\n        this._fn = null;\n        this._context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n", "import { UPDATE_PRIORITY } from './const';\nimport { TickerListener } from './TickerListener';\n\n/**\n * A callback which can be added to a ticker.\n * ```js\n * ticker.add(() => {\n *    // do something every frame\n * });\n * ```\n * @memberof ticker\n */\nexport type TickerCallback<T> = (this: T, ticker: Ticker) => any;\n\n/**\n * {@link ticker.Ticker|Tickers} provide periodic callbacks based on the system clock.\n * Your game update logic will generally be run in response to a tick once per frame.\n * You can have multiple tickers in use at one time.\n * ```js\n * import { Ticker } from 'pixi.js';\n *\n * const callback = (ticker: Ticker) => {\n *    // do something on the next animation frame\n * };\n *\n * // create a ticker\n * const ticker = new Ticker();\n *\n * // register the callback and start the ticker\n * ticker.add(callback);\n * ticker.start();\n * ```\n *\n * You can always use the {@link ticker.Ticker.shared|shared} ticker that Pixi renders with by default.\n * ```js\n * Ticker.shared.add(callback);\n * ```\n * @namespace ticker\n */\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n *\n * This class is composed around listeners meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary, e.g. When the ticker is started and the emitter has listeners.\n * @class\n * @memberof ticker\n */\nexport class Ticker\n{\n    /**\n     * Target frames per millisecond.\n     * @static\n     */\n    public static targetFPMS = 0.06;\n\n    /** The private shared ticker instance */\n    private static _shared: Ticker;\n    /** The private system ticker instance  */\n    private static _system: Ticker;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link ticker.Ticker#start|start} automatically when a listener is added.\n     */\n    public autoStart = false;\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     */\n    public deltaTime = 1;\n    /**\n     * Scalar time elapsed in milliseconds from last frame to this frame.\n     * This value is capped by setting {@link ticker.Ticker#minFPS|minFPS}\n     * and is scaled with {@link ticker.Ticker#speed|speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public deltaMS: number;\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link ticker.Ticker#deltaTime|deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     * Defaults to target frame time\n     * @default 16.66\n     */\n    public elapsedMS: number;\n    /**\n     * The last time {@link ticker.Ticker#update|update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 s.\n     */\n    public lastTime = -1;\n    /**\n     * Factor of current {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @example\n     * // Scales ticker.deltaTime to what would be\n     * // the equivalent of approximately 120 FPS\n     * ticker.speed = 2;\n     */\n    public speed = 1;\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link ticker.Ticker#start|start} has been called.\n     * `false` if {@link ticker.Ticker#stop|Stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link ticker.Ticker#autoStart|autoStart} being `true`\n     * and a listener is added.\n     */\n    public started = false;\n\n    /** The first listener. All new listeners added are chained on this. */\n    private _head: TickerListener;\n    /** Internal current frame request ID */\n    private _requestId: number = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     */\n    private _maxElapsedMS = 100;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the minimum allowed milliseconds between updates.\n     */\n    private _minElapsedMS = 0;\n    /** If enabled, deleting is disabled.*/\n    private _protected = false;\n    /** The last time keyframe was executed. Maintains a relatively fixed interval with the previous value. */\n    private _lastFrame = -1;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     * @param time - Time since last tick.\n     */\n    private readonly _tick: (time: number) => any;\n\n    constructor()\n    {\n        this._head = new TickerListener(null, null, Infinity);\n        this.deltaMS = 1 / Ticker.targetFPMS;\n        this.elapsedMS = 1 / Ticker.targetFPMS;\n\n        this._tick = (time: number): void =>\n        {\n            this._requestId = null;\n\n            if (this.started)\n            {\n                // Invoke listeners now\n                this.update(time);\n                // Listener side effects may have modified ticker state.\n                if (this.started && this._requestId === null && this._head.next)\n                {\n                    this._requestId = requestAnimationFrame(this._tick);\n                }\n            }\n        };\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If a frame has not already been requested, and if the internal\n     * emitter has listeners, a new frame is requested.\n     * @private\n     */\n    private _requestIfNeeded(): void\n    {\n        if (this._requestId === null && this._head.next)\n        {\n            // ensure callbacks get correct delta\n            this.lastTime = performance.now();\n            this._lastFrame = this.lastTime;\n            this._requestId = requestAnimationFrame(this._tick);\n        }\n    }\n\n    /**\n     * Conditionally cancels a pending animation frame.\n     * @private\n     */\n    private _cancelIfNeeded(): void\n    {\n        if (this._requestId !== null)\n        {\n            cancelAnimationFrame(this._requestId);\n            this._requestId = null;\n        }\n    }\n\n    /**\n     * Conditionally requests a new animation frame.\n     * If the ticker has been started it checks if a frame has not already\n     * been requested, and if the internal emitter has listeners. If these\n     * conditions are met, a new frame is requested. If the ticker has not\n     * been started, but autoStart is `true`, then the ticker starts now,\n     * and continues with the previous conditions to request a new frame.\n     * @private\n     */\n    private _startIfPossible(): void\n    {\n        if (this.started)\n        {\n            this._requestIfNeeded();\n        }\n        else if (this.autoStart)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Register a handler for tick events. Calls continuously unless\n     * it is removed or the ticker is stopped.\n     * @param fn - The listener function to be added for updates\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public add<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority));\n    }\n\n    /**\n     * Add a handler for the tick event which is only execute once.\n     * @param fn - The listener function to be added for one update\n     * @param context - The listener context\n     * @param {number} [priority=UPDATE_PRIORITY.NORMAL] - The priority for emitting\n     * @returns This instance of a ticker\n     */\n    public addOnce<T = any>(fn: TickerCallback<T>, context?: T, priority: number = UPDATE_PRIORITY.NORMAL): this\n    {\n        return this._addListener(new TickerListener(fn, context, priority, true));\n    }\n\n    /**\n     * Internally adds the event handler so that it can be sorted by priority.\n     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run\n     * before the rendering.\n     * @private\n     * @param listener - Current listener being added.\n     * @returns This instance of a ticker\n     */\n    private _addListener(listener: TickerListener): this\n    {\n        // For attaching to head\n        let current = this._head.next;\n        let previous = this._head;\n\n        // Add the first item\n        if (!current)\n        {\n            listener.connect(previous);\n        }\n        else\n        {\n            // Go from highest to lowest priority\n            while (current)\n            {\n                if (listener.priority > current.priority)\n                {\n                    listener.connect(previous);\n                    break;\n                }\n                previous = current;\n                current = current.next;\n            }\n\n            // Not yet connected\n            if (!listener.previous)\n            {\n                listener.connect(previous);\n            }\n        }\n\n        this._startIfPossible();\n\n        return this;\n    }\n\n    /**\n     * Removes any handlers matching the function and context parameters.\n     * If no handlers are left after removing, then it cancels the animation frame.\n     * @param fn - The listener function to be removed\n     * @param context - The listener context to be removed\n     * @returns This instance of a ticker\n     */\n    public remove<T = any>(fn: TickerCallback<T>, context?: T): this\n    {\n        let listener = this._head.next;\n\n        while (listener)\n        {\n            // We found a match, lets remove it\n            // no break to delete all possible matches\n            // incase a listener was added 2+ times\n            if (listener.match(fn, context))\n            {\n                listener = listener.destroy();\n            }\n            else\n            {\n                listener = listener.next;\n            }\n        }\n\n        if (!this._head.next)\n        {\n            this._cancelIfNeeded();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of listeners on this ticker, calculated by walking through linked list\n     * @readonly\n     * @member {number}\n     */\n    get count(): number\n    {\n        if (!this._head)\n        {\n            return 0;\n        }\n\n        let count = 0;\n        let current = this._head;\n\n        while ((current = current.next))\n        {\n            count++;\n        }\n\n        return count;\n    }\n\n    /** Starts the ticker. If the ticker has listeners a new animation frame is requested at this point. */\n    public start(): void\n    {\n        if (!this.started)\n        {\n            this.started = true;\n            this._requestIfNeeded();\n        }\n    }\n\n    /** Stops the ticker. If the ticker has requested an animation frame it is canceled at this point. */\n    public stop(): void\n    {\n        if (this.started)\n        {\n            this.started = false;\n            this._cancelIfNeeded();\n        }\n    }\n\n    /** Destroy the ticker and don't use after this. Calling this method removes all references to internal events. */\n    public destroy(): void\n    {\n        if (!this._protected)\n        {\n            this.stop();\n\n            let listener = this._head.next;\n\n            while (listener)\n            {\n                listener = listener.destroy(true);\n            }\n\n            this._head.destroy();\n            this._head = null;\n        }\n    }\n\n    /**\n     * Triggers an update. An update entails setting the\n     * current {@link ticker.Ticker#elapsedMS|elapsedMS},\n     * the current {@link ticker.Ticker#deltaTime|deltaTime},\n     * invoking all listeners with current deltaTime,\n     * and then finally setting {@link ticker.Ticker#lastTime|lastTime}\n     * with the value of currentTime that was provided.\n     * This method will be called automatically by animation\n     * frame callbacks if the ticker instance has been started\n     * and listeners are added.\n     * @param {number} [currentTime=performance.now()] - the current time of execution\n     */\n    public update(currentTime: number = performance.now()): void\n    {\n        let elapsedMS;\n\n        // If the difference in time is zero or negative, we ignore most of the work done here.\n        // If there is no valid difference, then should be no reason to let anyone know about it.\n        // A zero delta, is exactly that, nothing should update.\n        //\n        // The difference in time can be negative, and no this does not mean time traveling.\n        // This can be the result of a race condition between when an animation frame is requested\n        // on the current JavaScript engine event loop, and when the ticker's start method is invoked\n        // (which invokes the internal _requestIfNeeded method). If a frame is requested before\n        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,\n        // can receive a time argument that can be less than the lastTime value that was set within\n        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.\n        //\n        // This check covers this browser engine timing issue, as well as if consumers pass an invalid\n        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.\n\n        if (currentTime > this.lastTime)\n        {\n            // Save uncapped elapsedMS for measurement\n            elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n            // cap the milliseconds elapsed used for deltaTime\n            if (elapsedMS > this._maxElapsedMS)\n            {\n                elapsedMS = this._maxElapsedMS;\n            }\n\n            elapsedMS *= this.speed;\n\n            // If not enough time has passed, exit the function.\n            // Get ready for next frame by setting _lastFrame, but based on _minElapsedMS\n            // adjustment to ensure a relatively stable interval.\n            if (this._minElapsedMS)\n            {\n                const delta = currentTime - this._lastFrame | 0;\n\n                if (delta < this._minElapsedMS)\n                {\n                    return;\n                }\n\n                this._lastFrame = currentTime - (delta % this._minElapsedMS);\n            }\n\n            this.deltaMS = elapsedMS;\n            this.deltaTime = this.deltaMS * Ticker.targetFPMS;\n\n            // Cache a local reference, in-case ticker is destroyed\n            // during the emit, we can still check for head.next\n            const head = this._head;\n\n            // Invoke listeners added to internal emitter\n            let listener = head.next;\n\n            while (listener)\n            {\n                listener = listener.emit(this);\n            }\n\n            if (!head.next)\n            {\n                this._cancelIfNeeded();\n            }\n        }\n        else\n        {\n            this.deltaTime = this.deltaMS = this.elapsedMS = 0;\n        }\n\n        this.lastTime = currentTime;\n    }\n\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link ticker.Ticker#speed|speed}, which is specific\n     * to scaling {@link ticker.Ticker#deltaTime|deltaTime}.\n     * @member {number}\n     * @readonly\n     */\n    get FPS(): number\n    {\n        return 1000 / this.elapsedMS;\n    }\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This value is used to cap {@link ticker.Ticker#deltaTime|deltaTime},\n     * but does not effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `Ticker.targetFPMS * 1000`.\n     * @member {number}\n     * @default 10\n     */\n    get minFPS(): number\n    {\n        return 1000 / this._maxElapsedMS;\n    }\n\n    set minFPS(fps: number)\n    {\n        // Minimum must be below the maxFPS\n        const minFPS = Math.min(this.maxFPS, fps);\n\n        // Must be at least 0, but below 1 / Ticker.targetFPMS\n        const minFPMS = Math.min(Math.max(0, minFPS) / 1000, Ticker.targetFPMS);\n\n        this._maxElapsedMS = 1 / minFPMS;\n    }\n\n    /**\n     * Manages the minimum amount of milliseconds required to\n     * elapse between invoking {@link ticker.Ticker#update|update}.\n     * This will effect the measured value of {@link ticker.Ticker#FPS|FPS}.\n     * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.\n     * Otherwise it will be at least `minFPS`\n     * @member {number}\n     * @default 0\n     */\n    get maxFPS(): number\n    {\n        if (this._minElapsedMS)\n        {\n            return Math.round(1000 / this._minElapsedMS);\n        }\n\n        return 0;\n    }\n\n    set maxFPS(fps: number)\n    {\n        if (fps === 0)\n        {\n            this._minElapsedMS = 0;\n        }\n        else\n        {\n            // Max must be at least the minFPS\n            const maxFPS = Math.max(this.minFPS, fps);\n\n            this._minElapsedMS = 1 / (maxFPS / 1000);\n        }\n    }\n\n    /**\n     * The shared ticker instance used by {@link AnimatedSprite} and by\n     * {@link VideoResource} to update animation frames / video textures.\n     *\n     * It may also be used by {@link Application} if created with the `sharedTicker` option property set to true.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.\n     * @example\n     * import { Ticker } from 'pixi.js';\n     *\n     * const ticker = Ticker.shared;\n     * // Set this to prevent starting this ticker when listeners are added.\n     * // By default this is true only for the Ticker.shared instance.\n     * ticker.autoStart = false;\n     *\n     * // FYI, call this to ensure the ticker is stopped. It should be stopped\n     * // if you have not attempted to render anything yet.\n     * ticker.stop();\n     *\n     * // Call this when you are ready for a running shared ticker.\n     * ticker.start();\n     * @example\n     * import { autoDetectRenderer, Container } from 'pixi.js';\n     *\n     * // You may use the shared ticker to render...\n     * const renderer = autoDetectRenderer();\n     * const stage = new Container();\n     * document.body.appendChild(renderer.view);\n     * ticker.add((time) => renderer.render(stage));\n     *\n     * // Or you can just update it manually.\n     * ticker.autoStart = false;\n     * ticker.stop();\n     * const animate = (time) => {\n     *     ticker.update(time);\n     *     renderer.render(stage);\n     *     requestAnimationFrame(animate);\n     * };\n     * animate(performance.now());\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get shared(): Ticker\n    {\n        if (!Ticker._shared)\n        {\n            const shared = Ticker._shared = new Ticker();\n\n            shared.autoStart = true;\n            shared._protected = true;\n        }\n\n        return Ticker._shared;\n    }\n\n    /**\n     * The system ticker instance used by {@link BasePrepare} for core timing\n     * functionality that shouldn't usually need to be paused, unlike the `shared`\n     * ticker which drives visual animations and rendering which may want to be paused.\n     *\n     * The property {@link ticker.Ticker#autoStart|autoStart} is set to `true` for this instance.\n     * @member {ticker.Ticker}\n     * @readonly\n     * @static\n     */\n    static get system(): Ticker\n    {\n        if (!Ticker._system)\n        {\n            const system = Ticker._system = new Ticker();\n\n            system.autoStart = true;\n            system._protected = true;\n        }\n\n        return Ticker._system;\n    }\n}\n", "import { type InstructionSet } from '../../rendering/renderers/shared/instructions/InstructionSet';\nimport { type RenderPipe } from '../../rendering/renderers/shared/instructions/RenderPipe';\nimport { type Renderer } from '../../rendering/renderers/types';\nimport { Bounds } from '../container/bounds/Bounds';\nimport { Container, type ContainerOptions } from '../container/Container';\nimport { type IRenderLayer } from '../layers/RenderLayer';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\nexport interface ViewContainerOptions extends ContainerOptions, PixiMixins.ViewContainerOptions {}\nexport interface ViewContainer extends PixiMixins.ViewContainer, Container {}\n\n/**\n * A ViewContainer is a type of container that represents a view.\n * This view can be a Sprite, a Graphics object, or any other object that can be rendered.\n * This class is abstract and should not be used directly.\n * @memberof scene\n */\nexport abstract class ViewContainer extends Container implements View\n{\n    /** @private */\n    public override readonly renderPipeId: string;\n    /** @private */\n    public readonly canBundle = true;\n    /** @private */\n    public override allowChildren = false;\n\n    /** @private */\n    public _roundPixels: 0 | 1 = 0;\n    /** @private */\n    public _lastUsed = -1;\n\n    protected _bounds: Bounds = new Bounds(0, 1, 0, 0);\n    protected _boundsDirty = true;\n\n    /**\n     * The local bounds of the view.\n     * @type {rendering.Bounds}\n     */\n    public get bounds()\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this.updateBounds();\n\n        this._boundsDirty = false;\n\n        return this._bounds;\n    }\n\n    /** @private */\n    protected abstract updateBounds(): void;\n\n    /**\n     * Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor(options: ViewContainerOptions)\n    {\n        super(options);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n        const { x, y } = point;\n\n        return (x >= bounds.minX\n            && x <= bounds.maxX\n            && y >= bounds.minY\n            && y <= bounds.maxY);\n    }\n\n    /** @private */\n    public abstract batched: boolean;\n\n    /** @private */\n    protected onViewUpdate()\n    {\n        this._didViewChangeTick++;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    public override destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        this._bounds = null;\n    }\n\n    public override collectRenderablesSimple(\n        instructionSet: InstructionSet,\n        renderer: Renderer,\n        currentLayer: IRenderLayer,\n    ): void\n    {\n        const { renderPipes, renderableGC } = renderer;\n\n        // TODO add blends in\n        renderPipes.blendMode.setBlendMode(this, this.groupBlendMode, instructionSet);\n\n        const rp = renderPipes as unknown as Record<string, RenderPipe>;\n\n        rp[this.renderPipeId].addRenderable(this, instructionSet);\n\n        renderableGC.addRenderable(this);\n\n        this.didViewUpdate = false;\n\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++)\n        {\n            children[i].collectRenderables(instructionSet, renderer, currentLayer);\n        }\n    }\n}\n", "import { type Adapter } from '../environment/adapter';\n\n/**\n * This is an implementation of the {@link environment.Adapter} interface.\n * It can be used to make Pixi work in the browser.\n * @memberof environment\n * @property {Function} createCanvas - Creates a canvas element of the given size.\n * This canvas is created using the browser's native canvas element.\n * @property {Function} getCanvasRenderingContext2D - Returns a 2D rendering context.\n * @property {Function} getWebGLRenderingContext - Returns a WebGL rendering context.\n * @property {Function} getNavigator - Returns browsers window.navigator\n * @property {Function} getBaseUrl - Returns the current base URL for browser environments this is either\n * the document.baseURI or window.location.href\n * @property {Function} getFontFaceSet - Return the font face set if available\n * @property {Function} fetch - Returns a Response object that has been fetched from the given URL.\n * @property {Function} parseXML - Returns Document object that has been parsed from the given XML string.\n */\nexport const BrowserAdapter = {\n    createCanvas: (width: number, height: number): HTMLCanvasElement =>\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = width;\n        canvas.height = height;\n\n        return canvas;\n    },\n    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,\n    getWebGLRenderingContext: () => WebGLRenderingContext,\n    getNavigator: () => navigator,\n    getBaseUrl: () => (document.baseURI ?? window.location.href),\n    getFontFaceSet: () => document.fonts,\n    fetch: (url: RequestInfo, options?: RequestInit) => fetch(url, options),\n    parseXML: (xml: string) =>\n    {\n        const parser = new DOMParser();\n\n        return parser.parseFromString(xml, 'text/xml');\n    },\n} as Adapter;\n", "import { BrowserAdapter } from '../environment-browser/BrowserAdapter';\n\nimport type { ICanvas } from './canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from './canvas/ICanvasRenderingContext2D';\n\n/**\n * PixiJS supports multiple environments including browsers, Web Workers, and Node.js.\n * The environment is auto-detected by default using the {@link environment.autoDetectEnvironment} function.\n *\n * The {@link environment.Adapter} interface provides a way to abstract away the differences between\n * these environments. PixiJS uses the {@link environment.BrowserAdapter} by default.\n *\n * However you can manually set the environment using the {@link environment.DOMAdapter} singleton, for example to\n * use Pixi within a WebWorker.\n * ```js\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * ```\n * @namespace environment\n */\n\n/**\n * This interface describes all the DOM dependent calls that Pixi makes throughout its codebase.\n * Implementations of this interface can be used to make sure Pixi will work in any environment,\n * such as browser, Web Workers, and Node.js.\n * @memberof environment\n */\nexport interface Adapter\n{\n    /** Returns a canvas object that can be used to create a webgl context. */\n    createCanvas: (width?: number, height?: number) => ICanvas;\n    /** Returns a 2D rendering context. */\n    getCanvasRenderingContext2D: () => { prototype: ICanvasRenderingContext2D; };\n    /** Returns a WebGL rendering context. */\n    getWebGLRenderingContext: () => typeof WebGLRenderingContext;\n    /** Returns a partial implementation of the browsers window.navigator */\n    getNavigator: () => { userAgent: string, gpu: GPU | null };\n    /** Returns the current base URL For browser environments this is either the document.baseURI or window.location.href */\n    getBaseUrl: () => string;\n    /** Return the font face set if available */\n    getFontFaceSet: () => FontFaceSet | null;\n    /** Returns a Response object that has been fetched from the given URL. */\n    fetch: (url: RequestInfo, options?: RequestInit) => Promise<Response>;\n    /** Returns Document object that has been parsed from the given XML string. */\n    parseXML: (xml: string) => Document;\n}\n\nlet currentAdapter: Adapter = BrowserAdapter;\n\n/**\n * The DOMAdapter is a singleton that allows PixiJS to perform DOM operations, such as creating a canvas.\n * This allows PixiJS to be used in any environment, such as a web browser, Web Worker, or Node.js.\n * It uses the {@link environment.Adapter} interface to abstract away the differences between these environments\n * and uses the {@link environment.BrowserAdapter} by default.\n *\n * It has two methods: `get():Adapter` and `set(adapter: Adapter)`.\n *\n * Defaults to the {@link environment.BrowserAdapter}.\n * @example\n * import { DOMAdapter, WebWorkerAdapter } from 'pixi.js';\n *\n * // WebWorkerAdapter is an implementation of the Adapter interface\n * DOMAdapter.set(WebWorkerAdapter);\n *\n * // use the adapter to create a canvas (in this case an OffscreenCanvas)\n * DOMAdapter.get().createCanvas(800, 600);\n * @memberof environment\n */\nexport const DOMAdapter = {\n    /**\n     * Returns the current adapter.\n     * @returns {environment.Adapter} The current adapter.\n     */\n    get(): Adapter\n    {\n        return currentAdapter;\n    },\n    /**\n     * Sets the current adapter.\n     * @param adapter - The new adapter.\n     */\n    set(adapter: Adapter): void\n    {\n        currentAdapter = adapter;\n    },\n};\n", "import type { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../../scene/container/bounds/Bounds';\n\n/**\n * Updates the bounds of a quad (a rectangular area) based on the provided texture and anchor point.\n *\n * This function calculates the minimum and maximum x and y coordinates of the bounds, taking into\n * account the texture's original dimensions and any trimming that may have been applied to it.\n * @param {BoundsData} bounds - The bounds object to be updated. It contains minX, maxX, minY, and maxY properties.\n * @param {ObservablePoint} anchor - The anchor point of the texture, which affects the positioning of the bounds.\n * @param {Texture} texture - The texture whose dimensions and trimming information are used to update the bounds.\n */\nexport function updateQuadBounds(\n    bounds: BoundsData,\n    anchor: ObservablePoint,\n    texture: Texture\n): void\n{\n    const { width, height } = texture.orig;\n    const trim = texture.trim;\n\n    // If the texture has trimming information, adjust the bounds accordingly\n    if (trim)\n    {\n        // Calculate the source width and height from the trim\n        const sourceWidth = trim.width;\n        const sourceHeight = trim.height;\n\n        // Update the bounds using the trim's x and y offsets and the anchor point\n        bounds.minX = trim.x - (anchor._x * width);\n        bounds.maxX = bounds.minX + sourceWidth;\n\n        bounds.minY = trim.y - (anchor._y * height);\n        bounds.maxY = bounds.minY + sourceHeight;\n    }\n    // If there is no trimming, calculate the bounds based solely on the texture's original dimensions\n    else\n    {\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n}\n", "import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { deprecation } from '../../utils/logging/deprecation';\nimport { ViewContainer, type ViewContainerOptions } from '../view/ViewContainer';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends PixiMixins.SpriteOptions, ViewContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\nexport interface Sprite extends PixiMixins.Sprite, ViewContainer {}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends ViewContainer\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public override readonly renderPipeId: string = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n\n    private readonly _visualBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture = Texture.EMPTY, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor)\n        {\n            this.anchor = anchor;\n        }\n        else if (texture.defaultAnchor)\n        {\n            this.anchor = texture.defaultAnchor;\n        }\n\n        this.texture = texture;\n\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width !== undefined) this.width = width;\n        if (height !== undefined) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        const currentTexture = this._texture;\n\n        if (currentTexture === value) return;\n\n        if (currentTexture && currentTexture.dynamic) currentTexture.off('update', this.onViewUpdate, this);\n        if (value.dynamic) value.on('update', this.onViewUpdate, this);\n\n        this._texture = value;\n\n        if (this._width)\n        {\n            this._setWidth(this._width, this._texture.orig.width);\n        }\n\n        if (this._height)\n        {\n            this._setHeight(this._height, this._texture.orig.height);\n        }\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get visualBounds()\n    {\n        updateQuadBounds(this._visualBounds, this._anchor, this._texture);\n\n        return this._visualBounds;\n    }\n\n    /**\n     * @deprecated\n     */\n    get sourceBounds()\n    {\n        // #if _DEBUG\n        deprecation('8.6.1', 'Sprite.sourceBounds is deprecated, use visualBounds instead.');\n        // #endif\n\n        return this.visualBounds;\n    }\n\n    /** @private */\n    protected updateBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const bounds = this._bounds;\n\n        const { width, height } = texture.orig;\n\n        bounds.minX = -anchor._x * width;\n        bounds.maxX = bounds.minX + width;\n\n        bounds.minY = -anchor._y * height;\n        bounds.maxY = bounds.minY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._visualBounds as null) = null;\n        (this._bounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n        this._width = value;\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n        this._height = value;\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        out ||= {} as Size;\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        if (typeof value === 'object')\n        {\n            height = value.height ?? value.width;\n            value = value.width;\n        }\n        else\n        {\n            height ??= value;\n        }\n\n        value !== undefined && this._setWidth(value, this._texture.orig.width);\n        height !== undefined && this._setHeight(height, this._texture.orig.height);\n    }\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\nimport { ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from './TextureSource';\n\nimport type { ICanvas } from '../../../../../environment/canvas/ICanvas';\nimport type { ExtensionMetadata } from '../../../../../extensions/Extensions';\nimport type { TextureSourceOptions } from './TextureSource';\n\nexport interface CanvasSourceOptions extends TextureSourceOptions<ICanvas>\n{\n    /**\n     * Should the canvas be resized to preserve its screen width and height regardless\n     * of the resolution of the renderer, this is only supported for HTMLCanvasElement\n     * and will be ignored if the canvas is an OffscreenCanvas.\n     */\n    autoDensity?: boolean;\n    /** if true, this canvas will be set up to be transparent where possible */\n    transparent?: boolean;\n}\n\nexport class CanvasSource extends TextureSource<ICanvas>\n{\n    public static extension: ExtensionMetadata = ExtensionType.TextureSource;\n\n    public uploadMethodId = 'image';\n    public autoDensity: boolean;\n    public transparent: boolean;\n\n    private _context2D: CanvasRenderingContext2D;\n\n    constructor(options: CanvasSourceOptions)\n    {\n        if (!options.resource)\n        {\n            options.resource = DOMAdapter.get().createCanvas();\n        }\n\n        if (!options.width)\n        {\n            options.width = options.resource.width;\n\n            if (!options.autoDensity)\n            {\n                options.width /= options.resolution;\n            }\n        }\n\n        if (!options.height)\n        {\n            options.height = options.resource.height;\n\n            if (!options.autoDensity)\n            {\n                options.height /= options.resolution;\n            }\n        }\n\n        super(options);\n\n        this.autoDensity = options.autoDensity;\n\n        this.resizeCanvas();\n\n        this.transparent = !!options.transparent;\n    }\n\n    public resizeCanvas()\n    {\n        if (this.autoDensity && 'style' in this.resource)\n        {\n            this.resource.style.width = `${this.width}px`;\n            this.resource.style.height = `${this.height}px`;\n        }\n\n        // only resize if wee need to, as this clears the canvas (even if values are set to the same)\n        if (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight)\n        {\n            this.resource.width = this.pixelWidth;\n            this.resource.height = this.pixelHeight;\n        }\n    }\n\n    public resize(width = this.width, height = this.height, resolution = this._resolution): boolean\n    {\n        const didResize = super.resize(width, height, resolution);\n\n        if (didResize)\n        {\n            this.resizeCanvas();\n        }\n\n        return didResize;\n    }\n\n    public static test(resource: any): resource is ICanvas\n    {\n        return (globalThis.HTMLCanvasElement && resource instanceof HTMLCanvasElement)\n        || (globalThis.OffscreenCanvas && resource instanceof OffscreenCanvas);\n    }\n\n    /**\n     * Returns the 2D rendering context for the canvas.\n     * Caches the context after creating it.\n     * @returns The 2D rendering context of the canvas.\n     */\n    get context2D(): CanvasRenderingContext2D\n    {\n        return this._context2D || (this._context2D = this.resource.getContext('2d') as CanvasRenderingContext2D);\n    }\n}\n", "import type { BindResource } from './BindResource';\n\n/**\n * A bind group is a collection of resources that are bound together for use by a shader.\n * They are essentially a wrapper for the WebGPU BindGroup class. But with the added bonus\n * that WebGL can also work with them.\n * @see https://gpuweb.github.io/gpuweb/#dictdef-gpubindgroupdescriptor\n * @example\n * // Create a bind group with a single texture and sampler\n * const bindGroup = new BindGroup({\n *    uTexture: texture.source,\n *    uTexture: texture.style,\n * });\n *\n * Bind groups resources must implement the {@link BindResource} interface.\n * The following resources are supported:\n * - {@link TextureSource}\n * - {@link TextureStyle}\n * - {@link Buffer}\n * - {@link BufferResource}\n * - {@link UniformGroup}\n *\n * The keys in the bind group must correspond to the names of the resources in the GPU program.\n *\n * This bind group class will also watch for changes in its resources ensuring that the changes\n * are reflected in the WebGPU BindGroup.\n * @memberof rendering\n */\nexport class BindGroup\n{\n    /** The resources that are bound together for use by a shader. */\n    public resources: Record<string, BindResource> = Object.create(null);\n    /**\n     * a key used internally to match it up to a WebGPU Bindgroup\n     * @internal\n     * @ignore\n     */\n    public _key: string;\n    private _dirty = true;\n\n    /**\n     * Create a new instance eof the Bind Group.\n     * @param resources - The resources that are bound together for use by a shader.\n     */\n    constructor(resources?: Record<string, BindResource>)\n    {\n        let index = 0;\n\n        for (const i in resources)\n        {\n            const resource: BindResource = resources[i];\n\n            this.setResource(resource, index++);\n        }\n\n        this._updateKey();\n    }\n\n    /**\n     * Updates the key if its flagged as dirty. This is used internally to\n     * match this bind group to a WebGPU BindGroup.\n     * @internal\n     * @ignore\n     */\n    public _updateKey(): void\n    {\n        if (!this._dirty) return;\n\n        this._dirty = false;\n\n        const keyParts = [];\n        let index = 0;\n\n        // TODO - lets use big ints instead of strings...\n        for (const i in this.resources)\n        {\n            // TODO make this consistent...\n            keyParts[index++] = this.resources[i]._resourceId;\n        }\n\n        this._key = keyParts.join('|');\n    }\n\n    /**\n     * Set a resource at a given index. this function will\n     * ensure that listeners will be removed from the current resource\n     * and added to the new resource.\n     * @param resource - The resource to set.\n     * @param index - The index to set the resource at.\n     */\n    public setResource(resource: BindResource, index: number): void\n    {\n        const currentResource = this.resources[index];\n\n        if (resource === currentResource) return;\n\n        if (currentResource)\n        {\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        resource.on?.('change', this.onResourceChange, this);\n\n        this.resources[index] = resource;\n        this._dirty = true;\n    }\n\n    /**\n     * Returns the resource at the current specified index.\n     * @param index - The index of the resource to get.\n     * @returns - The resource at the specified index.\n     */\n    public getResource(index: number): BindResource\n    {\n        return this.resources[index];\n    }\n\n    /**\n     * Used internally to 'touch' each resource, to ensure that the GC\n     * knows that all resources in this bind group are still being used.\n     * @param tick - The current tick.\n     * @internal\n     * @ignore\n     */\n    public _touch(tick: number)\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            resources[i]._touched = tick;\n        }\n    }\n\n    /** Destroys this bind group and removes all listeners. */\n    public destroy()\n    {\n        const resources = this.resources;\n\n        for (const i in resources)\n        {\n            const resource = resources[i];\n\n            resource.off?.('change', this.onResourceChange, this);\n        }\n\n        this.resources = null;\n    }\n\n    protected onResourceChange(resource: BindResource)\n    {\n        this._dirty = true;\n\n        // check if a resource has been destroyed, if it has then we need to destroy this bind group\n        // using this bind group with a destroyed resource will cause the renderer to explode :)\n        if (resource.destroyed)\n        {\n            // free up the resource\n            const resources = this.resources;\n\n            for (const i in resources)\n            {\n                if (resources[i] === resource)\n                {\n                    resources[i] = null;\n                }\n            }\n        }\n        else\n        {\n            this._updateKey();\n        }\n    }\n}\n", "import { DOMAdapter } from '../../../../../environment/adapter';\n\nimport type { GlRenderingContext } from '../../context/GlRenderingContext';\n\nlet context: GlRenderingContext;\n\n/**\n * returns a little WebGL context to use for program inspection.\n * @static\n * @private\n * @returns {WebGLRenderingContext} a gl context to test with\n */\nexport function getTestContext(): GlRenderingContext\n{\n    if (!context || context?.isContextLost())\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        context = canvas.getContext('webgl', {}) as GlRenderingContext;\n    }\n\n    return context;\n}\n", "import type { GlRenderingContext } from '../../../renderers/gl/context/GlRenderingContext';\n\nconst fragTemplate = [\n    'precision mediump float;',\n    'void main(void){',\n    'float test = 0.1;',\n    '%forloop%',\n    'gl_FragColor = vec4(0.0);',\n    '}',\n].join('\\n');\n\nfunction generateIfTestSrc(maxIfs: number): string\n{\n    let src = '';\n\n    for (let i = 0; i < maxIfs; ++i)\n    {\n        if (i > 0)\n        {\n            src += '\\nelse ';\n        }\n\n        if (i < maxIfs - 1)\n        {\n            src += `if(test == ${i}.0){}`;\n        }\n    }\n\n    return src;\n}\n\nexport function checkMaxIfStatementsInShader(maxIfs: number, gl: GlRenderingContext): number\n{\n    if (maxIfs === 0)\n    {\n        throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');\n    }\n\n    const shader = gl.createShader(gl.FRAGMENT_SHADER);\n\n    try\n    {\n        while (true)\n        {\n            const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n\n            gl.shaderSource(shader, fragmentSrc);\n            gl.compileShader(shader);\n\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))\n            {\n                maxIfs = (maxIfs / 2) | 0;\n            }\n            else\n            {\n                // valid!\n                break;\n            }\n        }\n    }\n    finally\n    {\n        gl.deleteShader(shader);\n    }\n\n    return maxIfs;\n}\n", "import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader';\n\nlet maxTexturesPerBatchCache: number | null = null;\n\n/**\n * Returns the maximum number of textures that can be batched. This uses WebGL1's `MAX_TEXTURE_IMAGE_UNITS`.\n * The response for this is that to get this info via WebGPU, we would need to make a context, which\n * would make this function async, and we want to avoid that.\n * @private\n * @returns {number} The maximum number of textures that can be batched\n */\nexport function getMaxTexturesPerBatch(): number\n{\n    if (maxTexturesPerBatchCache) return maxTexturesPerBatchCache;\n\n    const gl = getTestContext();\n\n    // step 1: first check max textures the GPU can handle.\n    maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n    // step 2: check the maximum number of if statements the shader can have too..\n    maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n        maxTexturesPerBatchCache, gl);\n\n    gl.getExtension('WEBGL_lose_context')?.loseContext();\n\n    return maxTexturesPerBatchCache;\n}\n", "type TypedArray = Float32Array | Uint32Array | Int32Array | Uint8Array;\n\n/**\n * Flexible wrapper around `ArrayBuffer` that also provides typed array views on demand.\n * @memberof utils\n */\nexport class ViewableBuffer\n{\n    /** The size of the buffer in bytes. */\n    public size: number;\n\n    /** Underlying `ArrayBuffer` that holds all the data and is of capacity `this.size`. */\n    public rawBinaryData: ArrayBuffer;\n\n    /** View on the raw binary data as a `Uint32Array`. */\n    public uint32View: Uint32Array;\n\n    /** View on the raw binary data as a `Float32Array`. */\n    public float32View: Float32Array;\n    public uint16View: Uint16Array;\n\n    private _int8View: Int8Array;\n    private _uint8View: Uint8Array;\n    private _int16View: Int16Array;\n    private _int32View: Int32Array;\n    private _float64Array: Float64Array;\n    private _bigUint64Array: BigUint64Array;\n\n    /**\n     * @param length - The size of the buffer in bytes.\n     */\n    constructor(length: number);\n\n    /**\n     * @param arrayBuffer - The source array buffer.\n     */\n    constructor(arrayBuffer: ArrayBuffer);\n\n    constructor(sizeOrBuffer: number | ArrayBuffer | Uint8Array)\n    {\n        if (typeof sizeOrBuffer === 'number')\n        {\n            this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n        }\n        else if (sizeOrBuffer instanceof Uint8Array)\n        {\n            this.rawBinaryData = sizeOrBuffer.buffer;\n        }\n        else\n        {\n            this.rawBinaryData = sizeOrBuffer;\n        }\n\n        this.uint32View = new Uint32Array(this.rawBinaryData);\n        this.float32View = new Float32Array(this.rawBinaryData);\n\n        this.size = this.rawBinaryData.byteLength;\n    }\n\n    /** View on the raw binary data as a `Int8Array`. */\n    get int8View(): Int8Array\n    {\n        if (!this._int8View)\n        {\n            this._int8View = new Int8Array(this.rawBinaryData);\n        }\n\n        return this._int8View;\n    }\n\n    /** View on the raw binary data as a `Uint8Array`. */\n    get uint8View(): Uint8Array\n    {\n        if (!this._uint8View)\n        {\n            this._uint8View = new Uint8Array(this.rawBinaryData);\n        }\n\n        return this._uint8View;\n    }\n\n    /**  View on the raw binary data as a `Int16Array`. */\n    get int16View(): Int16Array\n    {\n        if (!this._int16View)\n        {\n            this._int16View = new Int16Array(this.rawBinaryData);\n        }\n\n        return this._int16View;\n    }\n\n    /** View on the raw binary data as a `Int32Array`. */\n    get int32View(): Int32Array\n    {\n        if (!this._int32View)\n        {\n            this._int32View = new Int32Array(this.rawBinaryData);\n        }\n\n        return this._int32View;\n    }\n\n    /** View on the raw binary data as a `Float64Array`. */\n    get float64View(): Float64Array\n    {\n        if (!this._float64Array)\n        {\n            this._float64Array = new Float64Array(this.rawBinaryData);\n        }\n\n        return this._float64Array;\n    }\n\n    /** View on the raw binary data as a `BigUint64Array`. */\n    get bigUint64View(): BigUint64Array\n    {\n        if (!this._bigUint64Array)\n        {\n            this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n        }\n\n        return this._bigUint64Array;\n    }\n\n    /**\n     * Returns the view of the given type.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *    `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - typed array of given type\n     */\n    public view(type: string): TypedArray\n    {\n        return (this as any)[`${type}View`];\n    }\n\n    /** Destroys all buffer references. Do not use after calling this. */\n    public destroy(): void\n    {\n        this.rawBinaryData = null;\n        this._int8View = null;\n        this._uint8View = null;\n        this._int16View = null;\n        this.uint16View = null;\n        this._int32View = null;\n        this.uint32View = null;\n        this.float32View = null;\n    }\n\n    /**\n     * Returns the size of the given type in bytes.\n     * @param type - One of `int8`, `uint8`, `int16`,\n     *   `uint16`, `int32`, `uint32`, and `float32`.\n     * @returns - size of the type in bytes\n     */\n    public static sizeOf(type: string): number\n    {\n        switch (type)\n        {\n            case 'int8':\n            case 'uint8':\n                return 1;\n            case 'int16':\n            case 'uint16':\n                return 2;\n            case 'int32':\n            case 'uint32':\n            case 'float32':\n                return 4;\n            default:\n                throw new Error(`${type} isn't a valid view type`);\n        }\n    }\n}\n", "/**\n * Copies from one buffer to another.\n * This is an optimised function that will use `Float64Array` window.\n * This means it can copy twice as fast!\n * @param sourceBuffer - the array buffer to copy from\n * @param destinationBuffer - the array buffer to copy to\n * @private\n */\nexport function fastCopy(sourceBuffer: ArrayBuffer, destinationBuffer: ArrayBuffer): void\n{\n    const lengthDouble = (sourceBuffer.byteLength / 8) | 0;\n\n    const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n    const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n\n    // Use set for faster copying\n    destinationFloat64View.set(sourceFloat64View);\n\n    // copying over the remaining bytes\n    const remainingBytes = sourceBuffer.byteLength - (lengthDouble * 8);\n\n    if (remainingBytes > 0)\n    {\n        const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n        const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n\n        // Direct copy for remaining bytes\n        destinationUint8View.set(sourceUint8View);\n    }\n}\n", "/**\n * Various blend modes supported by Pixi\n * @memberof filters\n */\nexport type BLEND_MODES = 'inherit'\n| 'normal'\n| 'add'\n| 'multiply'\n| 'screen'\n| 'darken'\n| 'lighten'\n| 'erase'\n| 'color-dodge'\n| 'color-burn'\n| 'linear-burn'\n| 'linear-dodge'\n| 'linear-light'\n| 'hard-light'\n| 'soft-light'\n| 'pin-light'\n| 'difference'\n| 'exclusion'\n| 'overlay'\n// | 'hue'\n| 'saturation'\n| 'color'\n| 'luminosity'\n| 'normal-npm'\n| 'add-npm'\n| 'screen-npm'\n| 'none'\n| 'subtract'\n| 'divide'\n| 'vivid-light'\n| 'hard-mix'\n| 'negation'\n| 'min'\n| 'max';\n\n/**\n * The map of blend modes supported by Pixi\n * @memberof rendering\n */\nexport const BLEND_TO_NPM = {\n    normal: 'normal-npm',\n    add: 'add-npm',\n    screen: 'screen-npm',\n};\n\n/**\n * The stencil operation to perform when using the stencil buffer\n * @memberof rendering\n */\nexport enum STENCIL_MODES\n{\n    DISABLED = 0,\n    RENDERING_MASK_ADD = 1,\n    MASK_ACTIVE = 2,\n    INVERSE_MASK_ACTIVE = 3,\n    RENDERING_MASK_REMOVE = 4,\n    NONE = 5,\n}\n\n/**\n * The culling mode to use. It can be either `none`, `front` or `back`.\n * @memberof rendering\n */\nexport type CULL_MODES = 'none' | 'back' | 'front';\n\n", "import { type BLEND_MODES, BLEND_TO_NPM } from './const';\n\nimport type { TextureSource } from '../texture/sources/TextureSource';\n\n/**\n * Adjusts a blend mode for the current alpha mode. Returns the blend mode that works with that format.\n * eg 'normal' blend mode will return 'normal-npm' when rendering with premultiplied alpha.\n * and 'normal' if the texture is already premultiplied (the default)\n * @param blendMode - The blend mode to get the adjusted blend mode for.\n * @param textureSource - The texture to test the format of.\n * @returns - the blend mode that should be used to render this texture correctly based on its alphaMode\n */\nexport function getAdjustedBlendModeBlend(blendMode: BLEND_MODES, textureSource: TextureSource): BLEND_MODES\n{\n    if (textureSource.alphaMode === 'no-premultiply-alpha')\n    {\n        return (BLEND_TO_NPM[blendMode as keyof typeof BLEND_TO_NPM] || blendMode) as BLEND_MODES;\n    }\n\n    return blendMode;\n}\n", "import type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\n/**\n * Used by the batcher to build texture batches. Holds list of textures and their respective locations.\n * @memberof rendering\n */\nexport class BatchTextureArray\n{\n    /** Inside textures array. */\n    public textures: TextureSource[];\n\n    /** Respective locations for textures. */\n    public ids: Record<number, number> = Object.create(null);\n\n    /** Number of filled elements. */\n    public count: number;\n\n    constructor()\n    {\n        this.textures = [];\n        this.count = 0;\n    }\n\n    /** Clear the textures and their locations. */\n    public clear(): void\n    {\n        for (let i = 0; i < this.count; i++)\n        {\n            const t = this.textures[i];\n\n            this.textures[i] = null;\n            this.ids[t.uid] = null;\n        }\n\n        this.count = 0;\n    }\n}\n", "import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\nimport { BatchTextureArray } from './BatchTextureArray';\n\nimport type { BoundsData } from '../../../scene/container/bounds/Bounds';\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { Topology } from '../../renderers/shared/geometry/const';\nimport type { Geometry, IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray = new BatchTextureArray();\n\n    public blendMode: BLEND_MODES = 'normal';\n    public topology: Topology = 'triangle-strip';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\n// inlined pool for SPEEEEEEEEEED :D\nconst batchPool: Batch[] = [];\nlet batchPoolIndex = 0;\n\nfunction getBatchFromPool()\n{\n    return batchPoolIndex > 0 ? batchPool[--batchPoolIndex] : new Batch();\n}\n\nfunction returnBatchToPool(batch: Batch)\n{\n    batchPool[batchPoolIndex++] = batch;\n}\n\n/**\n * Represents an element that can be batched for rendering.\n * @interface\n * @memberof rendering\n */\nexport interface BatchableElement\n{\n    /**\n     * The name of the batcher to use. Must be registered.\n     * @type {string}\n     */\n    batcherName: string;\n\n    /**\n     * The texture to be used for rendering.\n     * @type {Texture}\n     */\n    texture: Texture;\n\n    /**\n     * The blend mode to be applied.\n     * @type {BLEND_MODES}\n     */\n    blendMode: BLEND_MODES;\n\n    /**\n     * The size of the index data.\n     * @type {number}\n     */\n    indexSize: number;\n\n    /**\n     * The size of the attribute data.\n     * @type {number}\n     */\n    attributeSize: number;\n\n    /**\n     * The topology to be used for rendering.\n     * @type {Topology}\n     */\n    topology: Topology\n\n    /**\n     * Whether the element should be packed as a quad for better performance.\n     * @type {boolean}\n     */\n    packAsQuad: boolean;\n\n    /**\n     * The texture ID, stored for efficient updating.\n     * @type {number}\n     * @private\n     */\n    _textureId: number;\n\n    /**\n     * The starting position in the attribute buffer.\n     * @type {number}\n     * @private\n     */\n    _attributeStart: number;\n\n    /**\n     * The starting position in the index buffer.\n     * @type {number}\n     * @private\n     */\n    _indexStart: number;\n\n    /**\n     * Reference to the batcher.\n     * @type {Batcher}\n     * @private\n     */\n    _batcher: Batcher;\n\n    /**\n     * Reference to the batch.\n     * @type {Batch}\n     * @private\n     */\n    _batch: Batch;\n\n}\n\n/**\n * Represents a batchable quad element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableQuadElement extends BatchableElement\n{\n    /**\n     * Indicates that this element should be packed as a quad.\n     * @type {true}\n     */\n    packAsQuad: true;\n\n    /**\n     * The size of the attribute data for this quad element.\n     * @type {4}\n     */\n    attributeSize: 4;\n\n    /**\n     * The size of the index data for this quad element.\n     * @type {6}\n     */\n    indexSize: 6;\n\n    /**\n     * The bounds data for this quad element.\n     * @type {BoundsData}\n     */\n    bounds: BoundsData;\n}\n\n/**\n * Represents a batchable mesh element.\n * @extends BatchableElement\n * @memberof rendering\n */\nexport interface BatchableMeshElement extends BatchableElement\n{\n    /**\n     * The UV coordinates of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    uvs: number[] | Float32Array;\n\n    /**\n     * The vertex positions of the mesh.\n     * @type {number[] | Float32Array}\n     */\n    positions: number[] | Float32Array;\n\n    /**\n     * The indices of the mesh.\n     * @type {number[] | Uint16Array | Uint32Array}\n     */\n    indices: number[] | Uint16Array | Uint32Array;\n\n    /**\n     * The offset in the index buffer.\n     * @type {number}\n     */\n    indexOffset: number;\n\n    /**\n     * The offset in the attribute buffer.\n     * @type {number}\n     */\n    attributeOffset: number;\n\n    /**\n     * Indicates that this element should not be packed as a quad.\n     * @type {false}\n     */\n    packAsQuad: false;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @memberof rendering\n */\nexport interface BatcherOptions\n{\n    /** The maximum number of textures per batch. */\n    maxTextures?: number;\n    attributesInitialSize?: number;\n    indicesInitialSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * It is an abstract class that must be extended. see DefaultBatcher for an example.\n * @memberof rendering\n */\nexport abstract class Batcher\n{\n    public static defaultOptions: Partial<BatcherOptions> = {\n        maxTextures: null,\n        attributesInitialSize: 4,\n        indicesInitialSize: 6,\n    };\n\n    /** unique id for this batcher */\n    public readonly uid: number = uid('batcher');\n\n    /** The buffer containing attribute data for all elements in the batch. */\n    public attributeBuffer: ViewableBuffer;\n\n    /** The buffer containing index data for all elements in the batch. */\n    public indexBuffer: IndexBufferArray;\n\n    /** The current size of the attribute data in the batch. */\n    public attributeSize: number;\n\n    /** The current size of the index data in the batch. */\n    public indexSize: number;\n\n    /** The total number of elements currently in the batch. */\n    public elementSize: number;\n\n    /** The starting index of elements in the current batch. */\n    public elementStart: number;\n\n    /** Indicates whether the batch data has been modified and needs updating. */\n    public dirty = true;\n\n    /** The current index of the batch being processed. */\n    public batchIndex = 0;\n\n    /** An array of all batches created during the current rendering process. */\n    public batches: Batch[] = [];\n\n    private _elements: BatchableElement[] = [];\n\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    /** The maximum number of textures per batch. */\n    public readonly maxTextures: number;\n\n    /** The name of the batcher. Must be implemented by subclasses. */\n    public abstract name: string;\n    /** The vertex size of the batcher. Must be implemented by subclasses. */\n    protected abstract vertexSize: number;\n\n    /** The geometry used by this batcher. Must be implemented by subclasses. */\n    public abstract geometry: Geometry;\n\n    /**\n     * The shader used by this batcher. Must be implemented by subclasses.\n     * this can be shared by multiple batchers of the same type.\n     */\n    public abstract shader: Shader;\n\n    /**\n     * Packs the attributes of a BatchableMeshElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packAttributes(\n        element: BatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    /**\n     * Packs the attributes of a BatchableQuadElement into the provided views.\n     * Must be implemented by subclasses.\n     * @param element - The BatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public abstract packQuadAttributes(\n        element: BatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    ): void;\n\n    constructor(options: BatcherOptions = {})\n    {\n        Batcher.defaultOptions.maxTextures = Batcher.defaultOptions.maxTextures ?? getMaxTexturesPerBatch();\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { maxTextures, attributesInitialSize, indicesInitialSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(attributesInitialSize * 4);\n\n        this.indexBuffer = new Uint16Array(indicesInitialSize);\n\n        this.maxTextures = maxTextures;\n    }\n\n    public begin()\n    {\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n\n        for (let i = 0; i < this.batchIndex; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batchIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableElement)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject._indexStart = this.indexSize;\n        batchableObject._attributeStart = this.attributeSize;\n        batchableObject._batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.attributeSize) * this.vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableElement, texture: Texture): boolean\n    {\n        const textureId = batchableObject._batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject._textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableElement)\n    {\n        this.dirty = true;\n\n        const attributeBuffer = this.attributeBuffer;\n\n        if (batchableObject.packAsQuad)\n        {\n            this.packQuadAttributes(\n                batchableObject as BatchableQuadElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n        else\n        {\n            this.packAttributes(\n                batchableObject as BatchableMeshElement,\n                attributeBuffer.float32View,\n                attributeBuffer.uint32View,\n                batchableObject._attributeStart, batchableObject._textureId);\n        }\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        const elements = this._elements;\n\n        // length 0??!! (we broke without adding anything)\n        if (!elements[this.elementStart]) return;\n\n        let batch = getBatchFromPool();\n        let textureBatch = batch.textures;\n\n        textureBatch.clear();\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n        let topology = firstElement.topology;\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const indexBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n\n        const maxTextures = this.maxTextures;\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const breakRequired = blendMode !== adjustedBlendMode || topology !== element.topology;\n\n            if (source._batchTick === BATCH_TICK && !breakRequired)\n            {\n                element._textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n\n                if (element.packAsQuad)\n                {\n                    this.packQuadAttributes(\n                        element as BatchableQuadElement,\n                        f32, u32,\n                        element._attributeStart, element._textureId\n                    );\n                    this.packQuadIndex(\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n                else\n                {\n                    this.packAttributes(\n                        element as BatchableMeshElement,\n                        f32, u32,\n                        element._attributeStart,\n                        element._textureId\n                    );\n                    this.packIndex(\n                        element as BatchableMeshElement,\n                        indexBuffer,\n                        element._indexStart,\n                        element._attributeStart / this.vertexSize\n                    );\n                }\n\n                element._batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= maxTextures || breakRequired)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    topology,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n                topology = element.topology;\n\n                batch = getBatchFromPool();\n                textureBatch = batch.textures;\n                textureBatch.clear();\n\n                ++BATCH_TICK;\n            }\n\n            element._textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element._batch = batch;\n\n            size += element.indexSize;\n\n            if (element.packAsQuad)\n            {\n                this.packQuadAttributes(\n                    element as BatchableQuadElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n                this.packQuadIndex(\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n            else\n            {\n                this.packAttributes(element as BatchableMeshElement,\n                    f32, u32,\n                    element._attributeStart, element._textureId\n                );\n\n                this.packIndex(\n                    element as BatchableMeshElement,\n                    indexBuffer,\n                    element._indexStart,\n                    element._attributeStart / this.vertexSize\n                );\n            }\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                topology,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        topology: Topology,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.bindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n        batch.topology = topology;\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        // track for returning later!\n        this.batches[this.batchIndex++] = batch;\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public packQuadIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        indexBuffer[index] = indicesOffset + 0;\n        indexBuffer[index + 1] = indicesOffset + 1;\n        indexBuffer[index + 2] = indicesOffset + 2;\n\n        indexBuffer[index + 3] = indicesOffset + 0;\n        indexBuffer[index + 4] = indicesOffset + 2;\n        indexBuffer[index + 5] = indicesOffset + 3;\n    }\n\n    public packIndex(element: BatchableMeshElement, indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = element.indices;\n        const size = element.indexSize;\n        const indexOffset = element.indexOffset;\n        const attributeOffset = element.attributeOffset;\n\n        for (let i = 0; i < size; i++)\n        {\n            indexBuffer[index++] = indicesOffset + indices[i + indexOffset] - attributeOffset;\n        }\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            returnBatchToPool(this.batches[i]);\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i]._batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n", "/**\n * Buffer usage flags. they can be combined using the bitwise OR operator\n * eg : BufferUsage.VERTEX | BufferUsage.INDEX\n * @memberof rendering\n */\nexport enum BufferUsage\n{\n    /**\n     * The buffer can be mapped for reading. (Example: calling mapAsync() with GPUMapMode.READ)\n     * May only be combined with COPY_DST.\n     */\n    MAP_READ = 0x0001,\n    /**\n     * The buffer can be mapped for writing. (Example: calling mapAsync() with GPUMapMode.WRITE)\n     * May only be combined with COPY_SRC.\n     */\n    MAP_WRITE = 0x0002,\n    /**\n     * The buffer can be used as the source of a copy operation.\n     * (Examples: as the source argument of a copyBufferToBuffer() or copyBufferToTexture() call.)\n     */\n    COPY_SRC = 0x0004,\n    /**\n     * The buffer can be used as the destination of a copy or write operation.\n     * (Examples: as the destination argument of a copyBufferToBuffer() or\n     * copyTextureToBuffer() call, or as the target of a writeBuffer() call.)\n     */\n    COPY_DST = 0x0008,\n    /** The buffer can be used as an index buffer. (Example: passed to setIndexBuffer().) */\n    INDEX = 0x0010,\n    /** The buffer can be used as a vertex buffer. (Example: passed to setVertexBuffer().) */\n    VERTEX = 0x0020,\n    /**\n     * The buffer can be used as a uniform buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"uniform\".)\n     */\n    UNIFORM = 0x0040,\n    /**\n     * The buffer can be used as a storage buffer.\n     * (Example: as a bind group entry for a GPUBufferBindingLayout with a buffer.type of \"storage\" or \"read-only-storage\".)\n     */\n    STORAGE = 0x0080,\n    /**\n     * The buffer can be used as to store indirect command arguments.\n     * (Examples: as the indirectBuffer argument of a drawIndirect() or dispatchWorkgroupsIndirect() call.)\n     */\n    INDIRECT = 0x0100,\n    /**\n     * The buffer can be used to capture query results.\n     * (Example: as the destination argument of a resolveQuerySet() call.)\n     */\n    QUERY_RESOLVE = 0x0200,\n    /** the buffer will not be updated frequently */\n    STATIC = 0x0400\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { BufferUsage } from './const';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\n\n/** All the various typed arrays that exist in js */\n// eslint-disable-next-line max-len\nexport type TypedArray = Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array;\n\n/** Options for creating a buffer */\nexport interface BufferOptions\n{\n    /**\n     * the data to initialize the buffer with, this can be a typed array,\n     * or a regular number array. If it is a number array, it will be converted to a Float32Array\n     */\n    data?: TypedArray | number[];\n    /** the size of the buffer in bytes, if not supplied, it will be inferred from the data */\n    size?: number;\n    /** the usage of the buffer, see {@link rendering.BufferUsage} */\n    usage: number;\n    /** a label for the buffer, this is useful for debugging */\n    label?: string;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    shrinkToFit?: boolean;\n}\n\nexport interface BufferDescriptor\n{\n    label?: string;\n    size: GPUSize64;\n    usage: BufferUsage;\n    mappedAtCreation?: boolean;\n}\n\n/**\n * A wrapper for a WebGPU/WebGL Buffer.\n * In PixiJS, the Buffer class is used to manage the data that is sent to the GPU rendering pipeline.\n * It abstracts away the underlying GPU buffer and provides an interface for uploading typed arrays or other data to the GPU,\n * They are used in the following places:\n * <br><br>\n * .1. {@link Geometry} as attribute data or index data for geometry\n * <br>\n * .2. {@link UniformGroup} as an underlying buffer for uniform data\n * <br>\n * .3. {@link BufferResource} as an underlying part of a buffer used directly by the GPU program\n * <br>\n *\n * It is important to note that you must provide a usage type when creating a buffer. This is because\n * the underlying GPU buffer needs to know how it will be used. For example, if you are creating a buffer\n * to hold vertex data, you would use `BufferUsage.VERTEX`. This will tell the GPU that this buffer will be\n * used as a vertex buffer. This is important because it will affect how you can use the buffer.\n *\n * Buffers are updated by calling the {@link Buffer.update} method. This immediately updates the buffer on the GPU.\n * Be mindful of calling this more often than you need to. It is recommended to update buffers only when needed.\n *\n * In WebGPU, a GPU buffer cannot resized. This limitation is abstracted away, but know that resizing a buffer means\n * creating a brand new one and destroying the old, so it is best to limit this if possible.\n * @example\n *\n * const buffer = new Buffer({\n *     data: new Float32Array([1, 2, 3, 4]),\n *     usage: BufferUsage.VERTEX,\n * });\n * @memberof rendering\n */\nexport class Buffer extends EventEmitter<{\n    change: BindResource,\n    update: Buffer,\n    destroy: Buffer,\n}> implements BindResource\n{\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('buffer');\n\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    public readonly _resourceType = 'buffer';\n\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    public _resourceId = uid('resource');\n\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    public _touched = 0;\n\n    /**\n     * a description of the buffer and how it should be set up on the GPU\n     * @internal\n     * @ignore\n     */\n    public readonly descriptor: BufferDescriptor;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateID = 1;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _updateSize: number;\n\n    private _data: TypedArray;\n\n    private _dataInt32: Int32Array = null;\n\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    public shrinkToFit = true;\n\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    public destroyed = false;\n\n    /**\n     * Creates a new Buffer with the given options\n     * @param options - the options for the buffer\n     */\n    constructor(options: BufferOptions)\n    {\n        let { data, size } = options;\n        const { usage, label, shrinkToFit } = options;\n\n        super();\n\n        if (data instanceof Array)\n        {\n            data = new Float32Array(data as number[]);\n        }\n\n        this._data = data as TypedArray;\n\n        size ??= (data as TypedArray)?.byteLength;\n\n        const mappedAtCreation = !!data;\n\n        this.descriptor = {\n            size,\n            usage,\n            mappedAtCreation,\n            label,\n        };\n\n        this.shrinkToFit = shrinkToFit ?? true;\n    }\n\n    /** the data in the buffer */\n    get data()\n    {\n        return this._data;\n    }\n\n    set data(value: TypedArray)\n    {\n        this.setDataWithSize(value, value.length, true);\n    }\n\n    get dataInt32()\n    {\n        if (!this._dataInt32)\n        {\n            this._dataInt32 = new Int32Array((this.data as any).buffer);\n        }\n\n        return this._dataInt32;\n    }\n\n    /** whether the buffer is static or not */\n    get static()\n    {\n        return !!(this.descriptor.usage & BufferUsage.STATIC);\n    }\n\n    set static(value: boolean)\n    {\n        if (value)\n        {\n            this.descriptor.usage |= BufferUsage.STATIC;\n        }\n        else\n        {\n            this.descriptor.usage &= ~BufferUsage.STATIC;\n        }\n    }\n\n    /**\n     * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n     * If you only want to update a subset of the buffer, you can pass in the size of the data.\n     * @param value - the data to set\n     * @param size - the size of the data in bytes\n     * @param syncGPU - should the buffer be updated on the GPU immediately?\n     */\n    public setDataWithSize(value: TypedArray, size: number, syncGPU: boolean)\n    {\n        // Increment update ID\n        this._updateID++;\n\n        this._updateSize = (size * value.BYTES_PER_ELEMENT);\n\n        // If the data hasn't changed, early return after emitting 'update'\n        if (this._data === value)\n        {\n            if (syncGPU) this.emit('update', this);\n\n            return;\n        }\n\n        // Cache old data and update to new value\n        const oldData = this._data;\n\n        this._data = value;\n        this._dataInt32 = null;\n\n        // Event handling\n        if (!oldData || oldData.length !== value.length)\n        {\n            if (!this.shrinkToFit && oldData && value.byteLength < oldData.byteLength)\n            {\n                if (syncGPU) this.emit('update', this);\n            }\n            else\n            {\n                this.descriptor.size = value.byteLength;\n                this._resourceId = uid('resource');\n                this.emit('change', this);\n            }\n\n            return;\n        }\n\n        if (syncGPU) this.emit('update', this);\n    }\n\n    /**\n     * updates the buffer on the GPU to reflect the data in the buffer.\n     * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n     * you can pass in the size of the buffer to update.\n     * @param sizeInBytes - the new size of the buffer in bytes\n     */\n    public update(sizeInBytes?: number): void\n    {\n        this._updateSize = sizeInBytes ?? this._updateSize;\n\n        this._updateID++;\n\n        this.emit('update', this);\n    }\n\n    /** Destroys the buffer */\n    public destroy()\n    {\n        this.destroyed = true;\n\n        this.emit('destroy', this);\n        this.emit('change', this);\n\n        this._data = null;\n        (this.descriptor as null) = null;\n\n        this.removeAllListeners();\n    }\n}\n\n", "import { Buffer } from '../../buffer/Buffer';\nimport { BufferUsage } from '../../buffer/const';\n\nimport type { TypedArray } from '../../buffer/Buffer';\n\n/**\n * Converts something into a buffer. If it is already a buffer it will pass it through\n * if it is a number array it will convert it to a float32 array before being passed into a buffer\n * the buffer will be created with the correct usage flags for geometry attributes\n * @param buffer - number array\n * @param index - is this an index buffer?\n * @returns a buffer\n * @memberof rendering\n */\nexport function ensureIsBuffer(buffer: Buffer | TypedArray | number[], index: boolean): Buffer\n{\n    if (!(buffer instanceof Buffer))\n    {\n        let usage: number = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n\n        // its an array!\n        if (buffer instanceof Array)\n        {\n            if (index)\n            {\n                buffer = new Uint32Array(buffer);\n                usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n            }\n\n            else\n            {\n                buffer = new Float32Array(buffer);\n                usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n            }\n        }\n\n        buffer = new Buffer({\n            data: buffer,\n            label: index ? 'index-mesh-buffer' : 'vertex-mesh-buffer',\n            usage\n        });\n    }\n\n    return buffer;\n}\n", "import type { Bounds } from '../../../../../scene/container/bounds/Bounds';\nimport type { Geometry } from '../Geometry';\n\n/**\n * Gets the 2D bounds of a geometry, based on a specific attribute.\n * @param geometry - Geometry to to measure\n * @param attributeId - AttributeId that contains the x,y data\n * @param bounds - Bounds to store the result in\n * @returns the bounds\n */\nexport function getGeometryBounds(geometry: Geometry, attributeId: string, bounds: Bounds): Bounds\n{\n    const attribute = geometry.getAttribute(attributeId);\n\n    if (!attribute)\n    {\n        bounds.minX = 0;\n        bounds.minY = 0;\n        bounds.maxX = 0;\n        bounds.maxY = 0;\n\n        return bounds;\n    }\n\n    const data = attribute.buffer.data as Float32Array;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const byteSize = data.BYTES_PER_ELEMENT;\n\n    // stride and offset MAY have not been calculated yet.. so go with assumed defaults\n    const offset = (attribute.offset || 0) / byteSize;\n    const stride = (attribute.stride || (2 * 4)) / byteSize;\n\n    for (let i = offset; i < data.length; i += stride)\n    {\n        const x = data[i];\n        const y = data[i + 1];\n\n        if (x > maxX)maxX = x;\n        if (y > maxY)maxY = y;\n        if (x < minX)minX = x;\n        if (y < minY)minY = y;\n    }\n\n    bounds.minX = minX;\n    bounds.minY = minY;\n    bounds.maxX = maxX;\n    bounds.maxY = maxY;\n\n    return bounds;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { uid } from '../../../../utils/data/uid';\nimport { Buffer } from '../buffer/Buffer';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer';\nimport { getGeometryBounds } from './utils/getGeometryBounds';\n\nimport type { TypedArray } from '../buffer/Buffer';\nimport type { Topology, VertexFormat } from './const';\n\nexport type IndexBufferArray = Uint16Array | Uint32Array;\n\n/**\n * The attribute data for a geometries attributes\n * @memberof rendering\n */\nexport interface Attribute\n{\n    /** the buffer that this attributes data belongs to */\n    buffer: Buffer;\n    /** the format of the attribute */\n    format?: VertexFormat;\n    /** the stride of the data in the buffer - in bytes*/\n    stride?: number;\n    /** the offset of the attribute from the buffer, defaults to 0 - in bytes*/\n    offset?: number;\n    /** is this an instanced buffer? (defaults to false) */\n    instance?: boolean;\n    /** the number of elements to be rendered. If not specified, all vertices after the starting vertex will be drawn. */\n    size?: number;\n    /**\n     * the starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     */\n    start?: number;\n    /**\n     * attribute divisor for instanced rendering. Note: this is a **WebGL-only** feature, the WebGPU renderer will\n     * issue a warning if one of the attributes has divisor set.\n     */\n    divisor?: number;\n}\n\n/**\n * The attribute options used by the constructor for adding geometries attributes\n * extends {@link rendering.Attribute} but allows for the buffer to be a typed or number array\n * @memberof rendering\n */\ntype AttributeOption = Omit<Attribute, 'buffer'> & { buffer: Buffer | TypedArray | number[]}\n| Buffer | TypedArray | number[];\n\nexport type AttributeOptions = Record<string, AttributeOption>;\n\n/**\n * the interface that describes the structure of the geometry\n * @memberof rendering\n */\nexport interface GeometryDescriptor\n{\n    /** an optional label to easily identify the geometry */\n    label?: string;\n    /** the attributes that make up the geometry */\n    attributes?: AttributeOptions;\n    /** optional index buffer for this geometry */\n    indexBuffer?: Buffer | TypedArray | number[];\n    /** the topology of the geometry, defaults to 'triangle-list' */\n    topology?: Topology;\n\n    instanceCount?: number;\n}\nfunction ensureIsAttribute(attribute: AttributeOption): Attribute\n{\n    if (attribute instanceof Buffer || Array.isArray(attribute) || (attribute as TypedArray).BYTES_PER_ELEMENT)\n    {\n        attribute = {\n            buffer: attribute as Buffer | TypedArray | number[],\n        };\n    }\n\n    (attribute as Attribute).buffer = ensureIsBuffer(attribute.buffer as Buffer | TypedArray | number[], false);\n\n    return attribute as Attribute;\n}\n\n/**\n * A Geometry is a low-level object that represents the structure of 2D shapes in terms of vertices and attributes.\n * It's a crucial component for rendering as it describes the shape and format of the data that will go through the shaders.\n * Essentially, a Geometry object holds the data you'd send to a GPU buffer.\n *\n * A geometry is basically made of two components:\n * <br>\n * <b>Attributes</b>: These are essentially arrays that define properties of the vertices like position, color,\n * texture coordinates, etc. They map directly to attributes in your vertex shaders.\n * <br>\n * <b>Indices</b>: An optional array that describes how the vertices are connected.\n * If not provided, vertices will be interpreted in the sequence they're given.\n * @example\n *\n * const geometry = new Geometry({\n *   attributes: {\n *     aPosition: [ // add some positions\n *       0, 0,\n *       0, 100,\n *       100, 100,\n *       100,   0,\n *     ],\n *     aUv: [ // add some uvs\n *       0, 0,\n *       0, 1,\n *       1, 1,\n *       1, 0,\n *     ]\n *   }\n * });\n * @memberof rendering\n * @class\n */\nexport class Geometry extends EventEmitter<{\n    update: Geometry,\n    destroy: Geometry,\n}>\n{\n    /** The topology of the geometry. */\n    public topology: Topology;\n    /** The unique id of the geometry. */\n    public readonly uid: number = uid('geometry');\n    /** A record of the attributes of the geometry. */\n    public readonly attributes: Record<string, Attribute>;\n    /** The buffers that the attributes use */\n    public readonly buffers: Buffer[];\n    /** The index buffer of the geometry */\n    public indexBuffer: Buffer;\n\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /** the instance count of the geometry to draw */\n    public instanceCount = 1;\n\n    private readonly _bounds: Bounds = new Bounds();\n    private _boundsDirty = true;\n\n    /**\n     * Create a new instance of a geometry\n     * @param options - The options for the geometry.\n     */\n    constructor(options: GeometryDescriptor = {})\n    {\n        super();\n\n        const { attributes, indexBuffer, topology } = options;\n\n        this.buffers = [];\n\n        this.attributes = {};\n\n        if (attributes)\n        {\n            for (const i in attributes)\n            {\n                this.addAttribute(i, attributes[i]);\n            }\n        }\n\n        this.instanceCount = options.instanceCount ?? 1;\n\n        if (indexBuffer)\n        {\n            this.addIndex(indexBuffer);\n        }\n\n        this.topology = topology || 'triangle-list';\n    }\n\n    protected onBufferUpdate(): void\n    {\n        this._boundsDirty = true;\n        this.emit('update', this);\n    }\n\n    /**\n     * Returns the requested attribute.\n     * @param id - The name of the attribute required\n     * @returns - The attribute requested.\n     */\n    public getAttribute(id: string): Attribute\n    {\n        return this.attributes[id];\n    }\n\n    /**\n     * Returns the index buffer\n     * @returns - The index buffer.\n     */\n    public getIndex(): Buffer\n    {\n        return this.indexBuffer;\n    }\n\n    /**\n     * Returns the requested buffer.\n     * @param id - The name of the buffer required.\n     * @returns - The buffer requested.\n     */\n    public getBuffer(id: string): Buffer\n    {\n        return this.getAttribute(id).buffer;\n    }\n\n    /**\n     * Used to figure out how many vertices there are in this geometry\n     * @returns the number of vertices in the geometry\n     */\n    public getSize(): number\n    {\n        for (const i in this.attributes)\n        {\n            const attribute = this.attributes[i];\n            const buffer = attribute.buffer;\n\n            // TODO use SIZE again like v7..\n            return (buffer.data as any).length / ((attribute.stride / 4) || attribute.size);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Adds an attribute to the geometry.\n     * @param name - The name of the attribute to add.\n     * @param attributeOption - The attribute option to add.\n     */\n    public addAttribute(name: string, attributeOption: AttributeOption): void\n    {\n        const attribute = ensureIsAttribute(attributeOption);\n\n        const bufferIndex = this.buffers.indexOf(attribute.buffer);\n\n        if (bufferIndex === -1)\n        {\n            this.buffers.push(attribute.buffer);\n\n            // two events here - one for a resize (new buffer change)\n            // and one for an update (existing buffer change)\n            attribute.buffer.on('update', this.onBufferUpdate, this);\n            attribute.buffer.on('change', this.onBufferUpdate, this);\n        }\n        this.attributes[name] = attribute;\n    }\n\n    /**\n     * Adds an index buffer to the geometry.\n     * @param indexBuffer - The index buffer to add. Can be a Buffer, TypedArray, or an array of numbers.\n     */\n    public addIndex(indexBuffer: Buffer | TypedArray | number[]): void\n    {\n        this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n        this.buffers.push(this.indexBuffer);\n    }\n\n    /** Returns the bounds of the geometry. */\n    get bounds(): Bounds\n    {\n        if (!this._boundsDirty) return this._bounds;\n\n        this._boundsDirty = false;\n\n        return getGeometryBounds(this, 'aPosition', this._bounds);\n    }\n\n    /**\n     * destroys the geometry.\n     * @param destroyBuffers - destroy the buffers associated with this geometry\n     */\n    public destroy(destroyBuffers = false): void\n    {\n        this.emit('destroy', this);\n\n        this.removeAllListeners();\n\n        if (destroyBuffers)\n        {\n            this.buffers.forEach((buffer) => buffer.destroy());\n        }\n\n        (this.attributes as null) = null;\n        (this.buffers as null) = null;\n        (this.indexBuffer as null) = null;\n        (this._bounds as null) = null;\n    }\n}\n", "import { Buffer } from '../../renderers/shared/buffer/Buffer';\nimport { BufferUsage } from '../../renderers/shared/buffer/const';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry';\n\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\n\nexport class BatchGeometry extends Geometry\n{\n    constructor()\n    {\n        const vertexSize = 6;\n\n        const attributeBuffer = new Buffer({\n            data: placeHolderBufferData,\n            label: 'attribute-batch-buffer',\n            usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n            shrinkToFit: false,\n        });\n\n        const indexBuffer = new Buffer({\n            data: placeHolderIndexData,\n            label: 'index-batch-buffer',\n            usage: BufferUsage.INDEX | BufferUsage.COPY_DST, // | BufferUsage.STATIC,\n            shrinkToFit: false,\n        });\n\n        const stride = vertexSize * 4;\n\n        super({\n            attributes: {\n                aPosition: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 0,\n                },\n                aUV: {\n                    buffer: attributeBuffer,\n                    format: 'float32x2',\n                    stride,\n                    offset: 2 * 4,\n                },\n                aColor: {\n                    buffer: attributeBuffer,\n                    format: 'unorm8x4',\n                    stride,\n                    offset: 4 * 4,\n                },\n                aTextureIdAndRound: {\n                    buffer: attributeBuffer,\n                    format: 'uint16x2',\n                    stride,\n                    offset: 5 * 4,\n                },\n            },\n            indexBuffer\n        });\n    }\n}\n\n", "const idCounts: Record<string, number> = Object.create(null);\nconst idHash: Record<string, number> = Object.create(null);\n\nexport function createIdFromString(value: string, groupId: string): number\n{\n    let id = idHash[value];\n\n    if (id === undefined)\n    {\n        if (idCounts[groupId] === undefined)\n        {\n            idCounts[groupId] = 1;\n        }\n\n        idHash[value] = id = idCounts[groupId]++;\n    }\n\n    return id;\n}\n", "import { getTestContext } from './getTestContext';\n\nimport type { PRECISION } from '../const';\n\nlet maxFragmentPrecision: PRECISION;\n\nexport function getMaxFragmentPrecision(): PRECISION\n{\n    if (!maxFragmentPrecision)\n    {\n        maxFragmentPrecision = 'mediump';\n        const gl = getTestContext();\n\n        if (gl)\n        {\n            if (gl.getShaderPrecisionFormat)\n            {\n                const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\n                maxFragmentPrecision = shaderFragment.precision ? 'highp' : 'mediump';\n            }\n        }\n    }\n\n    return maxFragmentPrecision;\n}\n", "export function addProgramDefines(src: string, isES300: boolean, isFragment?: boolean)\n{\n    if (isES300) return src;\n\n    if (isFragment)\n    {\n        src = src.replace('out vec4 finalColor;', '');\n\n        return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n    }\n\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n", "import type { PRECISION } from '../../const';\n\ninterface EnsurePrecisionOptions\n{\n    requestedVertexPrecision: PRECISION;\n    requestedFragmentPrecision: PRECISION;\n    maxSupportedVertexPrecision: PRECISION;\n    maxSupportedFragmentPrecision: PRECISION;\n}\n\n/**\n * Sets the float precision on the shader, ensuring the device supports the request precision.\n * If the precision is already present, it just ensures that the device is able to handle it.\n * @param src\n * @param options\n * @param options.requestedVertexPrecision\n * @param options.requestedFragmentPrecision\n * @param options.maxSupportedVertexPrecision\n * @param options.maxSupportedFragmentPrecision\n * @param isFragment\n * @private\n */\nexport function ensurePrecision(\n    src: string,\n    options: EnsurePrecisionOptions,\n    isFragment: boolean,\n): string\n{\n    const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n\n    if (src.substring(0, 9) !== 'precision')\n    {\n        // no precision supplied, so PixiJS will add the requested level.\n        let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n\n        // If highp is requested but not supported, downgrade precision to a level all devices support.\n        if (precision === 'highp' && maxSupportedPrecision !== 'highp')\n        {\n            precision = 'mediump';\n        }\n\n        return `precision ${precision} float;\\n${src}`;\n    }\n    else if (maxSupportedPrecision !== 'highp' && src.substring(0, 15) === 'precision highp')\n    {\n        // precision was supplied, but at a level this device does not support, so downgrading to mediump.\n        return src.replace('precision highp', 'precision mediump');\n    }\n\n    return src;\n}\n", "export function insertVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return `#version 300 es\\n${src}`;\n}\n", "const fragmentNameCache: { [key: string]: number } = {};\nconst VertexNameCache: { [key: string]: number } = {};\n\nexport function setProgramName(src: string, { name = `pixi-program` }: { name: string; }, isFragment = true)\n{\n    name = name.replace(/\\s+/g, '-');\n\n    name += isFragment ? '-fragment' : '-vertex';\n\n    const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n\n    if (nameCache[name])\n    {\n        nameCache[name]++;\n        name += `-${nameCache[name]}`;\n    }\n    else\n    {\n        nameCache[name] = 1;\n    }\n\n    // if it already contains the define return\n    if (src.indexOf('#define SHADER_NAME') !== -1) return src;\n\n    const shaderName = `#define SHADER_NAME ${name}`;\n\n    return `${shaderName}\\n${src}`;\n}\n", "export function stripVersion(src: string, isES300: boolean): string\n{\n    if (!isES300) return src;\n\n    return src.replace('#version 300 es', '');\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision';\nimport { insertVersion } from './program/preprocessors/insertVersion';\nimport { setProgramName } from './program/preprocessors/setProgramName';\nimport { stripVersion } from './program/preprocessors/stripVersion';\n\nimport type { TypedArray } from '../../shared/buffer/Buffer';\nimport type { ExtractedAttributeData } from './program/extractAttributesFromGlProgram';\n\nexport interface GlAttributeData\n{\n    type: string;\n    size: number;\n    location: number;\n    name: string;\n}\n\nexport interface GlUniformData\n{\n    name: string;\n    index: number;\n    type: string;\n    size: number;\n    isArray: boolean;\n    value: any;\n}\n\nexport interface GlUniformBlockData\n{\n    index: number;\n    name: string;\n    size: number;\n    value?: TypedArray;\n}\n\n/**\n * The options for the gl program\n * @memberof rendering\n */\nexport interface GlProgramOptions\n{\n    /** The fragment glsl shader source. */\n    fragment: string;\n    /** The vertex glsl shader source. */\n    vertex: string;\n    /** the name of the program, defaults to 'pixi-program' */\n    name?: string;\n    /** the preferred vertex precision for the shader, this may not be used if the device does not support it  */\n    preferredVertexPrecision?: string;\n    /** the preferred fragment precision for the shader, this may not be used if the device does not support it  */\n    preferredFragmentPrecision?: string;\n\n    transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n}\n\nconst processes: Record<string, ((source: string, options: any, isFragment?: boolean) => string)> = {\n    // strips any version headers..\n    stripVersion,\n    // adds precision string if not already present\n    ensurePrecision,\n    // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n    addProgramDefines,\n    // add the program name to the shader\n    setProgramName,\n    // add the version string to the shader header\n    insertVersion,\n};\n\nconst programCache: Record<string, GlProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGL Program. You can create one and then pass it to a shader.\n * This will manage the WebGL program that is compiled and uploaded to the GPU.\n *\n * To get the most out of this class, you should be familiar with glsl shaders and how they work.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLProgram\n * @example\n *\n * // Create a new program\n * const program = new GlProgram({\n *   vertex: '...',\n *   fragment: '...',\n * });\n *\n *\n * There are a few key things that pixi shader will do for you automatically:\n * <br>\n * - If no precision is provided in the shader, it will be injected into the program source for you.\n * This precision will be taken form the options provided, if none is provided,\n * then the program will default to the defaultOptions.\n * <br>\n * - It will inject the program name into the shader source if none is provided.\n * <br>\n *  - It will set the program version to 300 es.\n *\n * For optimal usage and best performance, its best to reuse programs as much as possible.\n * You should use the {@link GlProgram.from} helper function to create programs.\n * @class\n * @memberof rendering\n */\nexport class GlProgram\n{\n    /** The default options used by the program. */\n    public static defaultOptions: Partial<GlProgramOptions> = {\n        preferredVertexPrecision: 'highp',\n        preferredFragmentPrecision: 'mediump',\n    };\n\n    /** the fragment glsl shader source. */\n    public readonly fragment?: string;\n    /** the vertex glsl shader source */\n    public readonly vertex?: string;\n    /**\n     * attribute data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _attributeData: Record<string, ExtractedAttributeData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformData: Record<string, GlUniformData>;\n    /**\n     * uniform data extracted from the program once created this happens when the program is used for the first time\n     * @internal\n     * @ignore\n     */\n    public _uniformBlockData: Record<string, GlUniformBlockData>;\n    /** details on how to use this program with transform feedback */\n    public transformFeedbackVaryings?: {names: string[], bufferMode: 'separate' | 'interleaved'};\n    /**\n     * the key that identifies the program via its source vertex + fragment\n     * @internal\n     * @ignore\n     */\n    public readonly _key: number;\n\n    /**\n     * Creates a shiny new GlProgram. Used by WebGL renderer.\n     * @param options - The options for the program.\n     */\n    constructor(options: GlProgramOptions)\n    {\n        options = { ...GlProgram.defaultOptions, ...options };\n\n        // only need to check one as they both need to be the same or\n        // errors ensue!\n        const isES300 = options.fragment.indexOf('#version 300 es') !== -1;\n\n        const preprocessorOptions = {\n            stripVersion: isES300,\n            ensurePrecision: {\n                requestedFragmentPrecision: options.preferredFragmentPrecision,\n                requestedVertexPrecision: options.preferredVertexPrecision,\n                maxSupportedVertexPrecision: 'highp',\n                maxSupportedFragmentPrecision: getMaxFragmentPrecision(),\n            },\n            setProgramName: {\n                name: options.name,\n            },\n            addProgramDefines: isES300,\n            insertVersion: isES300\n        };\n\n        let fragment = options.fragment;\n        let vertex = options.vertex;\n\n        Object.keys(processes).forEach((processKey) =>\n        {\n            const processOptions = preprocessorOptions[processKey as keyof typeof preprocessorOptions];\n\n            fragment = processes[processKey](fragment, processOptions, true);\n            vertex = processes[processKey](vertex, processOptions, false);\n        });\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        this.transformFeedbackVaryings = options.transformFeedbackVaryings;\n\n        this._key = createIdFromString(`${this.vertex}:${this.fragment}`, 'gl-program');\n    }\n\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n\n        this._attributeData = null;\n        this._uniformData = null;\n        this._uniformBlockData = null;\n\n        this.transformFeedbackVaryings = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GlProgramOptions): GlProgram\n    {\n        const key = `${options.vertex}:${options.fragment}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GlProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n", "import type { VertexFormat } from '../const';\n\nconst attributeFormatData = {\n    uint8x2: { size: 2, stride: 2, normalised: false },\n    uint8x4: { size: 4, stride: 4, normalised: false },\n    sint8x2: { size: 2, stride: 2, normalised: false },\n    sint8x4: { size: 4, stride: 4, normalised: false },\n    unorm8x2: { size: 2, stride: 2, normalised: true },\n    unorm8x4: { size: 4, stride: 4, normalised: true },\n    snorm8x2: { size: 2, stride: 2, normalised: true },\n    snorm8x4: { size: 4, stride: 4, normalised: true },\n    uint16x2: { size: 2, stride: 4, normalised: false },\n    uint16x4: { size: 4, stride: 8, normalised: false },\n    sint16x2: { size: 2, stride: 4, normalised: false },\n    sint16x4: { size: 4, stride: 8, normalised: false },\n    unorm16x2: { size: 2, stride: 4, normalised: true },\n    unorm16x4: { size: 4, stride: 8, normalised: true },\n    snorm16x2: { size: 2, stride: 4, normalised: true },\n    snorm16x4: { size: 4, stride: 8, normalised: true },\n    float16x2: { size: 2, stride: 4, normalised: false },\n    float16x4: { size: 4, stride: 8, normalised: false },\n    float32: { size: 1, stride: 4, normalised: false },\n    float32x2: { size: 2, stride: 8, normalised: false },\n    float32x3: { size: 3, stride: 12, normalised: false },\n    float32x4: { size: 4, stride: 16, normalised: false },\n    uint32: { size: 1, stride: 4, normalised: false },\n    uint32x2: { size: 2, stride: 8, normalised: false },\n    uint32x3: { size: 3, stride: 12, normalised: false },\n    uint32x4: { size: 4, stride: 16, normalised: false },\n    sint32: { size: 1, stride: 4, normalised: false },\n    sint32x2: { size: 2, stride: 8, normalised: false },\n    sint32x3: { size: 3, stride: 12, normalised: false },\n    sint32x4: { size: 4, stride: 16, normalised: false },\n};\n\nexport function getAttributeInfoFromFormat(format: VertexFormat): { size: number; stride: number; normalised: boolean }\n{\n    return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n", "import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat';\n\nimport type { ExtractedAttributeData } from '../../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { VertexFormat } from '../../../shared/geometry/const';\nimport type { ProgramSource } from '../GpuProgram';\n\nconst WGSL_TO_VERTEX_TYPES: Record<string, VertexFormat> = {\n\n    f32:  'float32',\n    'vec2<f32>': 'float32x2',\n    'vec3<f32>': 'float32x3',\n    'vec4<f32>': 'float32x4',\n    vec2f: 'float32x2',\n    vec3f: 'float32x3',\n    vec4f: 'float32x4',\n\n    i32: 'sint32',\n    'vec2<i32>': 'sint32x2',\n    'vec3<i32>': 'sint32x3',\n    'vec4<i32>': 'sint32x4',\n\n    u32: 'uint32',\n    'vec2<u32>': 'uint32x2',\n    'vec3<u32>': 'uint32x3',\n    'vec4<u32>': 'uint32x4',\n\n    bool: 'uint32',\n    'vec2<bool>': 'uint32x2',\n    'vec3<bool>': 'uint32x3',\n    'vec4<bool>': 'uint32x4',\n};\n\nexport function extractAttributesFromGpuProgram(\n    { source, entryPoint }: ProgramSource\n): Record<string, ExtractedAttributeData>\n{\n    const results: Record<string, ExtractedAttributeData> = {};\n\n    // Step 1: Find the start of the mainVert function using string methods\n    const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n\n    if (mainVertStart !== -1)\n    {\n        // Step 2: Find the index of the next '->' after the start of the mainVert function\n        const arrowFunctionStart = source.indexOf('->', mainVertStart);\n\n        if (arrowFunctionStart !== -1)\n        {\n            const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n\n            // Apply the inputs regex directly to the trimmed string\n            const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n            let match;\n\n            while ((match = inputsRegex.exec(functionArgsSubstring)) !== null)\n            {\n                const format = WGSL_TO_VERTEX_TYPES[match[3] as VertexFormat] ?? 'float32';\n\n                results[match[2]] = {\n                    location: parseInt(match[1], 10),\n                    format,\n                    stride: getAttributeInfoFromFormat(format).stride,\n                    offset: 0,\n                    instance: false,\n                    start: 0,\n                };\n            }\n        }\n    }\n\n    return results;\n}\n", "export interface StructsAndGroups\n{\n    groups: {\n        group: number;\n        binding: number;\n        name: string;\n        isUniform: boolean;\n        type: string;\n    }[];\n    structs: {\n        name: string;\n        members: Record<string, string>;\n    }[];\n}\n\nexport function extractStructAndGroups(wgsl: string): StructsAndGroups\n{\n    // Patterns for parsing the WGSL file\n    const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n    const groupPattern = /@group\\((\\d+)\\)/;\n    const bindingPattern = /@binding\\((\\d+)\\)/;\n    const namePattern = /var(<[^>]+>)? (\\w+)/;\n    const typePattern = /:\\s*(\\w+)/;\n    const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n    const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n    const structName = /struct\\s+(\\w+)/;\n\n    // Find the @group and @binding annotations\n    const groups = wgsl.match(linePattern)?.map((item) => ({\n        group: parseInt(item.match(groupPattern)[1], 10),\n        binding: parseInt(item.match(bindingPattern)[1], 10),\n        name: item.match(namePattern)[2],\n        isUniform: item.match(namePattern)[1] === '<uniform>',\n        type: item.match(typePattern)[1],\n    }));\n\n    if (!groups)\n    {\n        return {\n            groups: [],\n            structs: [],\n        };\n    }\n\n    // Find the structs\n    const structs = wgsl\n        .match(structPattern)\n        ?.map((struct) =>\n        {\n            const name = struct.match(structName)[1];\n            const members = struct.match(structMemberPattern).reduce((acc: Record<string, string>, member) =>\n            {\n                const [name, type] = member.split(':');\n\n                acc[name.trim()] = type.trim();\n\n                return acc;\n            }, {});\n\n            if (!members)\n            {\n                return null;\n            }\n\n            return { name, members };\n            // Only include the structs mentioned in the @group/@binding annotations\n        })\n        .filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n\n    return {\n        groups,\n        structs,\n    };\n}\n", "export enum ShaderStage\n{\n    VERTEX = 1,\n    FRAGMENT = 2,\n    COMPUTE = 4\n}\n", "import { ShaderStage } from '../../../shared/shader/const';\n\nimport type { ProgramPipelineLayoutDescription } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateGpuLayoutGroups({ groups }: StructsAndGroups): ProgramPipelineLayoutDescription\n{\n    const layout: ProgramPipelineLayoutDescription = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = [];\n        }\n\n        if (group.isUniform)\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n                buffer: {\n                    type: 'uniform'\n                }\n            });\n        }\n        else if (group.type === 'sampler')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                sampler: {\n                    type: 'filtering'\n                }\n            });\n        }\n        else if (group.type === 'texture_2d')\n        {\n            layout[group.group].push({\n                binding: group.binding,\n                visibility: ShaderStage.FRAGMENT,\n                texture: {\n                    sampleType: 'float',\n                    viewDimension: '2d',\n                    multisampled: false,\n                }\n            });\n        }\n    }\n\n    return layout;\n}\n", "import type { ProgramLayout } from '../GpuProgram';\nimport type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function generateLayoutHash({ groups }: StructsAndGroups): ProgramLayout\n{\n    const layout: ProgramLayout = [];\n\n    for (let i = 0; i < groups.length; i++)\n    {\n        const group = groups[i];\n\n        if (!layout[group.group])\n        {\n            layout[group.group] = {};\n        }\n\n        layout[group.group][group.name] = group.binding;\n    }\n\n    return layout;\n}\n", "import type { StructsAndGroups } from './extractStructAndGroups';\n\nexport function removeStructAndGroupDuplicates(\n    vertexStructsAndGroups: StructsAndGroups,\n    fragmentStructsAndGroups: StructsAndGroups\n)\n{\n    const structNameSet = new Set();\n    const dupeGroupKeySet = new Set();\n\n    const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs]\n        .filter((struct) =>\n        {\n            if (structNameSet.has(struct.name))\n            {\n                return false;\n            }\n            structNameSet.add(struct.name);\n\n            return true;\n        });\n\n    const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups]\n        .filter((group) =>\n        {\n            const key = `${group.name}-${group.binding}`;\n\n            if (dupeGroupKeySet.has(key))\n            {\n                return false;\n            }\n            dupeGroupKeySet.add(key);\n\n            return true;\n        });\n\n    return { structs, groups };\n}\n", "import { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups';\nimport { generateLayoutHash } from './utils/generateLayoutHash';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates';\n\nimport type { ExtractedAttributeData } from '../../gl/shader/program/extractAttributesFromGlProgram';\nimport type { StructsAndGroups } from './utils/extractStructAndGroups';\n\n/**\n * a WebGPU descriptions of how the program is laid out\n * @see https://gpuweb.github.io/gpuweb/#gpupipelinelayout\n * @memberof rendering\n */\nexport type ProgramPipelineLayoutDescription = GPUBindGroupLayoutEntry[][];\n/**\n * a map the maps names of uniforms to group indexes\n * @memberof rendering\n */\nexport type ProgramLayout = Record<string, number>[];\n\n/**\n * the program source\n * @memberof rendering\n */\nexport interface ProgramSource\n{\n    /** The wgsl source code of the shader. */\n    source: string;\n    /** The main function to run in this shader */\n    entryPoint?: string;\n}\n\n/**\n * The options for the gpu program\n * @memberof rendering\n */\nexport interface GpuProgramOptions\n{\n    /**\n     * the name of the program, this is added to the label of the GPU Program created\n     * under the hood. Makes it much easier to debug!\n     */\n    name?: string;\n    /** The fragment glsl shader source. */\n    fragment?: ProgramSource;\n    /** The vertex glsl shader source. */\n    vertex?: ProgramSource;\n    /** The layout of the program. If not provided, it will be generated from the shader sources. */\n    layout?: ProgramLayout;\n    /** The gpu layout of the program. If not provided, it will be generated from the shader sources. */\n    gpuLayout?: ProgramPipelineLayoutDescription;\n}\n\nconst programCache: Record<string, GpuProgram> = Object.create(null);\n\n/**\n * A wrapper for a WebGPU Program, specifically designed for the WebGPU renderer.\n * This class facilitates the creation and management of shader code that integrates with the WebGPU pipeline.\n *\n * To leverage the full capabilities of this class, familiarity with WGSL shaders is recommended.\n * @see https://gpuweb.github.io/gpuweb/#index\n * @example\n *\n * // Create a new program\n * const program = new GpuProgram({\n *   vertex: {\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n *   fragment:{\n *    source: '...',\n *    entryPoint: 'main',\n *   },\n * });\n *\n *\n * Note: Both fragment and vertex shader sources can coexist within a single WGSL source file\n * this can make things a bit simpler.\n *\n * For optimal usage and best performance, it help to reuse programs whenever possible.\n * The {@link GpuProgram.from} helper function is designed for this purpose, utilizing an\n * internal cache to efficiently manage and retrieve program instances.\n * By leveraging this function, you can significantly reduce overhead and enhance the performance of your rendering pipeline.\n *\n * An important distinction between WebGL and WebGPU regarding program data retrieval:\n * While WebGL allows extraction of program information directly from its compiled state,\n * WebGPU does not offer such a capability. Therefore, in the context of WebGPU, we're required\n * to manually extract the program layout information from the source code itself.\n * @memberof rendering\n */\nexport class GpuProgram\n{\n    /** The fragment glsl shader source. */\n    public readonly fragment?: ProgramSource;\n    /** The vertex glsl shader source */\n    public readonly vertex?: ProgramSource;\n\n    /**\n     * Mapping of uniform names to group indexes for organizing shader program uniforms.\n     * Automatically generated from shader sources if not provided.\n     * @example\n     * // Assuming a shader with two uniforms, `u_time` and `u_resolution`, grouped respectively:\n     * [\n     *   { \"u_time\": 0 },\n     *   { \"u_resolution\": 1 }\n     * ]\n     */\n    public readonly layout: ProgramLayout;\n\n    /**\n     * Configuration for the WebGPU bind group layouts, detailing resource organization for the shader.\n     * Generated from shader sources if not explicitly provided.\n     * @example\n     * // Assuming a shader program that requires two bind groups:\n     * [\n     *   // First bind group layout entries\n     *   [{ binding: 0, visibility: GPUShaderStage.VERTEX, type: \"uniform-buffer\" }],\n     *   // Second bind group layout entries\n     *   [{ binding: 1, visibility: GPUShaderStage.FRAGMENT, type: \"sampler\" },\n     *    { binding: 2, visibility: GPUShaderStage.FRAGMENT, type: \"sampled-texture\" }]\n     * ]\n     */\n    public readonly gpuLayout: ProgramPipelineLayoutDescription;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _layoutKey = 0;\n\n    /**\n     * @internal\n     * @ignore\n     */\n    public _attributeLocationsKey = 0;\n\n    /** the structs and groups extracted from the shader sources */\n    public readonly structsAndGroups: StructsAndGroups;\n    /**\n     * the name of the program, this is added to the label of the GPU Program created under the hood.\n     * Makes it much easier to debug!\n     */\n    public readonly name: string;\n    private _attributeData: Record<string, ExtractedAttributeData>;\n\n    /** if true, the program will automatically assign global uniforms to group[0] */\n    public autoAssignGlobalUniforms: boolean;\n    /** if true, the program will automatically assign local uniforms to group[1] */\n    public autoAssignLocalUniforms: boolean;\n\n    /**\n     * Create a new GpuProgram\n     * @param options - The options for the gpu program\n     */\n    constructor(options: GpuProgramOptions)\n    {\n        const { fragment, vertex, layout, gpuLayout, name } = options;\n\n        this.name = name;\n\n        this.fragment = fragment;\n        this.vertex = vertex;\n\n        // TODO this should be cached - or dealt with at a system level.\n        if (fragment.source === vertex.source)\n        {\n            const structsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = structsAndGroups;\n        }\n        else\n        {\n            const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n            const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n\n            this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n        }\n\n        // todo layout\n        this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n\n        // struct properties!\n\n        this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n\n        this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== undefined);\n        this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== undefined);\n\n        this._generateProgramKey();\n    }\n\n    // TODO maker this pure\n    private _generateProgramKey()\n    {\n        const { vertex, fragment } = this;\n\n        const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n\n        this._layoutKey = createIdFromString(bigKey, 'program');\n    }\n\n    get attributeData()\n    {\n        this._attributeData ??= extractAttributesFromGpuProgram(this.vertex);\n\n        return this._attributeData;\n    }\n    /** destroys the program */\n    public destroy(): void\n    {\n        (this.gpuLayout as null) = null;\n        (this.layout as null) = null;\n        (this.structsAndGroups as null) = null;\n        (this.fragment as null) = null;\n        (this.vertex as null) = null;\n    }\n\n    /**\n     * Helper function that creates a program for a given source.\n     * It will check the program cache if the program has already been created.\n     * If it has that one will be returned, if not a new one will be created and cached.\n     * @param options - The options for the program.\n     * @returns A program using the same source\n     */\n    public static from(options: GpuProgramOptions): GpuProgram\n    {\n        // eslint-disable-next-line max-len\n        const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n\n        if (!programCache[key])\n        {\n            programCache[key] = new GpuProgram(options);\n        }\n\n        return programCache[key];\n    }\n}\n\n", "import { warn } from '../../../../utils/logging/warn';\n\n/**\n * takes the HighFragment source parts and adds them to the hook hash\n * @param srcParts - the hash of hook arrays\n * @param parts - the code to inject into the hooks\n * @param name - optional the name of the part to add\n */\nexport function addBits(srcParts: Record<string, string>, parts: Record<string, string[]>, name?: string)\n{\n    if (srcParts)\n    {\n        for (const i in srcParts)\n        {\n            const id = i.toLocaleLowerCase();\n\n            const part = parts[id];\n\n            if (part)\n            {\n                let sanitisedPart = srcParts[i];\n\n                if (i === 'header')\n                {\n                    sanitisedPart = sanitisedPart\n                        .replace(/@in\\s+[^;]+;\\s*/g, '')\n                        .replace(/@out\\s+[^;]+;\\s*/g, '');\n                }\n\n                if (name)\n                {\n                    part.push(`//----${name}----//`);\n                }\n                part.push(sanitisedPart);\n            }\n\n            else\n            {\n                // #if _DEBUG\n                warn(`${i} placement hook does not exist in shader`);\n                // #endif\n            }\n        }\n    }\n}\n", "export const findHooksRx = /\\{\\{(.*?)\\}\\}/g;\n\n/**\n * takes a program string and returns an hash mapping the hooks to empty arrays\n * @param programSrc - the program containing hooks\n */\nexport function compileHooks(programSrc: string): Record<string, string[]>\n{\n    const parts: Record<string, string[]> = {};\n\n    const partMatches = programSrc\n        .match(findHooksRx)\n        ?.map((hook) => hook.replace(/[{()}]/g, '')) ?? [];\n\n    partMatches.forEach((hook) =>\n    {\n        parts[hook] = [];\n    });\n\n    return parts;\n}\n", "function extractInputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@in\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nexport function compileInputs(fragments: any[], template: string, sort = false)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractInputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractInputs(fragment.header, results);\n        }\n    });\n\n    // build the input:\n    const mainInput = results;\n\n    if (sort)\n    {\n        mainInput.sort();\n    }\n\n    const finalString = mainInput\n        .map((inValue, i) => `       @location(${i}) ${inValue},`)\n        .join('\\n');\n\n    // Remove lines from original string\n    let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, '');\n\n    cleanedString = cleanedString.replace('{{in}}', `\\n${finalString}\\n`);\n\n    return cleanedString;\n}\n", "function extractOutputs(fragmentSource: string, out: string[])\n{\n    let match;\n    const regex = /@out\\s+([^;]+);/g;\n\n    while ((match = regex.exec(fragmentSource)) !== null)\n    {\n        out.push(match[1]);\n    }\n}\n\nfunction extractVariableName(value: string)\n{\n    const regex = /\\b(\\w+)\\s*:/g;\n\n    const match = regex.exec(value);\n\n    return match ? match[1] : '';\n}\n\nfunction stripVariable(value: string)\n{\n    const regex = /@.*?\\s+/g;\n\n    return value.replace(regex, '');\n}\n\nexport function compileOutputs(fragments: any[], template: string)\n{\n    // get all the inputs from the fragments..\n    const results: string[] = [];\n\n    extractOutputs(template, results);\n\n    fragments.forEach((fragment) =>\n    {\n        if (fragment.header)\n        {\n            extractOutputs(fragment.header, results);\n        }\n    });\n\n    let index = 0;\n\n    // generate the output struct\n    const mainStruct = results\n        .sort()\n        .map((inValue) =>\n        {\n            if (inValue.indexOf('builtin') > -1)\n            {\n                return inValue;\n            }\n\n            return `@location(${index++}) ${inValue}`;\n        })\n        .join(',\\n');\n\n    // generate the variables we will set:\n    const mainStart = results\n        .sort()\n        .map((inValue) => `       var ${stripVariable(inValue)};`)\n        .join('\\n');\n\n    // generate the return object\n    const mainEnd = `return VSOutput(\n            ${results\n                .sort()\n                .map((inValue) => ` ${extractVariableName(inValue)}`)\n                .join(',\\n')});`;\n\n    // Remove lines from original string\n    let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, '');\n\n    compiledCode = compiledCode.replace('{{struct}}', `\\n${mainStruct}\\n`);\n    compiledCode = compiledCode.replace('{{start}}', `\\n${mainStart}\\n`);\n    compiledCode = compiledCode.replace('{{return}}', `\\n${mainEnd}\\n`);\n\n    return compiledCode;\n}\n", "/**\n * takes a shader src and replaces any hooks with the HighFragment code.\n * @param templateSrc - the program src template\n * @param fragmentParts - the fragments to inject\n */\nexport function injectBits(templateSrc: string, fragmentParts: Record<string, string[]>): string\n{\n    let out = templateSrc;\n\n    for (const i in fragmentParts)\n    {\n        const parts = fragmentParts[i];\n\n        const toInject = parts.join('\\n');\n\n        if (toInject.length)\n        {\n            out = out.replace(`{{${i}}}`, `//-----${i} START-----//\\n${parts.join('\\n')}\\n//----${i} FINISH----//`);\n        }\n\n        else\n        {\n            out = out.replace(`{{${i}}}`, '');\n        }\n    }\n\n    return out;\n}\n", "import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n", "const vertexGPUTemplate = /* wgsl */`\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`;\n\nconst fragmentGPUTemplate = /* wgsl */`\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        var finalColor:vec4<f32> = outColor * vColor;\n\n        {{end}}\n\n        return finalColor;\n      };\n`;\n\nconst vertexGlTemplate = /* glsl */`\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`;\n\nconst fragmentGlTemplate = /* glsl */`\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n        \n        {{end}}\n    }\n`;\n\nexport {\n    fragmentGlTemplate,\n    fragmentGPUTemplate,\n    vertexGlTemplate,\n    vertexGPUTemplate\n};\n", "export const globalUniformsBit = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* wgsl */`\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    }\n};\n\nexport const globalUniformsUBOBitGl = {\n    name: 'global-uniforms-ubo-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    }\n};\n\nexport const globalUniformsBitGl = {\n    name: 'global-uniforms-bit',\n    vertex: {\n        header: /* glsl */`\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    }\n\n};\n", "import { GlProgram } from '../renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader';\nimport { fragmentGlTemplate, fragmentGPUTemplate, vertexGlTemplate, vertexGPUTemplate } from './defaultProgramTemplate';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit';\n\nimport type { HighShaderBit } from './compiler/types';\n\nexport function compileHighShaderGpuProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GpuProgram\n{\n    const source = compileHighShader({\n        template: {\n            fragment: fragmentGPUTemplate,\n            vertex: vertexGPUTemplate,\n        },\n        bits: [\n            globalUniformsBit,\n            ...bits,\n        ]\n    });\n\n    return GpuProgram.from({\n        name,\n        vertex: {\n            source: source.vertex,\n            entryPoint: 'main',\n        },\n        fragment: {\n            source: source.fragment,\n            entryPoint: 'main',\n        },\n    });\n}\n\nexport function compileHighShaderGlProgram({ bits, name }: {bits: HighShaderBit[], name: string}): GlProgram\n{\n    return new GlProgram({\n        name,\n        ...compileHighShaderGl({\n            template: {\n                vertex: vertexGlTemplate,\n                fragment: fragmentGlTemplate,\n            },\n            bits: [\n                globalUniformsBitGl,\n                ...bits,\n            ]\n        })\n    });\n}\n", "export const colorBit = {\n    name: 'color-bit',\n    vertex: {\n        header: /* wgsl */`\n            @in aColor: vec4<f32>;\n        `,\n        main: /* wgsl */`\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n\nexport const colorBitGl = {\n    name: 'color-bit',\n    vertex: {\n        header: /* glsl */`\n            in vec4 aColor;\n        `,\n        main: /* glsl */`\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    }\n};\n", "import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n\n                ${generateBindingSrc(maxTextures)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n\n                ${generateSampleSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n\n                uniform sampler2D uTextures[${maxTextures}];\n\n            `,\n                main: `\n\n                ${generateSampleGlSrc(maxTextures)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n", "export const roundPixelsBit = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* wgsl */`\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\nexport const roundPixelsBitGl = {\n    name: 'round-pixels-bit',\n    vertex: {\n        header: /* glsl */`   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    }\n};\n\n", "// TODO add more types as required\nexport const UNIFORM_TYPES_VALUES = [\n    'f32',\n    'i32',\n    'vec2<f32>',\n    'vec3<f32>',\n    'vec4<f32>',\n    'mat2x2<f32>',\n    'mat3x3<f32>',\n    'mat4x4<f32>',\n    'mat3x2<f32>',\n    'mat4x2<f32>',\n    'mat2x3<f32>',\n    'mat4x3<f32>',\n    'mat2x4<f32>',\n    'mat3x4<f32>',\n    'vec2<i32>',\n    'vec3<i32>',\n    'vec4<i32>',\n] as const;\n\n/** useful for checking if a type is supported - a map of supported types with a true value. */\nexport const UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) =>\n{\n    acc[type] = true;\n\n    return acc;\n}, {} as Record<UNIFORM_TYPES, boolean>);\n\nexport type UNIFORM_TYPES_SINGLE = typeof UNIFORM_TYPES_VALUES[number];\n\ntype OPTIONAL_SPACE = ' ' | '';\n\nexport type UNIFORM_TYPES_ARRAY = `array<${UNIFORM_TYPES_SINGLE},${OPTIONAL_SPACE}${number}>`;\n\nexport type UNIFORM_TYPES = UNIFORM_TYPES_SINGLE | UNIFORM_TYPES_ARRAY;\n\nexport interface UniformData\n{\n    /** the value of the uniform, this could be any object - a parser will figure out how to write it to the buffer */\n    value: unknown;\n    type: UNIFORM_TYPES;\n    /** the size of the variable (eg 2 for vec2, 3 for vec3, 4 for vec4) */\n    size?: number;\n    name?: string;\n}\n\nexport interface UboElement\n{\n    data: UniformData;\n    offset: number;\n    size: number;\n}\n\nexport interface UboLayout\n{\n    uboElements: UboElement[];\n    /** float32 size // TODO change to bytes */\n    size: number;\n}\n\nexport type UniformsSyncCallback = (...args: any[]) => void;\n", "/**\n * @method defaultValue\n * @param {string} type - Type of value\n * @param {number} size\n * @private\n */\nexport function getDefaultUniformValue(\n    type: string,\n    size: number\n): number | Float32Array | Int32Array | Uint32Array | boolean | boolean[]\n{\n    switch (type)\n    {\n        case 'f32':\n            return 0;\n\n        case 'vec2<f32>':\n            return new Float32Array(2 * size);\n\n        case 'vec3<f32>':\n            return new Float32Array(3 * size);\n\n        case 'vec4<f32>':\n            return new Float32Array(4 * size);\n        case 'mat2x2<f32>':\n            return new Float32Array([1, 0,\n                0, 1]);\n\n        case 'mat3x3<f32>':\n            return new Float32Array([1, 0, 0,\n                0, 1, 0,\n                0, 0, 1]);\n\n        case 'mat4x4<f32>':\n            return new Float32Array([1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1]);\n    }\n\n    return null;\n}\n", "import { uid } from '../../../../utils/data/uid';\nimport { createIdFromString } from '../utils/createIdFromString';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES, type UniformData } from './types';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue';\n\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { Buffer } from '../buffer/Buffer';\n\ntype FLOPS<T = UniformData> = T extends { value: infer V } ? V : never;\n\n// TODO replace..T['value']\ntype ExtractUniformObject<T = Record<string, UniformData>> = {\n    [K in keyof T]: FLOPS<T[K]>;\n};\n\n/**\n * Uniform group options\n * @memberof rendering\n */\nexport type UniformGroupOptions = {\n    /**\n     * if true the UniformGroup is handled as an Uniform buffer object.\n     * This is the only way WebGPU can work with uniforms. WebGL2 can also use this.\n     * So don't set to true if you want to use WebGPU :D\n     */\n    ubo?: boolean;\n    /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n    isStatic?: boolean;\n};\n\n/**\n * Uniform group holds uniform map and some ID's for work\n *\n * `UniformGroup` has two modes:\n *\n * 1: Normal mode\n * Normal mode will upload the uniforms with individual function calls as required. This is the default mode\n * for WebGL rendering.\n *\n * 2: Uniform buffer mode\n * This mode will treat the uniforms as a uniform buffer. You can pass in either a buffer that you manually handle, or\n * or a generic object that PixiJS will automatically map to a buffer for you.\n * For maximum benefits, make Ubo UniformGroups static, and only update them each frame.\n * This is the only way uniforms can be used with WebGPU.\n *\n * Rules of UBOs:\n * - UBOs only work with WebGL2, so make sure you have a fallback!\n * - Only floats are supported (including vec[2,3,4], mat[2,3,4])\n * - Samplers cannot be used in ubo's (a GPU limitation)\n * - You must ensure that the object you pass in exactly matches in the shader ubo structure.\n * Otherwise, weirdness will ensue!\n * - The name of the ubo object added to the group must match exactly the name of the ubo in the shader.\n *\n * When declaring your uniform options, you ust parse in the value and the type of the uniform.\n * The types correspond to the WebGPU types {@link UNIFORM_TYPES}\n *\n Uniforms can be modified via the classes 'uniforms' property. It will contain all the uniforms declared in the constructor.\n *\n * ```glsl\n * // UBO in shader:\n * uniform myCoolData { // Declaring a UBO...\n *     mat4 uCoolMatrix;\n *     float uFloatyMcFloatFace;\n * };\n * ```\n *\n * ```js\n * // A new Uniform Buffer Object...\n * const myCoolData = new UniformGroup({\n *     uCoolMatrix: {value:new Matrix(), type: 'mat4<f32>'},\n *     uFloatyMcFloatFace: {value:23, type: 'f32'},\n * }}\n *\n * // modify the data\n * myCoolData.uniforms.uFloatyMcFloatFace = 42;\n * // Build a shader...\n * const shader = Shader.from(srcVert, srcFrag, {\n *     myCoolData // Name matches the UBO name in the shader. Will be processed accordingly.\n * })\n *\n *\n *  ```\n * @memberof rendering\n */\nexport class UniformGroup<UNIFORMS extends { [key: string]: UniformData } = any> implements BindResource\n{\n    /** The default options used by the uniform group. */\n    public static defaultOptions: UniformGroupOptions = {\n        /** if true the UniformGroup is handled as an Uniform buffer object. */\n        ubo: false,\n        /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n        isStatic: false,\n    };\n\n    /** used internally to know if a uniform group was used in the last render pass */\n    public _touched = 0;\n\n    /** a unique id for this uniform group used through the renderer */\n    public readonly uid: number = uid('uniform');\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    public _resourceType = 'uniformGroup';\n    /** the resource id used internally by the renderer to build bind group keys */\n    public _resourceId = uid('resource');\n    /** the structures of the uniform group */\n    public uniformStructures: UNIFORMS;\n    /** the uniforms as an easily accessible map of properties */\n    public uniforms: ExtractUniformObject<UNIFORMS>;\n    /** true if it should be used as a uniform buffer object */\n    public ubo: boolean;\n    /** an underlying buffer that will be uploaded to the GPU when using this UniformGroup */\n    public buffer?: Buffer;\n    /**\n     * if true, then you are responsible for when the data is uploaded to the GPU.\n     * otherwise, the data is reuploaded each frame.\n     */\n    public isStatic: boolean;\n    /** used ito identify if this is a uniform group */\n    public readonly isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    public _dirtyId = 0;\n    /**\n     * a signature string generated for internal use\n     * @internal\n     * @ignore\n     */\n    public readonly _signature: number;\n\n    // implementing the interface - UniformGroup are not destroyed\n    public readonly destroyed = false;\n\n    /**\n     * Create a new Uniform group\n     * @param uniformStructures - The structures of the uniform group\n     * @param options - The optional parameters of this uniform group\n     */\n    constructor(uniformStructures: UNIFORMS, options?: UniformGroupOptions)\n    {\n        options = { ...UniformGroup.defaultOptions, ...options };\n\n        this.uniformStructures = uniformStructures;\n\n        const uniforms = {} as ExtractUniformObject<UNIFORMS>;\n\n        for (const i in uniformStructures)\n        {\n            const uniformData = uniformStructures[i] as UniformData;\n\n            uniformData.name = i;\n            uniformData.size = uniformData.size ?? 1;\n\n            if (!UNIFORM_TYPES_MAP[uniformData.type])\n            {\n                // eslint-disable-next-line max-len\n                throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(', ')}`);\n            }\n\n            uniformData.value ??= getDefaultUniformValue(uniformData.type, uniformData.size);\n\n            uniforms[i] = uniformData.value as ExtractUniformObject<UNIFORMS>[keyof UNIFORMS];\n        }\n\n        this.uniforms = uniforms;\n\n        this._dirtyId = 1;\n        this.ubo = options.ubo;\n        this.isStatic = options.isStatic;\n\n        this._signature = createIdFromString(Object.keys(uniforms).map(\n            (i) => `${i}-${(uniformStructures[i as keyof typeof uniformStructures] as UniformData).type}`\n        ).join('-'), 'uniform-group');\n    }\n\n    /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n    public update(): void\n    {\n        this._dirtyId++;\n        // dispatch...\n    }\n}\n", "import { UniformGroup } from '../../shared/shader/UniformGroup';\n\nconst batchSamplersUniformGroupHash: Record<number, UniformGroup> = {};\n\n/**\n * Automatically generates a uniform group that holds the texture samplers for a shader.\n * This is used mainly by the shaders that batch textures!\n * @param maxTextures - the number of textures that this uniform group will contain.\n * @returns a uniform group that holds the texture samplers.\n */\nexport function getBatchSamplersUniformGroup(maxTextures: number)\n{\n    let batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures];\n\n    if (batchSamplersUniformGroup) return batchSamplersUniformGroup;\n\n    const sampleValues = new Int32Array(maxTextures);\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        sampleValues[i] = i;\n    }\n\n    batchSamplersUniformGroup = batchSamplersUniformGroupHash[maxTextures] = new UniformGroup({\n        uTextures: { value: sampleValues, type: `i32`, size: maxTextures }\n    }, { isStatic: true });\n\n    return batchSamplersUniformGroup;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid';\nimport { GlProgram } from '../../gl/shader/GlProgram';\nimport { BindGroup } from '../../gpu/shader/BindGroup';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram';\nimport { RendererType } from '../../types';\nimport { UniformGroup } from './UniformGroup';\n\nimport type { GlProgramOptions } from '../../gl/shader/GlProgram';\nimport type { BindResource } from '../../gpu/shader/BindResource';\nimport type { GpuProgramOptions } from '../../gpu/shader/GpuProgram';\n\n/**\n * A record of {@link BindGroup}'s used by the shader.\n *\n * `Record<number, BindGroup>`\n * @memberof rendering\n */\nexport type ShaderGroups = Record<number, BindGroup>;\n\ninterface ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram?: GlProgram\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram?: GpuProgram\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    compatibleRenderers?: number\n}\n\nexport interface GlShaderWith extends ShaderBase\n{\n    /** The WebGL program used by the WebGL renderer. */\n    glProgram: GlProgram\n}\n\nexport interface GpuShaderWith extends ShaderBase\n{\n    /** The WebGPU program used by the WebGPU renderer. */\n    gpuProgram: GpuProgram\n}\n\nexport interface ShaderWithGroupsDescriptor\n{\n    /** A record of {@link BindGroup}'s used by the shader. */\n    groups: ShaderGroups;\n    /** an optional map of how to bind the groups. This is automatically generated by reading the WebGPU program */\n    groupMap?: Record<string, Record<string, any>>;\n}\n\ninterface ShaderWithResourcesDescriptor\n{\n    /**\n     * A key value of uniform resources used by the shader.\n     * Under the hood pixi will look at the provided shaders and figure out where\n     * the resources are mapped. Its up to you to make sure the resource key\n     * matches the uniform name in the webGPU program. WebGL is a little more forgiving!\n     */\n    resources?: Record<string, any>;\n}\n\ninterface GroupsData\n{\n    group: number\n    binding: number\n    name: string\n}\n\n/**\n * A descriptor for a shader\n * @memberof rendering\n */\nexport type ShaderWith = GlShaderWith | GpuShaderWith;\n\n/**\n * A descriptor for a shader with groups.\n * @memberof rendering\n */\nexport type ShaderWithGroups = ShaderWithGroupsDescriptor & ShaderWith;\nexport interface IShaderWithGroups extends ShaderWithGroupsDescriptor, ShaderBase {}\n\n/**\n * A descriptor for a shader with resources. This is an easier way to work with uniforms.\n * especially when you are not working with bind groups\n * @memberof rendering\n */\nexport type ShaderWithResources = ShaderWithResourcesDescriptor & ShaderWith;\nexport interface IShaderWithResources extends ShaderWithResourcesDescriptor, ShaderBase {}\n\nexport type ShaderDescriptor = ShaderWithGroups & ShaderWithResources;\n\ntype GlShaderFromWith = {\n    gpu?: GpuProgramOptions,\n    gl: GlProgramOptions\n};\ntype GpuShaderFromWith = {\n    gpu: GpuProgramOptions,\n    gl?: GlProgramOptions\n};\nexport type ShaderFromGroups = (GlShaderFromWith | GpuShaderFromWith) & Omit<ShaderWithGroups, 'glProgram' | 'gpuProgram'>;\nexport type ShaderFromResources = (GlShaderFromWith | GpuShaderFromWith)\n& Omit<ShaderWithResources, 'glProgram' | 'gpuProgram'>;\n\n/**\n * The Shader class is an integral part of the PixiJS graphics pipeline.\n * Central to rendering in PixiJS are two key elements: A [shader] and a [geometry].\n * The shader incorporates a {@link GlProgram} for WebGL or a {@link GpuProgram} for WebGPU,\n * instructing the respective technology on how to render the geometry.\n *\n * The primary goal of the Shader class is to offer a unified interface compatible with both WebGL and WebGPU.\n * When constructing a shader, you need to provide both a WebGL program and a WebGPU program due to the distinctions\n * between the two rendering engines. If only one is provided, the shader won't function with the omitted renderer.\n *\n * Both WebGL and WebGPU utilize the same resource object when passed into the shader.\n * Post-creation, the shader's interface remains consistent across both WebGL and WebGPU.\n * The sole distinction lies in whether a glProgram or a gpuProgram is employed.\n *\n * Modifying shader uniforms, which can encompass:\n *  - TextureSampler {@link TextureStyle}\n *  - TextureSource {@link TextureSource}\n *  - UniformsGroups {@link UniformGroup}\n * @example\n *\n * const shader = new Shader({\n *     glProgram: glProgram,\n *     gpuProgram: gpuProgram,\n *     resources: {\n *         uTexture: texture.source,\n *         uSampler: texture.sampler,\n *         uColor: [1, 0, 0, 1],\n *     },\n * });\n *\n * // update the uniforms\n * shader.resources.uColor[1] = 1;\n * shader.resources.uTexture = texture2.source;\n * @class\n * @memberof rendering\n */\nexport class Shader extends EventEmitter<{'destroy': Shader}>\n{\n    /** A unique identifier for the shader */\n    public readonly uid: number = uid('shader');\n    /** An instance of the GPU program used by the WebGPU renderer */\n    public gpuProgram: GpuProgram;\n    /** An instance of the GL program used by the WebGL renderer */\n    public glProgram: GlProgram;\n    /**\n     * A number that uses two bits on whether the shader is compatible with the WebGL renderer and/or the WebGPU renderer.\n     * 0b00 - not compatible with either\n     * 0b01 - compatible with WebGL\n     * 0b10 - compatible with WebGPU\n     * This is automatically set based on if a {@link GlProgram} or {@link GpuProgram} is provided.\n     */\n    public readonly compatibleRenderers: number;\n    /** */\n    public groups: Record<number, BindGroup>;\n    /** A record of the resources used by the shader. */\n    public resources: Record<string, any>;\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    public _uniformBindMap: Record<number, Record<number, string>> = Object.create(null);\n    private readonly _ownedBindGroups: BindGroup[] = [];\n\n    /**\n     * Fired after rendering finishes.\n     * @event rendering.Shader#destroy\n     */\n\n    /**\n     * There are two ways to create a shader.\n     * one is to pass in resources which is a record of uniform groups and resources.\n     * another is to pass in groups which is a record of {@link BindGroup}s.\n     * this second method is really to make use of shared {@link BindGroup}s.\n     * For most cases you will want to use resources as they are easier to work with.\n     * USe Groups if you want to share {@link BindGroup}s between shaders.\n     * you cannot mix and match - either use resources or groups.\n     * @param {ShaderWithResourcesDescriptor} options - The options for the shader using ShaderWithResourcesDescriptor.\n     */\n    constructor(options: ShaderWithResources);\n    constructor(options: ShaderWithGroups);\n    constructor(options: ShaderDescriptor)\n    {\n        super();\n\n        /* eslint-disable prefer-const */\n        let {\n            gpuProgram,\n            glProgram,\n            groups,\n            resources,\n            compatibleRenderers,\n            groupMap\n        } = options;\n        /* eslint-enable prefer-const */\n\n        this.gpuProgram = gpuProgram;\n        this.glProgram = glProgram;\n\n        if (compatibleRenderers === undefined)\n        {\n            compatibleRenderers = 0;\n\n            if (gpuProgram)compatibleRenderers |= RendererType.WEBGPU;\n            if (glProgram)compatibleRenderers |= RendererType.WEBGL;\n        }\n\n        this.compatibleRenderers = compatibleRenderers;\n\n        const nameHash: Record<string, GroupsData> = {};\n\n        if (!resources && !groups)\n        {\n            resources = {};\n        }\n\n        if (resources && groups)\n        {\n            throw new Error('[Shader] Cannot have both resources and groups');\n        }\n        else if (!gpuProgram && groups && !groupMap)\n        {\n            throw new Error('[Shader] No group map or WebGPU shader provided - consider using resources instead.');\n        }\n        else if (!gpuProgram && groups && groupMap)\n        {\n            for (const i in groupMap)\n            {\n                for (const j in groupMap[i])\n                {\n                    const uniformName = groupMap[i][j];\n\n                    nameHash[uniformName] = {\n                        group: i as unknown as number,\n                        binding: j as unknown as number,\n                        name: uniformName\n                    };\n                }\n            }\n        }\n        else if (gpuProgram && groups && !groupMap)\n        {\n            const groupData = gpuProgram.structsAndGroups.groups;\n\n            groupMap = {};\n\n            groupData.forEach((data) =>\n            {\n                groupMap[data.group] = groupMap[data.group] || {};\n                groupMap[data.group][data.binding] = data.name;\n\n                nameHash[data.name] = data;\n            });\n        }\n        else if (resources)\n        {\n            groups = {};\n            groupMap = {};\n\n            if (gpuProgram)\n            {\n                const groupData = gpuProgram.structsAndGroups.groups;\n\n                groupData.forEach((data) =>\n                {\n                    groupMap[data.group] = groupMap[data.group] || {};\n                    groupMap[data.group][data.binding] = data.name;\n\n                    nameHash[data.name] = data;\n                });\n            }\n\n            let bindTick = 0;\n\n            for (const i in resources)\n            {\n                if (nameHash[i]) continue;\n\n                // build out a dummy bind group..\n                if (!groups[99])\n                {\n                    groups[99] = new BindGroup();\n                    this._ownedBindGroups.push(groups[99]);\n                }\n                // Yes i know this is a little strange, but wil line up the shaders neatly\n                // basically we want to be driven by how webGPU does things.\n                // so making a fake group will work and not affect gpu as it means no gpu shader was provided..\n                nameHash[i] = { group: 99, binding: bindTick, name: i };\n\n                groupMap[99] = groupMap[99] || {};\n                groupMap[99][bindTick] = i;\n\n                bindTick++;\n            }\n\n            for (const i in resources)\n            {\n                const name = i;\n                let value = resources[i];\n\n                if (!(value.source) && !(value as BindResource)._resourceType)\n                {\n                    value = new UniformGroup(value);\n                }\n\n                const data = nameHash[name];\n\n                if (data)\n                {\n                    if (!groups[data.group])\n                    {\n                        groups[data.group] = new BindGroup();\n\n                        this._ownedBindGroups.push(groups[data.group]);\n                    }\n\n                    groups[data.group].setResource(value, data.binding);\n                }\n            }\n        }\n\n        this.groups = groups;\n        this._uniformBindMap = groupMap;\n\n        this.resources = this._buildResourceAccessor(groups, nameHash);\n    }\n\n    /**\n     * Sometimes a resource group will be provided later (for example global uniforms)\n     * In such cases, this method can be used to let the shader know about the group.\n     * @param name - the name of the resource group\n     * @param groupIndex - the index of the group (should match the webGPU shader group location)\n     * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n     */\n    public addResource(name: string, groupIndex: number, bindIndex: number): void\n    {\n        this._uniformBindMap[groupIndex] ||= {};\n\n        this._uniformBindMap[groupIndex][bindIndex] ||= name;\n\n        if (!this.groups[groupIndex])\n        {\n            this.groups[groupIndex] = new BindGroup();\n            this._ownedBindGroups.push(this.groups[groupIndex]);\n        }\n    }\n\n    private _buildResourceAccessor(groups: ShaderGroups, nameHash: Record<string, GroupsData>)\n    {\n        const uniformsOut = {};\n\n        for (const i in nameHash)\n        {\n            const data = nameHash[i];\n\n            // add getter setter for uniforms\n            Object.defineProperty(uniformsOut, data.name, {\n                get()\n                {\n                    return groups[data.group].getResource(data.binding);\n                },\n                set(value)\n                {\n                    groups[data.group].setResource(value, data.binding);\n                }\n            });\n        }\n\n        return uniformsOut;\n    }\n\n    /**\n     * Use to destroy the shader when its not longer needed.\n     * It will destroy the resources and remove listeners.\n     * @param destroyPrograms - if the programs should be destroyed as well.\n     * Make sure its not being used by other shaders!\n     */\n    public destroy(destroyPrograms = false): void\n    {\n        this.emit('destroy', this);\n\n        if (destroyPrograms)\n        {\n            this.gpuProgram?.destroy();\n            this.glProgram?.destroy();\n        }\n\n        this.gpuProgram = null;\n        this.glProgram = null;\n\n        this.removeAllListeners();\n\n        this._uniformBindMap = null;\n\n        this._ownedBindGroups.forEach((bindGroup) =>\n        {\n            bindGroup.destroy();\n        });\n\n        (this._ownedBindGroups as null) = null;\n\n        this.resources = null;\n        this.groups = null;\n    }\n\n    /**\n     * A short hand function to create a shader based of a vertex and fragment shader.\n     * @param options\n     * @returns A shiny new PixiJS shader!\n     */\n    public static from(options: ShaderFromGroups): Shader;\n    public static from(options: ShaderFromResources): Shader;\n    public static from(options: ShaderFromGroups & ShaderFromResources): Shader\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Shader({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n", "import { compileHighShaderGlProgram, compileHighShaderGpuProgram } from '../../high-shader/compileHighShaderToProgram';\nimport { colorBit, colorBitGl } from '../../high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit, generateTextureBatchBitGl } from '../../high-shader/shader-bits/generateTextureBatchBit';\nimport { roundPixelsBit, roundPixelsBitGl } from '../../high-shader/shader-bits/roundPixelsBit';\nimport { getBatchSamplersUniformGroup } from '../../renderers/gl/shader/getBatchSamplersUniformGroup';\nimport { Shader } from '../../renderers/shared/shader/Shader';\n\n/**\n * DefaultShader is a specialized shader class designed for batch rendering.\n * It extends the base Shader class and provides functionality for handling\n * color, texture batching, and pixel rounding in both WebGL and WebGPU contexts.\n *\n * It is used by the default batcher\n * @extends Shader\n * @memberof rendering\n */\nexport class DefaultShader extends Shader\n{\n    constructor(maxTextures: number)\n    {\n        const glProgram = compileHighShaderGlProgram({\n            name: 'batch',\n            bits: [\n                colorBitGl,\n                generateTextureBatchBitGl(maxTextures),\n                roundPixelsBitGl,\n            ]\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'batch',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(maxTextures),\n                roundPixelsBit,\n            ]\n        });\n\n        super({\n            glProgram,\n            gpuProgram,\n            resources: {\n                batchSamplers: getBatchSamplersUniformGroup(maxTextures),\n            }\n        });\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Batcher } from './Batcher';\nimport { BatchGeometry } from './BatchGeometry';\nimport { DefaultShader } from './DefaultShader';\n\nimport type { Matrix } from '../../../maths/matrix/Matrix';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { BatchableMeshElement, BatchableQuadElement } from './Batcher';\n\nlet defaultShader: Shader = null;\n\n/**\n * Represents the common elements for default batch rendering.\n * This interface defines the properties that are used by the DefaultBatcher\n * to render elements efficiently in a batch.\n * @memberof rendering\n */\nexport interface DefaultBatchElements\n{\n    /**\n     * The color of the element that will be multiplied with the texture color.\n     * This is typically represented as a 32-bit integer in RGBA format.\n     */\n    color: number;\n\n    /**\n     * Determines whether the element should be rounded to the nearest pixel.\n     * - 0: No rounding (default)\n     * - 1: Round to nearest pixel\n     * This can help with visual consistency, especially for pixel art styles.\n     */\n    roundPixels: 0 | 1;\n\n    /**\n     * The transform matrix of the element.\n     * This matrix represents the position, scale, rotation, and skew of the element.\n     */\n    transform: Matrix;\n}\n\n/**\n * Represents a batchable quad element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableQuadElement extends BatchableQuadElement, DefaultBatchElements {}\n\n/**\n * Represents a batchable mesh element with default batch properties.\n * @memberof rendering\n */\nexport interface DefaultBatchableMeshElement extends BatchableMeshElement, DefaultBatchElements {}\n\n/**\n * The default batcher is used to batch quads and meshes. This batcher will batch the following elements:\n * - tints\n * - roundPixels\n * - texture\n * - transform\n * @memberof rendering\n */\nexport class DefaultBatcher extends Batcher\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.Batcher,\n        ],\n        name: 'default',\n    } as const;\n\n    public geometry = new BatchGeometry();\n    public shader = defaultShader || (defaultShader = new DefaultShader(this.maxTextures));\n\n    public name = DefaultBatcher.extension.name;\n\n    /** The size of one attribute. 1 = 32 bit. x, y, u, v, color, textureIdAndRound -> total = 6 */\n    public vertexSize = 6;\n\n    /**\n     * Packs the attributes of a DefaultBatchableMeshElement into the provided views.\n     * @param element - The DefaultBatchableMeshElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packAttributes(\n        element: DefaultBatchableMeshElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const { positions, uvs } = element;\n\n        const argb = element.color;\n\n        const offset = element.attributeOffset;\n        const end = offset + element.attributeSize;\n\n        for (let i = offset; i < end; i++)\n        {\n            const i2 = i * 2;\n\n            const x = positions[i2];\n            const y = positions[(i2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (d * y) + (b * x) + ty;\n\n            float32View[index++] = uvs[i2];\n            float32View[index++] = uvs[(i2) + 1];\n\n            uint32View[index++] = argb;\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n\n    /**\n     * Packs the attributes of a DefaultBatchableQuadElement into the provided views.\n     * @param element - The DefaultBatchableQuadElement to pack.\n     * @param float32View - The Float32Array view to pack into.\n     * @param uint32View - The Uint32Array view to pack into.\n     * @param index - The starting index in the views.\n     * @param textureId - The texture ID to use.\n     */\n    public packQuadAttributes(\n        element: DefaultBatchableQuadElement,\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const texture = element.texture;\n\n        const wt = element.transform;\n\n        const a = wt.a;\n        const b = wt.b;\n        const c = wt.c;\n        const d = wt.d;\n        const tx = wt.tx;\n        const ty = wt.ty;\n\n        const bounds = element.bounds;\n\n        const w0 = bounds.maxX;\n        const w1 = bounds.minX;\n        const h0 = bounds.maxY;\n        const h1 = bounds.minY;\n\n        const uvs = texture.uvs;\n\n        // _ _ _ _\n        // a b g r\n        const argb = element.color;\n\n        const textureIdAndRound = (textureId << 16) | (element.roundPixels & 0xFFFF);\n\n        float32View[index + 0] = (a * w1) + (c * h1) + tx;\n        float32View[index + 1] = (d * h1) + (b * w1) + ty;\n\n        float32View[index + 2] = uvs.x0;\n        float32View[index + 3] = uvs.y0;\n\n        uint32View[index + 4] = argb;\n        uint32View[index + 5] = textureIdAndRound;\n\n        // xy\n        float32View[index + 6] = (a * w0) + (c * h1) + tx;\n        float32View[index + 7] = (d * h1) + (b * w0) + ty;\n\n        float32View[index + 8] = uvs.x1;\n        float32View[index + 9] = uvs.y1;\n\n        uint32View[index + 10] = argb;\n        uint32View[index + 11] = textureIdAndRound;\n\n        // xy\n        float32View[index + 12] = (a * w0) + (c * h0) + tx;\n        float32View[index + 13] = (d * h0) + (b * w0) + ty;\n\n        float32View[index + 14] = uvs.x2;\n        float32View[index + 15] = uvs.y2;\n\n        uint32View[index + 16] = argb;\n        uint32View[index + 17] = textureIdAndRound;\n\n        // xy\n        float32View[index + 18] = (a * w1) + (c * h0) + tx;\n        float32View[index + 19] = (d * h0) + (b * w1) + ty;\n\n        float32View[index + 20] = uvs.x3;\n        float32View[index + 21] = uvs.y3;\n\n        uint32View[index + 22] = argb;\n        uint32View[index + 23] = textureIdAndRound;\n    }\n}\n\n", "import type { BLEND_MODES, CULL_MODES } from './const';\n\nconst blendModeIds = {\n    normal: 0,\n    add: 1,\n    multiply: 2,\n    screen: 3,\n    overlay: 4,\n    erase: 5,\n    'normal-npm': 6,\n    'add-npm': 7,\n    'screen-npm': 8,\n    min: 9,\n    max: 10,\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\n\n/**\n * This is a WebGL state, and is is passed to {@link StateSystem}.\n *\n * Each mesh rendered may require WebGL to be in a different state.\n * For example you may want different blend mode or to enable polygon offsets\n * @memberof rendering\n */\nexport class State\n{\n    /**\n     * The data is a unique number based on the states settings.\n     * This lets us quickly compare states with a single number rather than looking\n     * at all the individual settings.\n     */\n    public data: number;\n    public _blendModeId: number;\n    private _blendMode: BLEND_MODES;\n    private _polygonOffset: number;\n\n    constructor()\n    {\n        this.data = 0;\n\n        this.blendMode = 'normal';\n        this.polygonOffset = 0;\n\n        this.blend = true;\n        this.depthMask = true;\n    }\n\n    /**\n     * Activates blending of the computed fragment color values.\n     * @default true\n     */\n    get blend(): boolean\n    {\n        return !!(this.data & (1 << BLEND));\n    }\n\n    set blend(value: boolean)\n    {\n        if (!!(this.data & (1 << BLEND)) !== value)\n        {\n            this.data ^= (1 << BLEND);\n        }\n    }\n\n    /**\n     * Activates adding an offset to depth values of polygon's fragments\n     * @default false\n     */\n    get offsets(): boolean\n    {\n        return !!(this.data & (1 << OFFSET));\n    }\n\n    set offsets(value: boolean)\n    {\n        if (!!(this.data & (1 << OFFSET)) !== value)\n        {\n            this.data ^= (1 << OFFSET);\n        }\n    }\n\n    /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n    set cullMode(value: CULL_MODES)\n    {\n        if (value === 'none')\n        {\n            this.culling = false;\n\n            return;\n        }\n\n        this.culling = true;\n        this.clockwiseFrontFace = value === 'front';\n    }\n\n    get cullMode(): CULL_MODES\n    {\n        if (!this.culling)\n        {\n            return 'none';\n        }\n\n        return this.clockwiseFrontFace ? 'front' : 'back';\n    }\n\n    /**\n     * Activates culling of polygons.\n     * @default false\n     */\n    get culling(): boolean\n    {\n        return !!(this.data & (1 << CULLING));\n    }\n\n    set culling(value: boolean)\n    {\n        if (!!(this.data & (1 << CULLING)) !== value)\n        {\n            this.data ^= (1 << CULLING);\n        }\n    }\n\n    /**\n     * Activates depth comparisons and updates to the depth buffer.\n     * @default false\n     */\n    get depthTest(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_TEST));\n    }\n\n    set depthTest(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_TEST)) !== value)\n        {\n            this.data ^= (1 << DEPTH_TEST);\n        }\n    }\n\n    /**\n     * Enables or disables writing to the depth buffer.\n     * @default true\n     */\n    get depthMask(): boolean\n    {\n        return !!(this.data & (1 << DEPTH_MASK));\n    }\n\n    set depthMask(value: boolean)\n    {\n        if (!!(this.data & (1 << DEPTH_MASK)) !== value)\n        {\n            this.data ^= (1 << DEPTH_MASK);\n        }\n    }\n\n    /**\n     * Specifies whether or not front or back-facing polygons can be culled.\n     * @default false\n     */\n    get clockwiseFrontFace(): boolean\n    {\n        return !!(this.data & (1 << WINDING));\n    }\n\n    set clockwiseFrontFace(value: boolean)\n    {\n        if (!!(this.data & (1 << WINDING)) !== value)\n        {\n            this.data ^= (1 << WINDING);\n        }\n    }\n\n    /**\n     * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n     * @default 'normal'\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value: BLEND_MODES)\n    {\n        this.blend = (value !== 'none');\n        this._blendMode = value;\n        this._blendModeId = blendModeIds[value as keyof typeof blendModeIds] || 0;\n    }\n\n    /**\n     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n     * @default 0\n     */\n    get polygonOffset(): number\n    {\n        return this._polygonOffset;\n    }\n\n    set polygonOffset(value: number)\n    {\n        this.offsets = !!value;\n        this._polygonOffset = value;\n    }\n\n    // #if _DEBUG\n    public toString(): string\n    {\n        return `[pixi.js/core:State `\n            + `blendMode=${this.blendMode} `\n            + `clockwiseFrontFace=${this.clockwiseFrontFace} `\n            + `culling=${this.culling} `\n            + `depthMask=${this.depthMask} `\n            + `polygonOffset=${this.polygonOffset}`\n            + `]`;\n    }\n    // #endif\n\n    /**\n     * A quickly getting an instance of a State that is configured for 2d rendering.\n     * @returns a new State with values set for 2d rendering\n     */\n    public static for2d(): State\n    {\n        const state = new State();\n\n        state.depthTest = false;\n        state.blend = true;\n\n        return state;\n    }\n\n    public static default2d = State.for2d();\n}\n\n", "export function colorToUniform(rgb: number, alpha: number, out: Float32Array, offset: number)\n{\n    // TODO replace with Color..\n    out[offset++] = ((rgb >> 16) & 0xFF) / 255;\n    out[offset++] = ((rgb >> 8) & 0xFF) / 255;\n    out[offset++] = (rgb & 0xFF) / 255;\n    out[offset++] = alpha;\n}\n\nexport function color32BitToUniform(abgr: number, out: Float32Array, offset: number)\n{\n    const alpha = ((abgr >> 24) & 0xFF) / 255;\n\n    out[offset++] = ((abgr & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 8) & 0xFF) / 255) * alpha;\n    out[offset++] = (((abgr >> 16) & 0xFF) / 255) * alpha;\n    out[offset++] = alpha;\n}\n", "import type { Matrix } from '../../maths/matrix/Matrix';\nimport type { Batch, Batcher } from '../../rendering/batcher/shared/Batcher';\nimport type { DefaultBatchableQuadElement } from '../../rendering/batcher/shared/DefaultBatcher';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { BoundsData } from '../container/bounds/Bounds';\nimport type { Container } from '../container/Container';\n\n/**\n * A batchable sprite object.\n * @ignore\n */\nexport class BatchableSprite implements DefaultBatchableQuadElement\n{\n    public batcherName = 'default';\n    public topology: Topology = 'triangle-list';\n\n    // batch specific..\n    public readonly attributeSize = 4;\n    public readonly indexSize = 6;\n    public readonly packAsQuad = true;\n\n    public transform: Matrix;\n\n    public renderable: Container;\n    public texture: Texture;\n    public bounds: BoundsData;\n\n    public roundPixels: 0 | 1 = 0;\n\n    public _indexStart: number;\n    public _textureId: number;\n    public _attributeStart = 0; // location in the buffer\n    public _batcher: Batcher = null;\n    public _batch: Batch = null;\n\n    get blendMode() { return this.renderable.groupBlendMode; }\n    get color() { return this.renderable.groupColorAlpha; }\n\n    public reset()\n    {\n        this.renderable = null;\n        this.texture = null;\n        this._batcher = null;\n        this._batch = null;\n        this.bounds = null;\n    }\n}\n", "export const localUniformBit = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* wgsl */`\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n};\n\n// TODO this works, but i think down the road it will be better to manage groups automatically if there are clashes\nexport const localUniformBitGroup2 = {\n    ...localUniformBit,\n    vertex: {\n        ...localUniformBit.vertex,\n        // replace the group!\n        header: localUniformBit.vertex.header.replace('group(1)', 'group(2)'),\n    }\n};\n\nexport const localUniformBitGl = {\n    name: 'local-uniform-bit',\n    vertex: {\n        header: /* glsl */`\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n};\n"],
  "mappings": "iDAAA,IAAAA,GAAAC,GAAA,CAAAC,GAAAC,KAAA,cAEA,IAAIC,GAAM,OAAO,UAAU,eACvBC,EAAS,IASb,SAASC,IAAS,CAAC,CASf,OAAO,SACTA,GAAO,UAAY,OAAO,OAAO,IAAI,EAMhC,IAAIA,GAAO,EAAE,YAAWD,EAAS,KAYxC,SAASE,GAAGC,EAAIC,EAASC,EAAM,CAC7B,KAAK,GAAKF,EACV,KAAK,QAAUC,EACf,KAAK,KAAOC,GAAQ,EACtB,CAaA,SAASC,GAAYC,EAASC,EAAOL,EAAIC,EAASC,EAAM,CACtD,GAAI,OAAOF,GAAO,WAChB,MAAM,IAAI,UAAU,iCAAiC,EAGvD,IAAIM,EAAW,IAAIP,GAAGC,EAAIC,GAAWG,EAASF,CAAI,EAC9CK,EAAMV,EAASA,EAASQ,EAAQA,EAEpC,OAAKD,EAAQ,QAAQG,CAAG,EACdH,EAAQ,QAAQG,CAAG,EAAE,GAC1BH,EAAQ,QAAQG,CAAG,EAAI,CAACH,EAAQ,QAAQG,CAAG,EAAGD,CAAQ,EADxBF,EAAQ,QAAQG,CAAG,EAAE,KAAKD,CAAQ,GAD1CF,EAAQ,QAAQG,CAAG,EAAID,EAAUF,EAAQ,gBAI7DA,CACT,CASA,SAASI,GAAWJ,EAASG,EAAK,CAC5B,EAAEH,EAAQ,eAAiB,EAAGA,EAAQ,QAAU,IAAIN,GACnD,OAAOM,EAAQ,QAAQG,CAAG,CACjC,CASA,SAASE,GAAe,CACtB,KAAK,QAAU,IAAIX,GACnB,KAAK,aAAe,CACtB,CASAW,EAAa,UAAU,WAAa,UAAsB,CACxD,IAAIC,EAAQ,CAAC,EACTC,EACAC,EAEJ,GAAI,KAAK,eAAiB,EAAG,OAAOF,EAEpC,IAAKE,KAASD,EAAS,KAAK,QACtBf,GAAI,KAAKe,EAAQC,CAAI,GAAGF,EAAM,KAAKb,EAASe,EAAK,MAAM,CAAC,EAAIA,CAAI,EAGtE,OAAI,OAAO,sBACFF,EAAM,OAAO,OAAO,sBAAsBC,CAAM,CAAC,EAGnDD,CACT,EASAD,EAAa,UAAU,UAAY,SAAmBJ,EAAO,CAC3D,IAAIE,EAAMV,EAASA,EAASQ,EAAQA,EAChCQ,EAAW,KAAK,QAAQN,CAAG,EAE/B,GAAI,CAACM,EAAU,MAAO,CAAC,EACvB,GAAIA,EAAS,GAAI,MAAO,CAACA,EAAS,EAAE,EAEpC,QAASC,EAAI,EAAGC,EAAIF,EAAS,OAAQG,EAAK,IAAI,MAAMD,CAAC,EAAGD,EAAIC,EAAGD,IAC7DE,EAAGF,CAAC,EAAID,EAASC,CAAC,EAAE,GAGtB,OAAOE,CACT,EASAP,EAAa,UAAU,cAAgB,SAAuBJ,EAAO,CACnE,IAAIE,EAAMV,EAASA,EAASQ,EAAQA,EAChCY,EAAY,KAAK,QAAQV,CAAG,EAEhC,OAAKU,EACDA,EAAU,GAAW,EAClBA,EAAU,OAFM,CAGzB,EASAR,EAAa,UAAU,KAAO,SAAcJ,EAAOa,EAAIC,EAAIC,EAAIC,EAAIC,EAAI,CACrE,IAAIf,EAAMV,EAASA,EAASQ,EAAQA,EAEpC,GAAI,CAAC,KAAK,QAAQE,CAAG,EAAG,MAAO,GAE/B,IAAIU,EAAY,KAAK,QAAQV,CAAG,EAC5BgB,EAAM,UAAU,OAChBC,EACAV,EAEJ,GAAIG,EAAU,GAAI,CAGhB,OAFIA,EAAU,MAAM,KAAK,eAAeZ,EAAOY,EAAU,GAAI,OAAW,EAAI,EAEpEM,EAAK,CACX,IAAK,GAAG,OAAON,EAAU,GAAG,KAAKA,EAAU,OAAO,EAAG,GACrD,IAAK,GAAG,OAAOA,EAAU,GAAG,KAAKA,EAAU,QAASC,CAAE,EAAG,GACzD,IAAK,GAAG,OAAOD,EAAU,GAAG,KAAKA,EAAU,QAASC,EAAIC,CAAE,EAAG,GAC7D,IAAK,GAAG,OAAOF,EAAU,GAAG,KAAKA,EAAU,QAASC,EAAIC,EAAIC,CAAE,EAAG,GACjE,IAAK,GAAG,OAAOH,EAAU,GAAG,KAAKA,EAAU,QAASC,EAAIC,EAAIC,EAAIC,CAAE,EAAG,GACrE,IAAK,GAAG,OAAOJ,EAAU,GAAG,KAAKA,EAAU,QAASC,EAAIC,EAAIC,EAAIC,EAAIC,CAAE,EAAG,EAC3E,CAEA,IAAKR,EAAI,EAAGU,EAAO,IAAI,MAAMD,EAAK,CAAC,EAAGT,EAAIS,EAAKT,IAC7CU,EAAKV,EAAI,CAAC,EAAI,UAAUA,CAAC,EAG3BG,EAAU,GAAG,MAAMA,EAAU,QAASO,CAAI,CAC5C,KAAO,CACL,IAAIC,EAASR,EAAU,OACnBS,EAEJ,IAAKZ,EAAI,EAAGA,EAAIW,EAAQX,IAGtB,OAFIG,EAAUH,CAAC,EAAE,MAAM,KAAK,eAAeT,EAAOY,EAAUH,CAAC,EAAE,GAAI,OAAW,EAAI,EAE1ES,EAAK,CACX,IAAK,GAAGN,EAAUH,CAAC,EAAE,GAAG,KAAKG,EAAUH,CAAC,EAAE,OAAO,EAAG,MACpD,IAAK,GAAGG,EAAUH,CAAC,EAAE,GAAG,KAAKG,EAAUH,CAAC,EAAE,QAASI,CAAE,EAAG,MACxD,IAAK,GAAGD,EAAUH,CAAC,EAAE,GAAG,KAAKG,EAAUH,CAAC,EAAE,QAASI,EAAIC,CAAE,EAAG,MAC5D,IAAK,GAAGF,EAAUH,CAAC,EAAE,GAAG,KAAKG,EAAUH,CAAC,EAAE,QAASI,EAAIC,EAAIC,CAAE,EAAG,MAChE,QACE,GAAI,CAACI,EAAM,IAAKE,EAAI,EAAGF,EAAO,IAAI,MAAMD,EAAK,CAAC,EAAGG,EAAIH,EAAKG,IACxDF,EAAKE,EAAI,CAAC,EAAI,UAAUA,CAAC,EAG3BT,EAAUH,CAAC,EAAE,GAAG,MAAMG,EAAUH,CAAC,EAAE,QAASU,CAAI,CACpD,CAEJ,CAEA,MAAO,EACT,EAWAf,EAAa,UAAU,GAAK,SAAYJ,EAAOL,EAAIC,EAAS,CAC1D,OAAOE,GAAY,KAAME,EAAOL,EAAIC,EAAS,EAAK,CACpD,EAWAQ,EAAa,UAAU,KAAO,SAAcJ,EAAOL,EAAIC,EAAS,CAC9D,OAAOE,GAAY,KAAME,EAAOL,EAAIC,EAAS,EAAI,CACnD,EAYAQ,EAAa,UAAU,eAAiB,SAAwBJ,EAAOL,EAAIC,EAASC,EAAM,CACxF,IAAIK,EAAMV,EAASA,EAASQ,EAAQA,EAEpC,GAAI,CAAC,KAAK,QAAQE,CAAG,EAAG,OAAO,KAC/B,GAAI,CAACP,EACH,OAAAQ,GAAW,KAAMD,CAAG,EACb,KAGT,IAAIU,EAAY,KAAK,QAAQV,CAAG,EAEhC,GAAIU,EAAU,GAEVA,EAAU,KAAOjB,IAChB,CAACE,GAAQe,EAAU,QACnB,CAAChB,GAAWgB,EAAU,UAAYhB,IAEnCO,GAAW,KAAMD,CAAG,MAEjB,CACL,QAASO,EAAI,EAAGH,EAAS,CAAC,EAAGc,EAASR,EAAU,OAAQH,EAAIW,EAAQX,KAEhEG,EAAUH,CAAC,EAAE,KAAOd,GACnBE,GAAQ,CAACe,EAAUH,CAAC,EAAE,MACtBb,GAAWgB,EAAUH,CAAC,EAAE,UAAYb,IAErCU,EAAO,KAAKM,EAAUH,CAAC,CAAC,EAOxBH,EAAO,OAAQ,KAAK,QAAQJ,CAAG,EAAII,EAAO,SAAW,EAAIA,EAAO,CAAC,EAAIA,EACpEH,GAAW,KAAMD,CAAG,CAC3B,CAEA,OAAO,IACT,EASAE,EAAa,UAAU,mBAAqB,SAA4BJ,EAAO,CAC7E,IAAIE,EAEJ,OAAIF,GACFE,EAAMV,EAASA,EAASQ,EAAQA,EAC5B,KAAK,QAAQE,CAAG,GAAGC,GAAW,KAAMD,CAAG,IAE3C,KAAK,QAAU,IAAIT,GACnB,KAAK,aAAe,GAGf,IACT,EAKAW,EAAa,UAAU,IAAMA,EAAa,UAAU,eACpDA,EAAa,UAAU,YAAcA,EAAa,UAAU,GAK5DA,EAAa,SAAWZ,EAKxBY,EAAa,aAAeA,EAKR,OAAOd,GAAvB,MACFA,GAAO,QAAUc,KCvSd,IAAAkB,GAAAA,IAGDA,EAAA,YAAc,cAGdA,EAAA,WAAa,cAEbA,EAAA,kBAAoB,sBAEpBA,EAAA,YAAc,eAGdA,EAAA,YAAc,eAEdA,EAAA,mBAAqB,uBAErBA,EAAA,aAAe,gBAGfA,EAAA,aAAe,gBAEfA,EAAA,mBAAqB,uBAErBA,EAAA,YAAc,eAGdA,EAAA,MAAQ,QAERA,EAAA,WAAa,cAEbA,EAAA,cAAgB,iBAEhBA,EAAA,YAAc,eAEdA,EAAA,gBAAkB,mBAGlBA,EAAA,WAAa,cAGbA,EAAA,UAAY,aAGZA,EAAA,cAAgB,iBAGhBA,EAAA,YAAc,cAGdA,EAAA,aAAe,gBAGfA,EAAA,QAAU,UArDTA,IAAAA,GAAA,CAAA,CAAA,EAgHCC,GAAsBC,GAC5B,CAEI,GAAI,OAAOA,GAAQ,YAAe,OAAOA,GAAQ,UAAYA,EAAI,UACjE,CAEQ,GAAA,CAACA,EAAI,UAEC,MAAA,IAAI,MAAM,+CAA+C,EAOnEA,EAAM,CAAE,GAJoC,OAAOA,EAAI,WAAc,SAC/D,CAAE,KAAMA,EAAI,SAAU,EACtBA,EAAI,UAEW,IAAKA,CAAI,CAAA,CAE9B,GAAA,OAAOA,GAAQ,SAETA,EAAA,CAAE,GAAGA,CAAI,MAIT,OAAA,IAAI,MAAM,wBAAwB,EAGxC,OAAA,OAAOA,EAAI,MAAS,WAEhBA,EAAA,KAAO,CAACA,EAAI,IAAI,GAGjBA,CACX,EAUaC,GAA6B,CAACD,EAA4BE,IACnEH,GAAmBC,CAAG,EAAE,UAAYE,EAoBlCC,GAAa,CAGf,aAAc,CAAA,EAGd,gBAAiB,CAAA,EAGjB,OAAQ,CAAA,EAOR,UAAUA,EACV,CACIA,OAAAA,EAAW,IAAIJ,EAAkB,EAAE,QAASC,GAC5C,CACQA,EAAA,KAAK,QAASI,GAAS,KAAK,gBAAgBA,CAAI,IAAIJ,CAAG,CAAC,CAAA,CAC/D,EAEM,IAAA,EAQX,OAAOG,EACP,CAEIA,OAAAA,EAAW,IAAIJ,EAAkB,EAAE,QAASC,GAC5C,CACQA,EAAA,KAAK,QAASI,GAClB,CACI,IAAMC,EAAW,KAAK,aAChBC,EAAQ,KAAK,OAEdD,EAASD,CAAI,EAOLC,EAAAD,CAAI,IAAIJ,CAAG,GALpBM,EAAMF,CAAI,EAAIE,EAAMF,CAAI,GAAK,CAAA,EACvBE,EAAAF,CAAI,GAAG,KAAKJ,CAAG,EAKzB,CACH,CAAA,CACJ,EAEM,IAAA,EAUX,OAAOI,EAAqBG,EAAyBC,EACrD,CACI,IAAMC,EAAc,KAAK,aACnBC,EAAiB,KAAK,gBAG5B,GAAID,EAAYL,CAAI,GAAKM,EAAeN,CAAI,EAExC,MAAM,IAAI,MAAM,kBAAkBA,CAAI,wBAAwB,EAIlEK,EAAYL,CAAI,EAAIG,EACpBG,EAAeN,CAAI,EAAII,EAGvB,IAAMF,EAAQ,KAAK,OAGf,OAAAA,EAAMF,CAAI,IAEVE,EAAMF,CAAI,GAAG,QAASJ,GAAQO,EAAMP,CAAG,CAAC,EACxC,OAAOM,EAAMF,CAAI,GAGd,IAAA,EASX,YAAYA,EAAqBO,EACjC,CACI,OAAO,KAAK,OAAOP,EACdQ,GACD,CACQA,EAAU,OAEND,EAAAC,EAAU,IAAI,EAAIA,EAAU,IACpC,EAEHA,GACD,CACQA,EAAU,MAEH,OAAAD,EAAIC,EAAU,IAAI,CAC7B,CACJ,CACJ,EAUJ,kBAAkBR,EAAqBO,EAAmCT,EAAkB,GAC5F,CACI,OAAO,KAAK,OACRE,EACCQ,GACD,CACkBD,EAAI,UAAWE,GAASA,EAAK,OAASD,EAAU,IAAI,GAErD,IAETD,EAAA,KAAK,CAAE,KAAMC,EAAU,KAAM,MAAOA,EAAU,GAAA,CAAK,EACvDD,EAAI,KAAK,CAACG,EAAGC,IACTd,GAA2Bc,EAAE,MAAOb,CAAe,EACjDD,GAA2Ba,EAAE,MAAOZ,CAAe,CAAC,EAAA,EAE7DU,GACD,CACU,IAAAI,EAAQL,EAAI,UAAWE,GAASA,EAAK,OAASD,EAAU,IAAI,EAE9DI,IAAU,IAENL,EAAA,OAAOK,EAAO,CAAC,CACvB,CACJ,CACJ,EAUJ,aAAaZ,EAAqBa,EAAaf,EAAkB,GACjE,CACI,OAAO,KAAK,OACRE,EACCQ,GACD,CACQK,EAAK,SAASL,EAAU,GAAG,IAK1BK,EAAA,KAAKL,EAAU,GAAG,EAClBK,EAAA,KAAK,CAACH,EAAGC,IACVd,GAA2Bc,EAAGb,CAAe,EAAID,GAA2Ba,EAAGZ,CAAe,CAAC,EAAA,EAEtGU,GACD,CACI,IAAMI,EAAQC,EAAK,QAAQL,EAAU,GAAG,EAEpCI,IAAU,IAELC,EAAA,OAAOD,EAAO,CAAC,CACxB,CACJ,CACJ,EAQJ,MAAME,KAAgBC,EACtB,CAEI,QAAWC,KAAUD,EAEjB,OAAO,iBAAiBD,EAAO,UAAW,OAAO,0BAA0BE,CAAM,CAAC,CACtF,CAER,EC5ZA,IAAAC,GAAyB,WAGzB,IAAOC,EAAQ,GAAAC,QCHf,IAAIC,GAAE,CAAC,KAAK,GAAG,KAAK,IAAI,IAAI,KAAK,EAAE,KAAK,GAAG,EAAEC,EAAE,SAASD,EAAE,CAAC,OAAgB,OAAOA,GAAjB,SAAmBA,EAAE,OAAO,EAAY,OAAOA,GAAjB,QAAkB,EAAEE,EAAE,SAASF,EAAE,EAAEE,EAAE,CAAC,OAAgB,IAAT,SAAa,EAAE,GAAYA,IAAT,SAAaA,EAAE,KAAK,IAAI,GAAG,CAAC,GAAG,KAAK,MAAMA,EAAEF,CAAC,EAAEE,EAAE,CAAC,EAAEC,EAAE,SAASH,EAAE,EAAEE,EAAE,CAAC,OAAgB,IAAT,SAAa,EAAE,GAAYA,IAAT,SAAaA,EAAE,GAAGF,EAAEE,EAAEA,EAAEF,EAAE,EAAEA,EAAE,CAAC,EAAEI,GAAE,SAASJ,EAAE,CAAC,OAAOA,EAAE,SAASA,CAAC,EAAEA,EAAE,IAAI,GAAG,EAAEA,EAAEA,EAAE,GAAG,EAAEK,GAAE,SAASL,EAAE,CAAC,MAAM,CAAC,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,CAAC,CAAC,CAAC,EAAEM,GAAE,SAASN,EAAE,CAAC,MAAM,CAAC,EAAEE,EAAEF,EAAE,CAAC,EAAE,EAAEE,EAAEF,EAAE,CAAC,EAAE,EAAEE,EAAEF,EAAE,CAAC,EAAE,EAAEE,EAAEF,EAAE,EAAE,CAAC,CAAC,CAAC,EAAEO,GAAE,sBAAsBC,GAAE,SAASR,EAAE,CAAC,IAAI,EAAEA,EAAE,SAAS,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,EAAES,GAAE,SAAST,EAAE,CAAC,IAAI,EAAEA,EAAE,EAAEE,EAAEF,EAAE,EAAEG,EAAEH,EAAE,EAAEI,EAAEJ,EAAE,EAAEK,EAAE,KAAK,IAAI,EAAEH,EAAEC,CAAC,EAAE,EAAEE,EAAE,KAAK,IAAI,EAAEH,EAAEC,CAAC,EAAEI,EAAE,EAAEF,IAAI,GAAGH,EAAEC,GAAG,EAAEE,IAAIH,EAAE,GAAGC,EAAE,GAAG,EAAE,GAAG,EAAED,GAAG,EAAE,EAAE,MAAM,CAAC,EAAE,IAAIK,EAAE,EAAEA,EAAE,EAAEA,GAAG,EAAEF,EAAE,EAAEA,EAAE,IAAI,EAAE,EAAEA,EAAE,IAAI,IAAI,EAAED,CAAC,CAAC,EAAEM,GAAE,SAASV,EAAE,CAAC,IAAI,EAAEA,EAAE,EAAEE,EAAEF,EAAE,EAAEG,EAAEH,EAAE,EAAEI,EAAEJ,EAAE,EAAE,EAAE,EAAE,IAAI,EAAEE,GAAG,IAAIC,GAAG,IAAI,IAAIE,EAAE,KAAK,MAAM,CAAC,EAAE,EAAEF,GAAG,EAAED,GAAGK,EAAEJ,GAAG,GAAG,EAAEE,GAAGH,GAAGM,EAAEL,GAAG,GAAG,EAAE,EAAEE,GAAGH,GAAGO,EAAEJ,EAAE,EAAE,MAAM,CAAC,EAAE,IAAI,CAACF,EAAEI,EAAE,EAAE,EAAEC,EAAEL,CAAC,EAAEM,CAAC,EAAE,EAAE,IAAI,CAACD,EAAEL,EAAEA,EAAEI,EAAE,EAAE,CAAC,EAAEE,CAAC,EAAE,EAAE,IAAI,CAAC,EAAE,EAAED,EAAEL,EAAEA,EAAEI,CAAC,EAAEE,CAAC,EAAE,EAAEL,CAAC,CAAC,EAAEO,GAAE,SAASX,EAAE,CAAC,MAAM,CAAC,EAAEI,GAAEJ,EAAE,CAAC,EAAE,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,CAAC,CAAC,CAAC,EAAEY,GAAE,SAASZ,EAAE,CAAC,MAAM,CAAC,EAAEE,EAAEF,EAAE,CAAC,EAAE,EAAEE,EAAEF,EAAE,CAAC,EAAE,EAAEE,EAAEF,EAAE,CAAC,EAAE,EAAEE,EAAEF,EAAE,EAAE,CAAC,CAAC,CAAC,EAAEa,GAAE,SAASb,EAAE,CAAC,OAAOU,IAAGR,GAAG,EAAEF,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,GAAGE,KAAKC,EAAE,EAAE,GAAG,GAAGA,EAAE,IAAIA,GAAG,KAAK,EAAE,EAAED,GAAGC,EAAED,GAAG,IAAI,EAAE,EAAEC,EAAED,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,IAAI,EAAEA,EAAEC,CAAC,EAAEW,GAAE,SAASd,EAAE,CAAC,MAAM,CAAC,GAAG,EAAES,GAAET,CAAC,GAAG,EAAE,GAAGI,GAAG,KAAKF,EAAE,EAAE,KAAKC,EAAE,EAAE,GAAG,KAAK,GAAGC,EAAE,IAAIF,EAAEC,EAAE,KAAKC,GAAG,IAAIA,EAAE,IAAIA,GAAG,IAAI,EAAE,EAAEA,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,IAAI,EAAEF,EAAEC,EAAEC,CAAC,EAAEW,GAAE,yIAAyIC,GAAE,kIAAkIC,GAAE,+HAA+HC,GAAE,wHAAwHC,GAAE,CAAC,OAAO,CAAC,CAAC,SAASnB,EAAE,CAAC,IAAI,EAAEO,GAAE,KAAKP,CAAC,EAAE,OAAO,GAAGA,EAAE,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,SAASA,EAAE,CAAC,EAAEA,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,SAASA,EAAE,CAAC,EAAEA,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,SAASA,EAAE,CAAC,EAAEA,EAAE,CAAC,EAAE,EAAE,EAAE,EAAMA,EAAE,SAAN,EAAaE,EAAE,SAASF,EAAE,CAAC,EAAEA,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,EAAMA,EAAE,SAAN,GAAkBA,EAAE,SAAN,EAAa,CAAC,EAAE,SAASA,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,SAASA,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,SAASA,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,EAAMA,EAAE,SAAN,EAAaE,EAAE,SAASF,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE,CAAC,EAAE,KAAK,IAAI,EAAE,KAAK,EAAE,CAAC,SAASA,EAAE,CAAC,IAAI,EAAEiB,GAAE,KAAKjB,CAAC,GAAGkB,GAAE,KAAKlB,CAAC,EAAE,OAAO,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,EAAE,KAAKK,GAAE,CAAC,EAAE,OAAO,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,IAAI,GAAG,EAAE,OAAO,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,IAAI,GAAG,EAAE,OAAO,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,IAAI,GAAG,EAAW,EAAE,CAAC,IAAZ,OAAc,EAAE,OAAO,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,SAASJ,EAAE,CAAC,IAAIC,EAAEa,GAAE,KAAKd,CAAC,GAAGe,GAAE,KAAKf,CAAC,EAAE,GAAG,CAACC,EAAE,OAAO,KAAK,IAAI,EAAEE,EAAEC,EAAEM,GAAE,CAAC,GAAG,EAAET,EAAE,CAAC,EAAEE,EAAEF,EAAE,CAAC,EAAWE,IAAT,SAAaA,EAAE,OAAO,OAAO,CAAC,GAAGJ,GAAEI,CAAC,GAAG,IAAI,EAAE,OAAOF,EAAE,CAAC,CAAC,EAAE,EAAE,OAAOA,EAAE,CAAC,CAAC,EAAE,EAAWA,EAAE,CAAC,IAAZ,OAAc,EAAE,OAAOA,EAAE,CAAC,CAAC,GAAGA,EAAE,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,OAAOW,GAAER,CAAC,CAAC,EAAE,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,SAASL,EAAE,CAAC,IAAIE,EAAEF,EAAE,EAAE,EAAEA,EAAE,EAAEI,EAAEJ,EAAE,EAAEM,EAAEN,EAAE,EAAEO,EAAWD,IAAT,OAAW,EAAEA,EAAE,OAAOL,EAAEC,CAAC,GAAGD,EAAE,CAAC,GAAGA,EAAEG,CAAC,EAAEC,GAAE,CAAC,EAAE,OAAOH,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,OAAOE,CAAC,EAAE,EAAE,OAAOG,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,CAAC,SAASP,EAAE,CAAC,IAAIE,EAAEF,EAAE,EAAE,EAAEA,EAAE,EAAEI,EAAEJ,EAAE,EAAEK,EAAEL,EAAE,EAAEM,EAAWD,IAAT,OAAW,EAAEA,EAAE,GAAG,CAACJ,EAAEC,CAAC,GAAG,CAACD,EAAE,CAAC,GAAG,CAACA,EAAEG,CAAC,EAAE,OAAO,KAAK,IAAIG,EAAEI,GAAE,CAAC,EAAE,OAAOT,CAAC,EAAE,EAAE,OAAO,CAAC,EAAE,EAAE,OAAOE,CAAC,EAAE,EAAE,OAAOE,CAAC,CAAC,CAAC,EAAE,OAAOO,GAAEN,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,SAASP,EAAE,CAAC,IAAIE,EAAEF,EAAE,EAAEK,EAAEL,EAAE,EAAEM,EAAEN,EAAE,EAAEO,EAAEP,EAAE,EAAEQ,EAAWD,IAAT,OAAW,EAAEA,EAAE,GAAG,CAACN,EAAEC,CAAC,GAAG,CAACD,EAAEI,CAAC,GAAG,CAACJ,EAAEK,CAAC,EAAE,OAAO,KAAK,IAAIG,EAAE,SAAST,EAAE,CAAC,MAAM,CAAC,EAAEI,GAAEJ,EAAE,CAAC,EAAE,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,EAAE,EAAE,GAAG,EAAE,EAAEG,EAAEH,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,OAAOE,CAAC,EAAE,EAAE,OAAOG,CAAC,EAAE,EAAE,OAAOC,CAAC,EAAE,EAAE,OAAOE,CAAC,CAAC,CAAC,EAAE,OAAOE,GAAED,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAEW,GAAE,SAASpB,EAAE,EAAE,CAAC,QAAQE,EAAE,EAAEA,EAAE,EAAE,OAAOA,IAAI,CAAC,IAAIC,EAAE,EAAED,CAAC,EAAE,CAAC,EAAEF,CAAC,EAAE,GAAGG,EAAE,MAAM,CAACA,EAAE,EAAED,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,MAAM,CAAC,EAAEmB,GAAE,SAASrB,EAAE,CAAC,OAAgB,OAAOA,GAAjB,SAAmBoB,GAAEpB,EAAE,KAAK,EAAEmB,GAAE,MAAM,EAAY,OAAOnB,GAAjB,UAA2BA,IAAP,KAASoB,GAAEpB,EAAEmB,GAAE,MAAM,EAAE,CAAC,KAAK,MAAM,CAAC,EAAh7G,IAAg9GG,GAAE,SAASC,EAAE,EAAE,CAAC,IAAIC,EAAEC,GAAEF,CAAC,EAAE,MAAM,CAAC,EAAEC,EAAE,EAAE,EAAEE,EAAEF,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAEA,EAAE,EAAE,EAAEA,EAAE,CAAC,CAAC,EAAEG,GAAE,SAASJ,EAAE,CAAC,OAAO,IAAIA,EAAE,EAAE,IAAIA,EAAE,EAAE,IAAIA,EAAE,GAAG,IAAI,GAAG,EAAEK,GAAE,SAASL,EAAE,EAAE,CAAC,IAAIC,EAAEC,GAAEF,CAAC,EAAE,MAAM,CAAC,EAAEC,EAAE,EAAE,EAAEA,EAAE,EAAE,EAAEE,EAAEF,EAAE,EAAE,IAAI,EAAE,EAAE,GAAG,EAAE,EAAEA,EAAE,CAAC,CAAC,EAAEK,GAAE,UAAU,CAAC,SAASN,EAAEA,EAAE,CAAC,KAAK,OAAOO,GAAEP,CAAC,EAAE,CAAC,EAAE,KAAK,KAAK,KAAK,QAAQ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC,OAAOA,EAAE,UAAU,QAAQ,UAAU,CAAC,OAAc,KAAK,SAAZ,IAAkB,EAAEA,EAAE,UAAU,WAAW,UAAU,CAAC,OAAOC,EAAEG,GAAE,KAAK,IAAI,EAAE,CAAC,CAAC,EAAEJ,EAAE,UAAU,OAAO,UAAU,CAAC,OAAOI,GAAE,KAAK,IAAI,EAAE,EAAE,EAAEJ,EAAE,UAAU,QAAQ,UAAU,CAAC,OAAOI,GAAE,KAAK,IAAI,GAAG,EAAE,EAAEJ,EAAE,UAAU,MAAM,UAAU,CAAC,OAAOA,EAAEQ,GAAE,KAAK,IAAI,EAAEC,EAAET,EAAE,EAAEG,EAAEH,EAAE,EAAEU,EAAEV,EAAE,EAAEW,GAAGC,EAAEZ,EAAE,GAAG,EAAEa,GAAEZ,EAAE,IAAIW,CAAC,CAAC,EAAE,GAAG,IAAIC,GAAEJ,CAAC,EAAEI,GAAEV,CAAC,EAAEU,GAAEH,CAAC,EAAEC,EAAE,IAAIX,EAAES,EAAEN,EAAEO,EAAEE,EAAED,CAAC,EAAEX,EAAE,UAAU,MAAM,UAAU,CAAC,OAAOQ,GAAE,KAAK,IAAI,CAAC,EAAER,EAAE,UAAU,YAAY,UAAU,CAAC,OAAOA,EAAEQ,GAAE,KAAK,IAAI,EAAEC,EAAET,EAAE,EAAEC,EAAED,EAAE,EAAEG,EAAEH,EAAE,GAAGU,EAAEV,EAAE,GAAG,EAAE,QAAQS,EAAE,KAAKR,EAAE,KAAKE,EAAE,KAAKO,EAAE,IAAI,OAAOD,EAAE,KAAKR,EAAE,KAAKE,EAAE,IAAI,IAAIH,EAAES,EAAER,EAAEE,EAAEO,CAAC,EAAEV,EAAE,UAAU,MAAM,UAAU,CAAC,OAAOc,GAAEZ,GAAE,KAAK,IAAI,CAAC,CAAC,EAAEF,EAAE,UAAU,YAAY,UAAU,CAAC,OAAOA,EAAEc,GAAEZ,GAAE,KAAK,IAAI,CAAC,EAAEO,EAAET,EAAE,EAAEC,EAAED,EAAE,EAAEG,EAAEH,EAAE,GAAGU,EAAEV,EAAE,GAAG,EAAE,QAAQS,EAAE,KAAKR,EAAE,MAAME,EAAE,MAAMO,EAAE,IAAI,OAAOD,EAAE,KAAKR,EAAE,MAAME,EAAE,KAAK,IAAIH,EAAES,EAAER,EAAEE,EAAEO,CAAC,EAAEV,EAAE,UAAU,MAAM,UAAU,CAAC,OAAOA,EAAEe,GAAE,KAAK,IAAI,EAAE,CAAC,EAAEd,EAAED,EAAE,CAAC,EAAE,EAAEC,EAAED,EAAE,CAAC,EAAE,EAAEC,EAAED,EAAE,CAAC,EAAE,EAAEC,EAAED,EAAE,EAAE,CAAC,CAAC,EAAE,IAAIA,CAAC,EAAEA,EAAE,UAAU,OAAO,UAAU,CAAC,OAAOgB,EAAE,CAAC,EAAE,KAAKhB,EAAE,KAAK,MAAM,EAAE,EAAE,IAAIA,EAAE,EAAE,EAAE,IAAIA,EAAE,EAAE,EAAEA,EAAE,CAAC,CAAC,EAAE,IAAIA,CAAC,EAAEA,EAAE,UAAU,SAAS,SAASA,EAAE,CAAC,OAAgBA,IAAT,SAAaA,EAAE,IAAIgB,EAAEjB,GAAE,KAAK,KAAKC,CAAC,CAAC,CAAC,EAAEA,EAAE,UAAU,WAAW,SAASA,EAAE,CAAC,OAAgBA,IAAT,SAAaA,EAAE,IAAIgB,EAAEjB,GAAE,KAAK,KAAK,CAACC,CAAC,CAAC,CAAC,EAAEA,EAAE,UAAU,UAAU,UAAU,CAAC,OAAOgB,EAAEjB,GAAE,KAAK,KAAK,EAAE,CAAC,CAAC,EAAEC,EAAE,UAAU,QAAQ,SAASA,EAAE,CAAC,OAAgBA,IAAT,SAAaA,EAAE,IAAIgB,EAAEX,GAAE,KAAK,KAAKL,CAAC,CAAC,CAAC,EAAEA,EAAE,UAAU,OAAO,SAASA,EAAE,CAAC,OAAgBA,IAAT,SAAaA,EAAE,IAAIgB,EAAEX,GAAE,KAAK,KAAK,CAACL,CAAC,CAAC,CAAC,EAAEA,EAAE,UAAU,OAAO,SAASA,EAAE,CAAC,OAAgBA,IAAT,SAAaA,EAAE,IAAI,KAAK,IAAI,KAAK,IAAI,EAAEA,CAAC,CAAC,EAAEA,EAAE,UAAU,MAAM,SAASA,EAAE,CAAC,OAAgB,OAAOA,GAAjB,SAAmBgB,EAAE,CAAC,GAAGP,EAAE,KAAK,MAAM,EAAE,EAAEA,EAAE,EAAE,EAAEA,EAAE,EAAE,EAAET,CAAC,CAAC,EAAEC,EAAE,KAAK,KAAK,EAAE,CAAC,EAAE,IAAIQ,CAAC,EAAET,EAAE,UAAU,IAAI,SAASA,EAAE,CAAC,IAAIS,EAAEP,GAAE,KAAK,IAAI,EAAE,OAAgB,OAAOF,GAAjB,SAAmBgB,EAAE,CAAC,EAAEhB,EAAE,EAAES,EAAE,EAAE,EAAEA,EAAE,EAAE,EAAEA,EAAE,CAAC,CAAC,EAAER,EAAEQ,EAAE,CAAC,CAAC,EAAET,EAAE,UAAU,QAAQ,SAASA,EAAE,CAAC,OAAO,KAAK,MAAM,IAAIgB,EAAEhB,CAAC,EAAE,MAAM,CAAC,EAAEA,CAAC,EAAE,EAAEgB,EAAE,SAAShB,EAAE,CAAC,OAAOA,aAAaM,GAAEN,EAAE,IAAIM,GAAEN,CAAC,CAAC,EAAEiB,GAAE,CAAC,EAAEC,GAAE,SAASlB,EAAE,CAACA,EAAE,QAAQ,SAASA,EAAE,CAACiB,GAAE,QAAQjB,CAAC,EAAE,IAAIA,EAAEM,GAAEa,EAAC,EAAEF,GAAE,KAAKjB,CAAC,EAAE,CAAC,CAAC,ECAzjL,SAARoB,GAAiBC,EAAEC,EAAE,CAAC,IAAIC,EAAE,CAAC,MAAM,UAAU,OAAO,UAAU,KAAK,UAAU,UAAU,UAAU,WAAW,UAAU,UAAU,UAAU,MAAM,UAAU,aAAa,UAAU,KAAK,UAAU,MAAM,UAAU,WAAW,UAAU,WAAW,UAAU,KAAK,UAAU,eAAe,UAAU,MAAM,UAAU,KAAK,UAAU,UAAU,UAAU,UAAU,UAAU,SAAS,UAAU,eAAe,UAAU,UAAU,UAAU,WAAW,UAAU,MAAM,UAAU,QAAQ,UAAU,KAAK,UAAU,SAAS,UAAU,SAAS,UAAU,cAAc,UAAU,UAAU,UAAU,SAAS,UAAU,UAAU,UAAU,SAAS,UAAU,UAAU,UAAU,YAAY,UAAU,QAAQ,UAAU,WAAW,UAAU,WAAW,UAAU,cAAc,UAAU,KAAK,UAAU,cAAc,UAAU,cAAc,UAAU,SAAS,UAAU,YAAY,UAAU,MAAM,UAAU,UAAU,UAAU,YAAY,UAAU,WAAW,UAAU,WAAW,UAAU,QAAQ,UAAU,MAAM,UAAU,WAAW,UAAU,KAAK,UAAU,SAAS,UAAU,QAAQ,UAAU,WAAW,UAAU,YAAY,UAAU,UAAU,UAAU,UAAU,UAAU,OAAO,UAAU,QAAQ,UAAU,MAAM,UAAU,OAAO,UAAU,WAAW,UAAU,WAAW,UAAU,cAAc,UAAU,UAAU,UAAU,MAAM,UAAU,YAAY,UAAU,YAAY,UAAU,cAAc,UAAU,MAAM,UAAU,iBAAiB,UAAU,aAAa,UAAU,KAAK,UAAU,MAAM,UAAU,eAAe,UAAU,UAAU,UAAU,kBAAkB,UAAU,aAAa,UAAU,UAAU,UAAU,aAAa,UAAU,UAAU,UAAU,UAAU,UAAU,SAAS,UAAU,UAAU,UAAU,eAAe,UAAU,eAAe,UAAU,YAAY,UAAU,KAAK,UAAU,gBAAgB,UAAU,WAAW,UAAU,cAAc,UAAU,QAAQ,UAAU,cAAc,UAAU,gBAAgB,UAAU,aAAa,UAAU,cAAc,UAAU,eAAe,UAAU,gBAAgB,UAAU,QAAQ,UAAU,IAAI,UAAU,OAAO,UAAU,aAAa,UAAU,OAAO,UAAU,KAAK,UAAU,QAAQ,UAAU,YAAY,UAAU,UAAU,UAAU,IAAI,UAAU,OAAO,UAAU,UAAU,UAAU,cAAc,UAAU,KAAK,UAAU,cAAc,UAAU,OAAO,UAAU,KAAK,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,aAAa,UAAU,eAAe,UAAU,YAAY,UAAU,SAAS,UAAU,SAAS,UAAU,OAAO,UAAU,OAAO,UAAU,OAAO,UAAU,SAAS,UAAU,WAAW,UAAU,OAAO,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,UAAU,YAAY,UAAU,OAAO,UAAU,YAAY,UAAU,WAAW,UAAU,UAAU,UAAU,WAAW,UAAU,qBAAqB,UAAU,KAAK,UAAU,UAAU,UAAU,UAAU,UAAU,QAAQ,UAAU,QAAQ,UAAU,UAAU,UAAU,MAAM,SAAS,EAAE,EAAE,CAAC,EAAE,QAAQC,KAAKD,EAAE,EAAEA,EAAEC,CAAC,CAAC,EAAEA,EAAE,IAAIC,EAAE,CAAC,EAAEJ,EAAE,UAAU,OAAO,SAASC,EAAE,CAAC,GAAG,EAAE,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,MAAM,cAAc,IAAIE,EAAEE,EAAEC,EAAE,EAAE,KAAK,MAAM,CAAC,EAAE,GAAGA,EAAE,OAAOA,EAAE,GAAkBL,GAAE,QAAQ,CAAC,IAAIM,EAAE,KAAK,MAAM,EAAEC,EAAE,IAAIC,EAAE,QAAQ,GAAG,CAACL,EAAE,OAAO,QAAQM,KAAKR,EAAEE,EAAEM,CAAC,EAAE,IAAIV,EAAEE,EAAEQ,CAAC,CAAC,EAAE,MAAM,EAAE,QAAQ,KAAKR,EAAE,CAAC,IAAIS,GAAGR,EAAEI,EAAEF,EAAED,EAAE,CAAC,EAAE,KAAK,IAAID,EAAE,EAAEE,EAAE,EAAE,CAAC,EAAE,KAAK,IAAIF,EAAE,EAAEE,EAAE,EAAE,CAAC,EAAE,KAAK,IAAIF,EAAE,EAAEE,EAAE,EAAE,CAAC,GAAGM,EAAEH,IAAIA,EAAEG,EAAEF,EAAE,EAAE,CAAC,OAAOA,CAAC,CAAC,EAAER,EAAE,OAAO,KAAK,CAAC,SAASA,EAAE,CAAC,IAAIW,EAAEX,EAAE,YAAY,EAAEE,EAAkBS,IAAhB,cAAkB,QAAQV,EAAEU,CAAC,EAAE,OAAOT,EAAE,IAAIH,EAAEG,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,CAAC,CAAC,CCK98GU,GAAO,CAACC,EAAW,CAAC,EAgHb,IAAMC,EAAN,MAAMA,EACb,CAoCI,YAAYC,EAAqB,SACjC,CACI,KAAK,OAAS,KACT,KAAA,YAAc,IAAI,aAAa,CAAC,EAChC,KAAA,YAAY,KAAK,CAAC,EACvB,KAAK,KAAO,SACZ,KAAK,MAAQA,CAAA,CAIjB,IAAI,KACJ,CACW,OAAA,KAAK,YAAY,CAAC,CAAA,CAI7B,IAAI,OACJ,CACW,OAAA,KAAK,YAAY,CAAC,CAAA,CAI7B,IAAI,MACJ,CACW,OAAA,KAAK,YAAY,CAAC,CAAA,CAI7B,IAAI,OACJ,CACW,OAAA,KAAK,YAAY,CAAC,CAAA,CAQtB,SAASA,EAChB,CACI,YAAK,MAAQA,EAEN,IAAA,CAmBX,IAAI,MAAMA,EACV,CAEI,GAAIA,aAAiBD,GAEjB,KAAK,OAAS,KAAK,aAAaC,EAAM,MAAM,EAC5C,KAAK,KAAOA,EAAM,KACb,KAAA,YAAY,IAAIA,EAAM,WAAW,MAC1C,IACSA,IAAU,KAET,MAAA,IAAI,MAAM,gCAAgC,GAE3C,KAAK,SAAW,MAAQ,CAAC,KAAK,eAAe,KAAK,OAAQA,CAAK,KAE/D,KAAA,OAAS,KAAK,aAAaA,CAAK,EAChC,KAAA,WAAW,KAAK,MAAM,GAC/B,CAEJ,IAAI,OACJ,CACI,OAAO,KAAK,MAAA,CAOR,aAAaA,EACrB,CACQ,OAAA,OAAOA,GAAU,UAAY,OAAOA,GAAU,UAAYA,aAAiB,QAAUA,IAAU,KAExFA,EAEF,MAAM,QAAQA,CAAK,GAAK,YAAY,OAAOA,CAAK,EAE9CA,EAAM,MAAM,CAAC,EAEf,OAAOA,GAAU,UAAYA,IAAU,KAErC,CAAE,GAAGA,CAAM,EAGfA,CAAA,CASH,eAAeC,EAAqCC,EAC5D,CACI,IAAMC,EAAQ,OAAOF,EAIrB,GAAIE,IAHU,OAAOD,EAKV,MAAA,GAAA,GAIFC,IAAU,UAAYA,IAAU,UAAYF,aAAkB,OAEnE,OAAOA,IAAWC,EAAA,GAIjB,MAAM,QAAQD,CAAM,GAAK,MAAM,QAAQC,CAAM,GAC1C,YAAY,OAAOD,CAAM,GAAK,YAAY,OAAOC,CAAM,EAGvD,OAAAD,EAAO,SAAWC,EAAO,OAElB,GAGJD,EAAO,MAAM,CAACG,EAAGC,IAAMD,IAAMF,EAAOG,CAAC,CAAC,EAGxC,GAAAJ,IAAW,MAAQC,IAAW,KACvC,CACU,IAAAI,EAAQ,OAAO,KAAKL,CAAM,EAC1BM,EAAQ,OAAO,KAAKL,CAAM,EAE5B,OAAAI,EAAM,SAAWC,EAAM,OAEhB,GAGJD,EAAM,MAAOE,GAAQP,EAAOO,CAAG,IAAMN,EAAOM,CAAG,CAAC,CAAA,CAG3D,OAAOP,IAAWC,CAAA,CASf,QACP,CACI,GAAM,CAACO,EAAGC,EAAGC,EAAGC,CAAC,EAAI,KAAK,YAE1B,MAAO,CAAE,EAAAH,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAE,CAAA,CASjB,OACP,CACI,GAAM,CAACH,EAAGC,EAAGC,CAAC,EAAI,KAAK,YAEhB,MAAA,CAAE,EAAAF,EAAG,EAAAC,EAAG,EAAAC,CAAE,CAAA,CAId,cACP,CACI,GAAM,CAACF,EAAGC,EAAGC,CAAC,EAAI,KAAK,gBAAgB,EAEhC,MAAA,QAAQF,CAAC,IAAIC,CAAC,IAAIC,CAAC,IAAI,KAAK,KAAK,GAAA,CAYrC,gBAAqEE,EAC5E,CACI,GAAM,CAACJ,EAAGC,EAAGC,CAAC,EAAI,KAAK,YAEnB,OAAC,KAAK,YAEN,KAAK,UAAY,CAAA,GAGrBE,IAAAA,EAAQ,KAAK,WAEbA,EAAI,CAAC,EAAI,KAAK,MAAMJ,EAAI,GAAG,EAC3BI,EAAI,CAAC,EAAI,KAAK,MAAMH,EAAI,GAAG,EAC3BG,EAAI,CAAC,EAAI,KAAK,MAAMF,EAAI,GAAG,EAEpBE,CAAA,CAYJ,QAA2CA,EAClD,CACS,KAAK,aAEN,KAAK,WAAa,CAAA,GAGtBA,IAAAA,EAAQ,KAAK,YACb,GAAM,CAACJ,EAAGC,EAAGC,EAAGC,CAAC,EAAI,KAAK,YAE1B,OAAAC,EAAI,CAAC,EAAIJ,EACTI,EAAI,CAAC,EAAIH,EACTG,EAAI,CAAC,EAAIF,EACTE,EAAI,CAAC,EAAID,EAEFC,CAAA,CAYJ,WAA8CA,EACrD,CACS,KAAK,YAEN,KAAK,UAAY,CAAA,GAGrBA,IAAAA,EAAQ,KAAK,WACb,GAAM,CAACJ,EAAGC,EAAGC,CAAC,EAAI,KAAK,YAEvB,OAAAE,EAAI,CAAC,EAAIJ,EACTI,EAAI,CAAC,EAAIH,EACTG,EAAI,CAAC,EAAIF,EAEFE,CAAA,CASJ,UACP,CACI,OAAO,KAAK,IAAA,CAST,aACP,CACI,GAAM,CAACJ,EAAGC,EAAGC,CAAC,EAAI,KAAK,gBAAgB,EAE/B,OAAAA,GAAK,KAAOD,GAAK,GAAKD,CAAA,CAU3B,sBACP,CACI,IAAMT,EAAQ,KAAK,KAEnB,OAAQA,GAAS,KAAOA,EAAQ,SAAYA,EAAQ,MAAS,GAAA,CAQ1D,SAASA,EAChB,CACU,GAAA,CAACS,EAAGC,EAAGC,EAAGC,CAAC,EAAIb,GAAM,MAAM,SAASC,CAAK,EAAE,YAE5C,YAAA,YAAY,CAAC,GAAKS,EAClB,KAAA,YAAY,CAAC,GAAKC,EAClB,KAAA,YAAY,CAAC,GAAKC,EAClB,KAAA,YAAY,CAAC,GAAKC,EAEvB,KAAK,YAAY,EACjB,KAAK,OAAS,KAEP,IAAA,CAUJ,YAAYE,EAAeC,EAAa,GAC/C,CACI,OAAIA,IAEK,KAAA,YAAY,CAAC,GAAKD,EAClB,KAAA,YAAY,CAAC,GAAKA,EAClB,KAAA,YAAY,CAAC,GAAKA,GAEtB,KAAA,YAAY,CAAC,EAAIA,EAEtB,KAAK,YAAY,EACjB,KAAK,OAAS,KAEP,IAAA,CASJ,gBAAgBA,EAAeC,EAAa,GACnD,CACI,GAAID,IAAU,EAEF,OAAA,KAAQ,IAAM,KAAK,KAE/B,GAAIA,IAAU,EAEH,OAAAC,EAAa,EAAI,KAAK,KAE7B,IAAA,EAAK,KAAK,MAAQ,GAAM,IACxBL,EAAK,KAAK,MAAQ,EAAK,IACvBC,EAAI,KAAK,KAAO,IAEpB,OAAII,IAEM,EAAA,EAAID,EAAS,GAAO,EACpBJ,EAAAA,EAAII,EAAS,GAAO,EACpBH,EAAAA,EAAIG,EAAS,GAAO,IAGrBA,EAAQ,KAAQ,KAAO,GAAK,KAAOJ,GAAK,GAAKC,CAAA,CASnD,OACP,CACI,IAAMK,EAAY,KAAK,KAAK,SAAS,EAAE,EAEhC,MAAA,IAAI,SAAS,UAAU,EAAG,EAAIA,EAAU,MAAM,EAAIA,CAAS,EAAA,CAS/D,QACP,CAEU,IAAAC,EADa,KAAK,MAAM,KAAK,YAAY,CAAC,EAAI,GAAG,EACxB,SAAS,EAAE,EAEnC,OAAA,KAAK,MAAA,EAAU,KAAK,UAAU,EAAG,EAAIA,EAAY,MAAM,EAAIA,CAAA,CAO/D,SAASH,EAChB,CACI,YAAK,YAAY,CAAC,EAAI,KAAK,OAAOA,CAAK,EAEhC,IAAA,CAOH,WAAWd,EACnB,CACQ,IAAAS,EACAC,EACAC,EACAC,EAMC,IAAA,OAAOZ,GAAU,UAAYA,aAAiB,SAC3CA,GAAoB,GACpBA,GAAoB,SAE5B,CACI,IAAMkB,EAAMlB,EAENS,GAAAS,GAAO,GAAM,KAAQ,IACrBR,GAAAQ,GAAO,EAAK,KAAQ,IAC1BP,GAAKO,EAAM,KAAQ,IACfN,EAAA,CAAA,UAGH,MAAM,QAAQZ,CAAK,GAAKA,aAAiB,eAEvCA,EAAM,QAAU,GAChBA,EAAM,QAAU,EAIXA,EAAA,KAAK,OAAOA,CAAK,EACzB,CAACS,EAAGC,EAAGC,EAAGC,EAAI,CAAG,EAAIZ,WAGpBA,aAAiB,YAAcA,aAAiB,oBAE9CA,EAAM,QAAU,GAChBA,EAAM,QAAU,EAInBA,EAAQ,KAAK,OAAOA,EAAO,EAAG,GAAG,EACjC,CAACS,EAAGC,EAAGC,EAAGC,EAAI,GAAG,EAAIZ,EAChBS,GAAA,IACAC,GAAA,IACAC,GAAA,IACAC,GAAA,YAEA,OAAOZ,GAAU,UAAY,OAAOA,GAAU,SACvD,CACQ,GAAA,OAAOA,GAAU,SACrB,CACI,IAAMmB,EAAQpB,GAAM,YAAY,KAAKC,CAAK,EAEtCmB,IAGQnB,EAAA,IAAImB,EAAM,CAAC,CAAC,GACxB,CAGE,IAAAC,EAAQC,EAAOrB,CAAiB,EAElCoB,EAAM,QAAA,IAEL,CAAE,EAAAX,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAA,EAAMQ,EAAM,KACnBX,GAAA,IACAC,GAAA,IACAC,GAAA,IACT,CAIJ,GAAIF,IAAM,OAED,KAAA,YAAY,CAAC,EAAIA,EACjB,KAAA,YAAY,CAAC,EAAIC,EACjB,KAAA,YAAY,CAAC,EAAIC,EACjB,KAAA,YAAY,CAAC,EAAIC,EACtB,KAAK,YAAY,MAIjB,OAAM,IAAI,MAAM,2BAA2BZ,CAAK,EAAE,CACtD,CAII,aACR,CAES,KAAA,OAAO,KAAK,WAAW,EAE5B,GAAM,CAACS,EAAGC,EAAGC,CAAC,EAAI,KAAK,YAElB,KAAA,MAASF,EAAI,KAAQ,KAAQC,EAAI,KAAQ,IAAOC,EAAI,IAAO,EAAA,CAS5D,OAA4DX,EAAUsB,EAAM,EAAGC,EAAM,EAC7F,CACQ,OAAA,OAAOvB,GAAU,SAEV,KAAK,IAAI,KAAK,IAAIA,EAAOsB,CAAG,EAAGC,CAAG,GAGvCvB,EAAA,QAAQ,CAACI,EAAGC,IAClB,CACUL,EAAAK,CAAC,EAAI,KAAK,IAAI,KAAK,IAAID,EAAGkB,CAAG,EAAGC,CAAG,CAAA,CAC5C,EAEMvB,EAAA,CAcX,OAAc,YAAYA,EAC1B,CACI,OACI,OAAOA,GAAU,UACd,OAAOA,GAAU,UACjBA,aAAiB,QACjBA,aAAiBD,IACjB,MAAM,QAAQC,CAAK,GACnBA,aAAiB,YACjBA,aAAiB,mBACjBA,aAAiB,cACfA,EAAmB,IAAM,QACtBA,EAAmB,IAAM,QACzBA,EAAmB,IAAM,QAC5BA,EAAoB,IAAM,QACvBA,EAAoB,IAAM,QAC1BA,EAAoB,IAAM,QAC1BA,EAAoB,IAAM,QAC7BA,EAAmB,IAAM,QACtBA,EAAmB,IAAM,QACzBA,EAAmB,IAAM,QAC5BA,EAAoB,IAAM,QACvBA,EAAoB,IAAM,QAC1BA,EAAoB,IAAM,QAC1BA,EAAoB,IAAM,QAC7BA,EAAmB,IAAM,QACtBA,EAAmB,IAAM,QACzBA,EAAmB,IAAM,QAC5BA,EAAoB,IAAM,QACvBA,EAAoB,IAAM,QAC1BA,EAAoB,IAAM,QAC1BA,EAAoB,IAAM,MAAA,CAG9C,EApnBaD,EAQc,OAAS,IAAIA,EAR3BA,EAee,MAAQ,IAAIA,EAf3BA,EAmBe,YAAc,+CAnBnC,IAAMyB,GAANzB,ECxFA,IAAM0B,GAAwC,CACjD,SAAU,KACV,SAAU,GACV,iBAAkB,EACtB,EC3Ba,IAAAC,GAAO,KAAK,GAAK,EAQjBC,GAAa,IAAM,KAAK,GAQxBC,GAAa,KAAK,GAAK,ICL7B,IAAMC,EAAN,MAAMC,CACb,CAWI,YAAYC,EAAI,EAAGC,EAAI,EACvB,CAVA,KAAO,EAAI,EAEX,KAAO,EAAI,EASP,KAAK,EAAID,EACT,KAAK,EAAIC,CAAA,CAON,OACP,CACI,OAAO,IAAIF,EAAM,KAAK,EAAG,KAAK,CAAC,CAAA,CAQ5B,SAASG,EAChB,CACI,YAAK,IAAIA,EAAE,EAAGA,EAAE,CAAC,EAEV,IAAA,CAQJ,OAA4BA,EACnC,CACI,OAAAA,EAAE,IAAI,KAAK,EAAG,KAAK,CAAC,EAEbA,CAAA,CAQJ,OAAOA,EACd,CACI,OAAQA,EAAE,IAAM,KAAK,GAAOA,EAAE,IAAM,KAAK,CAAA,CAUtC,IAAIF,EAAI,EAAGC,EAAYD,EAC9B,CACI,YAAK,EAAIA,EACT,KAAK,EAAIC,EAEF,IAAA,CAIJ,UACP,CACI,MAAO,yBAAyB,KAAK,CAAC,MAAM,KAAK,CAAC,GAAA,CAQtD,WAAW,QACX,CACI,OAAAE,GAAU,EAAI,EACdA,GAAU,EAAI,EAEPA,EAAA,CAEf,EAEMA,GAAY,IAAIL,ECzFf,IAAMM,EAAN,MAAMC,CACb,CA8BI,YAAYC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAI,EAAGC,EAAK,EAAGC,EAAK,EACrD,CAXA,KAAO,MAA6B,KAYhC,KAAK,EAAIL,EACT,KAAK,EAAIC,EACT,KAAK,EAAIC,EACT,KAAK,EAAIC,EACT,KAAK,GAAKC,EACV,KAAK,GAAKC,CAAA,CAcP,UAAUC,EACjB,CACS,KAAA,EAAIA,EAAM,CAAC,EACX,KAAA,EAAIA,EAAM,CAAC,EACX,KAAA,EAAIA,EAAM,CAAC,EACX,KAAA,EAAIA,EAAM,CAAC,EACX,KAAA,GAAKA,EAAM,CAAC,EACZ,KAAA,GAAKA,EAAM,CAAC,CAAA,CAad,IAAIN,EAAWC,EAAWC,EAAWC,EAAWC,EAAYC,EACnE,CACI,YAAK,EAAIL,EACT,KAAK,EAAIC,EACT,KAAK,EAAIC,EACT,KAAK,EAAIC,EACT,KAAK,GAAKC,EACV,KAAK,GAAKC,EAEH,IAAA,CASJ,QAAQE,EAAqBC,EACpC,CACS,KAAK,QAED,KAAA,MAAQ,IAAI,aAAa,CAAC,GAG7B,IAAAF,EAAQE,GAAO,KAAK,MAE1B,OAAID,GAEMD,EAAA,CAAC,EAAI,KAAK,EACVA,EAAA,CAAC,EAAI,KAAK,EAChBA,EAAM,CAAC,EAAI,EACLA,EAAA,CAAC,EAAI,KAAK,EACVA,EAAA,CAAC,EAAI,KAAK,EAChBA,EAAM,CAAC,EAAI,EACLA,EAAA,CAAC,EAAI,KAAK,GACVA,EAAA,CAAC,EAAI,KAAK,GAChBA,EAAM,CAAC,EAAI,IAILA,EAAA,CAAC,EAAI,KAAK,EACVA,EAAA,CAAC,EAAI,KAAK,EACVA,EAAA,CAAC,EAAI,KAAK,GACVA,EAAA,CAAC,EAAI,KAAK,EACVA,EAAA,CAAC,EAAI,KAAK,EACVA,EAAA,CAAC,EAAI,KAAK,GAChBA,EAAM,CAAC,EAAI,EACXA,EAAM,CAAC,EAAI,EACXA,EAAM,CAAC,EAAI,GAGRA,CAAA,CAUJ,MAAmCG,EAAgBC,EAC1D,CACcA,EAAAA,GAAU,IAAIC,EAExB,IAAMC,EAAIH,EAAI,EACRI,EAAIJ,EAAI,EAEd,OAAAC,EAAO,EAAK,KAAK,EAAIE,EAAM,KAAK,EAAIC,EAAK,KAAK,GAC9CH,EAAO,EAAK,KAAK,EAAIE,EAAM,KAAK,EAAIC,EAAK,KAAK,GAEvCH,CAAA,CAUJ,aAA0CD,EAAgBC,EACjE,CACcA,EAAAA,GAAU,IAAIC,EAExB,IAAMX,EAAI,KAAK,EACTC,EAAI,KAAK,EACTC,EAAI,KAAK,EACTC,EAAI,KAAK,EACTC,EAAK,KAAK,GACVC,EAAK,KAAK,GAEVS,EAAK,GAAMd,EAAIG,EAAMD,EAAI,CAACD,GAE1BW,EAAIH,EAAI,EACRI,EAAIJ,EAAI,EAEP,OAAAC,EAAA,EAAKP,EAAIW,EAAKF,EAAM,CAACV,EAAIY,EAAKD,GAAQR,EAAKH,EAAME,EAAKD,GAAMW,EACnEJ,EAAO,EAAKV,EAAIc,EAAKD,EAAM,CAACZ,EAAIa,EAAKF,GAAQ,CAACP,EAAKL,EAAMI,EAAKH,GAAMa,EAE7DJ,CAAA,CASJ,UAAUE,EAAWC,EAC5B,CACI,YAAK,IAAMD,EACX,KAAK,IAAMC,EAEJ,IAAA,CASJ,MAAMD,EAAWC,EACxB,CACI,YAAK,GAAKD,EACV,KAAK,GAAKC,EACV,KAAK,GAAKD,EACV,KAAK,GAAKC,EACV,KAAK,IAAMD,EACX,KAAK,IAAMC,EAEJ,IAAA,CAQJ,OAAOE,EACd,CACU,IAAAC,EAAM,KAAK,IAAID,CAAK,EACpBE,EAAM,KAAK,IAAIF,CAAK,EAEpBG,EAAK,KAAK,EACVC,EAAK,KAAK,EACVC,EAAM,KAAK,GAEjB,YAAK,EAAKF,EAAKF,EAAQ,KAAK,EAAIC,EAChC,KAAK,EAAKC,EAAKD,EAAQ,KAAK,EAAID,EAChC,KAAK,EAAKG,EAAKH,EAAQ,KAAK,EAAIC,EAChC,KAAK,EAAKE,EAAKF,EAAQ,KAAK,EAAID,EAChC,KAAK,GAAMI,EAAMJ,EAAQ,KAAK,GAAKC,EACnC,KAAK,GAAMG,EAAMH,EAAQ,KAAK,GAAKD,EAE5B,IAAA,CAQJ,OAAOK,EACd,CACI,IAAMH,EAAK,KAAK,EACVI,EAAK,KAAK,EACVH,EAAK,KAAK,EACVI,EAAK,KAAK,EAEhB,YAAK,EAAKF,EAAO,EAAIH,EAAOG,EAAO,EAAIF,EACvC,KAAK,EAAKE,EAAO,EAAIC,EAAOD,EAAO,EAAIE,EACvC,KAAK,EAAKF,EAAO,EAAIH,EAAOG,EAAO,EAAIF,EACvC,KAAK,EAAKE,EAAO,EAAIC,EAAOD,EAAO,EAAIE,EAEvC,KAAK,GAAMF,EAAO,GAAKH,EAAOG,EAAO,GAAKF,EAAM,KAAK,GACrD,KAAK,GAAME,EAAO,GAAKC,EAAOD,EAAO,GAAKE,EAAM,KAAK,GAE9C,IAAA,CASJ,WAAWvB,EAAWC,EAC7B,CACI,IAAMiB,EAAKlB,EAAE,EACPsB,EAAKtB,EAAE,EACPmB,EAAKnB,EAAE,EACPuB,EAAKvB,EAAE,EACPI,EAAKJ,EAAE,GACPK,EAAKL,EAAE,GAEPwB,EAAKvB,EAAE,EACPwB,EAAKxB,EAAE,EACPyB,EAAKzB,EAAE,EACP0B,EAAK1B,EAAE,EAER,YAAA,EAAKiB,EAAKM,EAAOF,EAAKI,EACtB,KAAA,EAAKR,EAAKO,EAAOH,EAAKK,EACtB,KAAA,EAAKR,EAAKK,EAAOD,EAAKG,EACtB,KAAA,EAAKP,EAAKM,EAAOF,EAAKI,EAC3B,KAAK,GAAMvB,EAAKoB,EAAOnB,EAAKqB,EAAMzB,EAAE,GACpC,KAAK,GAAMG,EAAKqB,EAAOpB,EAAKsB,EAAM1B,EAAE,GAE7B,IAAA,CAgBJ,aAAaW,EAAWC,EAAWe,EAAgBC,EAAgBC,EACtEC,EAAgBC,EAAkBC,EAAeC,EACrD,CACI,YAAK,EAAI,KAAK,IAAIF,EAAWE,CAAK,EAAIJ,EACtC,KAAK,EAAI,KAAK,IAAIE,EAAWE,CAAK,EAAIJ,EACtC,KAAK,EAAI,CAAC,KAAK,IAAIE,EAAWC,CAAK,EAAIF,EACvC,KAAK,EAAI,KAAK,IAAIC,EAAWC,CAAK,EAAIF,EAEtC,KAAK,GAAKnB,GAAMgB,EAAS,KAAK,EAAMC,EAAS,KAAK,GAClD,KAAK,GAAKhB,GAAMe,EAAS,KAAK,EAAMC,EAAS,KAAK,GAE3C,IAAA,CAQJ,QAAQR,EACf,CACI,IAAMD,EAAM,KAAK,GAEb,GAAAC,EAAO,IAAM,GAAKA,EAAO,IAAM,GAAKA,EAAO,IAAM,GAAKA,EAAO,IAAM,EACvE,CACI,IAAMH,EAAK,KAAK,EACVC,EAAK,KAAK,EAEhB,KAAK,EAAKD,EAAKG,EAAO,EAAM,KAAK,EAAIA,EAAO,EAC5C,KAAK,EAAKH,EAAKG,EAAO,EAAM,KAAK,EAAIA,EAAO,EAC5C,KAAK,EAAKF,EAAKE,EAAO,EAAM,KAAK,EAAIA,EAAO,EAC5C,KAAK,EAAKF,EAAKE,EAAO,EAAM,KAAK,EAAIA,EAAO,CAAA,CAG3C,YAAA,GAAMD,EAAMC,EAAO,EAAM,KAAK,GAAKA,EAAO,EAAKA,EAAO,GACtD,KAAA,GAAMD,EAAMC,EAAO,EAAM,KAAK,GAAKA,EAAO,EAAKA,EAAO,GAEpD,IAAA,CAQJ,UAAUc,EACjB,CAEI,IAAMnC,EAAI,KAAK,EACTC,EAAI,KAAK,EACTC,EAAI,KAAK,EACTC,EAAI,KAAK,EACTiC,EAAQD,EAAU,MAElBF,EAAQ,CAAC,KAAK,MAAM,CAAC/B,EAAGC,CAAC,EACzB+B,EAAQ,KAAK,MAAMjC,EAAGD,CAAC,EAEvBqC,EAAQ,KAAK,IAAIJ,EAAQC,CAAK,EAEpC,OAAIG,EAAQ,MAAW,KAAK,IAAIC,GAAOD,CAAK,EAAI,MAE5CF,EAAU,SAAWD,EACrBC,EAAU,KAAK,EAAIA,EAAU,KAAK,EAAI,IAItCA,EAAU,SAAW,EACrBA,EAAU,KAAK,EAAIF,EACnBE,EAAU,KAAK,EAAID,GAIvBC,EAAU,MAAM,EAAI,KAAK,KAAMnC,EAAIA,EAAMC,EAAIA,CAAE,EAC/CkC,EAAU,MAAM,EAAI,KAAK,KAAMjC,EAAIA,EAAMC,EAAIA,CAAE,EAGrCgC,EAAA,SAAS,EAAI,KAAK,IAAOC,EAAM,EAAIpC,EAAMoC,EAAM,EAAIlC,GACnDiC,EAAA,SAAS,EAAI,KAAK,IAAOC,EAAM,EAAInC,EAAMmC,EAAM,EAAIjC,GAEtDgC,CAAA,CAOJ,QACP,CACI,IAAMjB,EAAK,KAAK,EACVI,EAAK,KAAK,EACVH,EAAK,KAAK,EACVI,EAAK,KAAK,EACVH,EAAM,KAAK,GACXmB,EAAKrB,EAAKK,EAAOD,EAAKH,EAE5B,YAAK,EAAII,EAAKgB,EACT,KAAA,EAAI,CAACjB,EAAKiB,EACV,KAAA,EAAI,CAACpB,EAAKoB,EACf,KAAK,EAAIrB,EAAKqB,EACd,KAAK,IAAOpB,EAAK,KAAK,GAAOI,EAAKH,GAAQmB,EAC1C,KAAK,GAAK,EAAGrB,EAAK,KAAK,GAAOI,EAAKF,GAAQmB,EAEpC,IAAA,CAIJ,YACP,CACI,OAAO,KAAK,IAAM,GAAK,KAAK,IAAM,GAAK,KAAK,IAAM,GAAK,KAAK,IAAM,GAAK,KAAK,KAAO,GAAK,KAAK,KAAO,CAAA,CAOjG,UACP,CACI,YAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,EAAI,EACT,KAAK,GAAK,EACV,KAAK,GAAK,EAEH,IAAA,CAOJ,OACP,CACU,IAAAlB,EAAS,IAAItB,EAEnB,OAAAsB,EAAO,EAAI,KAAK,EAChBA,EAAO,EAAI,KAAK,EAChBA,EAAO,EAAI,KAAK,EAChBA,EAAO,EAAI,KAAK,EAChBA,EAAO,GAAK,KAAK,GACjBA,EAAO,GAAK,KAAK,GAEVA,CAAA,CAQJ,OAAOA,EACd,CACI,OAAAA,EAAO,EAAI,KAAK,EAChBA,EAAO,EAAI,KAAK,EAChBA,EAAO,EAAI,KAAK,EAChBA,EAAO,EAAI,KAAK,EAChBA,EAAO,GAAK,KAAK,GACjBA,EAAO,GAAK,KAAK,GAEVA,CAAA,CAQJ,SAASA,EAChB,CACI,YAAK,EAAIA,EAAO,EAChB,KAAK,EAAIA,EAAO,EAChB,KAAK,EAAIA,EAAO,EAChB,KAAK,EAAIA,EAAO,EAChB,KAAK,GAAKA,EAAO,GACjB,KAAK,GAAKA,EAAO,GAEV,IAAA,CAOJ,OAAOA,EACd,CACW,OAAAA,EAAO,IAAM,KAAK,GAAKA,EAAO,IAAM,KAAK,GACzCA,EAAO,IAAM,KAAK,GAAKA,EAAO,IAAM,KAAK,GACzCA,EAAO,KAAO,KAAK,IAAMA,EAAO,KAAO,KAAK,EAAA,CAIhD,UACP,CACI,MAAO,qBAAqB,KAAK,CAAC,MAAM,KAAK,CAAC,MAAM,KAAK,CAAC,MAAM,KAAK,CAAC,OAAO,KAAK,EAAE,OAAO,KAAK,EAAE,GAAA,CAUtG,WAAW,UACX,CACI,OAAOmB,GAAe,SAAS,CAAA,CAUnC,WAAW,QACX,CACI,OAAOC,GAAW,SAAS,CAAA,CAEnC,EAEMA,GAAa,IAAI3C,EACjB0C,GAAiB,IAAI1C,ECzgBpB,IAAM4C,EAAN,MAAMC,CACb,CAeI,YAAYC,EAAqCC,EAAYC,EAC7D,CACI,KAAK,GAAKD,GAAK,EACf,KAAK,GAAKC,GAAK,EAEf,KAAK,UAAYF,CAAA,CAQd,MAAMA,EACb,CACW,OAAA,IAAID,EAAgBC,GAAY,KAAK,UAAW,KAAK,GAAI,KAAK,EAAE,CAAA,CAUpE,IAAIC,EAAI,EAAGC,EAAID,EACtB,CACI,OAAI,KAAK,KAAOA,GAAK,KAAK,KAAOC,KAE7B,KAAK,GAAKD,EACV,KAAK,GAAKC,EACL,KAAA,UAAU,UAAU,IAAI,GAG1B,IAAA,CAQJ,SAASC,EAChB,CACI,OAAI,KAAK,KAAOA,EAAE,GAAK,KAAK,KAAOA,EAAE,KAEjC,KAAK,GAAKA,EAAE,EACZ,KAAK,GAAKA,EAAE,EACP,KAAA,UAAU,UAAU,IAAI,GAG1B,IAAA,CAQJ,OAA4BA,EACnC,CACI,OAAAA,EAAE,IAAI,KAAK,GAAI,KAAK,EAAE,EAEfA,CAAA,CAQJ,OAAOA,EACd,CACI,OAAQA,EAAE,IAAM,KAAK,IAAQA,EAAE,IAAM,KAAK,EAAA,CAIvC,UACP,CACI,MAAO,+CAAqD,KAAK,SAAS,GAAA,CAK9E,IAAI,GACJ,CACI,OAAO,KAAK,EAAA,CAGhB,IAAI,EAAEC,EACN,CACQ,KAAK,KAAOA,IAEZ,KAAK,GAAKA,EACL,KAAA,UAAU,UAAU,IAAI,EACjC,CAIJ,IAAI,GACJ,CACI,OAAO,KAAK,EAAA,CAGhB,IAAI,EAAEA,EACN,CACQ,KAAK,KAAOA,IAEZ,KAAK,GAAKA,EACL,KAAA,UAAU,UAAU,IAAI,EACjC,CAER,ECvJA,IAAMC,GAAmC,CACrC,QAAS,EACb,EAkCgB,SAAAC,EAAIC,EAAiB,UACrC,CACQ,OAAAF,GAASE,CAAI,IAAM,SAEnBF,GAASE,CAAI,EAAI,IAGd,EAAEF,GAASE,CAAI,CAC1B,CCzCA,IAAMC,GAA0B,CAAA,EAMnBC,EAAS,QACTC,GAAS,QAcf,SAASC,EAAYC,EAAiBC,EAAiBC,EAAc,EAC5E,CAEQ,GAAAN,GAASK,CAAO,EAEhB,OAIA,IAAAE,EAAQ,IAAI,MAAA,EAAQ,MAGpB,OAAOA,EAAU,IAET,QAAA,KAAK,+BAAgC,GAAGF,CAAO;oBAAuBD,CAAO,EAAE,GAK/EG,EAAAA,EAAM,MAAM;CAAI,EAAE,OAAOD,CAAW,EAAE,KAAK;CAAI,EAEnD,QAAQ,gBAEA,QAAA,eACJ,qCACA,mCACA,sDACA,GAAGD,CAAO;oBAAuBD,CAAO,EAAA,EAE5C,QAAQ,KAAKG,CAAK,EAClB,QAAQ,SAAS,IAIT,QAAA,KAAK,+BAAgC,GAAGF,CAAO;oBAAuBD,CAAO,EAAE,EACvF,QAAQ,KAAKG,CAAK,IAK1BP,GAASK,CAAO,EAAI,EACxB,CC5DO,IAAMG,EAAN,KACP,CAWI,YAAYC,EAAmCC,EAC/C,CAVA,KAAiB,MAAa,CAAA,EAC9B,KAAQ,OAAS,EACjB,KAAQ,OAAS,EASb,KAAK,WAAaD,EAEdC,GAEA,KAAK,YAAYA,CAAW,CAChC,CAOG,YAAYC,EACnB,CACI,QAASC,EAAI,EAAGA,EAAID,EAAOC,IAEvB,KAAK,MAAM,KAAK,QAAQ,EAAI,IAAI,KAAK,WAGzC,KAAK,QAAUD,CAAA,CASZ,IAAIE,EACX,CACQ,IAAAC,EAEA,OAAA,KAAK,OAAS,EAEdA,EAAO,KAAK,MAAM,EAAE,KAAK,MAAM,EAIxBA,EAAA,IAAI,KAAK,WAGpBA,EAAK,OAAOD,CAAI,EAETC,CAAA,CAOJ,OAAOA,EACd,CACIA,EAAK,QAAQ,EAER,KAAA,MAAM,KAAK,QAAQ,EAAIA,CAAA,CAQhC,IAAI,WACJ,CACI,OAAO,KAAK,MAAA,CAQhB,IAAI,WACJ,CACI,OAAO,KAAK,MAAA,CAQhB,IAAI,WACJ,CACW,OAAA,KAAK,OAAS,KAAK,MAAA,CAIvB,OACP,CACI,KAAK,MAAM,OAAS,EACpB,KAAK,OAAS,CAAA,CAEtB,ECjGO,IAAMC,GAAN,KACP,CADO,aAAA,CAMc,KAAA,cAAA,IAAwE,GAAI,CAQtF,YAAgCC,EAA+BC,EACtE,CACsB,KAAK,QAAQD,CAAK,EAE1B,YAAYC,CAAK,CAAA,CAUxB,IAAwBD,EAA+BE,EAC9D,CAGW,OAFM,KAAK,QAAQF,CAAK,EAEnB,IAAIE,CAAI,CAAA,CAOjB,OAAOC,EACd,CACiB,KAAK,QAAQA,EAAK,WAA4C,EAEtE,OAAOA,CAAI,CAAA,CASb,QAA4BC,EACnC,CACI,OAAK,KAAK,cAAc,IAAIA,CAAS,GAEjC,KAAK,cAAc,IAAIA,EAAW,IAAIC,EAAKD,CAAS,CAAC,EAGlD,KAAK,cAAc,IAAIA,CAAS,CAAA,CAIpC,OACP,CACI,IAAME,EAAQ,CAAA,EAET,YAAA,cAAc,QAASC,GAC5B,CAEI,IAAMC,EAAOF,EAAMC,EAAK,WAAW,IAAI,EACjCA,EAAK,WAAW,KAAQA,EAAK,WAAmB,GAAKA,EAAK,WAAW,KAE3ED,EAAME,CAAI,EAAI,CACV,KAAMD,EAAK,UACX,KAAMA,EAAK,UACX,KAAMA,EAAK,SAAA,CACf,CACH,EAEMD,CAAA,CAEf,EAEaG,EAAU,IAAIV,GCvDpB,IAAMW,GAA0C,CAOnD,IAAI,mBACJ,CACW,MAAA,CAAC,CAAC,KAAK,aAAa,iBAAA,EAG/B,eAAeC,EACf,CACQ,OAAOA,GAAQ,WAAaA,IAAQ,GAEpC,KAAK,mBAAmB,GAIxB,KAAK,kBAAkB,EACvB,KAAK,YAAY,qBAAqBA,IAAQ,GAAO,CAAA,EAAKA,CAAG,EACjE,EAQJ,oBACA,CACI,KAAK,aAAa,mBAAmB,CAAA,EAOzC,IAAI,eACJ,CACI,OAAO,KAAK,iBAAA,EAMhB,IAAI,cAAcA,EAClB,CAEIC,EAAY,SAAU,0DAA0D,EAEhF,KAAK,eAAeD,CAAG,CAAA,CAE/B,EC1FgB,SAAAE,GAAYC,EAAYC,EAAkBC,EAC1D,CACI,IAAMC,EAASH,EAAI,OACfI,EAEA,GAAAH,GAAYE,GAAUD,IAAgB,EAEtC,OAGJA,EAAeD,EAAWC,EAAcC,EAASA,EAASF,EAAWC,EAErE,IAAMG,EAAMF,EAASD,EAErB,IAAKE,EAAIH,EAAUG,EAAIC,EAAK,EAAED,EAE1BJ,EAAII,CAAC,EAAIJ,EAAII,EAAIF,CAAW,EAGhCF,EAAI,OAASK,CACjB,CCJO,IAAMC,GAA2D,CAEpE,cAAe,GASf,eAAeC,EAAa,EAAGC,EAC/B,CACU,IAAAC,EAAMD,GAAY,KAAK,SAAS,OAChCE,EAAQD,EAAMF,EACdI,EAA4B,CAAA,EAE9B,GAAAD,EAAQ,GAAKA,GAASD,EAC1B,CACI,QAASG,EAAIH,EAAM,EAAGG,GAAKL,EAAYK,IACvC,CACU,IAAAC,EAAQ,KAAK,SAASD,CAAC,EAExBC,IACLF,EAAQ,KAAKE,CAAK,EAClBA,EAAM,OAAS,KAAA,CAGPC,GAAA,KAAK,SAAUP,EAAYE,CAAG,EAEpC,IAAAM,EAAc,KAAK,aAAe,KAAK,kBAEzCA,GAEAA,EAAY,eAAeJ,CAAO,EAGtC,QAASC,EAAI,EAAGA,EAAID,EAAQ,OAAQ,EAAEC,EAElC,KAAK,KAAK,eAAgBD,EAAQC,CAAC,EAAG,KAAMA,CAAC,EAC7CD,EAAQC,CAAC,EAAE,KAAK,UAAW,IAAI,EAG/B,OAAAD,EAAQ,OAAS,GAEZ,KAAA,qBAGFA,CAAA,SAEFD,IAAU,GAAK,KAAK,SAAS,SAAW,EAEtC,OAAAC,EAGL,MAAA,IAAI,WAAW,kEAAkE,CAAA,EAS3F,cAAwDK,EACxD,CACU,IAAAH,EAAQ,KAAK,WAAcG,CAAK,EAE/B,OAAA,KAAK,YAAYH,CAAK,CAAA,EASjC,WAAqDG,EACrD,CACI,GAAIA,EAAQ,GAAKA,GAAS,KAAK,SAAS,OAEpC,MAAM,IAAI,MAAM,sBAAsBA,CAAK,mBAAmB,EAG3D,OAAA,KAAK,SAASA,CAAK,CAAA,EAS9B,cAAcH,EAAsCG,EACpD,CACI,GAAIA,EAAQ,GAAKA,GAAS,KAAK,SAAS,OAE9B,MAAA,IAAI,MAAM,aAAaA,CAAK,8BAA8B,KAAK,SAAS,MAAM,EAAE,EAG1F,KAAK,cAAcH,CAAK,EACnB,KAAA,WAAWA,EAAOG,CAAK,CAAA,EAShC,cAAcH,EACd,CACI,IAAMG,EAAQ,KAAK,SAAS,QAAQH,CAAuB,EAE3D,GAAIG,IAAU,GAEJ,MAAA,IAAI,MAAM,sDAAsD,EAGnE,OAAAA,CAAA,EAWX,WAAqDH,EAAUG,EAC/D,CAES,KAAK,eAENC,EAAYC,EAAQ,uEAAuE,EAIzF,GAAA,CAAE,SAAAC,CAAA,EAAa,KAErB,GAAIH,EAAQ,GAAKA,EAAQG,EAAS,OAExB,MAAA,IAAI,MAAM,GAAGN,CAAK,yBAAyBG,CAAK,8BAA8BG,EAAS,MAAM,EAAE,EAMzG,GAAIN,EAAM,OACV,CACI,IAAMO,EAAeP,EAAM,OAAO,SAAS,QAAQA,CAAuB,EAG1E,GAAIA,EAAM,SAAW,MAAQO,IAAiBJ,EAEnC,OAAAH,EAGPO,IAAiB,IAEjBP,EAAM,OAAO,SAAS,OAAOO,EAAc,CAAC,CAChD,CAGAJ,IAAUG,EAAS,OAEnBA,EAAS,KAAKN,CAAuB,EAI5BM,EAAA,OAAOH,EAAO,EAAGH,CAAuB,EAGrDA,EAAM,OAAS,KACfA,EAAM,UAAY,GAClBA,EAAM,aAAe,GAEf,IAAAE,EAAc,KAAK,aAAe,KAAK,kBAE7C,OAAIA,GAEAA,EAAY,SAASF,CAAuB,EAG5C,KAAK,mBAAkB,KAAK,UAAY,IAE5C,KAAK,KAAK,aAAcA,EAAyB,KAAMG,CAAK,EACtDH,EAAA,KAAK,QAAS,IAAI,EAEjBA,CAAA,EAQX,aAAuDA,EAAUQ,EACjE,CACI,GAAIR,IAAUQ,EAEV,OAGE,IAAAC,EAAS,KAAK,cAAcT,CAAK,EACjCU,EAAS,KAAK,cAAcF,CAAM,EAEnC,KAAA,SAASC,CAAM,EAAID,EACnB,KAAA,SAASE,CAAM,EAAIV,EAElB,IAAAE,EAAc,KAAK,aAAe,KAAK,kBAEzCA,IAEAA,EAAY,mBAAqB,IAGhC,KAAA,yBAAA,EAMT,kBACA,CACS,KAAA,QAAQ,YAAY,IAAI,CAAA,EASjC,iBAA6CF,EAC7C,CACQ,OAAAA,EAAM,SAAW,EAEV,KAAK,gBAAgBA,EAAM,CAAC,EAAG,KAAK,SAAS,MAAM,GAGxDA,EAAA,QAASW,GAAM,KAAK,gBAAgBA,EAAG,KAAK,SAAS,MAAM,CAAC,EAE3DX,EAAM,CAAC,EAAA,EASlB,gBAA0CA,EAAUG,EACpD,CACQ,GAAAH,EAAM,SAAW,KAEZ,YAAA,cAAcA,EAAOG,CAAK,EAExBH,EAGL,IAAAY,EAAWZ,EAAM,eAAe,MAAM,EAE5CA,EAAM,iBAAiB,EAClB,KAAA,WAAWA,EAAOG,CAAK,EAEtB,IAAAU,EAAY,KAAK,eAAe,MAAM,EAE5C,OAAAA,EAAU,OAAO,EACjBD,EAAS,QAAQC,CAAS,EAE1Bb,EAAM,cAAcY,CAAQ,EAErBZ,CAAA,CAEf,ECvPO,IAAMc,GAA8C,CAUvD,mBAAmBC,EAAgCC,EAAoBC,EACvE,CAES,KAAK,mBAAqB,KAAK,oBAAsBA,GACnD,KAAK,oBAAsB,GAAS,CAAC,KAAK,iBAG7C,KAAK,kBAEL,KAAK,aAAa,EAIlB,KAAK,SAEA,KAAA,yBAAyBF,EAAgBC,EAAUC,CAAY,EAE/D,KAAK,YAEVD,EAAS,YAAY,YAAY,eAAe,KAAK,YAAaD,CAAc,EAI3E,KAAA,8BAA8BA,EAAgBC,EAAUC,CAAY,EAC7E,EAWJ,yBACIF,EACAC,EACAC,EAEJ,CACI,IAAMC,EAAW,KAAK,SAChBC,EAASD,EAAS,OAGxB,QAASE,EAAI,EAAGA,EAAID,EAAQC,IAExBF,EAASE,CAAC,EAAE,mBAAmBL,EAAgBC,EAAUC,CAAY,CACzE,EAWJ,8BACIF,EACAC,EACAC,EAEJ,CACU,GAAA,CAAE,YAAAI,CAAA,EAAgBL,EAGxB,QAASI,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IACzC,CACU,IAAAE,EAAS,KAAK,QAAQF,CAAC,EAChBC,EAAYC,EAAO,IAAyB,EAEpD,KAAKA,EAAQ,KAAMP,CAAc,CAAA,CAIrC,KAAA,yBAAyBA,EAAgBC,EAAUC,CAAY,EAGpE,QAASG,EAAI,KAAK,QAAQ,OAAS,EAAGA,GAAK,EAAGA,IAC9C,CACU,IAAAE,EAAS,KAAK,QAAQF,CAAC,EAChBC,EAAYC,EAAO,IAAyB,EAEpD,IAAIA,EAAQ,KAAMP,CAAc,CAAA,CACzC,CAER,EC/IO,IAAMQ,GAAN,KACP,CADO,aAAA,CAYH,KAAO,KAAO,SAEd,KAAO,SAAW,CAAA,CAEX,SACP,CACI,QAASC,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAEhC,KAAA,QAAQA,CAAC,EAAE,QAAQ,EAG5B,KAAK,QAAU,KACf,KAAK,WAAa,IAAA,CAE1B,ECfO,IAAMC,GAAN,KACP,CADO,aAAA,CAKH,KAAgB,eAAsC,CAAA,EACtD,KAAiB,OAA+B,CAAA,EAChD,KAAQ,aAAe,EAAA,CAEhB,MACP,CACQ,KAAK,eAET,KAAK,aAAe,GAEf,KAAA,eAAe,QAASC,GAC7B,CACI,KAAK,IAAI,CACL,KAAMA,EAAK,KACX,UAAWA,CAAA,CACd,CAAA,CACJ,EAAA,CAGE,IAAIA,EACX,CACS,KAAA,OAAO,KAAKA,CAAI,CAAA,CAGlB,cAAcC,EACrB,CACS,KAAK,cAAc,KAAK,KAAK,EAElC,QAASC,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IACxC,CACU,IAAAF,EAAO,KAAK,OAAOE,CAAC,EAEtB,GAAAF,EAAK,KAAKC,CAAI,EAEd,OAAOE,EAAQ,IAAIH,EAAK,UAAyDC,CAAI,CACzF,CAGG,OAAAA,CAAA,CAGJ,iBAAiBG,EACxB,CACID,EAAQ,OAAOC,CAAM,CAAA,CAE7B,EAEaC,GAAoB,IAAIN,GAGrCO,GACK,aAAaC,EAAc,WAAYF,GAAkB,cAAc,ECjCrE,IAAMG,GAAmC,CAC5C,YAAa,KACb,aAAc,CACV,QAAS,EAAA,EAEb,cAAe,KAOf,QAAS,CAAA,EAET,yBACA,CACU,IAAAC,EAAc,KAAK,aAAe,KAAK,kBAEzCA,IAEAA,EAAY,mBAAqB,GACrC,EAQJ,UAAUC,EACV,CACkB,KAAK,QAAQ,QAAQA,CAAM,IAE3B,KAET,KAAA,QAAQ,KAAKA,CAAM,EAEnB,KAAA,QAAQ,KAAK,CAACC,EAAGC,IAAMD,EAAE,SAAWC,EAAE,QAAQ,EAEnD,KAAK,wBAAwB,EAO7B,KAAK,gBAAgB,EAAA,EAQzB,aAAaF,EACb,CACI,IAAMG,EAAQ,KAAK,QAAQ,QAAQH,CAAM,EAErCG,IAAU,KAET,KAAA,QAAQ,OAAOA,EAAO,CAAC,EAE5B,KAAK,wBAAwB,EAE7B,KAAK,gBAAgB,EAAA,EAGzB,IAAI,KAAKC,EACT,CACI,IAAMJ,EAAS,KAAK,YAEhBA,GAAQ,OAASI,IAEjBJ,IAEA,KAAK,aAAaA,CAAM,EAExBK,GAAkB,iBAAiBL,CAAM,EAEzC,KAAK,YAAc,MAGnBI,GAAU,OAET,KAAA,YAAcC,GAAkB,cAAcD,CAAK,EAEnD,KAAA,UAAU,KAAK,WAAW,GAAA,EAqBnC,QAAQE,EACR,CACI,KAAK,aAAe,CAChB,GAAG,KAAK,aACR,GAAGA,CAAA,EAGHA,EAAQ,OAER,KAAK,KAAOA,EAAQ,MAGxB,KAAK,wBAAwB,CAAA,EAwBjC,IAAI,MACJ,CACI,OAAO,KAAK,aAAa,IAAA,EAG7B,IAAI,QAAQF,EACZ,CACQ,CAAC,MAAM,QAAQA,CAAK,GAAKA,IAAOA,EAAQ,CAACA,CAAK,GAElD,IAAMJ,EAAS,KAAK,gBAAL,KAAK,cAAkB,IAAIO,IAGlCH,EAAAA,EAEF,IAAAI,EAAaJ,GAAO,OAAS,EAC7BK,EAAaT,EAAO,SAAS,OAAS,EAEtCU,EAAYF,IAAeC,EAGjCL,EAAQ,MAAM,QAAQA,CAAK,EAAIA,EAAM,MAAM,CAAC,EAAIA,EAGzCJ,EAAA,QAAU,OAAO,OAAOI,CAAK,EAEhCM,IAEIF,EAEA,KAAK,UAAUR,CAAM,GAIrB,KAAK,aAAaA,CAAM,EAGxBA,EAAO,QAAUI,GAAS,MAElC,EASJ,IAAI,SACJ,CACI,OAAO,KAAK,eAAe,OAAA,EAG/B,IAAI,WAAWA,EACf,CACI,KAAK,gBAAL,KAAK,cAAkB,IAAIG,IAE3B,KAAK,cAAc,WAAaH,CAAA,EAUpC,IAAI,YACJ,CACI,OAAO,KAAK,eAAe,UAAA,CAGnC,EC5OO,IAAMO,GAAgC,CAMzC,MAAO,KASP,IAAI,MACJ,CAEI,OAAAC,EAAYC,EAAQ,uEAAuE,EAGpF,KAAK,KAAA,EAEhB,IAAI,KAAKC,EACT,CAEIF,EAAYC,EAAQ,uEAAuE,EAG3F,KAAK,MAAQC,CAAA,EAYjB,eAAeC,EAAcC,EAAO,GACpC,CACW,OAAA,KAAK,gBAAgBD,EAAMC,CAAI,CAAA,EAW1C,gBAAgBC,EAAwBD,EAAO,GAC/C,CACI,IAAME,EAAW,KAAK,SAEtB,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IACrC,CACU,IAAAC,EAAQF,EAASC,CAAC,EAEpB,GAAAC,EAAM,QAAUH,GAAUA,aAAiB,QAAUA,EAAM,KAAKG,EAAM,KAAK,EAAW,OAAAA,CAAA,CAG9F,GAAIJ,EAEA,QAASG,EAAI,EAAGA,EAAID,EAAS,OAAQC,IACrC,CAEI,IAAME,EADQH,EAASC,CAAC,EACJ,gBAAgBF,EAAO,EAAI,EAE/C,GAAII,EAEO,OAAAA,CACX,CAID,OAAA,IAAA,EAWX,mBAAmBJ,EAAwBD,EAAO,GAAOM,EAAM,CAAA,EAC/D,CACI,IAAMJ,EAAW,KAAK,SAEtB,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IACrC,CACU,IAAAC,EAAQF,EAASC,CAAC,GAEpBC,EAAM,QAAUH,GAAUA,aAAiB,QAAUA,EAAM,KAAKG,EAAM,KAAK,IAE3EE,EAAI,KAAKF,CAAK,CAClB,CAGJ,GAAIJ,EAEA,QAASG,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAEjCD,EAASC,CAAC,EAAE,mBAAmBF,EAAO,GAAMK,CAAG,EAIhD,OAAAA,CAAA,CAEf,EC9HA,IAAMC,GAAa,CAAC,IAAIC,EAAS,IAAIA,EAAS,IAAIA,EAAS,IAAIA,CAAO,EAazDC,EAAN,MAAMC,CACb,CAqCI,YAAYC,EAAqB,EAAGC,EAAqB,EAAGC,EAAyB,EAAGC,EAA0B,EAClH,CAjCA,KAAgB,KAAwB,YAkC/B,KAAA,EAAI,OAAOH,CAAC,EACZ,KAAA,EAAI,OAAOC,CAAC,EACZ,KAAA,MAAQ,OAAOC,CAAK,EACpB,KAAA,OAAS,OAAOC,CAAM,CAAA,CAI/B,IAAI,MACJ,CACI,OAAO,KAAK,CAAA,CAIhB,IAAI,OACJ,CACW,OAAA,KAAK,EAAI,KAAK,KAAA,CAIzB,IAAI,KACJ,CACI,OAAO,KAAK,CAAA,CAIhB,IAAI,QACJ,CACW,OAAA,KAAK,EAAI,KAAK,MAAA,CAIlB,SACP,CACI,OAAO,KAAK,OAAS,KAAK,OAAS,KAAK,MAAQ,KAAK,MAAA,CAIzD,WAAW,OACX,CACI,OAAO,IAAIJ,EAAU,EAAG,EAAG,EAAG,CAAC,CAAA,CAO5B,OACP,CACW,OAAA,IAAIA,EAAU,KAAK,EAAG,KAAK,EAAG,KAAK,MAAO,KAAK,MAAM,CAAA,CAQzD,eAAeK,EACtB,CACI,YAAK,EAAIA,EAAO,KAChB,KAAK,EAAIA,EAAO,KACX,KAAA,MAAQA,EAAO,KAAOA,EAAO,KAC7B,KAAA,OAASA,EAAO,KAAOA,EAAO,KAE5B,IAAA,CAQJ,SAASC,EAChB,CACI,YAAK,EAAIA,EAAU,EACnB,KAAK,EAAIA,EAAU,EACnB,KAAK,MAAQA,EAAU,MACvB,KAAK,OAASA,EAAU,OAEjB,IAAA,CAQJ,OAAOA,EACd,CACI,OAAAA,EAAU,SAAS,IAAI,EAEhBA,CAAA,CASJ,SAASL,EAAWC,EAC3B,CACI,OAAI,KAAK,OAAS,GAAK,KAAK,QAAU,EAE3B,GAGPD,GAAK,KAAK,GAAKA,EAAI,KAAK,EAAI,KAAK,OAE7BC,GAAK,KAAK,GAAKA,EAAI,KAAK,EAAI,KAAK,MAMlC,CAWJ,eAAeD,EAAWC,EAAWK,EAAqBC,EAAoB,GACrF,CACU,GAAA,CAAE,MAAAL,EAAO,OAAAC,CAAA,EAAW,KAEtB,GAAAD,GAAS,GAAKC,GAAU,EAAU,MAAA,GAEtC,IAAMK,EAAK,KAAK,EACVC,EAAK,KAAK,EAEVC,EAAmBJ,GAAe,EAAIC,GACtCI,EAAmBL,EAAcI,EAEjCE,EAAYJ,EAAKE,EACjBG,EAAaL,EAAKN,EAAQQ,EAC1BI,EAAWL,EAAKC,EAChBK,EAAcN,EAAKN,EAASO,EAE5BM,EAAYR,EAAKG,EACjBM,EAAaT,EAAKN,EAAQS,EAC1BO,EAAWT,EAAKE,EAChBQ,EAAcV,EAAKN,EAASQ,EAElC,OAAQX,GAAKY,GAAaZ,GAAKa,GAAcZ,GAAKa,GAAYb,GAAKc,GAC5D,EAAEf,EAAIgB,GAAahB,EAAIiB,GAAchB,EAAIiB,GAAYjB,EAAIkB,EAAA,CAW7D,WAAWC,EAAkBC,EACpC,CACI,GAAI,CAACA,EACL,CACI,IAAMC,GAAK,KAAK,EAAIF,EAAM,EAAIA,EAAM,EAAI,KAAK,EAG7C,IAFW,KAAK,MAAQA,EAAM,MAAQA,EAAM,MAAQ,KAAK,QAE/CE,GAEC,MAAA,GAGX,IAAMC,GAAK,KAAK,EAAIH,EAAM,EAAIA,EAAM,EAAI,KAAK,EAG7C,OAFW,KAAK,OAASA,EAAM,OAASA,EAAM,OAAS,KAAK,QAEhDG,EAAA,CAGhB,IAAMD,EAAK,KAAK,KACVE,EAAK,KAAK,MACVD,EAAK,KAAK,IACVE,EAAK,KAAK,OAEZ,GAAAD,GAAMF,GAAMG,GAAMF,EAEX,MAAA,GAGL,IAAAG,EAAK9B,GAAW,CAAC,EAAE,IAAIwB,EAAM,KAAMA,EAAM,GAAG,EAC5CO,EAAK/B,GAAW,CAAC,EAAE,IAAIwB,EAAM,KAAMA,EAAM,MAAM,EAC/CQ,EAAKhC,GAAW,CAAC,EAAE,IAAIwB,EAAM,MAAOA,EAAM,GAAG,EAC7CS,EAAKjC,GAAW,CAAC,EAAE,IAAIwB,EAAM,MAAOA,EAAM,MAAM,EAEtD,GAAIQ,EAAG,GAAKF,EAAG,GAAKC,EAAG,GAAKD,EAAG,EAEpB,MAAA,GAGL,IAAAI,EAAI,KAAK,KAAMT,EAAU,EAAIA,EAAU,EAAMA,EAAU,EAAIA,EAAU,CAAE,EAYzE,GAVAS,IAAM,IAKAT,EAAA,MAAMK,EAAIA,CAAE,EACZL,EAAA,MAAMM,EAAIA,CAAE,EACZN,EAAA,MAAMO,EAAIA,CAAE,EACZP,EAAA,MAAMQ,EAAIA,CAAE,EAElB,KAAK,IAAIH,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,CAAC,GAAKP,GACjC,KAAK,IAAII,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,CAAC,GAAKL,GACpC,KAAK,IAAIE,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,CAAC,GAAKN,GACpC,KAAK,IAAIG,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGC,EAAG,CAAC,GAAKJ,GAEhC,MAAA,GAGX,IAAMM,EAAKD,GAAKH,EAAG,EAAID,EAAG,GACpBM,EAAKF,GAAKJ,EAAG,EAAIC,EAAG,GACpBM,EAAOF,EAAKT,EAAOU,EAAKT,EACxBW,EAAOH,EAAKP,EAAOQ,EAAKT,EACxBY,EAAOJ,EAAKT,EAAOU,EAAKP,EACxBW,EAAOL,EAAKP,EAAOQ,EAAKP,EAE1B,GAAA,KAAK,IAAIQ,EAAKC,EAAKC,EAAKC,CAAG,GAAML,EAAKL,EAAG,EAAMM,EAAKN,EAAG,GACpD,KAAK,IAAIO,EAAKC,EAAKC,EAAKC,CAAG,GAAML,EAAKF,EAAG,EAAMG,EAAKH,EAAG,EAEnD,MAAA,GAGX,IAAMQ,EAAKP,GAAKJ,EAAG,EAAIE,EAAG,GACpBU,EAAKR,GAAKF,EAAG,EAAIF,EAAG,GACpBa,EAAOF,EAAKf,EAAOgB,EAAKf,EACxBiB,EAAOH,EAAKb,EAAOc,EAAKf,EACxBkB,GAAOJ,EAAKf,EAAOgB,EAAKb,EACxBiB,GAAOL,EAAKb,EAAOc,EAAKb,EAE1B,MAAA,OAAK,IAAIc,EAAKC,EAAKC,GAAKC,EAAG,GAAML,EAAKX,EAAG,EAAMY,EAAKZ,EAAG,GACpD,KAAK,IAAIa,EAAKC,EAAKC,GAAKC,EAAG,GAAML,EAAKR,EAAG,EAAMS,EAAKT,EAAG,EAKvD,CAUJ,IAAIc,EAAW,EAAGC,EAAWD,EACpC,CACI,YAAK,GAAKA,EACV,KAAK,GAAKC,EAEV,KAAK,OAASD,EAAW,EACzB,KAAK,QAAUC,EAAW,EAEnB,IAAA,CAQJ,IAAIvC,EACX,CACI,IAAMmB,EAAK,KAAK,IAAI,KAAK,EAAGnB,EAAU,CAAC,EACjCwC,EAAK,KAAK,IAAI,KAAK,EAAI,KAAK,MAAOxC,EAAU,EAAIA,EAAU,KAAK,EAChEoB,EAAK,KAAK,IAAI,KAAK,EAAGpB,EAAU,CAAC,EACjCyC,EAAK,KAAK,IAAI,KAAK,EAAI,KAAK,OAAQzC,EAAU,EAAIA,EAAU,MAAM,EAExE,YAAK,EAAImB,EACT,KAAK,MAAQ,KAAK,IAAIqB,EAAKrB,EAAI,CAAC,EAChC,KAAK,EAAIC,EACT,KAAK,OAAS,KAAK,IAAIqB,EAAKrB,EAAI,CAAC,EAE1B,IAAA,CASJ,KAAKsB,EAAa,EAAGC,EAAM,KAClC,CACU,IAAAH,EAAK,KAAK,MAAM,KAAK,EAAI,KAAK,MAAQG,GAAOD,CAAU,EAAIA,EAC3DD,EAAK,KAAK,MAAM,KAAK,EAAI,KAAK,OAASE,GAAOD,CAAU,EAAIA,EAElE,YAAK,EAAI,KAAK,OAAO,KAAK,EAAIC,GAAOD,CAAU,EAAIA,EACnD,KAAK,EAAI,KAAK,OAAO,KAAK,EAAIC,GAAOD,CAAU,EAAIA,EAE9C,KAAA,MAAQF,EAAK,KAAK,EAClB,KAAA,OAASC,EAAK,KAAK,EAEjB,IAAA,CAQJ,QAAQzC,EACf,CACI,IAAMmB,EAAK,KAAK,IAAI,KAAK,EAAGnB,EAAU,CAAC,EACjCwC,EAAK,KAAK,IAAI,KAAK,EAAI,KAAK,MAAOxC,EAAU,EAAIA,EAAU,KAAK,EAChEoB,EAAK,KAAK,IAAI,KAAK,EAAGpB,EAAU,CAAC,EACjCyC,EAAK,KAAK,IAAI,KAAK,EAAI,KAAK,OAAQzC,EAAU,EAAIA,EAAU,MAAM,EAExE,YAAK,EAAImB,EACT,KAAK,MAAQqB,EAAKrB,EAClB,KAAK,EAAIC,EACT,KAAK,OAASqB,EAAKrB,EAEZ,IAAA,CAQJ,UAAUwB,EACjB,CACI,OAAAA,IAAAA,EAAQ,IAAIlD,GACZkD,EAAI,SAAS,IAAI,EAEVA,CAAA,CAuBJ,aAAa7B,EACpB,CACI,GAAI,KAAK,OAAS,GAAK,KAAK,QAAU,EAAU,MAAA,GAEhD,IAAMI,EAAKJ,EAAM,EACXK,EAAKL,EAAM,EACXyB,EAAKzB,EAAM,EAAIA,EAAM,MACrB0B,EAAK1B,EAAM,EAAIA,EAAM,OAE3B,OAAOI,GAAM,KAAK,GAAKA,EAAK,KAAK,EAAI,KAAK,OACnCC,GAAM,KAAK,GAAKA,EAAK,KAAK,EAAI,KAAK,QACnCoB,GAAM,KAAK,GAAKA,EAAK,KAAK,EAAI,KAAK,OACnCC,GAAM,KAAK,GAAKA,EAAK,KAAK,EAAI,KAAK,MAAA,CAIvC,UACP,CACW,MAAA,6BAA6B,KAAK,CAAC,MAAM,KAAK,CAAC,UAAU,KAAK,KAAK,WAAW,KAAK,MAAM,GAAA,CAGxG,ECxaA,IAAMI,GAAgB,IAAIC,EAUbC,EAAN,MAAMC,CACb,CAiBI,YAAYC,EAAO,IAAUC,EAAO,IAAUC,EAAO,KAAWC,EAAO,KACvE,CAhBA,KAAO,KAAO,IAGd,KAAO,KAAO,IAGd,KAAO,KAAO,KAGd,KAAO,KAAO,KAEd,KAAO,OAASP,GAMZ,KAAK,KAAOI,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,CAAA,CAOT,SACP,CACI,OAAO,KAAK,KAAO,KAAK,MAAQ,KAAK,KAAO,KAAK,IAAA,CAIrD,IAAI,WACJ,CACS,KAAK,aAED,KAAA,WAAa,IAAIC,GAG1B,IAAMC,EAAY,KAAK,WAEvB,OAAI,KAAK,KAAO,KAAK,MAAQ,KAAK,KAAO,KAAK,MAE1CA,EAAU,EAAI,EACdA,EAAU,EAAI,EACdA,EAAU,MAAQ,EAClBA,EAAU,OAAS,GAInBA,EAAU,eAAe,IAAI,EAG1BA,CAAA,CAIJ,OACP,CACI,YAAK,KAAO,IACZ,KAAK,KAAO,IACZ,KAAK,KAAO,KACZ,KAAK,KAAO,KAEZ,KAAK,OAAST,GAEP,IAAA,CAUJ,IAAIU,EAAYC,EAAYC,EAAYC,EAC/C,CACI,KAAK,KAAOH,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,CAAA,CAWT,SAASH,EAAYC,EAAYC,EAAYC,EAAYC,EAChE,CACIA,IAAAA,EAAW,KAAK,QAEhB,IAAMC,EAAID,EAAO,EACXE,EAAIF,EAAO,EACXG,EAAIH,EAAO,EACXI,EAAIJ,EAAO,EACXK,EAAKL,EAAO,GACZM,EAAKN,EAAO,GAEdV,EAAO,KAAK,KACZC,EAAO,KAAK,KACZC,EAAO,KAAK,KACZC,EAAO,KAAK,KAEZc,EAAKN,EAAIL,EAAOO,EAAIN,EAAMQ,EAC1BG,EAAKN,EAAIN,EAAOQ,EAAIP,EAAMS,EAE1BC,EAAIjB,IAAaA,EAAAiB,GACjBC,EAAIjB,IAAaA,EAAAiB,GACjBD,EAAIf,IAAaA,EAAAe,GACjBC,EAAIf,IAAaA,EAAAe,GAEhBD,EAAAN,EAAIH,EAAOK,EAAIN,EAAMQ,EACrBG,EAAAN,EAAIJ,EAAOM,EAAIP,EAAMS,EAEtBC,EAAIjB,IAAaA,EAAAiB,GACjBC,EAAIjB,IAAaA,EAAAiB,GACjBD,EAAIf,IAAaA,EAAAe,GACjBC,EAAIf,IAAaA,EAAAe,GAEhBD,EAAAN,EAAIL,EAAOO,EAAIJ,EAAMM,EACrBG,EAAAN,EAAIN,EAAOQ,EAAIL,EAAMO,EAEtBC,EAAIjB,IAAaA,EAAAiB,GACjBC,EAAIjB,IAAaA,EAAAiB,GACjBD,EAAIf,IAAaA,EAAAe,GACjBC,EAAIf,IAAaA,EAAAe,GAEhBD,EAAAN,EAAIH,EAAOK,EAAIJ,EAAMM,EACrBG,EAAAN,EAAIJ,EAAOM,EAAIL,EAAMO,EAEtBC,EAAIjB,IAAaA,EAAAiB,GACjBC,EAAIjB,IAAaA,EAAAiB,GACjBD,EAAIf,IAAaA,EAAAe,GACjBC,EAAIf,IAAaA,EAAAe,GAErB,KAAK,KAAOlB,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,CAAA,CAQT,QAAQgB,EAAiBT,EAChC,CACI,KAAK,SAASS,EAAK,EAAGA,EAAK,EAAGA,EAAK,EAAIA,EAAK,MAAOA,EAAK,EAAIA,EAAK,OAAQT,CAAM,CAAA,CAQ5E,UAAUU,EAAoBV,EACrC,CACS,KAAA,SAASU,EAAO,KAAMA,EAAO,KAAMA,EAAO,KAAMA,EAAO,KAAMV,CAAM,CAAA,CAOrE,cAAcW,EACrB,CACI,KAAK,KAAO,KAAK,KAAOA,EAAK,KAAO,KAAK,KAAOA,EAAK,KACrD,KAAK,KAAO,KAAK,KAAOA,EAAK,KAAO,KAAK,KAAOA,EAAK,KACrD,KAAK,KAAO,KAAK,KAAOA,EAAK,KAAO,KAAK,KAAOA,EAAK,KACrD,KAAK,KAAO,KAAK,KAAOA,EAAK,KAAO,KAAK,KAAOA,EAAK,IAAA,CAOlD,YAAYX,EACnB,CACI,IAAMV,EAAO,KAAK,KACZC,EAAO,KAAK,KACZC,EAAO,KAAK,KACZC,EAAO,KAAK,KAGZ,CAAE,EAAAQ,EAAG,EAAAC,EAAG,EAAAC,EAAG,EAAAC,EAAG,GAAAC,EAAI,GAAAC,CAAA,EAAON,EAE3BO,EAAKN,EAAIX,EAASa,EAAIZ,EAAQc,EAC9BG,EAAKN,EAAIZ,EAASc,EAAIb,EAAQe,EAElC,KAAK,KAAOC,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOD,EACZ,KAAK,KAAOC,EAEPD,EAAAN,EAAIT,EAASW,EAAIZ,EAAQc,EACzBG,EAAAN,EAAIV,EAASY,EAAIb,EAAQe,EAC9B,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOD,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KAEhCD,EAAAN,EAAIX,EAASa,EAAIV,EAAQY,EACzBG,EAAAN,EAAIZ,EAASc,EAAIX,EAAQa,EAC9B,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOD,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KAEhCD,EAAAN,EAAIT,EAASW,EAAIV,EAAQY,EACzBG,EAAAN,EAAIV,EAASY,EAAIX,EAAQa,EAC9B,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOD,EAAI,KAAK,KAAOA,EAAI,KAAK,KACrC,KAAK,KAAOC,EAAI,KAAK,KAAOA,EAAI,KAAK,IAAA,CAOlC,IAAIC,EACX,CACQ,OAAA,KAAK,KAAOA,EAAK,OAAM,KAAK,KAAOA,EAAK,MACxC,KAAK,KAAOA,EAAK,QAAO,KAAK,KAAOA,EAAK,OAEzC,KAAK,KAAOA,EAAK,MAAK,KAAK,KAAOA,EAAK,KACvC,KAAK,KAAOA,EAAK,SAAQ,KAAK,KAAOA,EAAK,QAEvC,IAAA,CAUJ,UAAUG,EAAcC,EAAeC,EAAaC,EAC3D,CACI,OAAI,KAAK,KAAOH,IAAM,KAAK,KAAOA,GAC9B,KAAK,KAAOC,IAAO,KAAK,KAAOA,GAE/B,KAAK,KAAOC,IAAK,KAAK,KAAOA,GAC7B,KAAK,KAAOC,IAAQ,KAAK,KAAOA,GAE7B,IAAA,CASJ,IAAIC,EAAkBC,EAAmBD,EAChD,CACI,YAAK,MAAQA,EACb,KAAK,MAAQA,EAEb,KAAK,MAAQC,EACb,KAAK,MAAQA,EAEN,IAAA,CAIJ,MACP,CACI,YAAK,KAAO,KAAK,MAAM,KAAK,IAAI,EAChC,KAAK,KAAO,KAAK,MAAM,KAAK,IAAI,EAChC,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,EAC/B,KAAK,KAAO,KAAK,KAAK,KAAK,IAAI,EAExB,IAAA,CAIJ,OACP,CACW,OAAA,IAAI5B,EAAO,KAAK,KAAM,KAAK,KAAM,KAAK,KAAM,KAAK,IAAI,CAAA,CAQzD,MAAMkB,EAAWC,EAAYD,EACpC,CACI,YAAK,MAAQA,EACb,KAAK,MAAQC,EACb,KAAK,MAAQD,EACb,KAAK,MAAQC,EAEN,IAAA,CAIX,IAAI,GACJ,CACI,OAAO,KAAK,IAAA,CAEhB,IAAI,EAAEU,EACN,CACU,IAAAC,EAAQ,KAAK,KAAO,KAAK,KAE/B,KAAK,KAAOD,EACZ,KAAK,KAAOA,EAAQC,CAAA,CAIxB,IAAI,GACJ,CACI,OAAO,KAAK,IAAA,CAGhB,IAAI,EAAED,EACN,CACU,IAAAE,EAAS,KAAK,KAAO,KAAK,KAEhC,KAAK,KAAOF,EACZ,KAAK,KAAOA,EAAQE,CAAA,CAIxB,IAAI,OACJ,CACW,OAAA,KAAK,KAAO,KAAK,IAAA,CAG5B,IAAI,MAAMF,EACV,CACS,KAAA,KAAO,KAAK,KAAOA,CAAA,CAI5B,IAAI,QACJ,CACW,OAAA,KAAK,KAAO,KAAK,IAAA,CAG5B,IAAI,OAAOA,EACX,CACS,KAAA,KAAO,KAAK,KAAOA,CAAA,CAI5B,IAAI,MACJ,CACI,OAAO,KAAK,IAAA,CAIhB,IAAI,OACJ,CACI,OAAO,KAAK,IAAA,CAIhB,IAAI,KACJ,CACI,OAAO,KAAK,IAAA,CAIhB,IAAI,QACJ,CACI,OAAO,KAAK,IAAA,CAIhB,IAAI,YACJ,CACY,OAAA,KAAK,KAAO,KAAK,KAAO,GAAO,KAAK,KAAO,KAAK,KAAO,CAAA,CAGnE,IAAI,SACJ,CACY,OAAA,KAAK,KAAO,KAAK,OAAS,GAAA,CAU/B,cAAcG,EAA0BC,EAAqBC,EAAmBvB,EACvF,CACI,IAAIV,EAAO,KAAK,KACZC,EAAO,KAAK,KACZC,EAAO,KAAK,KACZC,EAAO,KAAK,KAEhBO,IAAAA,EAAW,KAAK,QAEhB,IAAMC,EAAID,EAAO,EACXE,EAAIF,EAAO,EACXG,EAAIH,EAAO,EACX,EAAIA,EAAO,EACXK,EAAKL,EAAO,GACZM,EAAKN,EAAO,GAElB,QAASwB,EAAIF,EAAaE,EAAID,EAAWC,GAAK,EAC9C,CACU,IAAAC,EAASJ,EAAWG,CAAC,EACrBE,EAASL,EAAWG,EAAI,CAAC,EAEzBjB,EAAKN,EAAIwB,EAAWtB,EAAIuB,EAAUrB,EAClCG,EAAKN,EAAIuB,EAAW,EAAIC,EAAUpB,EAEjChB,EAAAiB,EAAIjB,EAAOiB,EAAIjB,EACfC,EAAAiB,EAAIjB,EAAOiB,EAAIjB,EACfC,EAAAe,EAAIf,EAAOe,EAAIf,EACfC,EAAAe,EAAIf,EAAOe,EAAIf,CAAA,CAG1B,KAAK,KAAOH,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,EACZ,KAAK,KAAOC,CAAA,CAQT,cAAcc,EAAWC,EAChC,CACQ,OAAA,KAAK,MAAQD,GAAK,KAAK,MAAQC,GAAK,KAAK,MAAQD,GAAK,KAAK,MAAQC,CAKhE,CAGJ,UACP,CAEI,MAAO,wBAAwB,KAAK,IAAI,SAAS,KAAK,IAAI,SAAS,KAAK,IAAI,SAAS,KAAK,IAAI,UAAU,KAAK,KAAK,WAAW,KAAK,MAAM,GAAA,CAQrI,SAASE,EAChB,CACI,YAAK,KAAOA,EAAO,KACnB,KAAK,KAAOA,EAAO,KACnB,KAAK,KAAOA,EAAO,KACnB,KAAK,KAAOA,EAAO,KAEZ,IAAA,CAEf,ECvea,IAAAiB,EAAa,IAAIC,EAAqBC,CAAM,EAC5CC,EAAa,IAAIF,EAAqBG,CAAM,ECDzD,IAAMC,GAAa,IAAIC,EAyCVC,GAA+C,CAUxD,oBAAoBC,EAA8BC,EAClD,CACIA,IAAAA,EAAW,IAAIC,GAGfD,EAAO,MAAM,EAGb,KAAK,0BAA0B,CAAC,CAACD,EAAoBC,EAAQ,KAAK,iBAAiB,EAG9EA,EAAO,SAERA,EAAO,IAAI,EAAG,EAAG,EAAG,CAAC,EAInB,IAAAE,EAAc,KAAK,aAAe,KAAK,kBAEtC,OAAAF,EAAA,YAAYE,EAAY,cAAc,EAEtCF,CAAA,EAYX,0BACID,EACAC,EACAG,EAEJ,CACI,IAAIC,EAAcJ,EAMlB,GAHID,GAAsB,KAAK,mBAAqB,KAAK,oBAAsBI,GAG3E,KAAK,qBAAuB,GAAU,CAAC,KAAK,WAE5C,OAIJ,IAAME,EAAgB,CAAC,CAAC,KAAK,QAAQ,OASrC,IANI,KAAK,aAAeA,KAEND,EAAAE,EAAW,IAAI,EAAE,MAAM,GAIrC,KAAK,WAELN,EAAO,QAAQ,KAAK,WAAY,KAAK,cAAc,MAGvD,CAEI,GAAI,KAAK,aACT,CACI,IAAMO,EAAc,KAAoB,OAE5BH,EAAA,SACRG,EAAW,KACXA,EAAW,KACXA,EAAW,KACXA,EAAW,KACX,KAAK,cAAA,CACT,CAIJ,IAAMC,EAAW,KAAK,SAEtB,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAEjCD,EAASC,CAAC,EAAE,0BAA0BV,EAAoBK,EAAaD,CAAY,CACvF,CAIJ,GAAIE,EACJ,CACI,IAAIK,EAAW,GACTR,EAAc,KAAK,aAAe,KAAK,kBAG7C,QAASO,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAEjC,KAAK,QAAQA,CAAC,EAAE,YAEXC,IAEUA,EAAA,GACCN,EAAA,YAAYF,EAAY,cAAc,GAEtD,KAAK,QAAQO,CAAC,EAAE,UAAUL,EAAa,EAAI,GAK/CM,IAEAN,EAAY,YAAYF,EAAY,eAAe,OAAON,EAAU,EAAE,OAAA,CAAQ,EACvEI,EAAA,UAAUI,EAAa,KAAK,sBAAsB,GAI7DJ,EAAO,UAAUI,CAAW,EAC5BE,EAAW,OAAOF,CAAW,CAAA,MAExB,KAAK,cAGHJ,EAAA,UAAUI,EAAa,KAAK,sBAAsB,EACzDE,EAAW,OAAOF,CAAW,EACjC,CAGR,ECpLgB,SAAAO,GAAgBC,EAAmBC,EAA8BC,EACjF,CACIA,EAAO,MAAM,EAET,IAAAC,EACAC,EAEJ,OAAIJ,EAAO,OAEFC,EAODE,EAAkBH,EAAO,OAAO,gBALjBI,EAAAC,EAAW,IAAI,EAAE,SAAS,EACvBF,EAAAG,GAAyBN,EAAQI,CAAY,GASnED,EAAkBI,EAAO,SAKZC,GAAAR,EAAQE,EAAQC,EAAiBF,CAAmB,EAEjEG,GAEAC,EAAW,OAAOD,CAAY,EAG7BF,EAAO,SAERA,EAAO,IAAI,EAAG,EAAG,EAAG,CAAC,EAGlBA,CACX,CAEO,SAASM,GACZR,EACAE,EACAC,EACAF,EAEJ,CACI,GAAI,CAACD,EAAO,SAAW,CAACA,EAAO,WAAY,OAEvC,IAAAS,EAECR,EAUDQ,EAAiBT,EAAO,gBARxBA,EAAO,qBAAqB,EAE5BS,EAAiBJ,EAAW,IAAI,EAEjBI,EAAA,WAAWT,EAAO,eAAgBG,CAAe,GAOpE,IAAMO,EAAeR,EACfS,EAAiB,CAAC,CAACX,EAAO,QAAQ,OAOxC,GALIW,IAEST,EAAAU,EAAW,IAAI,EAAE,MAAM,GAGhCZ,EAAO,WAEAE,EAAA,QAAQF,EAAO,WAAYS,CAAc,MAGpD,CACST,EAAsB,SAGvBE,EAAO,OAASO,EACTP,EAAA,UAAWF,EAAsB,MAAM,GAGlD,QAASa,EAAI,EAAGA,EAAIb,EAAO,SAAS,OAAQa,IAExCL,GAAiBR,EAAO,SAASa,CAAC,EAAGX,EAAQO,EAAgBR,CAAmB,CACpF,CAGJ,GAAIU,EACJ,CACI,QAASE,EAAI,EAAGA,EAAIb,EAAO,QAAQ,OAAQa,IAEvCb,EAAO,QAAQa,CAAC,EAAE,YAAYX,CAAM,EAG3BQ,EAAA,UAAUR,EAAQK,EAAO,QAAQ,EAE9CK,EAAW,OAAOV,CAAM,CAAA,CAGvBD,GAEDI,EAAW,OAAOI,CAAc,CAExC,CAEgB,SAAAH,GAAyBN,EAAmBG,EAC5D,CACI,IAAMW,EAASd,EAAO,OAEtB,OAAIc,IAEAR,GAAyBQ,EAAQX,CAAe,EAEhDW,EAAO,qBAAqB,EAEZX,EAAA,OAAOW,EAAO,cAAc,GAGzCX,CACX,CCnIgB,SAAAY,GAAkBC,EAAgBC,EAClD,CACQ,GAAAD,IAAW,UAAY,CAACC,EAAe,OAAAA,EACvC,GAAAA,IAAW,UAAY,CAACD,EAAe,OAAAA,EAErC,IAAAE,EAAMF,GAAU,GAAM,IACtBG,EAAMH,GAAU,EAAK,IACrBI,EAAKJ,EAAS,IAEdK,EAAMJ,GAAU,GAAM,IACtBK,EAAML,GAAU,EAAK,IACrBM,EAAKN,EAAS,IAEdO,EAAMN,EAAKG,EAAM,IAAO,EACxBI,EAAMN,EAAKG,EAAM,IAAO,EACxBI,EAAMN,EAAKG,EAAM,IAAO,EAEtB,OAAAC,GAAK,KAAOC,GAAK,GAAKC,CAClC,CChBA,IAAMC,GAAY,SAEF,SAAAC,GAAeC,EAAuBC,EACtD,CACI,OAAID,IAAkBF,GAEXG,EAGPA,IAAmBH,GAEZE,EAGJE,GAAkBF,EAAeC,CAAc,CAC1D,CCVO,SAASE,GAAQC,EACxB,CACI,QAASA,EAAQ,MAAS,KAAOA,EAAQ,QAAYA,GAAS,GAAM,IACxE,CASO,IAAMC,GAAqC,CAc9C,eAAeC,EACf,CACI,GAAIA,EAEA,OAAI,KAAK,YAEE,KAAK,YAAY,WAGxB,KAAK,kBAEE,KAAK,kBAAkB,WAAa,KAAK,MAG7C,KAAK,MAGhB,IAAIC,EAAQ,KAAK,MACbC,EAAU,KAAK,OAEnB,KAAOA,GAEHD,GAASC,EAAQ,MACjBA,EAAUA,EAAQ,OAGf,OAAAD,CAAA,EAqBX,mBAAmBE,EAAgBH,EACnC,CACI,GAAIA,EAEO,OAAAG,EAAO,SAAS,KAAK,cAAc,EAG9C,KAAK,qBAAqB,EAE1B,IAAMC,EAAkBC,GAAyB,KAAMC,EAAW,IAAI,EAAE,SAAA,CAAU,EAE3E,OAAAH,EAAA,WAAW,KAAK,eAAgBC,CAAe,EACtDE,EAAW,OAAOF,CAAe,EAE1BD,CAAA,EAgBX,cAAcH,EACd,CACI,GAAIA,EAEA,OAAI,KAAK,YAEEH,GAAQ,KAAK,YAAY,UAAU,EAG1C,KAAK,kBAEEA,GACHU,GAAe,KAAK,WAAY,KAAK,kBAAkB,UAAU,CAAA,EAIlE,KAAK,KAGhB,IAAIT,EAAQ,KAAK,WACbU,EAAS,KAAK,OAElB,KAAOA,GAEKV,EAAAS,GAAeT,EAAOU,EAAO,UAAU,EAC/CA,EAASA,EAAO,OAGpB,OAAOX,GAAQC,CAAK,CAAA,CAG5B,EC7IA,IAAIW,GAAY,EACVC,GAAc,IASb,SAASC,MAAQC,EACxB,CACQH,KAAcC,KAElBD,KAEIA,KAAcC,GAEd,QAAQ,KAAK,gGAAgG,EAIrG,QAAA,KAAK,mBAAoB,GAAGE,CAAI,EAEhD,CChBgB,SAAAC,GAAeC,EAAmBC,EAAgBC,EAClE,CACI,OAAAD,EAAO,MAAM,EAEbC,IAAAA,EAAmBC,EAAO,UAE1BC,GAAgBJ,EAAQC,EAAQC,EAAgBF,EAAQ,EAAI,EAEvDC,EAAO,SAERA,EAAO,IAAI,EAAG,EAAG,EAAG,CAAC,EAGlBA,CACX,CAEA,SAASG,GACLJ,EACAC,EACAI,EACAC,EACAC,EAEJ,CACQ,IAAAC,EAEJ,GAAKD,EAaDC,EAAoBC,EAAW,IAAI,EACfD,EAAAH,EAAgB,OAAOG,CAAiB,MAbhE,CACI,GAAI,CAACR,EAAO,SAAW,CAACA,EAAO,WAAY,OAE3CA,EAAO,qBAAqB,EAE5B,IAAMU,EAAiBV,EAAO,eAE9BQ,EAAoBC,EAAW,IAAI,EACjBD,EAAA,WAAWE,EAAgBL,CAAe,CAAA,CAQhE,IAAMM,EAAeV,EACfW,EAAiB,CAAC,CAACZ,EAAO,QAAQ,OAOxC,GALIY,IAESX,EAAAY,EAAW,IAAI,EAAE,MAAM,GAGhCb,EAAO,WAEAC,EAAA,QAAQD,EAAO,WAAYQ,CAAiB,MAGvD,CACQR,EAAO,eAEPC,EAAO,OAASO,EACTP,EAAA,UAAWD,EAAsB,MAAM,GAGlD,IAAMc,EAAWd,EAAO,SAExB,QAASe,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAEjCX,GAAgBU,EAASC,CAAC,EAAGd,EAAQO,EAAmBF,EAAe,EAAK,CAChF,CAGJ,GAAIM,EACJ,CACI,QAASG,EAAI,EAAGA,EAAIf,EAAO,QAAQ,OAAQe,IAEvCf,EAAO,QAAQe,CAAC,EAAE,iBAAiBd,EAAQK,CAAa,EAI/CK,EAAA,UAAUV,EAAQE,EAAO,QAAQ,EAE9CU,EAAW,OAAOZ,CAAM,CAAA,CAG5BQ,EAAW,OAAOD,CAAiB,CACvC,CC5EgB,SAAAQ,GACZC,EACAC,EAKJ,CACI,IAAMC,EAAWF,EAAU,SAE3B,QAASG,EAAI,EAAGA,EAAID,EAAS,OAAQC,IACrC,CACU,IAAAC,EAAQF,EAASC,CAAC,EAElBE,EAAMD,EAAM,IACZE,GAAcF,EAAM,mBAAqB,QAAW,GAAOA,EAAM,wBAA0B,MAE3FG,EAAQN,EAAa,OAEvBA,EAAa,KAAKM,CAAK,IAAMF,GAAOJ,EAAa,KAAKM,EAAQ,CAAC,IAAMD,KAExDL,EAAA,KAAKA,EAAa,KAAK,EAAII,EACxCJ,EAAa,KAAKA,EAAa,MAAQ,CAAC,EAAIK,EAE5CL,EAAa,UAAY,IAG7BA,EAAa,MAAQM,EAAQ,EAEzBH,EAAM,SAAS,QAEfL,GAAuBK,EAAOH,CAAY,CAC9C,CAGJ,OAAOA,EAAa,SACxB,CChBA,IAAMO,GAAa,IAAIC,EAEVC,GAAmC,CAE5C,oBAAqB,GACrB,sBAAuB,KAEvB,UAAUC,EAAeC,EACzB,CACI,IAAMC,EAAO,KAAK,KAAK,KAAK,MAAM,CAAC,GAAK,EAEpCD,IAAe,EAEV,KAAA,MAAM,EAAKD,EAAQC,EAAcC,EAItC,KAAK,MAAM,EAAIA,CACnB,EAGJ,WAAWF,EAAeG,EAC1B,CACI,IAAMD,EAAO,KAAK,KAAK,KAAK,MAAM,CAAC,GAAK,EAEpCC,IAAgB,EAEX,KAAA,MAAM,EAAKH,EAAQG,EAAeD,EAIvC,KAAK,MAAM,EAAIA,CACnB,EAQJ,gBACA,CACS,KAAK,wBAEN,KAAK,sBAAwB,CACzB,KAAM,CAAA,EACN,MAAO,EACP,UAAW,GACX,YAAa,IAAIE,CAAO,GAIhC,IAAMC,EAAuB,KAAK,sBAElC,OAAAA,EAAqB,MAAQ,EAC7BA,EAAqB,UAAY,GAE7BA,EAAqB,KAAK,CAAC,IAAM,KAAK,qBAEtCA,EAAqB,UAAY,GACZA,EAAA,KAAK,CAAC,EAAI,KAAK,oBAGxCC,GAAuB,KAAMD,CAAoB,EAE7CA,EAAqB,WAENE,GAAA,KAAMF,EAAqB,YAAaR,EAAU,EAG9DQ,EAAqB,WAAA,EAYhC,UAAUG,EAAsBC,EAChC,CACI,OAAOC,GAAgB,KAAMF,EAAYC,GAAU,IAAIL,CAAQ,CAAA,CAEvE,EC/GO,IAAMO,GAAoC,CAC7C,UAAW,KAEX,IAAI,SAASC,EACb,CACU,IAAAC,EAAc,KAAK,aAAe,KAAK,kBAE7C,GAAI,CAACD,EACL,CACQ,KAAK,WAELC,GAAa,eAAe,IAAI,EAGpC,KAAK,UAAY,KAEjB,MAAA,CAGC,KAAK,WAENA,GAAa,YAAY,IAAI,EAGjC,KAAK,UAAYD,CAAA,EAgBrB,IAAI,UACJ,CACI,OAAO,KAAK,SAAA,CAEpB,ECxCO,IAAME,GAAgC,CACzC,QAAS,EAQT,UAAW,GAcX,iBAAkB,GAWlB,IAAI,QACJ,CACI,OAAO,KAAK,OAAA,EAGhB,IAAI,OAAOC,EACX,CACQ,KAAK,UAAYA,IAErB,KAAK,QAAUA,EAEf,KAAK,qBAAqB,EAAA,EAG9B,sBACA,CACQ,KAAK,SAEL,KAAK,OAAO,iBAAmB,GAC/B,KAAK,OAAO,UAAY,IAGxB,KAAK,oBAEL,KAAK,kBAAkB,mBAAqB,GAChD,EAOJ,cACA,CACS,KAAK,YAEV,KAAK,UAAY,GAEZ,KAAA,SAAS,KAAKC,EAAY,EAAA,CAEvC,EAEA,SAASA,GAAaC,EAAcC,EACpC,CACW,OAAAD,EAAE,QAAUC,EAAE,OACzB,CClFO,IAAMC,GAAyC,CAQlD,kBAAkBC,EAAe,IAAIC,EAASC,EAAa,GAC3D,CACI,OAAI,KAAK,OAEL,KAAK,OAAO,SAAS,KAAK,UAAWF,EAAOE,CAAU,GAIhDF,EAAA,EAAI,KAAK,UAAU,EACnBA,EAAA,EAAI,KAAK,UAAU,GAGtBA,CAAA,EAYX,SAAsCG,EAAqBH,EAAWE,EAAa,GACnF,CACI,IAAME,EAAe,KAAK,mBAAmBC,EAAW,IAAA,EAAOH,CAAU,EAGjE,OAAAF,EAAAI,EAAa,MAAMD,EAAUH,CAAK,EAE1CK,EAAW,OAAOD,CAAY,EAEvBJ,CAAA,EAaX,QAAqCG,EAAqBG,EAAkBN,EAAWE,EACvF,CACQI,IAEAH,EAAWG,EAAK,SAASH,EAAUH,EAAOE,CAAU,GAGxD,IAAME,EAAe,KAAK,mBAAmBC,EAAW,IAAA,EAAOH,CAAU,EAGjE,OAAAF,EAAAI,EAAa,aAAaD,EAAUH,CAAK,EAEjDK,EAAW,OAAOD,CAAY,EAEvBJ,CAAA,CAEf,ECpEO,IAAMO,GAAN,KACP,CADO,aAAA,CAGa,KAAA,IAAcC,EAAI,gBAAgB,EAElD,KAAgB,aAA8B,CAAA,EAE9C,KAAO,gBAAkB,EAIzB,KAAO,YAA4B,CAAA,EAEnC,KAAO,OAAS,CAAA,CAGT,OACP,CACI,KAAK,gBAAkB,CAAA,CAOpB,IAAIC,EACX,CACS,KAAA,aAAa,KAAK,iBAAiB,EAAIA,CAAA,CAQzC,KACP,CACS,KAAA,aAAa,OAAS,KAAK,gBAEhC,QAAQ,MAAM,KAAK,aAAc,CAAC,OAAQ,QAAQ,CAAC,CAAA,CAE3D,EC/CO,SAASC,GAASC,EACzB,CACS,OAAAA,GAAAA,IAAM,EAAI,EAAI,EACjB,EAAAA,EACFA,GAAKA,IAAM,EACXA,GAAKA,IAAM,EACXA,GAAKA,IAAM,EACXA,GAAKA,IAAM,EACXA,GAAKA,IAAM,GAEJA,EAAI,CACf,CASO,SAASC,GAAOD,EACvB,CACI,MAAO,EAAEA,EAAKA,EAAI,IAAQ,CAAC,CAACA,CAChC,CCxBO,SAASE,GAA4CC,EAC5D,CACI,IAAMC,EAAqB,CAAA,EAE3B,QAAWC,KAAOF,EAEVA,EAAIE,CAAG,IAAM,SAEND,EAAAC,CAAG,EAAIF,EAAIE,CAAG,GAItB,OAAAD,CACX,CCdA,IAAME,GAAwC,OAAA,OAAO,IAAI,EASzD,SAASC,GAA2BC,EACpC,CACU,IAAAC,EAAKH,GAAOE,CAAK,EAEvB,OAAIC,IAAO,SAEAH,GAAAE,CAAK,EAAIE,EAAI,UAAU,GAG3BD,CACX,CAiDO,IAAME,GAAN,MAAMA,WAAqBC,CAIlC,CAqDI,YAAYC,EAA+B,CAAA,EAC3C,CACU,MAAA,EAtDV,KAAO,cAAgB,iBACvB,KAAO,SAAW,EAwClB,KAAO,eAA0B,EAMjC,KAAO,UAAY,GASfA,EAAU,CAAE,GAAGF,GAAa,eAAgB,GAAGE,CAAQ,EAEvD,KAAK,YAAcA,EAAQ,YAEtB,KAAA,aAAeA,EAAQ,cAAgB,KAAK,aAC5C,KAAA,aAAeA,EAAQ,cAAgB,KAAK,aAC5C,KAAA,aAAeA,EAAQ,cAAgB,KAAK,aAEjD,KAAK,UAAYA,EAAQ,UAEpB,KAAA,UAAYA,EAAQ,WAAa,KAAK,UACtC,KAAA,UAAYA,EAAQ,WAAa,KAAK,UACtC,KAAA,aAAeA,EAAQ,cAAgB,KAAK,aAEjD,KAAK,YAAcA,EAAQ,YAC3B,KAAK,YAAcA,EAAQ,YAE3B,KAAK,QAAUA,EAAQ,QAElB,KAAA,cAAgBA,EAAQ,eAAiB,CAAA,CAGlD,IAAI,YAAYL,EAChB,CACI,KAAK,aAAeA,EACpB,KAAK,aAAeA,EACpB,KAAK,aAAeA,CAAA,CAIxB,IAAI,aACJ,CACI,OAAO,KAAK,YAAA,CAGhB,IAAI,SAASA,EACb,CAEIM,EAAYC,EAAQ,uDAAuD,EAG3E,KAAK,YAAcP,CAAA,CAGvB,IAAI,UACJ,CACI,OAAO,KAAK,WAAA,CAGhB,IAAI,UAAUA,EACd,CACI,KAAK,UAAYA,EACjB,KAAK,UAAYA,EACjB,KAAK,aAAeA,CAAA,CAIxB,IAAI,WACJ,CACI,OAAO,KAAK,SAAA,CAIhB,IAAI,cAAcA,EAClB,CACI,KAAK,eAAiB,KAAK,IAAIA,EAAO,EAAE,EAEpC,KAAK,eAAiB,IAEtB,KAAK,UAAY,SACrB,CAGJ,IAAI,eACJ,CACI,OAAO,KAAK,cAAA,CAIhB,IAAI,aACJ,CACW,OAAA,KAAK,mBAAqB,KAAK,oBAAoB,CAAA,CAGvD,QACP,CAES,KAAA,KAAK,SAAU,IAAI,EACxB,KAAK,kBAAoB,IAAA,CAGrB,qBACR,CAEI,IAAMQ,EAAS,GAAG,KAAK,YAAY,IAAI,KAAK,YAAY,IAAI,KAAK,YAAY,IAAI,KAAK,SAAS,IAAI,KAAK,SAAS,IAAI,KAAK,YAAY,IAAI,KAAK,WAAW,IAAI,KAAK,WAAW,IAAI,KAAK,OAAO,IAAI,KAAK,cAAc,GAEhN,YAAA,kBAAoBT,GAA2BS,CAAM,EAEnD,KAAK,WAAA,CAIT,SACP,CACI,KAAK,UAAY,GAEZ,KAAA,KAAK,UAAW,IAAI,EACpB,KAAA,KAAK,SAAU,IAAI,EAExB,KAAK,mBAAmB,CAAA,CAEhC,EA5KaL,GAUc,eAAsC,CACzD,YAAa,gBACb,UAAW,QACf,EAbG,IAAMM,GAANN,GCHA,IAAMO,GAAN,MAAMA,WAA2DC,CAUxE,CAwII,YAA+BC,EAAmC,CAAA,EAClE,CACU,MAAA,EAFqB,KAAA,QAAAA,EAzHf,KAAA,IAAcC,EAAI,eAAe,EAUjD,KAAgB,cAAgB,gBAKzB,KAAA,YAAcA,EAAI,UAAU,EAQnC,KAAO,eAAiB,UAGxB,KAAO,YAAc,EAGrB,KAAO,WAAa,EAEpB,KAAO,YAAc,EAMrB,KAAO,MAAQ,EAKf,KAAO,OAAS,EAchB,KAAO,YAAc,EAGrB,KAAO,cAAgB,EASvB,KAAO,oBAAsB,GAE7B,KAAO,OAA0B,aAEjC,KAAO,UAAgC,KAUvC,KAAO,UAAY,GAYnB,KAAO,SAAW,EAMlB,KAAO,WAAa,GAKpB,KAAO,qBAAuB,GAoB1BD,EAAU,CAAE,GAAGF,GAAc,eAAgB,GAAGE,CAAQ,EAEnD,KAAA,MAAQA,EAAQ,OAAS,GAC9B,KAAK,SAAWA,EAAQ,SACxB,KAAK,mBAAqBA,EAAQ,mBAClC,KAAK,YAAcA,EAAQ,WAEvBA,EAAQ,MAEH,KAAA,WAAaA,EAAQ,MAAQ,KAAK,YAIvC,KAAK,WAAa,KAAK,SAAY,KAAK,eAAiB,EAAK,EAG9DA,EAAQ,OAEH,KAAA,YAAcA,EAAQ,OAAS,KAAK,YAIzC,KAAK,YAAc,KAAK,SAAY,KAAK,gBAAkB,EAAK,EAG/D,KAAA,MAAQ,KAAK,WAAa,KAAK,YAC/B,KAAA,OAAS,KAAK,YAAc,KAAK,YAEtC,KAAK,OAASA,EAAQ,OACtB,KAAK,UAAYA,EAAQ,WACzB,KAAK,cAAgBA,EAAQ,cAC7B,KAAK,oBAAsBA,EAAQ,oBACnC,KAAK,YAAcA,EAAQ,YAC3B,KAAK,UAAYA,EAAQ,UACzB,KAAK,UAAYA,EAAQ,UAEzB,KAAK,MAAQ,IAAIE,GAAaC,GAAaH,CAAO,CAAC,EAEnD,KAAK,UAAY,GAEjB,KAAK,YAAY,CAAA,CAIrB,IAAI,QACJ,CACW,OAAA,IAAA,CAIX,IAAI,OACJ,CACI,OAAO,KAAK,MAAA,CAGhB,IAAI,MAAMI,EACV,CACQ,KAAK,QAAUA,IAEnB,KAAK,QAAQ,IAAI,SAAU,KAAK,eAAgB,IAAI,EACpD,KAAK,OAASA,EACd,KAAK,QAAQ,GAAG,SAAU,KAAK,eAAgB,IAAI,EAEnD,KAAK,eAAe,EAAA,CAIxB,IAAI,aACJ,CACI,OAAO,KAAK,OAAO,WAAA,CAGvB,IAAI,YAAYA,EAChB,CACI,KAAK,OAAO,YAAcA,CAAA,CAI9B,IAAI,YACJ,CACI,OAAO,KAAK,OAAO,WAAA,CAGvB,IAAI,WAAWA,EACf,CACI,KAAK,OAAO,YAAcA,CAAA,CAI9B,IAAI,WACJ,CACI,OAAO,KAAK,OAAO,SAAA,CAGvB,IAAI,UAAUA,EACd,CACI,KAAK,OAAO,UAAYA,CAAA,CAI5B,IAAI,WACJ,CACI,OAAO,KAAK,OAAO,SAAA,CAGvB,IAAI,UAAUA,EACd,CACI,KAAK,OAAO,UAAYA,CAAA,CAI5B,IAAI,cACJ,CACI,OAAO,KAAK,OAAO,YAAA,CAGvB,IAAI,aAAaA,EACjB,CACI,KAAK,OAAO,aAAeA,CAAA,CAI/B,IAAI,aACJ,CACI,OAAO,KAAK,OAAO,WAAA,CAGvB,IAAI,YAAYA,EAChB,CACI,KAAK,OAAO,YAAcA,CAAA,CAI9B,IAAI,aACJ,CACI,OAAO,KAAK,OAAO,WAAA,CAGvB,IAAI,YAAYA,EAChB,CACI,KAAK,OAAO,YAAcA,CAAA,CAGtB,gBACR,CACS,KAAA,KAAK,cAAe,IAAI,CAAA,CAI1B,QACP,CAEI,GAAI,KAAK,SACT,CACI,IAAMC,EAAa,KAAK,YAMpB,GAJc,KAAK,OAAO,KAAK,cAAgBA,EAAY,KAAK,eAAiBA,CAAU,EAIhF,MAAA,CAGd,KAAA,KAAK,SAAU,IAAI,CAAA,CAIrB,SACP,CACI,KAAK,UAAY,GACZ,KAAA,KAAK,UAAW,IAAI,EACpB,KAAA,KAAK,SAAU,IAAI,EAEpB,KAAK,SAEL,KAAK,OAAO,QAAQ,EACpB,KAAK,OAAS,MAGlB,KAAK,eAAiB,KACtB,KAAK,SAAW,KAChB,KAAK,mBAAmB,CAAA,CAOrB,QACP,CACS,KAAA,YAAcJ,EAAI,UAAU,EAC5B,KAAA,KAAK,SAAU,IAAI,EACnB,KAAA,KAAK,SAAU,IAAI,CAAA,CAI5B,IAAW,eACX,CACU,GAAA,CAAE,SAAAK,CAAA,EAAa,KAErB,OAAOA,EAAS,cAAgBA,EAAS,YAAcA,EAAS,cAAgBA,EAAS,KAAA,CAI7F,IAAW,gBACX,CACU,GAAA,CAAE,SAAAA,CAAA,EAAa,KAErB,OAAOA,EAAS,eAAiBA,EAAS,aAAeA,EAAS,eAAiBA,EAAS,MAAA,CAUhG,IAAI,YACJ,CACI,OAAO,KAAK,WAAA,CAGhB,IAAI,WAAWD,EACf,CACQ,KAAK,cAAgBA,IAEzB,KAAK,YAAcA,EAEd,KAAA,MAAQ,KAAK,WAAaA,EAC1B,KAAA,OAAS,KAAK,YAAcA,EAAA,CAU9B,OAAOE,EAAgBC,EAAiBH,EAC/C,CACIA,IAAAA,EAAe,KAAK,aACpBE,IAAAA,EAAU,KAAK,OACfC,IAAAA,EAAW,KAAK,QAGhB,IAAMC,EAAgB,KAAK,MAAMF,EAAQF,CAAU,EAC7CK,EAAiB,KAAK,MAAMF,EAASH,CAAU,EAOrD,OALA,KAAK,MAAQI,EAAgBJ,EAC7B,KAAK,OAASK,EAAiBL,EAE/B,KAAK,YAAcA,EAEf,KAAK,aAAeI,GAAiB,KAAK,cAAgBC,EAEnD,IAGX,KAAK,YAAY,EAEjB,KAAK,WAAaD,EAClB,KAAK,YAAcC,EAEd,KAAA,KAAK,SAAU,IAAI,EAEnB,KAAA,YAAcT,EAAI,UAAU,EAC5B,KAAA,KAAK,SAAU,IAAI,EAEjB,GAAA,CAaJ,eACP,CACQ,KAAK,qBAAuB,KAAK,cAAgB,GAE5C,KAAA,KAAK,gBAAiB,IAAI,CACnC,CAGJ,IAAI,SAASG,EACb,CACI,KAAK,OAAO,SAAWA,CAAA,CAG3B,IAAI,UACJ,CACI,OAAO,KAAK,OAAO,QAAA,CAGvB,IAAI,UAAUA,EACd,CACI,KAAK,OAAO,UAAYA,CAAA,CAI5B,IAAI,WACJ,CACI,OAAO,KAAK,OAAO,SAAA,CAOb,aACV,CACI,KAAK,aAAeO,GAAO,KAAK,UAAU,GAAKA,GAAO,KAAK,WAAW,CAAA,CAG1E,OAAc,KAAKC,EACnB,CAEU,MAAA,IAAI,MAAM,eAAe,CAAA,CAQvC,EAlead,GAYK,eAAuC,CACjD,WAAY,EACZ,OAAQ,aACR,UAAW,8BACX,WAAY,KACZ,cAAe,EACf,oBAAqB,GACrB,YAAa,EACb,UAAW,GACX,mBAAoB,EACxB,EAtBG,IAAMe,EAANf,GC3DP,IAAMgB,EAAK,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,CAAC,EAC1DC,EAAK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAE,EAC1DC,EAAK,CAAC,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,GAAI,EAAE,EAC1DC,EAAK,CAAC,EAAG,EAAG,EAAG,GAAI,GAAI,GAAI,EAAG,EAAG,GAAI,GAAI,EAAG,EAAG,EAAG,EAAG,EAAG,EAAE,EAQ1DC,GAA6B,CAAA,EAO7BC,GAA6B,CAAA,EAK7BC,GAAS,KAAK,KAMpB,SAASC,IACT,CACI,QAAS,EAAI,EAAG,EAAI,GAAI,IACxB,CACI,IAAMC,EAAgB,CAAA,EAEtBJ,GAAe,KAAKI,CAAG,EAEvB,QAASC,EAAI,EAAGA,EAAI,GAAIA,IACxB,CAEI,IAAMC,EAAMJ,GAAQN,EAAG,CAAC,EAAIA,EAAGS,CAAC,EAAMP,EAAG,CAAC,EAAID,EAAGQ,CAAC,CAAE,EAC9CE,EAAML,GAAQL,EAAG,CAAC,EAAID,EAAGS,CAAC,EAAMN,EAAG,CAAC,EAAIF,EAAGQ,CAAC,CAAE,EAC9CG,EAAMN,GAAQN,EAAG,CAAC,EAAIE,EAAGO,CAAC,EAAMP,EAAG,CAAC,EAAIC,EAAGM,CAAC,CAAE,EAC9CI,EAAMP,GAAQL,EAAG,CAAC,EAAIC,EAAGO,CAAC,EAAMN,EAAG,CAAC,EAAIA,EAAGM,CAAC,CAAE,EAGpD,QAASK,EAAI,EAAGA,EAAI,GAAIA,IAEpB,GAAId,EAAGc,CAAC,IAAMJ,GAAOT,EAAGa,CAAC,IAAMH,GACtBT,EAAGY,CAAC,IAAMF,GAAOT,EAAGW,CAAC,IAAMD,EACpC,CACIL,EAAI,KAAKM,CAAC,EACV,KAAA,CAER,CACJ,CAGJ,QAAS,EAAI,EAAG,EAAI,GAAI,IACxB,CACU,IAAAC,EAAM,IAAIC,EAEhBD,EAAI,IAAIf,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAGC,EAAG,CAAC,EAAG,EAAG,CAAC,EACxCE,GAAiB,KAAKU,CAAG,CAAA,CAEjC,CAEAR,GAAK,EA+BE,IAAMU,EAAU,CAQnB,EAAG,EASH,GAAI,EASJ,EAAG,EASH,GAAI,EASJ,EAAG,EASH,GAAI,EASJ,EAAG,EASH,GAAI,EAOJ,gBAAiB,EAOjB,cAAe,GAOf,kBAAmB,GAOnB,iBAAkB,GAQlB,GAAKC,GAAkClB,EAAGkB,CAAG,EAQ7C,GAAKA,GAAkCjB,EAAGiB,CAAG,EAQ7C,GAAKA,GAAkChB,EAAGgB,CAAG,EAQ7C,GAAKA,GAAkCf,EAAGe,CAAG,EAS7C,IAAMC,GAEEA,EAAW,EAEJA,EAAW,GAGd,CAACA,EAAY,EA2BzB,IAAK,CAACC,EAA6BC,IAC/BjB,GAAegB,CAAc,EAAEC,CAAa,EAUhD,IAAK,CAACD,EAA6BC,IAC/BjB,GAAegB,CAAc,EAAEH,EAAQ,IAAII,CAAa,CAAC,EAU7D,UAAYF,GAA6BA,EAAW,EASpD,WAAaA,IAAoCA,EAAW,KAAO,EAWnE,YAAa,CAACG,EAAYC,IAElB,KAAK,IAAID,CAAE,EAAI,GAAK,KAAK,IAAIC,CAAE,EAE3BA,GAAM,EAECN,EAAQ,EAGZA,EAAQ,EAEV,KAAK,IAAIM,CAAE,EAAI,GAAK,KAAK,IAAID,CAAE,EAEhCA,EAAK,EAEEL,EAAQ,EAGZA,EAAQ,EAEVM,EAAK,EAEND,EAAK,EAEEL,EAAQ,GAGZA,EAAQ,GAEVK,EAAK,EAEHL,EAAQ,GAGZA,EAAQ,GAWnB,wBAAyB,CAACO,EAAgBL,EAAuBM,EAAK,EAAGC,EAAK,IAC9E,CAEI,IAAMX,EAAcV,GAAiBY,EAAQ,IAAIE,CAAQ,CAAC,EAE1DJ,EAAI,GAAKU,EACTV,EAAI,GAAKW,EACTF,EAAO,OAAOT,CAAG,CAAA,CAEzB,EC7XO,IAAMY,GAAO,IACpB,CAEA,ECUO,IAAMC,GAAN,cAAgCC,CACvC,CAKI,YAAYC,EACZ,CACU,IAAAC,EAASD,EAAQ,UAAY,IAAI,aAAaA,EAAQ,MAAQA,EAAQ,OAAS,CAAC,EAClFE,EAASF,EAAQ,OAEhBE,IAEGD,aAAkB,aAETC,EAAA,cAEJD,aAAkB,YAIlBA,aAAkB,YAFdC,EAAA,aAMJD,aAAkB,YAIlBA,aAAkB,YAFdC,EAAA,cAMJD,aAAkB,UAEdC,EAAA,eAQX,MAAA,CACF,GAAGF,EACH,SAAUC,EACV,OAAAC,CAAA,CACH,EA3CL,KAAO,eAAiB,QAAA,CA8CxB,OAAc,KAAKC,EACnB,CACI,OAAOA,aAAoB,WACxBA,aAAoB,YACpBA,aAAoB,mBACpBA,aAAoB,YACpBA,aAAoB,aACpBA,aAAoB,YACpBA,aAAoB,aACpBA,aAAoB,YAAA,CAE/B,EA7DaL,GAEK,UAA+BM,EAAc,cCX/D,IAAMC,GAAU,IAAIC,EAiBPC,GAAN,KACP,CAyDI,YAAYC,EAAkBC,EAC9B,CACS,KAAA,SAAW,IAAIH,EACf,KAAA,YAAc,IAAI,aAAa,CAAC,EAChC,KAAA,aAAe,IAAI,aAAa,CAAC,EACtC,KAAK,WAAa,GAClB,KAAK,UAAY,EAEjB,KAAK,YAAc,EAEd,OAAOG,EAAgB,IAExB,KAAK,YAAeD,EAAQ,MAAQ,GAAM,EAAI,GAI9C,KAAK,YAAcC,EAGvB,KAAK,SAAW,GAEhB,KAAK,QAAUD,CAAA,CAInB,IAAI,SACJ,CACI,OAAO,KAAK,QAAA,CAGhB,IAAI,QAAQE,EACZ,CACQ,KAAK,UAAYA,IAErB,KAAK,UAAU,eAAe,SAAU,KAAK,OAAQ,IAAI,EACzD,KAAK,SAAWA,EAChB,KAAK,SAAS,YAAY,SAAU,KAAK,OAAQ,IAAI,EAErD,KAAK,OAAO,EAAA,CAST,YAAYC,EAAmBC,EACtC,CACQA,IAAQ,SAEFA,EAAAD,GAGV,IAAME,EAAM,KAAK,SAEjB,QAASC,EAAI,EAAGA,EAAIH,EAAI,OAAQG,GAAK,EACrC,CACU,IAAAC,EAAIJ,EAAIG,CAAC,EACTE,EAAIL,EAAIG,EAAI,CAAC,EAEfF,EAAAE,CAAC,EAAKC,EAAIF,EAAI,EAAMG,EAAIH,EAAI,EAAKA,EAAI,GACrCD,EAAAE,EAAI,CAAC,EAAKC,EAAIF,EAAI,EAAMG,EAAIH,EAAI,EAAKA,EAAI,EAAA,CAG1C,OAAAD,CAAA,CAOJ,QACP,CACI,IAAMK,EAAM,KAAK,SAEZ,KAAA,YAEL,IAAMN,EAAMM,EAAI,IAEX,KAAA,SAAS,IAAIN,EAAI,GAAKA,EAAI,GAAIA,EAAI,GAAKA,EAAI,GAAIA,EAAI,GAAKA,EAAI,GAAIA,EAAI,GAAKA,EAAI,GAAIA,EAAI,GAAIA,EAAI,EAAE,EAEpG,IAAMO,EAAOD,EAAI,KACXE,EAAOF,EAAI,KAEbE,IAEQd,GAAA,IACJa,EAAK,MAAQC,EAAK,MAClB,EAAG,EAAGD,EAAK,OAASC,EAAK,OACzB,CAACA,EAAK,EAAIA,EAAK,MACf,CAACA,EAAK,EAAIA,EAAK,MAAA,EAGd,KAAA,SAAS,OAAOd,EAAO,GAGhC,IAAMe,EAAUH,EAAI,OACdI,EAAQ,KAAK,YACbC,EAAS,KAAK,YAAcF,EAAQ,YACpCG,EAAS,KAAK,YAAcH,EAAQ,YAE1C,OAAAC,EAAM,CAAC,GAAKJ,EAAI,MAAM,EAAIK,EAASC,GAAUH,EAAQ,MACrDC,EAAM,CAAC,GAAKJ,EAAI,MAAM,EAAIK,EAASC,GAAUH,EAAQ,OAC/CC,EAAA,CAAC,GAAKJ,EAAI,MAAM,EAAIA,EAAI,MAAM,MAAQK,EAASC,GAAUH,EAAQ,MACjEC,EAAA,CAAC,GAAKJ,EAAI,MAAM,EAAIA,EAAI,MAAM,OAASK,EAASC,GAAUH,EAAQ,OAExE,KAAK,aAAa,CAAC,EAAI,KAAK,YAAcA,EAAQ,WAClD,KAAK,aAAa,CAAC,EAAI,KAAK,YAAcA,EAAQ,YAElD,KAAK,SAAWH,EAAI,MAAM,QAAUG,EAAQ,OACrCH,EAAI,MAAM,SAAWG,EAAQ,QAC7BH,EAAI,SAAW,EAEf,EAAA,CAEf,ECtEO,IAAMO,EAAN,cAA+EC,CAItF,CAsFI,YAAY,CACR,OAAAC,EACA,MAAAC,EACA,MAAAC,EACA,KAAAC,EACA,KAAAC,EACA,cAAAC,EACA,eAAAC,EACA,OAAAC,EACA,QAAAC,CAAA,EACmC,CAAA,EACvC,CAQI,GAPM,MAAA,EArFM,KAAA,IAAcC,EAAI,SAAS,EAkB3C,KAAgB,IAAW,CAAE,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,CAAE,EAiBpE,KAAA,MAAQ,IAAIC,EAqB5B,KAAO,QAAU,GAOjB,KAAO,QAAU,GAKjB,KAAgB,UAAY,GAmBxB,KAAK,MAAQT,EACb,KAAK,OAAUD,GAAQ,QAAU,IAAIW,EAErC,KAAK,QAAU,CAACT,EAEZA,EAEK,KAAA,MAAM,SAASA,CAAK,MAG7B,CACI,GAAM,CAAE,MAAAU,EAAO,OAAAC,CAAO,EAAI,KAAK,QAE/B,KAAK,MAAM,MAAQD,EACnB,KAAK,MAAM,OAASC,CAAA,CAGnB,KAAA,KAAOV,GAAQ,KAAK,MACzB,KAAK,KAAOC,EAEZ,KAAK,OAASG,GAAU,EACxB,KAAK,cAAgBF,EACrB,KAAK,eAAiBC,EAEtB,KAAK,UAAY,GACjB,KAAK,QAAUE,GAAW,GAE1B,KAAK,UAAU,CAAA,CAGnB,IAAI,OAAOM,EACX,CACQ,KAAK,SAEL,KAAK,QAAQ,IAAI,SAAU,KAAK,OAAQ,IAAI,EAGhD,KAAK,QAAUA,EAEfA,EAAM,GAAG,SAAU,KAAK,OAAQ,IAAI,EAE/B,KAAA,KAAK,SAAU,IAAI,CAAA,CAI5B,IAAI,QACJ,CACI,OAAO,KAAK,OAAA,CAIhB,IAAI,eACJ,CACQ,OAAC,KAAK,iBAED,KAAA,eAAiB,IAAIC,GAAc,IAAI,GAGzC,KAAK,cAAA,CAIhB,IAAI,OACJ,CACI,OAAO,KAAK,KAAK,KAAA,CAIrB,IAAI,QACJ,CACI,OAAO,KAAK,KAAK,MAAA,CAId,WACP,CACU,GAAA,CAAE,IAAAC,EAAK,MAAAd,CAAA,EAAU,KACjB,CAAE,MAAAU,EAAO,OAAAC,CAAO,EAAI,KAAK,QAEzBI,EAAKf,EAAM,EAAIU,EACfM,EAAKhB,EAAM,EAAIW,EAEfM,EAAKjB,EAAM,MAAQU,EACnBQ,EAAKlB,EAAM,OAASW,EAEtBN,EAAS,KAAK,OAElB,GAAIA,EACJ,CAEI,IAAMc,EAAKF,EAAK,EACVG,EAAKF,EAAK,EAGVG,EAAKN,EAAKI,EACVG,EAAKN,EAAKI,EAEhBf,EAASkB,EAAQ,IAAIlB,EAAQkB,EAAQ,EAAE,EACvCT,EAAI,GAAKO,EAAMF,EAAKI,EAAQ,GAAGlB,CAAM,EACrCS,EAAI,GAAKQ,EAAMF,EAAKG,EAAQ,GAAGlB,CAAM,EAE5BA,EAAAkB,EAAQ,IAAIlB,EAAQ,CAAC,EAC9BS,EAAI,GAAKO,EAAMF,EAAKI,EAAQ,GAAGlB,CAAM,EACrCS,EAAI,GAAKQ,EAAMF,EAAKG,EAAQ,GAAGlB,CAAM,EAE5BA,EAAAkB,EAAQ,IAAIlB,EAAQ,CAAC,EAC9BS,EAAI,GAAKO,EAAMF,EAAKI,EAAQ,GAAGlB,CAAM,EACrCS,EAAI,GAAKQ,EAAMF,EAAKG,EAAQ,GAAGlB,CAAM,EAE5BA,EAAAkB,EAAQ,IAAIlB,EAAQ,CAAC,EAC9BS,EAAI,GAAKO,EAAMF,EAAKI,EAAQ,GAAGlB,CAAM,EACrCS,EAAI,GAAKQ,EAAMF,EAAKG,EAAQ,GAAGlB,CAAM,CAAA,MAKrCS,EAAI,GAAKC,EACTD,EAAI,GAAKE,EACTF,EAAI,GAAKC,EAAKE,EACdH,EAAI,GAAKE,EACTF,EAAI,GAAKC,EAAKE,EACdH,EAAI,GAAKE,EAAKE,EACdJ,EAAI,GAAKC,EACTD,EAAI,GAAKE,EAAKE,CAClB,CAOG,QAAQM,EAAgB,GAC/B,CACQ,KAAK,SAEDA,IAEA,KAAK,QAAQ,QAAQ,EACrB,KAAK,QAAU,MAIvB,KAAK,eAAiB,KACtB,KAAK,UAAY,GACZ,KAAA,KAAK,UAAW,IAAI,EACzB,KAAK,mBAAmB,CAAA,CAQrB,QACP,CACQ,KAAK,UAEA,KAAA,MAAM,MAAQ,KAAK,QAAQ,MAC3B,KAAA,MAAM,OAAS,KAAK,QAAQ,QAGrC,KAAK,UAAU,EACV,KAAA,KAAK,SAAU,IAAI,CAAA,CAI5B,IAAI,aACJ,CAEI,OAAAC,EAAYC,EAAQ,2CAA2C,EAGxD,KAAK,OAAA,CAOpB,EAEA9B,EAAQ,MAAQ,IAAIA,EAAQ,CACxB,MAAO,QACP,OAAQ,IAAIa,EAAc,CACtB,MAAO,OAAA,CACV,CACL,CAAC,EAEDb,EAAQ,MAAM,QAAU+B,GAExB/B,EAAQ,MAAQ,IAAIA,EAAQ,CACxB,OAAQ,IAAIgC,GAAkB,CAC1B,SAAU,IAAI,WAAW,CAAC,IAAK,IAAK,IAAK,GAAG,CAAC,EAC7C,MAAO,EACP,OAAQ,EACR,UAAW,8BACX,MAAO,OAAA,CACV,EACD,MAAO,OACX,CAAC,EAEDhC,EAAQ,MAAM,QAAU+B,GCxaxB,IAAIE,GAAQ,EAYCC,GAAN,KACP,CAmBI,YAAYC,EACZ,CAPQ,KAAA,aAA8C,OAAA,OAAO,IAAI,EAQ7D,KAAK,aAAe,CAAA,EACf,KAAA,eAAiBA,GAAkB,CAAA,EACxC,KAAK,iBAAmB,EAAA,CASrB,cAAcC,EAAoBC,EAAqBC,EAC9D,CACU,IAAAC,EAAgB,IAAIC,EAAc,CACpC,GAAG,KAAK,eAER,MAAOJ,EACP,OAAQC,EACR,WAAY,EACZ,UAAAC,EACA,mBAAoB,EAAA,CACvB,EAED,OAAO,IAAIG,EAAQ,CACf,OAAQF,EACR,MAAO,eAAeN,IAAO,EAAA,CAChC,CAAA,CAWE,kBAAkBS,EAAoBC,EAAqBC,EAAa,EAAGN,EAClF,CACI,IAAIO,EAAW,KAAK,KAAMH,EAAaE,EAAc,IAAI,EACrDE,EAAY,KAAK,KAAMH,EAAcC,EAAc,IAAI,EAE3DC,EAAWE,GAASF,CAAQ,EAC5BC,EAAYC,GAASD,CAAS,EAE9B,IAAME,GAAOH,GAAY,KAAOC,GAAa,IAAMR,EAAY,EAAI,GAE9D,KAAK,aAAaU,CAAG,IAEjB,KAAA,aAAaA,CAAG,EAAI,CAAA,GAG7B,IAAIC,EAAU,KAAK,aAAaD,CAAG,EAAE,IAAI,EAEzC,OAAKC,IAEDA,EAAU,KAAK,cAAcJ,EAAUC,EAAWR,CAAS,GAG/DW,EAAQ,OAAO,YAAcL,EACrBK,EAAA,OAAO,MAAQJ,EAAWD,EAC1BK,EAAA,OAAO,OAASH,EAAYF,EACpCK,EAAQ,OAAO,WAAaJ,EAC5BI,EAAQ,OAAO,YAAcH,EAG7BG,EAAQ,MAAM,EAAI,EAClBA,EAAQ,MAAM,EAAI,EAClBA,EAAQ,MAAM,MAAQP,EACtBO,EAAQ,MAAM,OAASN,EAEvBM,EAAQ,UAAU,EAEb,KAAA,aAAaA,EAAQ,GAAG,EAAID,EAE1BC,CAAA,CASJ,mBAAmBA,EAAkBX,EAAY,GACxD,CACI,IAAMY,EAASD,EAAQ,OAEhB,OAAA,KAAK,kBAAkBA,EAAQ,MAAOA,EAAQ,OAAQC,EAAO,YAAaZ,CAAS,CAAA,CAOvF,cAAca,EACrB,CACI,IAAMH,EAAM,KAAK,aAAaG,EAAc,GAAG,EAE/C,KAAK,aAAaH,CAAG,EAAE,KAAKG,CAAa,CAAA,CAOtC,MAAMC,EACb,CAEI,GADAA,EAAkBA,IAAoB,GAClCA,EAEW,QAAAC,KAAK,KAAK,aACrB,CACU,IAAAC,EAAW,KAAK,aAAaD,CAAC,EAEpC,GAAIC,EAEA,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAExBD,EAAAC,CAAC,EAAE,QAAQ,EAAI,CAEhC,CAIR,KAAK,aAAe,CAAA,CAAC,CAE7B,EAEaC,GAAc,IAAItB,GCpIxB,IAAMuB,GAAN,KACP,CADO,aAAA,CAEH,KAAO,aAAe,cACtB,KAAO,KAAkB,KAEzB,KAAO,UAAY,GAEnB,KAAO,kBAAiC,KACxC,KAAO,oBAAqC,CAAA,EAErC,KAAA,eAAyB,IAAIC,EACpC,KAAO,gBAAkB,WACzB,KAAO,WAAa,SACpB,KAAO,WAAa,EAGJ,KAAA,iBAAiF,OAAA,OAAO,IAAI,EAC5G,KAAO,WAAa,EACpB,KAAO,OAAS,EAGhB,KAAgB,4BAAqE,CAAE,KAAM,CAAA,EAAI,MAAO,CAAE,EAG1G,KAAO,mBAAqB,GAErB,KAAA,eAAiC,IAAIC,GAE5C,KAAiB,oBAAmC,CAAA,EAMpD,KAAO,mBAAqB,GAM5B,KAAO,kBAAoB,GAwC3B,KAAQ,aAAe,CAAA,CAEhB,KAAKC,EACZ,CACI,KAAK,KAAOA,EAERA,EAAK,WAAW,KAAK,YAAYA,CAAI,EAEzCA,EAAK,UAAY,GAEjB,IAAMC,EAAWD,EAAK,SAEtB,QAASE,EAAI,EAAGA,EAAID,EAAS,OAAQC,IACrC,CACU,IAAAC,EAAQF,EAASC,CAAC,EAGxBC,EAAM,aAAe,GAErB,KAAK,SAASA,CAAK,CAAA,CACvB,CAGG,qBAAqBC,EAAiC,CAAA,EAC7D,CACI,KAAK,eAAiBA,EACtB,KAAK,kBAAoB,GACzB,KAAK,mBAAqB,EAAA,CAGvB,uBACP,CACI,KAAK,kBAAoB,GACrB,KAAK,UAEOC,GAAA,cAAc,KAAK,OAAO,EACtC,KAAK,QAAU,KACnB,CAGG,oBACP,CACI,KAAK,mBAAqB,EAAA,CAGvB,OACP,CACI,KAAK,oBAAoB,OAAS,EAEvB,QAAAH,KAAK,KAAK,iBACrB,CACU,IAAAI,EAAkB,KAAK,iBAAiBJ,CAAC,EAE/BI,EAAA,KAAK,KAAK,IAAI,EAC9BA,EAAgB,MAAQ,CAAA,CAG5B,KAAK,4BAA4B,MAAQ,EACpC,KAAA,4BAA4B,KAAK,KAAK,IAAI,EAE/C,KAAK,KAAO,KACZ,KAAK,WAAa,EAClB,KAAK,mBAAqB,GAE1B,KAAK,oBAAoB,OAAS,EAClC,KAAK,kBAAoB,KAEzB,KAAK,sBAAsB,CAAA,CAG/B,IAAI,gBACJ,CACI,OAAO,KAAK,KAAK,cAAA,CAGd,oBAAoBC,EAC3B,CACQA,EAAiB,mBAEAA,EAAA,kBAAkB,wBAAwBA,CAAgB,EAG/EA,EAAiB,kBAAoB,KAEhC,KAAA,oBAAoB,KAAKA,CAAgB,CAAA,CAG1C,wBAAwBA,EAChC,CACI,IAAMC,EAAQ,KAAK,oBAAoB,QAAQD,CAAgB,EAE3DC,EAAQ,IAEH,KAAA,oBAAoB,OAAOA,EAAO,CAAC,EAG5CD,EAAiB,kBAAoB,IAAA,CAGlC,SAASJ,EAChB,CAmBI,GAlBA,KAAK,mBAAqB,GAE1BA,EAAM,kBAAoB,KAE1BA,EAAM,WAAa,GAEfA,EAAM,SAAW,KAAK,KAEtBA,EAAM,yBAA2B,EAI3BA,EAAA,yBAA2BA,EAAM,OAAO,yBAA2B,EAG7EA,EAAM,UAAY,GAClB,KAAK,cAAcA,CAAK,EAEpBA,EAAM,YACV,CACS,KAAA,oBAAoBA,EAAM,WAAW,EAE1C,MAAA,CAGAA,EAAM,WAAW,KAAK,YAAYA,CAAK,EAE3C,IAAMF,EAAWE,EAAM,SAEvB,QAASD,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAE5B,KAAA,SAASD,EAASC,CAAC,CAAC,CAC7B,CAGG,YAAYC,EACnB,CAiBI,GAfA,KAAK,mBAAqB,GAEtBA,EAAM,YAKDA,EAAM,aAEP,KAAK,eAAeA,CAAK,GAIjCA,EAAM,kBAAoB,KAEtBA,EAAM,YACV,CACS,KAAA,wBAAwBA,EAAM,WAAW,EAE9C,MAAA,CAGJ,IAAMF,EAAWE,EAAM,SAEvB,QAASD,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAE5B,KAAA,YAAYD,EAASC,CAAC,CAAC,CAChC,CAGG,eAAeD,EACtB,CACI,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAE5B,KAAA,YAAYD,EAASC,CAAC,CAAC,CAChC,CAGG,cAAcC,EACrB,CACI,IAAIM,EAAmB,KAAK,iBAAiBN,EAAM,wBAAwB,EAEtEM,IAEDA,EAAmB,KAAK,iBAAiBN,EAAM,wBAAwB,EAAI,CACvE,MAAO,EACP,KAAM,CAAA,CAAC,GAIEM,EAAA,KAAKA,EAAiB,OAAO,EAAIN,CAAA,CAG/C,iBAAiBO,EACxB,CACQA,EAAW,oBAAsB,IACrC,KAAK,eAAe,YAAYA,EAAW,YAAY,EAAE,iBAAiBA,CAAU,EACpFA,EAAW,cAAgB,GAAA,CAGxB,kBAAkBP,EACzB,CACI,KAAK,4BAA4B,KAAK,KAAK,4BAA4B,OAAO,EAAIA,CAAA,CAGtF,IAAI,cACJ,CACI,OAAQ,KAAK,KAAK,qBAAuB,GAAS,KAAK,WAAa,CAAA,CAQjE,YAAYQ,EACnB,CACS,KAAA,oBAAoB,KAAKA,CAAS,CAAA,CAGpC,eAAeA,EACtB,CACI,KAAK,oBAAoB,OAAO,KAAK,oBAAoB,QAAQA,CAAS,EAAG,CAAC,CAAA,CAG3E,YAAYC,EACnB,CACI,QAASV,EAAI,EAAGA,EAAI,KAAK,oBAAoB,OAAQA,IAEjD,KAAK,oBAAoBA,CAAC,EAAE,UAAUU,CAAQ,CAClD,CAGG,SACP,CACI,KAAK,sBAAsB,EAE3B,KAAK,kBAAoB,KACzB,KAAK,KAAO,KACX,KAAK,4BAAsC,KAC3C,KAAK,iBAA2B,KAChC,KAAK,oBAA8B,KACnC,KAAK,oBAA8B,KACpC,KAAK,eAAiB,IAAA,CAGnB,YAAYC,EAAmB,CAAA,EACtC,CACU,IAAAZ,EAAW,KAAK,KAAK,SAE3B,QAASC,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAEjC,KAAK,aAAaD,EAASC,CAAC,EAAGW,CAAG,EAG/B,OAAAA,CAAA,CAGH,aAAaF,EAAsBE,EAAmB,CAAA,EAC9D,CAGI,GAFAA,EAAI,KAAKF,CAAS,EAEdA,EAAU,YAAoB,OAAAE,EAElC,IAAMZ,EAAWU,EAAU,SAE3B,QAAST,EAAI,EAAGA,EAAID,EAAS,OAAQC,IAEjC,KAAK,aAAaD,EAASC,CAAC,EAAGW,CAAG,EAG/B,OAAAA,CAAA,CAGJ,oBACP,CACI,KAAK,aAAe,CAAA,CAOxB,IAAW,uBACX,CACS,OAAA,KAAK,aAAe,KAAW,EAAU,KAAK,wBAEnD,KAAK,cAAgB,GAGrB,KAAK,yBAAL,KAAK,uBAA2B,IAAIf,GAE7B,KAAK,uBACP,SAAS,KAAK,cAAc,EAC5B,OAAO,EAAA,CAOhB,IAAW,+BACX,CACS,OAAA,KAAK,aAAe,KAAW,EAAU,KAAK,gCAEnD,KAAK,cAAgB,GAErB,KAAK,iCAAL,KAAK,+BAAmC,IAAIA,GAGrC,KAAK,+BACP,SAAS,KAAK,qBAAqB,EACnC,UACG,CAAC,KAAK,eAAe,EACrB,CAAC,KAAK,eAAe,CAAA,EACzB,CAQR,IAAW,+BACX,CACS,IAAA,KAAK,aAAe,KAAW,EAAG,OAAO,KAAK,+BAEnD,KAAK,cAAgB,GAErB,IAAMgB,EAAuB,KAAK,iCAElC,OAAIA,GAEA,KAAK,iCAAL,KAAK,+BAAmC,IAAIhB,GAGrC,KAAK,+BACP,SAAS,KAAK,cAAc,EAC5B,QAAQgB,EAAqB,qBAAqB,EAElD,UACG,CAACA,EAAqB,eAAe,EACrC,CAACA,EAAqB,eAAe,CAAA,GAI1C,KAAK,cAAA,CAShB,IAAW,uBACX,CACI,OAAK,KAAK,iCAEH,KAAK,iCAAiC,8BAFM,IAEN,CAErD,ECvdO,SAASC,GACZC,EACAC,EACAC,EAAkC,CAAA,EAEtC,CACI,QAAWC,KAAOF,EAEV,CAACC,EAAOC,CAAG,GAAKF,EAAQE,CAAG,IAAM,SAE1BH,EAAAG,CAAG,EAAIF,EAAQE,CAAG,EAGrC,CCwCA,IAAMC,GAAc,IAAIC,EAAgB,IAAI,EACtCC,GAAe,IAAID,EAAgB,IAAI,EACvCE,GAAe,IAAIF,EAAgB,KAAM,EAAG,CAAC,EAyBtCG,GAAe,EACfC,GAAe,EACfC,GAAiB,EAsQvB,IAAMC,GAAN,MAAMC,UAA6DC,CAC1E,CAuQI,YAAYC,EAA+B,CAAA,EAC3C,CACU,MAAA,EA1PM,KAAA,IAAcC,EAAI,YAAY,EAG9C,KAAO,aAAe,GAItB,KAAO,YAA2B,KAGlC,KAAO,kBAAiC,KAGxC,KAAO,uBAAiC,EAMxC,KAAO,UAAY,GAGnB,KAAO,cAAgB,GAKvB,KAAO,yBAA2B,EAMlC,KAAO,SAAgB,CAAA,EAEvB,KAAO,OAAoB,KAK3B,KAAO,eAAiB,GAExB,KAAO,WAAa,GAEpB,KAAO,SAAW,GAiBlB,KAAO,WAAa,GAMb,KAAA,eAAyB,IAAIC,EAO7B,KAAA,uBAAiC,IAAIA,EAQ5C,KAAO,eAAyB,KAAK,uBAMrC,KAAO,UAAY,GAQnB,KAAO,UAA6B,IAAIC,EAAgB,KAAM,EAAG,CAAC,EAOlE,KAAO,OAA0BC,GAOjC,KAAO,OAA0BC,GAOjC,KAAO,MAAyBC,GAQhC,KAAO,IAAM,EAQb,KAAO,IAAM,EAQb,KAAO,IAAM,EAQb,KAAO,IAAM,EAOb,KAAQ,UAAY,EAKpB,KAAO,WAAa,SACpB,KAAO,WAAa,EAEpB,KAAO,WAAa,EACpB,KAAO,WAAa,SACpB,KAAO,gBAAkB,WAQzB,KAAO,eAA8B,UAKrC,KAAO,eAA8B,SAerC,KAAO,mBAAqB,EAK5B,KAAO,oBAAsB,EAkB7B,KAAO,wBAA0B,EAMjC,KAAO,mBAAqB,EAuB5B,KAAQ,2BAA6B,GAMjC,KAAK,QAAU,CAAA,EACfC,GAAiB,KAAMP,EAAS,CAC5B,SAAU,GACV,OAAQ,GACR,QAAS,EAAA,CACZ,EAEDA,EAAQ,UAAU,QAASQ,GAAU,KAAK,SAASA,CAAK,CAAC,EACjDR,EAAA,QAAQ,SAAS,IAAI,CAAA,CA7QjC,OAAc,MAAMS,EACpB,CAEIC,EAAY,QAAS,qEAAqE,EAE/EC,GAAA,MAAMb,EAAWW,CAAM,CAAA,CA2OtC,IAAI,aAAaG,EACjB,CACS,KAAA,mBAAsBA,GAAS,GAAM,KAC1C,KAAK,wBAA0BA,EAAQ,IAAA,CAG3C,IAAI,cACJ,CACI,OAAQ,KAAK,wBAA0B,MAAW,KAAK,mBAAqB,OAAU,EAAA,CA+BnF,YAA2CC,EAClD,CAQQ,GANC,KAAK,eAENH,EAAYI,EAAQ,qEAAqE,EAIzFD,EAAS,OAAS,EACtB,CAEI,QAASE,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IAE5B,KAAA,SAASF,EAASE,CAAC,CAAC,EAG7B,OAAOF,EAAS,CAAC,CAAA,CAGf,IAAAL,EAAQK,EAAS,CAAC,EAElBG,EAAc,KAAK,aAAe,KAAK,kBAEzC,OAAAR,EAAM,SAAW,MAEjB,KAAK,SAAS,OAAO,KAAK,SAAS,QAAQA,CAAK,EAAG,CAAC,EAC/C,KAAA,SAAS,KAAKA,CAAK,EAEpBQ,IAEAA,EAAY,mBAAqB,IAG9BR,IAGPA,EAAM,QAGAA,EAAA,OAAO,YAAYA,CAAK,EAG7B,KAAA,SAAS,KAAKA,CAAK,EAEpB,KAAK,mBAAkB,KAAK,UAAY,IAE5CA,EAAM,OAAS,KAEfA,EAAM,UAAY,GAGlBA,EAAM,aAAe,GAEjBQ,GAEAA,EAAY,SAASR,CAAK,EAG9B,KAAK,KAAK,aAAcA,EAAO,KAAM,KAAK,SAAS,OAAS,CAAC,EACvDA,EAAA,KAAK,QAAS,IAAI,EAEnB,KAAA,qBAEDA,EAAM,UAAY,GAElBA,EAAM,qBAAqB,EAGxBA,EAAA,CAQJ,eAA8CK,EACrD,CAEQ,GAAAA,EAAS,OAAS,EACtB,CAEI,QAASE,EAAI,EAAGA,EAAIF,EAAS,OAAQE,IAE5B,KAAA,YAAYF,EAASE,CAAC,CAAC,EAGhC,OAAOF,EAAS,CAAC,CAAA,CAGf,IAAAL,EAAQK,EAAS,CAAC,EAElBI,EAAQ,KAAK,SAAS,QAAQT,CAAK,EAEzC,OAAIS,EAAQ,KAEH,KAAA,qBAEA,KAAA,SAAS,OAAOA,EAAO,CAAC,EAEzB,KAAK,YAEA,KAAA,YAAY,YAAYT,CAAK,EAE7B,KAAK,mBAEL,KAAA,kBAAkB,YAAYA,CAAK,EAGxCA,EAAM,mBAEAA,EAAA,kBAAkB,OAAOA,CAAK,EAGxCA,EAAM,OAAS,KACf,KAAK,KAAK,eAAgBA,EAAO,KAAMS,CAAK,EACtCT,EAAA,KAAK,UAAW,IAAI,GAGvBA,CAAA,CAIJ,UAAUU,EACjB,CACQA,GAIIA,IAAU,KAAK,OAEf,KAAK,YAAY,EAIpB,KAAA,0BAED,MAAK,YACT,KAAK,UAAY,GAEb,KAAK,mBAEA,KAAA,kBAAkB,cAAc,IAAI,EAC7C,CAGJ,IAAI,cAAcN,EAClB,CACQ,CAAC,CAAC,KAAK,cAAgBA,IAEvBA,EAEA,KAAK,kBAAkB,EAIvB,KAAK,mBAAmB,EAC5B,CAOJ,IAAI,eACJ,CACW,MAAA,CAAC,CAAC,KAAK,WAAA,CAQX,mBACP,CACI,GAAI,KAAK,YAAa,OAEtB,IAAMO,EAAoB,KAAK,kBAE/BA,GAAmB,YAAY,IAAI,EAEnC,KAAK,YAAcC,EAAQ,IAAIC,GAAa,IAAI,EAIhD,KAAK,eAAiBnB,EAAO,SAE7BiB,GAAmB,SAAS,IAAI,EAEhC,KAAK,gBAAgB,CAAA,CAIlB,oBACP,CACI,GAAI,CAAC,KAAK,YAAa,OAEvB,IAAMA,EAAoB,KAAK,kBAE/BA,GAAmB,YAAY,IAAI,EAE3BC,EAAA,OAAO,KAAK,WAAW,EAE/B,KAAK,YAAc,KACnB,KAAK,eAAiB,KAAK,uBAE3BD,GAAmB,SAAS,IAAI,EAEhC,KAAK,gBAAgB,CAAA,CAIlB,iBACP,CACI,KAAK,SAAW,CAAE,KAAK,aAAiB,KAAK,QAAQ,SAAW,CAAA,CAOpE,IAAI,gBACJ,CACI,YAAK,kBAAL,KAAK,gBAAoB,IAAIjB,GAEzB,KAAK,YAEL,KAAK,gBAAgB,SAAS,KAAK,YAAY,cAAc,EAExD,KAAK,mBAEV,KAAK,gBAAgB,WAAW,KAAK,uBAAwB,KAAK,kBAAkB,cAAc,EAG/F,KAAK,eAAA,CAOhB,IAAI,GACJ,CACI,OAAO,KAAK,UAAU,CAAA,CAG1B,IAAI,EAAEU,EACN,CACI,KAAK,UAAU,EAAIA,CAAA,CAOvB,IAAI,GACJ,CACI,OAAO,KAAK,UAAU,CAAA,CAG1B,IAAI,EAAEA,EACN,CACI,KAAK,UAAU,EAAIA,CAAA,CAOvB,IAAI,UACJ,CACI,OAAO,KAAK,SAAA,CAGhB,IAAI,SAASA,EACb,CACS,KAAA,UAAU,SAASA,CAAK,CAAA,CAOjC,IAAI,UACJ,CACI,OAAO,KAAK,SAAA,CAGhB,IAAI,SAASA,EACb,CACQ,KAAK,YAAcA,IAEnB,KAAK,UAAYA,EACZ,KAAA,UAAU,KAAK,KAAK,EAC7B,CAOJ,IAAI,OACJ,CACI,OAAO,KAAK,SAAWU,EAAA,CAG3B,IAAI,MAAMV,EACV,CACI,KAAK,SAAWA,EAAQW,EAAA,CAU5B,IAAI,OACJ,CACQ,OAAA,KAAK,SAAWlB,KAEhB,KAAK,OAAS,IAAIF,EAAgB,KAAM,EAAG,CAAC,GAGzC,KAAK,MAAA,CAGhB,IAAI,MAAMS,EACV,CACQ,KAAK,SAAWP,KAEhB,KAAK,OAAS,IAAIF,EAAgB,KAAM,EAAG,CAAC,GAGzC,OAAAS,GAAU,SAAW,KAAK,OAAO,IAAIA,CAAK,EAAI,KAAK,OAAO,SAASA,CAAK,CAAA,CAOnF,IAAI,MACJ,CACQ,OAAA,KAAK,QAAUN,KAEf,KAAK,MAAQ,IAAIH,EAAgB,KAAM,EAAG,CAAC,GAGxC,KAAK,KAAA,CAGhB,IAAI,KAAKS,EACT,CACQ,KAAK,QAAUN,KAEf,KAAK,MAAQ,IAAIH,EAAgB,KAAM,EAAG,CAAC,GAG1C,KAAA,MAAM,SAASS,CAAK,CAAA,CAS7B,IAAI,OACJ,CACQ,OAAA,KAAK,SAAWR,KAEhB,KAAK,OAAS,IAAID,EAAgB,KAAM,EAAG,CAAC,GAGzC,KAAK,MAAA,CAGhB,IAAI,MAAMS,EACV,CACQ,KAAK,SAAWR,KAEhB,KAAK,OAAS,IAAID,EAAgB,KAAM,EAAG,CAAC,GAGzC,OAAAS,GAAU,SAAW,KAAK,OAAO,IAAIA,CAAK,EAAI,KAAK,OAAO,SAASA,CAAK,CAAA,CAOnF,IAAI,OACJ,CACW,OAAA,KAAK,IAAI,KAAK,MAAM,EAAI,KAAK,eAAA,EAAiB,KAAK,CAAA,CAG9D,IAAI,MAAMA,EACV,CACU,IAAAY,EAAa,KAAK,eAAA,EAAiB,MAEpC,KAAA,UAAUZ,EAAOY,CAAU,CAAA,CAOpC,IAAI,QACJ,CACW,OAAA,KAAK,IAAI,KAAK,MAAM,EAAI,KAAK,eAAA,EAAiB,MAAM,CAAA,CAG/D,IAAI,OAAOZ,EACX,CACU,IAAAa,EAAc,KAAK,eAAA,EAAiB,OAErC,KAAA,WAAWb,EAAOa,CAAW,CAAA,CAU/B,QAAQC,EACf,CACSA,IAEDA,EAAM,CAAA,GAGJ,IAAAC,EAAS,KAAK,eAAe,EAEnC,OAAAD,EAAI,MAAQ,KAAK,IAAI,KAAK,MAAM,EAAIC,EAAO,KAAK,EAChDD,EAAI,OAAS,KAAK,IAAI,KAAK,MAAM,EAAIC,EAAO,MAAM,EAE3CD,CAAA,CAUJ,QAAQd,EAA0CgB,EACzD,CACU,IAAAC,EAAO,KAAK,eAAe,EAE7B,OAAOjB,GAAU,UAERgB,EAAAhB,EAAM,QAAUA,EAAM,MAC/BA,EAAQA,EAAM,OAIHgB,IAAAA,EAAAhB,GAGfA,IAAU,QAAa,KAAK,UAAUA,EAAOiB,EAAK,KAAK,EACvDD,IAAW,QAAa,KAAK,WAAWA,EAAQC,EAAK,MAAM,CAAA,CAIvD,aACR,CACI,IAAMC,EAAW,KAAK,UAChBC,EAAO,KAAK,MAElB,KAAK,IAAM,KAAK,IAAID,EAAWC,EAAK,EAAE,EACtC,KAAK,IAAM,KAAK,IAAID,EAAWC,EAAK,EAAE,EACtC,KAAK,IAAM,CAAC,KAAK,IAAID,EAAWC,EAAK,EAAE,EACvC,KAAK,IAAM,KAAK,IAAID,EAAWC,EAAK,EAAE,CAAA,CAgBnC,gBAAgBC,EACvB,CACI,YAAK,SAAS,IACV,OAAOA,EAAK,GAAM,SAAWA,EAAK,EAAI,KAAK,SAAS,EACpD,OAAOA,EAAK,GAAM,SAAWA,EAAK,EAAI,KAAK,SAAS,CAAA,EAExD,KAAK,MAAM,IACP,OAAOA,EAAK,QAAW,SAAWA,EAAK,QAAU,EAAI,KAAK,MAAM,EAChE,OAAOA,EAAK,QAAW,SAAWA,EAAK,QAAU,EAAI,KAAK,MAAM,CAAA,EAEpE,KAAK,SAAW,OAAOA,EAAK,UAAa,SAAWA,EAAK,SAAW,KAAK,SACzE,KAAK,KAAK,IACN,OAAOA,EAAK,OAAU,SAAWA,EAAK,MAAQ,KAAK,KAAK,EACxD,OAAOA,EAAK,OAAU,SAAWA,EAAK,MAAQ,KAAK,KAAK,CAAA,EAE5D,KAAK,MAAM,IACP,OAAOA,EAAK,QAAW,SAAWA,EAAK,OAAS,KAAK,MAAM,EAC3D,OAAOA,EAAK,QAAW,SAAWA,EAAK,OAAS,KAAK,MAAM,CAAA,EAGxD,IAAA,CAOJ,cAAcC,EACrB,CACIA,EAAO,UAAU,IAAI,CAAA,CAIlB,sBACP,CACI,IAAMC,EAAyB,KAAK,wBAEpC,GAAI,KAAK,6BAA+BA,EAAwB,OAEhE,KAAK,2BAA6BA,EAGlC,IAAMC,EAAK,KAAK,eACVC,EAAQ,KAAK,OACbC,EAAQ,KAAK,OACbC,EAAW,KAAK,UAEhBC,EAAKH,EAAM,GACXI,EAAKJ,EAAM,GAEXK,EAAKJ,EAAM,GACXK,EAAKL,EAAM,GAGdF,EAAA,EAAI,KAAK,IAAMI,EACfJ,EAAA,EAAI,KAAK,IAAMI,EACfJ,EAAA,EAAI,KAAK,IAAMK,EACfL,EAAA,EAAI,KAAK,IAAMK,EAElBL,EAAG,GAAKG,EAAS,IAAOG,EAAKN,EAAG,EAAMO,EAAKP,EAAG,GAC9CA,EAAG,GAAKG,EAAS,IAAOG,EAAKN,EAAG,EAAMO,EAAKP,EAAG,EAAA,CAKlD,IAAI,MAAMvB,EACV,CACQA,IAAU,KAAK,aAEnB,KAAK,WAAaA,EAElB,KAAK,cAAgB+B,GAErB,KAAK,UAAU,EAAA,CAInB,IAAI,OACJ,CACI,OAAO,KAAK,UAAA,CAGhB,IAAI,KAAK/B,EACT,CAEU,IAAAgC,EADYC,GAAM,OAAO,SAASjC,GAAS,QAAQ,EACnC,YAAY,EAE9BgC,IAAQ,KAAK,aAEjB,KAAK,WAAaA,EAElB,KAAK,cAAgBD,GAErB,KAAK,UAAU,EAAA,CASnB,IAAI,MACJ,CAEW,OAAAG,GAAQ,KAAK,UAAU,CAAA,CAKlC,IAAI,UAAUlC,EACd,CACQ,KAAK,iBAAmBA,IACxB,KAAK,oBAEL,KAAK,kBAAkB,mBAAqB,IAGhD,KAAK,cAAgBmC,GAErB,KAAK,eAAiBnC,EAEtB,KAAK,UAAU,EAAA,CAOnB,IAAI,WACJ,CACI,OAAO,KAAK,cAAA,CAMhB,IAAI,SACJ,CACW,MAAA,CAAC,EAAE,KAAK,mBAAqB,EAAA,CAGxC,IAAI,QAAQA,EACZ,CACU,IAAAoC,EAAcpC,EAAQ,EAAQ,GAE/B,KAAK,mBAAqB,KAAWoC,IAEtC,KAAK,oBAEL,KAAK,kBAAkB,mBAAqB,IAGhD,KAAK,cAAgBC,GAErB,KAAK,oBAAsB,EAE3B,KAAK,UAAU,EAAA,CAInB,IAAI,QACJ,CACW,MAAA,EAAE,KAAK,mBAAqB,EAAA,CAIvC,IAAI,OAAOrC,EACX,CACU,IAAAoC,EAAcpC,EAAQ,EAAI,GAE3B,KAAK,mBAAqB,KAAWoC,IAEtC,KAAK,oBAEL,KAAK,kBAAkB,mBAAqB,IAGhD,KAAK,cAAgBC,GACrB,KAAK,oBAAsB,EAE3B,KAAK,UAAU,EAAA,CAInB,IAAI,YACJ,CACW,MAAA,CAAC,EAAE,KAAK,mBAAqB,EAAA,CAGxC,IAAI,WAAWrC,EACf,CACU,IAAAoC,EAAcpC,EAAQ,EAAQ,GAE/B,KAAK,mBAAqB,KAAWoC,IAE1C,KAAK,cAAgBC,GACrB,KAAK,oBAAsB,EAEvB,KAAK,oBAEL,KAAK,kBAAkB,mBAAqB,IAGhD,KAAK,UAAU,EAAA,CAInB,IAAI,cACJ,CACI,OAAQ,KAAK,qBAAuB,GAAS,KAAK,WAAa,CAAA,CAiB5D,QAAQjD,EAA0B,GACzC,CACI,GAAI,KAAK,UAAW,OACpB,KAAK,UAAY,GAIb,IAAAkD,EAyBJ,GArBI,KAAK,SAAS,SAEdA,EAAc,KAAK,eAAe,EAAG,KAAK,SAAS,MAAM,GAG7D,KAAK,iBAAiB,EACtB,KAAK,OAAS,KACd,KAAK,YAAc,KACnB,KAAK,cAAgB,KACrB,KAAK,QAAU,KACf,KAAK,UAAY,KACjB,KAAK,OAAS,KACd,KAAK,OAAS,KACd,KAAK,MAAQ,KAER,KAAA,KAAK,YAAa,IAAI,EAE3B,KAAK,mBAAmB,GAEA,OAAOlD,GAAY,UAAYA,EAAUA,GAAS,WAEnDkD,EAEnB,QAASnC,EAAI,EAAGA,EAAImC,EAAY,OAAQ,EAAEnC,EAE1BmC,EAAAnC,CAAC,EAAE,QAAQf,CAAO,EAItC,KAAK,aAAa,QAAQ,EAC1B,KAAK,YAAc,IAAA,CAE3B,EAEAW,GAAW,MACPd,GACAsD,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,GACAC,EACJ,EC72CY,IAAAC,IAAAA,IAERA,EAAAA,EAAA,MAAQ,CAAR,EAAA,QACAA,EAAAA,EAAA,OAAS,CAAT,EAAA,SACAA,EAAAA,EAAA,KAAO,CAAP,EAAA,OAJQA,IAAAA,IAAA,CAAA,CAAA,ECnBA,IAAAC,IAAAA,IAMRA,EAAAA,EAAA,YAAc,EAAd,EAAA,cAKAA,EAAAA,EAAA,KAAO,EAAP,EAAA,OAKAA,EAAAA,EAAA,OAAS,CAAT,EAAA,SAKAA,EAAAA,EAAA,IAAM,GAAN,EAAA,MAKAA,EAAAA,EAAA,QAAU,GAAV,EAAA,UA1BQA,IAAAA,IAAA,CAAA,CAAA,ECDL,IAAMC,GAAN,KACP,CAyBI,YAAYC,EAAuBC,EAAa,KAAMC,EAAW,EAAGC,EAAO,GAC3E,CAtBA,KAAO,KAAuB,KAE9B,KAAO,SAA2B,KASlC,KAAQ,WAAa,GAYjB,KAAK,IAAMH,EACX,KAAK,SAAWC,EAChB,KAAK,SAAWC,EAChB,KAAK,MAAQC,CAAA,CASV,MAAMH,EAAuBC,EAAe,KACnD,CACI,OAAO,KAAK,MAAQD,GAAM,KAAK,WAAaC,CAAA,CAQzC,KAAKG,EACZ,CACQ,KAAK,MAED,KAAK,SAEL,KAAK,IAAI,KAAK,KAAK,SAAUA,CAAM,EAIlC,KAA6B,IAAIA,CAAM,GAIhD,IAAMC,EAAW,KAAK,KAEtB,OAAI,KAAK,OAEL,KAAK,QAAQ,EAAI,EAKjB,KAAK,aAEL,KAAK,KAAO,MAGTA,CAAA,CAOJ,QAAQC,EACf,CACI,KAAK,SAAWA,EACZA,EAAS,OAETA,EAAS,KAAK,SAAW,MAE7B,KAAK,KAAOA,EAAS,KACrBA,EAAS,KAAO,IAAA,CASb,QAAQC,EAAO,GACtB,CACI,KAAK,WAAa,GAClB,KAAK,IAAM,KACX,KAAK,SAAW,KAGZ,KAAK,WAEA,KAAA,SAAS,KAAO,KAAK,MAG1B,KAAK,OAEA,KAAA,KAAK,SAAW,KAAK,UAI9B,IAAMF,EAAW,KAAK,KAGjB,YAAA,KAAOE,EAAO,KAAOF,EAC1B,KAAK,SAAW,KAETA,CAAA,CAEf,ECvFO,IAAMG,GAAN,MAAMA,CACb,CAoGI,aACA,CArFA,KAAO,UAAY,GAOnB,KAAO,UAAY,EA6BnB,KAAO,SAAW,GAQlB,KAAO,MAAQ,EASf,KAAO,QAAU,GAKjB,KAAQ,WAAqB,KAK7B,KAAQ,cAAgB,IAKxB,KAAQ,cAAgB,EAExB,KAAQ,WAAa,GAErB,KAAQ,WAAa,GAcjB,KAAK,MAAQ,IAAIC,GAAe,KAAM,KAAM,GAAQ,EAC/C,KAAA,QAAU,EAAID,EAAO,WACrB,KAAA,UAAY,EAAIA,EAAO,WAEvB,KAAA,MAASE,GACd,CACI,KAAK,WAAa,KAEd,KAAK,UAGL,KAAK,OAAOA,CAAI,EAEZ,KAAK,SAAW,KAAK,aAAe,MAAQ,KAAK,MAAM,OAElD,KAAA,WAAa,sBAAsB,KAAK,KAAK,GAE1D,CACJ,CASI,kBACR,CACQ,KAAK,aAAe,MAAQ,KAAK,MAAM,OAGlC,KAAA,SAAW,YAAY,IAAI,EAChC,KAAK,WAAa,KAAK,SAClB,KAAA,WAAa,sBAAsB,KAAK,KAAK,EACtD,CAOI,iBACR,CACQ,KAAK,aAAe,OAEpB,qBAAqB,KAAK,UAAU,EACpC,KAAK,WAAa,KACtB,CAYI,kBACR,CACQ,KAAK,QAEL,KAAK,iBAAiB,EAEjB,KAAK,WAEV,KAAK,MAAM,CACf,CAWG,IAAaC,EAAuBC,EAAaC,EAAmBC,GAAgB,OAC3F,CACI,OAAO,KAAK,aAAa,IAAIL,GAAeE,EAAIC,EAASC,CAAQ,CAAC,CAAA,CAU/D,QAAiBF,EAAuBC,EAAaC,EAAmBC,GAAgB,OAC/F,CACW,OAAA,KAAK,aAAa,IAAIL,GAAeE,EAAIC,EAASC,EAAU,EAAI,CAAC,CAAA,CAWpE,aAAaE,EACrB,CAEQ,IAAAC,EAAU,KAAK,MAAM,KACrBC,EAAW,KAAK,MAGpB,GAAI,CAACD,EAEDD,EAAS,QAAQE,CAAQ,MAG7B,CAEI,KAAOD,GACP,CACQ,GAAAD,EAAS,SAAWC,EAAQ,SAChC,CACID,EAAS,QAAQE,CAAQ,EACzB,KAAA,CAEOA,EAAAD,EACXA,EAAUA,EAAQ,IAAA,CAIjBD,EAAS,UAEVA,EAAS,QAAQE,CAAQ,CAC7B,CAGJ,YAAK,iBAAiB,EAEf,IAAA,CAUJ,OAAgBN,EAAuBC,EAC9C,CACQ,IAAAG,EAAW,KAAK,MAAM,KAE1B,KAAOA,GAKCA,EAAS,MAAMJ,EAAIC,CAAO,EAE1BG,EAAWA,EAAS,QAAQ,EAI5BA,EAAWA,EAAS,KAIxB,OAAC,KAAK,MAAM,MAEZ,KAAK,gBAAgB,EAGlB,IAAA,CAQX,IAAI,OACJ,CACQ,GAAA,CAAC,KAAK,MAEC,MAAA,GAGX,IAAIG,EAAQ,EACRF,EAAU,KAAK,MAEX,KAAAA,EAAUA,EAAQ,MAEtBE,IAGG,OAAAA,CAAA,CAIJ,OACP,CACS,KAAK,UAEN,KAAK,QAAU,GACf,KAAK,iBAAiB,EAC1B,CAIG,MACP,CACQ,KAAK,UAEL,KAAK,QAAU,GACf,KAAK,gBAAgB,EACzB,CAIG,SACP,CACQ,GAAA,CAAC,KAAK,WACV,CACI,KAAK,KAAK,EAEN,IAAAH,EAAW,KAAK,MAAM,KAE1B,KAAOA,GAEQA,EAAAA,EAAS,QAAQ,EAAI,EAGpC,KAAK,MAAM,QAAQ,EACnB,KAAK,MAAQ,IAAA,CACjB,CAeG,OAAOI,EAAsB,YAAY,IAAA,EAChD,CACQ,IAAAC,EAiBA,GAAAD,EAAc,KAAK,SACvB,CAeI,GAbYC,EAAA,KAAK,UAAYD,EAAc,KAAK,SAG5CC,EAAY,KAAK,gBAEjBA,EAAY,KAAK,eAGrBA,GAAa,KAAK,MAKd,KAAK,cACT,CACU,IAAAC,EAAQF,EAAc,KAAK,WAAa,EAE1C,GAAAE,EAAQ,KAAK,cAEb,OAGC,KAAA,WAAaF,EAAeE,EAAQ,KAAK,aAAA,CAGlD,KAAK,QAAUD,EACV,KAAA,UAAY,KAAK,QAAUZ,EAAO,WAIvC,IAAMc,EAAO,KAAK,MAGdP,EAAWO,EAAK,KAEpB,KAAOP,GAEQA,EAAAA,EAAS,KAAK,IAAI,EAG5BO,EAAK,MAEN,KAAK,gBAAgB,CACzB,MAIA,KAAK,UAAY,KAAK,QAAU,KAAK,UAAY,EAGrD,KAAK,SAAWH,CAAA,CAYpB,IAAI,KACJ,CACI,MAAO,KAAO,KAAK,SAAA,CAavB,IAAI,QACJ,CACI,MAAO,KAAO,KAAK,aAAA,CAGvB,IAAI,OAAOI,EACX,CAEI,IAAMC,EAAS,KAAK,IAAI,KAAK,OAAQD,CAAG,EAGlCE,EAAU,KAAK,IAAI,KAAK,IAAI,EAAGD,CAAM,EAAI,IAAMhB,EAAO,UAAU,EAEtE,KAAK,cAAgB,EAAIiB,CAAA,CAY7B,IAAI,QACJ,CACI,OAAI,KAAK,cAEE,KAAK,MAAM,IAAO,KAAK,aAAa,EAGxC,CAAA,CAGX,IAAI,OAAOF,EACX,CACI,GAAIA,IAAQ,EAER,KAAK,cAAgB,MAGzB,CAEI,IAAMG,EAAS,KAAK,IAAI,KAAK,OAAQH,CAAG,EAEnC,KAAA,cAAgB,GAAKG,EAAS,IAAA,CACvC,CA+CJ,WAAW,QACX,CACQ,GAAA,CAAClB,EAAO,QACZ,CACI,IAAMmB,EAASnB,EAAO,QAAU,IAAIA,EAEpCmB,EAAO,UAAY,GACnBA,EAAO,WAAa,EAAA,CAGxB,OAAOnB,EAAO,OAAA,CAalB,WAAW,QACX,CACQ,GAAA,CAACA,EAAO,QACZ,CACI,IAAMoB,EAASpB,EAAO,QAAU,IAAIA,EAEpCoB,EAAO,UAAY,GACnBA,EAAO,WAAa,EAAA,CAGxB,OAAOpB,EAAO,OAAA,CAEtB,EArkBaA,GAMK,WAAa,IANxB,IAAMqB,GAANrB,GC5BA,IAAesB,GAAf,cAAqCC,EAC5C,CAiDI,YAAYC,EACZ,CACI,MAAMA,CAAO,EA/CjB,KAAgB,UAAY,GAE5B,KAAgB,cAAgB,GAGhC,KAAO,aAAsB,EAE7B,KAAO,UAAY,GAEnB,KAAU,QAAkB,IAAIC,EAAO,EAAG,EAAG,EAAG,CAAC,EACjD,KAAU,aAAe,EAAA,CAMzB,IAAW,QACX,CACI,OAAK,KAAK,cAEV,KAAK,aAAa,EAElB,KAAK,aAAe,GAEb,KAAK,SANmB,KAAK,OAMxB,CAUhB,IAAI,aACJ,CACW,MAAA,CAAC,CAAC,KAAK,YAAA,CAGlB,IAAI,YAAYC,EAChB,CACS,KAAA,aAAeA,EAAQ,EAAI,CAAA,CAa7B,cAAcC,EACrB,CACI,IAAMC,EAAS,KAAK,OACd,CAAE,EAAAC,EAAG,EAAAC,CAAA,EAAMH,EAET,OAAAE,GAAKD,EAAO,MACbC,GAAKD,EAAO,MACZE,GAAKF,EAAO,MACZE,GAAKF,EAAO,IAAA,CAOb,cACV,CAKI,GAJK,KAAA,qBAEL,KAAK,aAAe,GAEhB,KAAK,cAAe,OACxB,KAAK,cAAgB,GAEf,IAAAG,EAAc,KAAK,aAAe,KAAK,kBAEzCA,GAEAA,EAAY,kBAAkB,IAAI,CACtC,CAGY,QAAQP,EACxB,CACI,MAAM,QAAQA,CAAO,EAErB,KAAK,QAAU,IAAA,CAGH,yBACZQ,EACAC,EACAC,EAEJ,CACU,GAAA,CAAE,YAAAC,EAAa,aAAAC,CAAA,EAAiBH,EAGtCE,EAAY,UAAU,aAAa,KAAM,KAAK,eAAgBH,CAAc,EAEjEG,EAER,KAAK,YAAY,EAAE,cAAc,KAAMH,CAAc,EAExDI,EAAa,cAAc,IAAI,EAE/B,KAAK,cAAgB,GAErB,IAAMC,EAAW,KAAK,SAChBC,EAASD,EAAS,OAExB,QAASE,EAAI,EAAGA,EAAID,EAAQC,IAExBF,EAASE,CAAC,EAAE,mBAAmBP,EAAgBC,EAAUC,CAAY,CACzE,CAER,EChIO,IAAMM,GAAiB,CAC1B,aAAc,CAACC,EAAeC,IAC9B,CACU,IAAAC,EAAS,SAAS,cAAc,QAAQ,EAE9C,OAAAA,EAAO,MAAQF,EACfE,EAAO,OAASD,EAETC,CAAA,EAEX,4BAA6B,IAAM,yBACnC,yBAA0B,IAAM,sBAChC,aAAc,IAAM,UACpB,WAAY,IAAO,SAAS,SAAW,OAAO,SAAS,KACvD,eAAgB,IAAM,SAAS,MAC/B,MAAO,CAACC,EAAkBC,IAA0B,MAAMD,EAAKC,CAAO,EACtE,SAAWC,GAEQ,IAAI,UAAU,EAEf,gBAAgBA,EAAK,UAAU,CAErD,ECaA,IAAIC,GAA0BC,GAqBjBC,GAAa,CAKtB,KACA,CACW,OAAAF,EAAA,EAMX,IAAIG,EACJ,CACqBH,GAAAG,CAAA,CAEzB,EC7EgB,SAAAC,GACZC,EACAC,EACAC,EAEJ,CACI,GAAM,CAAE,MAAAC,EAAO,OAAAC,CAAO,EAAIF,EAAQ,KAC5BG,EAAOH,EAAQ,KAGrB,GAAIG,EACJ,CAEI,IAAMC,EAAcD,EAAK,MACnBE,EAAeF,EAAK,OAG1BL,EAAO,KAAOK,EAAK,EAAKJ,EAAO,GAAKE,EAC7BH,EAAA,KAAOA,EAAO,KAAOM,EAE5BN,EAAO,KAAOK,EAAK,EAAKJ,EAAO,GAAKG,EAC7BJ,EAAA,KAAOA,EAAO,KAAOO,CAAA,MAKrBP,EAAA,KAAO,CAACC,EAAO,GAAKE,EACpBH,EAAA,KAAOA,EAAO,KAAOG,EAErBH,EAAA,KAAO,CAACC,EAAO,GAAKG,EACpBJ,EAAA,KAAOA,EAAO,KAAOI,CAEpC,CCOO,IAAMI,GAAN,MAAMC,UAAeC,EAC5B,CAkCI,YAAYC,EAAmCC,EAAQ,MACvD,CACQD,aAAmBC,IAETD,EAAA,CAAE,QAASA,CAAQ,GAI3B,GAAA,CAAE,QAAAE,EAAUD,EAAQ,MAAO,OAAAE,EAAQ,YAAAC,EAAa,MAAAC,EAAO,OAAAC,EAAQ,GAAGC,CAAA,EAASP,EAE3E,MAAA,CACF,MAAO,SACP,GAAGO,CAAA,CACN,EA7BL,KAAyB,aAAuB,SAEhD,KAAO,QAAU,GAMA,KAAA,cAA4B,CAAE,KAAM,EAAG,KAAM,EAAG,KAAM,EAAG,KAAM,CAAE,EAuB9E,KAAK,QAAU,IAAIC,EACf,CACI,UAAW,IACX,CACI,KAAK,aAAa,CAAA,CACtB,CACJ,EAGAL,EAEA,KAAK,OAASA,EAETD,EAAQ,gBAEb,KAAK,OAASA,EAAQ,eAG1B,KAAK,QAAUA,EAEf,KAAK,cAAgB,GACrB,KAAK,YAAcE,GAAe,GAG9BC,IAAU,SAAW,KAAK,MAAQA,GAClCC,IAAW,SAAW,KAAK,OAASA,EAAA,CAlE5C,OAAc,KAAKG,EAAqCC,EAAY,GACpE,CACI,OAAID,aAAkBR,EAEX,IAAIH,EAAOW,CAAM,EAGrB,IAAIX,EAAOG,EAAQ,KAAKQ,EAAQC,CAAS,CAAC,CAAA,CA8DrD,IAAI,QAAQC,EACZ,CACIA,IAAAA,EAAUV,EAAQ,OAElB,IAAMW,EAAiB,KAAK,SAExBA,IAAmBD,IAEnBC,GAAkBA,EAAe,SAASA,EAAe,IAAI,SAAU,KAAK,aAAc,IAAI,EAC9FD,EAAM,SAASA,EAAM,GAAG,SAAU,KAAK,aAAc,IAAI,EAE7D,KAAK,SAAWA,EAEZ,KAAK,QAEL,KAAK,UAAU,KAAK,OAAQ,KAAK,SAAS,KAAK,KAAK,EAGpD,KAAK,SAEL,KAAK,WAAW,KAAK,QAAS,KAAK,SAAS,KAAK,MAAM,EAG3D,KAAK,aAAa,EAAA,CAItB,IAAI,SACJ,CACI,OAAO,KAAK,QAAA,CAOhB,IAAI,cACJ,CACI,OAAAE,GAAiB,KAAK,cAAe,KAAK,QAAS,KAAK,QAAQ,EAEzD,KAAK,aAAA,CAMhB,IAAI,cACJ,CAEI,OAAAC,EAAY,QAAS,8DAA8D,EAG5E,KAAK,YAAA,CAIN,cACV,CACI,IAAMX,EAAS,KAAK,QACdD,EAAU,KAAK,SAEfa,EAAS,KAAK,QAEd,CAAE,MAAAV,EAAO,OAAAC,CAAO,EAAIJ,EAAQ,KAE3Ba,EAAA,KAAO,CAACZ,EAAO,GAAKE,EACpBU,EAAA,KAAOA,EAAO,KAAOV,EAErBU,EAAA,KAAO,CAACZ,EAAO,GAAKG,EACpBS,EAAA,KAAOA,EAAO,KAAOT,CAAA,CAUhB,QAAQN,EAA0B,GAClD,CAKI,GAJA,MAAM,QAAQA,CAAO,EAEE,OAAOA,GAAY,UAAYA,EAAUA,GAAS,QAGzE,CACI,IAAMgB,EAAuB,OAAOhB,GAAY,UAAYA,EAAUA,GAAS,cAE1E,KAAA,SAAS,QAAQgB,CAAoB,CAAA,CAG9C,KAAK,SAAW,KACf,KAAK,cAAyB,KAC9B,KAAK,QAAmB,KACxB,KAAK,QAAmB,IAAA,CAoB7B,IAAI,QACJ,CACI,OAAO,KAAK,OAAA,CAGhB,IAAI,OAAOL,EACX,CACW,OAAAA,GAAU,SAAW,KAAK,QAAQ,IAAIA,CAAK,EAAI,KAAK,QAAQ,SAASA,CAAK,CAAA,CAIrF,IAAa,OACb,CACW,OAAA,KAAK,IAAI,KAAK,MAAM,CAAC,EAAI,KAAK,SAAS,KAAK,KAAA,CAGvD,IAAa,MAAMA,EACnB,CACI,KAAK,UAAUA,EAAO,KAAK,SAAS,KAAK,KAAK,EAC9C,KAAK,OAASA,CAAA,CAIlB,IAAa,QACb,CACW,OAAA,KAAK,IAAI,KAAK,MAAM,CAAC,EAAI,KAAK,SAAS,KAAK,MAAA,CAGvD,IAAa,OAAOA,EACpB,CACI,KAAK,WAAWA,EAAO,KAAK,SAAS,KAAK,MAAM,EAChD,KAAK,QAAUA,CAAA,CASH,QAAQM,EACxB,CACI,OAAAA,IAAAA,EAAQ,CAAA,GACJA,EAAA,MAAQ,KAAK,IAAI,KAAK,MAAM,CAAC,EAAI,KAAK,SAAS,KAAK,MACpDA,EAAA,OAAS,KAAK,IAAI,KAAK,MAAM,CAAC,EAAI,KAAK,SAAS,KAAK,OAElDA,CAAA,CASK,QAAQN,EAA0CL,EAClE,CACQ,OAAOK,GAAU,UAERL,EAAAK,EAAM,QAAUA,EAAM,MAC/BA,EAAQA,EAAM,OAIHL,IAAAA,EAAAK,GAGfA,IAAU,QAAa,KAAK,UAAUA,EAAO,KAAK,SAAS,KAAK,KAAK,EACrEL,IAAW,QAAa,KAAK,WAAWA,EAAQ,KAAK,SAAS,KAAK,MAAM,CAAA,CAEjF,ECvSO,IAAMY,GAAN,cAA2BC,CAClC,CASI,YAAYC,EACZ,CACSA,EAAQ,WAETA,EAAQ,SAAWC,GAAW,IAAI,EAAE,aAAa,GAGhDD,EAAQ,QAEDA,EAAA,MAAQA,EAAQ,SAAS,MAE5BA,EAAQ,cAETA,EAAQ,OAASA,EAAQ,aAI5BA,EAAQ,SAEDA,EAAA,OAASA,EAAQ,SAAS,OAE7BA,EAAQ,cAETA,EAAQ,QAAUA,EAAQ,aAIlC,MAAMA,CAAO,EAjCjB,KAAO,eAAiB,QAmCpB,KAAK,YAAcA,EAAQ,YAE3B,KAAK,aAAa,EAEb,KAAA,YAAc,CAAC,CAACA,EAAQ,WAAA,CAG1B,cACP,CACQ,KAAK,aAAe,UAAW,KAAK,WAEpC,KAAK,SAAS,MAAM,MAAQ,GAAG,KAAK,KAAK,KACzC,KAAK,SAAS,MAAM,OAAS,GAAG,KAAK,MAAM,OAI3C,KAAK,SAAS,QAAU,KAAK,YAAc,KAAK,SAAS,SAAW,KAAK,eAEpE,KAAA,SAAS,MAAQ,KAAK,WACtB,KAAA,SAAS,OAAS,KAAK,YAChC,CAGG,OAAOE,EAAQ,KAAK,MAAOC,EAAS,KAAK,OAAQC,EAAa,KAAK,YAC1E,CACI,IAAMC,EAAY,MAAM,OAAOH,EAAOC,EAAQC,CAAU,EAExD,OAAIC,GAEA,KAAK,aAAa,EAGfA,CAAA,CAGX,OAAc,KAAKC,EACnB,CACI,OAAQ,WAAW,mBAAqBA,aAAoB,mBACxD,WAAW,iBAAmBA,aAAoB,eAAA,CAQ1D,IAAI,WACJ,CACI,OAAO,KAAK,aAAe,KAAK,WAAa,KAAK,SAAS,WAAW,IAAI,EAAA,CAElF,EAzFaR,GAEK,UAA+BS,EAAc,cCMxD,IAAMC,GAAN,KACP,CAeI,YAAYC,EACZ,CAdO,KAAA,UAAiD,OAAA,OAAO,IAAI,EAOnE,KAAQ,OAAS,GAQb,IAAIC,EAAQ,EAEZ,QAAWC,KAAKF,EAChB,CACU,IAAAG,EAAyBH,EAAUE,CAAC,EAErC,KAAA,YAAYC,EAAUF,GAAO,CAAA,CAGtC,KAAK,WAAW,CAAA,CASb,YACP,CACI,GAAI,CAAC,KAAK,OAAQ,OAElB,KAAK,OAAS,GAEd,IAAMG,EAAW,CAAA,EACbH,EAAQ,EAGD,QAAAC,KAAK,KAAK,UAGjBE,EAASH,GAAO,EAAI,KAAK,UAAUC,CAAC,EAAE,YAGrC,KAAA,KAAOE,EAAS,KAAK,GAAG,CAAA,CAU1B,YAAYD,EAAwBF,EAC3C,CACU,IAAAI,EAAkB,KAAK,UAAUJ,CAAK,EAExCE,IAAaE,IAEbA,GAEAF,EAAS,MAAM,SAAU,KAAK,iBAAkB,IAAI,EAGxDA,EAAS,KAAK,SAAU,KAAK,iBAAkB,IAAI,EAE9C,KAAA,UAAUF,CAAK,EAAIE,EACxB,KAAK,OAAS,GAAA,CAQX,YAAYF,EACnB,CACW,OAAA,KAAK,UAAUA,CAAK,CAAA,CAUxB,OAAOK,EACd,CACI,IAAMN,EAAY,KAAK,UAEvB,QAAWE,KAAKF,EAEFA,EAAAE,CAAC,EAAE,SAAWI,CAC5B,CAIG,SACP,CACI,IAAMN,EAAY,KAAK,UAEvB,QAAWE,KAAKF,EAEKA,EAAUE,CAAC,EAEnB,MAAM,SAAU,KAAK,iBAAkB,IAAI,EAGxD,KAAK,UAAY,IAAA,CAGX,iBAAiBC,EAC3B,CAKI,GAJA,KAAK,OAAS,GAIVA,EAAS,UACb,CAEI,IAAMH,EAAY,KAAK,UAEvB,QAAWE,KAAKF,EAERA,EAAUE,CAAC,IAAMC,IAEjBH,EAAUE,CAAC,EAAI,KAEvB,MAIA,KAAK,WAAW,CACpB,CAER,ECzKA,IAAIK,GAQG,SAASC,IAChB,CACI,OAAI,CAACD,IAAWA,IAAS,cAAA,KAIrBA,GAFeE,GAAW,IAAI,EAAE,aAAa,EAE5B,WAAW,QAAS,CAAA,CAAE,GAGpCF,EACX,CCpBA,IAAMG,GAAe,CACjB,2BACA,mBACA,oBACA,YACA,4BACA,GACJ,EAAE,KAAK;CAAI,EAEX,SAASC,GAAkBC,EAC3B,CACI,IAAIC,EAAM,GAEV,QAASC,EAAI,EAAGA,EAAIF,EAAQ,EAAEE,EAEtBA,EAAI,IAEGD,GAAA;QAGPC,EAAIF,EAAS,IAEbC,GAAO,cAAcC,CAAC,SAIvB,OAAAD,CACX,CAEgB,SAAAE,GAA6BH,EAAgBI,EAC7D,CACI,GAAIJ,IAAW,EAEL,MAAA,IAAI,MAAM,+DAA+D,EAGnF,IAAMK,EAASD,EAAG,aAAaA,EAAG,eAAe,EAGjD,GAAA,CACI,OACA,CACI,IAAME,EAAcR,GAAa,QAAQ,cAAeC,GAAkBC,CAAM,CAAC,EAKjF,GAHGI,EAAA,aAAaC,EAAQC,CAAW,EACnCF,EAAG,cAAcC,CAAM,EAEnB,CAACD,EAAG,mBAAmBC,EAAQD,EAAG,cAAc,EAEhDJ,EAAUA,EAAS,EAAK,MAKxB,MACJ,CACJ,QAEJ,CAEII,EAAG,aAAaC,CAAM,CAAA,CAGnB,OAAAL,CACX,CC/DA,IAAIO,GAA0C,KASvC,SAASC,IAChB,CACQ,GAAAD,GAAiC,OAAAA,GAErC,IAAME,EAAKC,GAAe,EAGC,OAAAH,GAAAE,EAAG,aAAaA,EAAG,uBAAuB,EAG1CF,GAAAI,GACvBJ,GAA0BE,CAAA,EAE3BA,EAAA,aAAa,oBAAoB,GAAG,YAAY,EAE5CF,EACX,CCtBO,IAAMK,GAAN,KACP,CA+BI,YAAYC,EACZ,CACQ,OAAOA,GAAiB,SAEnB,KAAA,cAAgB,IAAI,YAAYA,CAAY,EAE5CA,aAAwB,WAE7B,KAAK,cAAgBA,EAAa,OAIlC,KAAK,cAAgBA,EAGzB,KAAK,WAAa,IAAI,YAAY,KAAK,aAAa,EACpD,KAAK,YAAc,IAAI,aAAa,KAAK,aAAa,EAEjD,KAAA,KAAO,KAAK,cAAc,UAAA,CAInC,IAAI,UACJ,CACQ,OAAC,KAAK,YAEN,KAAK,UAAY,IAAI,UAAU,KAAK,aAAa,GAG9C,KAAK,SAAA,CAIhB,IAAI,WACJ,CACQ,OAAC,KAAK,aAEN,KAAK,WAAa,IAAI,WAAW,KAAK,aAAa,GAGhD,KAAK,UAAA,CAIhB,IAAI,WACJ,CACQ,OAAC,KAAK,aAEN,KAAK,WAAa,IAAI,WAAW,KAAK,aAAa,GAGhD,KAAK,UAAA,CAIhB,IAAI,WACJ,CACQ,OAAC,KAAK,aAEN,KAAK,WAAa,IAAI,WAAW,KAAK,aAAa,GAGhD,KAAK,UAAA,CAIhB,IAAI,aACJ,CACQ,OAAC,KAAK,gBAEN,KAAK,cAAgB,IAAI,aAAa,KAAK,aAAa,GAGrD,KAAK,aAAA,CAIhB,IAAI,eACJ,CACQ,OAAC,KAAK,kBAEN,KAAK,gBAAkB,IAAI,eAAe,KAAK,aAAa,GAGzD,KAAK,eAAA,CAST,KAAKC,EACZ,CACY,OAAA,KAAa,GAAGA,CAAI,MAAM,CAAA,CAI/B,SACP,CACI,KAAK,cAAgB,KACrB,KAAK,UAAY,KACjB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,WAAa,KAClB,KAAK,YAAc,IAAA,CASvB,OAAc,OAAOA,EACrB,CACI,OAAQA,EACR,CACI,IAAK,OACL,IAAK,QACM,MAAA,GACX,IAAK,QACL,IAAK,SACM,MAAA,GACX,IAAK,QACL,IAAK,SACL,IAAK,UACM,MAAA,GACX,QACI,MAAM,IAAI,MAAM,GAAGA,CAAI,0BAA0B,CAAA,CACzD,CAER,ECrKgB,SAAAC,GAASC,EAA2BC,EACpD,CACU,IAAAC,EAAgBF,EAAa,WAAa,EAAK,EAE/CG,EAAoB,IAAI,aAAaH,EAAc,EAAGE,CAAY,EACzC,IAAI,aAAaD,EAAmB,EAAGC,CAAY,EAG3D,IAAIC,CAAiB,EAGtC,IAAAC,EAAiBJ,EAAa,WAAcE,EAAe,EAEjE,GAAIE,EAAiB,EACrB,CACI,IAAMC,EAAkB,IAAI,WAAWL,EAAcE,EAAe,EAAGE,CAAc,EACxD,IAAI,WAAWH,EAAmBC,EAAe,EAAGE,CAAc,EAG1E,IAAIC,CAAe,CAAA,CAEhD,CCcO,IAAMC,GAAe,CACxB,OAAQ,aACR,IAAK,UACL,OAAQ,YACZ,EAMYC,IAAAA,IAERA,EAAAA,EAAA,SAAW,CAAX,EAAA,WACAA,EAAAA,EAAA,mBAAqB,CAArB,EAAA,qBACAA,EAAAA,EAAA,YAAc,CAAd,EAAA,cACAA,EAAAA,EAAA,oBAAsB,CAAtB,EAAA,sBACAA,EAAAA,EAAA,sBAAwB,CAAxB,EAAA,wBACAA,EAAAA,EAAA,KAAO,CAAP,EAAA,OAPQA,IAAAA,IAAA,CAAA,CAAA,ECzCI,SAAAC,GAA0BC,EAAwBC,EAClE,CACQ,OAAAA,EAAc,YAAc,wBAEpBC,GAAaF,CAAsC,GAAKA,CAIxE,CCdO,IAAMG,GAAN,KACP,CAUI,aACA,CANO,KAAA,IAAqC,OAAA,OAAO,IAAI,EAOnD,KAAK,SAAW,CAAA,EAChB,KAAK,MAAQ,CAAA,CAIV,OACP,CACI,QAASC,EAAI,EAAGA,EAAI,KAAK,MAAOA,IAChC,CACU,IAAAC,EAAI,KAAK,SAASD,CAAC,EAEpB,KAAA,SAASA,CAAC,EAAI,KACd,KAAA,IAAIC,EAAE,GAAG,EAAI,IAAA,CAGtB,KAAK,MAAQ,CAAA,CAErB,ECbO,IAAMC,GAAN,KACP,CADO,aAAA,CAEH,KAAO,aAAe,QACtB,KAAO,OAAsB,aAO7B,KAAO,MAAQ,EACf,KAAO,KAAO,EACP,KAAA,SAA8B,IAAIC,GAEzC,KAAO,UAAyB,SAChC,KAAO,SAAqB,iBAE5B,KAAO,UAAY,EAAA,CAiBZ,SACP,CACI,KAAK,SAAW,KAChB,KAAK,aAAe,KACpB,KAAK,UAAY,KACjB,KAAK,QAAU,IAAA,CAEvB,EAGMC,GAAqB,CAAA,EACvBC,GAAiB,EAErB,SAASC,IACT,CACI,OAAOD,GAAiB,EAAID,GAAU,EAAEC,EAAc,EAAI,IAAIH,EAClE,CAEA,SAASK,GAAkBC,EAC3B,CACIJ,GAAUC,IAAgB,EAAIG,CAClC,CAoKA,IAAIC,GAAa,EAmBKC,GAAf,MAAeA,EACtB,CA6FI,YAAYC,EAA0B,CAAA,EACtC,CAtFgB,KAAA,IAAcC,EAAI,SAAS,EAqB3C,KAAO,MAAQ,GAGf,KAAO,WAAa,EAGpB,KAAO,QAAmB,CAAA,EAE1B,KAAQ,UAAgC,CAAA,EA0DpCF,GAAQ,eAAe,YAAcA,GAAQ,eAAe,aAAeG,GAAuB,EAClGF,EAAU,CAAE,GAAGD,GAAQ,eAAgB,GAAGC,CAAQ,EAElD,GAAM,CAAE,YAAAG,EAAa,sBAAAC,EAAuB,mBAAAC,CAAA,EAAuBL,EAEnE,KAAK,gBAAkB,IAAIM,GAAeF,EAAwB,CAAC,EAE9D,KAAA,YAAc,IAAI,YAAYC,CAAkB,EAErD,KAAK,YAAcF,CAAA,CAGhB,OACP,CACI,KAAK,YAAc,EACnB,KAAK,aAAe,EACpB,KAAK,UAAY,EACjB,KAAK,cAAgB,EAErB,QAASI,EAAI,EAAGA,EAAI,KAAK,WAAYA,IAEfX,GAAA,KAAK,QAAQW,CAAC,CAAC,EAGrC,KAAK,WAAa,EAClB,KAAK,iBAAmB,EACxB,KAAK,gBAAkB,EAEvB,KAAK,MAAQ,EAAA,CAGV,IAAIC,EACX,CACS,KAAA,UAAU,KAAK,aAAa,EAAIA,EAErCA,EAAgB,YAAc,KAAK,UACnCA,EAAgB,gBAAkB,KAAK,cACvCA,EAAgB,SAAW,KAE3B,KAAK,WAAaA,EAAgB,UAC7B,KAAA,eAAmBA,EAAgB,cAAiB,KAAK,UAAA,CAG3D,sBAAsBA,EAAmCC,EAChE,CACI,IAAMC,EAAYF,EAAgB,OAAO,SAAS,IAAIC,EAAQ,QAAQ,GAAG,EAIrE,MAAA,CAACC,GAAaA,IAAc,EAAU,IAE1CF,EAAgB,WAAaE,EAC7BF,EAAgB,QAAUC,EAEnB,GAAA,CAGJ,cAAcD,EACrB,CACI,KAAK,MAAQ,GAEb,IAAMG,EAAkB,KAAK,gBAEzBH,EAAgB,WAEX,KAAA,mBACDA,EACAG,EAAgB,YAChBA,EAAgB,WAChBH,EAAgB,gBAAiBA,EAAgB,UAAA,EAIhD,KAAA,eACDA,EACAG,EAAgB,YAChBA,EAAgB,WAChBH,EAAgB,gBAAiBA,EAAgB,UAAA,CACzD,CAQG,MAAMI,EACb,CACI,IAAMC,EAAW,KAAK,UAGlB,GAAA,CAACA,EAAS,KAAK,YAAY,EAAG,OAElC,IAAIhB,EAAQF,GAAiB,EACzBmB,EAAejB,EAAM,SAEzBiB,EAAa,MAAM,EAEb,IAAAC,EAAeF,EAAS,KAAK,YAAY,EAC3CG,EAAYC,GAA0BF,EAAa,UAAWA,EAAa,QAAQ,OAAO,EAC1FG,EAAWH,EAAa,SAExB,KAAK,cAAgB,EAAI,KAAK,gBAAgB,MAEzC,KAAA,uBAAuB,KAAK,cAAgB,CAAC,EAGlD,KAAK,UAAY,KAAK,YAAY,QAE7B,KAAA,mBAAmB,KAAK,SAAS,EAGpC,IAAAI,EAAM,KAAK,gBAAgB,YAC3BC,EAAM,KAAK,gBAAgB,WAC3BC,EAAc,KAAK,YAErBC,EAAO,KAAK,gBACZC,EAAQ,KAAK,iBAEbC,EAAsB,aAEpBrB,EAAc,KAAK,YAEzB,QAASI,EAAI,KAAK,aAAcA,EAAI,KAAK,YAAa,EAAEA,EACxD,CACU,IAAAkB,EAAUZ,EAASN,CAAC,EAE1BM,EAASN,CAAC,EAAI,KAGd,IAAMmB,EADUD,EAAQ,QACD,QAEjBE,EAAoBV,GAA0BQ,EAAQ,UAAWC,CAAM,EAEvEE,EAAgBZ,IAAcW,GAAqBT,IAAaO,EAAQ,SAE9E,GAAIC,EAAO,aAAe5B,IAAc,CAAC8B,EACzC,CACIH,EAAQ,WAAaC,EAAO,qBAE5BJ,GAAQG,EAAQ,UAEZA,EAAQ,YAEH,KAAA,mBACDA,EACAN,EAAKC,EACLK,EAAQ,gBAAiBA,EAAQ,UAAA,EAEhC,KAAA,cACDJ,EACAI,EAAQ,YACRA,EAAQ,gBAAkB,KAAK,UAAA,IAK9B,KAAA,eACDA,EACAN,EAAKC,EACLK,EAAQ,gBACRA,EAAQ,UAAA,EAEP,KAAA,UACDA,EACAJ,EACAI,EAAQ,YACRA,EAAQ,gBAAkB,KAAK,UAAA,GAIvCA,EAAQ,OAAS5B,EAEjB,QAAA,CAGJ6B,EAAO,WAAa5B,IAEhBgB,EAAa,OAASX,GAAeyB,KAEhC,KAAA,aACD/B,EACA0B,EACAD,EAAOC,EACPT,EACAE,EACAE,EACAN,EACAY,CAAA,EAGKA,EAAA,cACDD,EAAAD,EAEIN,EAAAW,EACZT,EAAWO,EAAQ,SAEnB5B,EAAQF,GAAiB,EACzBmB,EAAejB,EAAM,SACrBiB,EAAa,MAAM,EAEjB,EAAAhB,IAGE2B,EAAA,WAAaC,EAAO,qBAAuBZ,EAAa,MAChEA,EAAa,IAAIY,EAAO,GAAG,EAAIZ,EAAa,MAC/BA,EAAA,SAASA,EAAa,OAAO,EAAIY,EAC9CD,EAAQ,OAAS5B,EAEjByB,GAAQG,EAAQ,UAEZA,EAAQ,YAEH,KAAA,mBACDA,EACAN,EAAKC,EACLK,EAAQ,gBAAiBA,EAAQ,UAAA,EAEhC,KAAA,cACDJ,EACAI,EAAQ,YACRA,EAAQ,gBAAkB,KAAK,UAAA,IAK9B,KAAA,eAAeA,EAChBN,EAAKC,EACLK,EAAQ,gBAAiBA,EAAQ,UAAA,EAGhC,KAAA,UACDA,EACAJ,EACAI,EAAQ,YACRA,EAAQ,gBAAkB,KAAK,UAAA,EAEvC,CAGAX,EAAa,MAAQ,IAEhB,KAAA,aACDjB,EACA0B,EACAD,EAAOC,EACPT,EACAE,EACAE,EACAN,EACAY,CAAA,EAGID,EAAAD,EACN,EAAAxB,IAGN,KAAK,aAAe,KAAK,YACzB,KAAK,iBAAmByB,EACxB,KAAK,gBAAkBD,CAAA,CAGnB,aACJzB,EACAgC,EACAC,EACAhB,EACAE,EACAE,EACAN,EACAY,EAEJ,CACI3B,EAAM,aAAe,KACrBA,EAAM,UAAY,KAClBA,EAAM,OAAS2B,EAEf3B,EAAM,QAAU,KAChBA,EAAM,SAAWiB,EACjBjB,EAAM,UAAYmB,EAClBnB,EAAM,SAAWqB,EACjBrB,EAAM,MAAQgC,EACdhC,EAAM,KAAOiC,EAEX,EAAAhC,GAGG,KAAA,QAAQ,KAAK,YAAY,EAAID,EAClCe,EAAe,IAAIf,CAAK,CAAA,CAGrB,OAAOe,EACd,CACI,KAAK,MAAMA,CAAc,CAAA,CAOtB,sBAAsBU,EAC7B,CACQA,EAAO,GAAK,KAAK,gBAAgB,MAEhC,KAAA,uBAAuBA,EAAO,CAAC,CAAA,CAOjC,kBAAkBA,EACzB,CACQA,GAAQ,KAAK,YAAY,QAE7B,KAAK,mBAAmBA,CAAI,CAAA,CAGxB,uBAAuBA,EAC/B,CACI,IAAMS,EAAU,KAAK,IAAIT,EAAM,KAAK,gBAAgB,KAAO,CAAC,EAEtDU,EAAiB,IAAI1B,GAAeyB,CAAO,EAEjDE,GAAS,KAAK,gBAAgB,cAAeD,EAAe,aAAa,EAEzE,KAAK,gBAAkBA,CAAA,CAGnB,mBAAmBV,EAC3B,CACI,IAAMD,EAAc,KAAK,YAErBU,EAAU,KAAK,IAAIT,EAAMD,EAAY,OAAS,GAAG,EAErDU,GAAWA,EAAU,EAOf,IAAAG,EAAkBH,EAAU,MAAS,IAAI,YAAYA,CAAO,EAAI,IAAI,YAAYA,CAAO,EAEzF,GAAAG,EAAe,oBAAsBb,EAAY,kBAEjD,QAASd,EAAI,EAAGA,EAAIc,EAAY,OAAQd,IAErB2B,EAAA3B,CAAC,EAAIc,EAAYd,CAAC,OAK5B0B,GAAAZ,EAAY,OAAQa,EAAe,MAAM,EAGtD,KAAK,YAAcA,CAAA,CAGhB,cAAcb,EAA+Bc,EAAeC,EACnE,CACgBf,EAAAc,CAAK,EAAIC,EAAgB,EACzBf,EAAAc,EAAQ,CAAC,EAAIC,EAAgB,EAC7Bf,EAAAc,EAAQ,CAAC,EAAIC,EAAgB,EAE7Bf,EAAAc,EAAQ,CAAC,EAAIC,EAAgB,EAC7Bf,EAAAc,EAAQ,CAAC,EAAIC,EAAgB,EAC7Bf,EAAAc,EAAQ,CAAC,EAAIC,EAAgB,CAAA,CAGtC,UAAUX,EAA+BJ,EAA+Bc,EAAeC,EAC9F,CACI,IAAMC,EAAUZ,EAAQ,QAClBH,EAAOG,EAAQ,UACfa,EAAcb,EAAQ,YACtBc,EAAkBd,EAAQ,gBAEhC,QAASlB,EAAI,EAAGA,EAAIe,EAAMf,IAEtBc,EAAYc,GAAO,EAAIC,EAAgBC,EAAQ9B,EAAI+B,CAAW,EAAIC,CACtE,CAGG,SACP,CACI,QAAShC,EAAI,EAAGA,EAAI,KAAK,QAAQ,OAAQA,IAEnBX,GAAA,KAAK,QAAQW,CAAC,CAAC,EAGrC,KAAK,QAAU,KAEf,QAASA,EAAI,EAAGA,EAAI,KAAK,UAAU,OAAQA,IAElC,KAAA,UAAUA,CAAC,EAAE,OAAS,KAG/B,KAAK,UAAY,KAEjB,KAAK,YAAc,KAEnB,KAAK,gBAAgB,QAAQ,EAC7B,KAAK,gBAAkB,IAAA,CAE/B,EApfsBR,GAEJ,eAA0C,CACpD,YAAa,KACb,sBAAuB,EACvB,mBAAoB,CACxB,EANG,IAAeyC,GAAfzC,GChQK,IAAA0C,GAAAA,IAMRA,EAAAA,EAAA,SAAW,CAAX,EAAA,WAKAA,EAAAA,EAAA,UAAY,CAAZ,EAAA,YAKAA,EAAAA,EAAA,SAAW,CAAX,EAAA,WAMAA,EAAAA,EAAA,SAAW,CAAX,EAAA,WAEAA,EAAAA,EAAA,MAAQ,EAAR,EAAA,QAEAA,EAAAA,EAAA,OAAS,EAAT,EAAA,SAKAA,EAAAA,EAAA,QAAU,EAAV,EAAA,UAKAA,EAAAA,EAAA,QAAU,GAAV,EAAA,UAKAA,EAAAA,EAAA,SAAW,GAAX,EAAA,WAKAA,EAAAA,EAAA,cAAgB,GAAhB,EAAA,gBAEAA,EAAAA,EAAA,OAAS,IAAT,EAAA,SAhDQA,IAAAA,GAAA,CAAA,CAAA,ECqEL,IAAMC,EAAN,cAAqBC,CAK5B,CAqFI,YAAYC,EACZ,CACQ,GAAA,CAAE,KAAAC,EAAM,KAAAC,CAAA,EAASF,EACf,CAAE,MAAAG,EAAO,MAAAC,EAAO,YAAAC,CAAA,EAAgBL,EAEhC,MAAA,EAvEM,KAAA,IAAcM,EAAI,QAAQ,EAO1C,KAAgB,cAAgB,SAOzB,KAAA,YAAcA,EAAI,UAAU,EAOnC,KAAO,SAAW,EAalB,KAAO,UAAY,EAUnB,KAAQ,WAAyB,KAUjC,KAAO,YAAc,GAMrB,KAAO,UAAY,GAaXL,aAAgB,QAETA,EAAA,IAAI,aAAaA,CAAgB,GAG5C,KAAK,MAAQA,EAEbC,IAAAA,EAAUD,GAAqB,YAEzB,IAAAM,EAAmB,CAAC,CAACN,EAE3B,KAAK,WAAa,CACd,KAAAC,EACA,MAAAC,EACA,iBAAAI,EACA,MAAAH,CAAA,EAGJ,KAAK,YAAcC,GAAe,EAAA,CAItC,IAAI,MACJ,CACI,OAAO,KAAK,KAAA,CAGhB,IAAI,KAAKG,EACT,CACI,KAAK,gBAAgBA,EAAOA,EAAM,OAAQ,EAAI,CAAA,CAGlD,IAAI,WACJ,CACQ,OAAC,KAAK,aAEN,KAAK,WAAa,IAAI,WAAY,KAAK,KAAa,MAAM,GAGvD,KAAK,UAAA,CAIhB,IAAI,QACJ,CACI,MAAO,CAAC,EAAE,KAAK,WAAW,MAAQC,EAAY,OAAA,CAGlD,IAAI,OAAOD,EACX,CACQA,EAEK,KAAA,WAAW,OAASC,EAAY,OAIhC,KAAA,WAAW,OAAS,CAACA,EAAY,MAC1C,CAUG,gBAAgBD,EAAmBN,EAAcQ,EACxD,CAOQ,GALC,KAAA,YAEA,KAAA,YAAeR,EAAOM,EAAM,kBAG7B,KAAK,QAAUA,EACnB,CACQE,GAAc,KAAA,KAAK,SAAU,IAAI,EAErC,MAAA,CAIJ,IAAMC,EAAU,KAAK,MAMrB,GAJA,KAAK,MAAQH,EACb,KAAK,WAAa,KAGd,CAACG,GAAWA,EAAQ,SAAWH,EAAM,OACzC,CACQ,CAAC,KAAK,aAAeG,GAAWH,EAAM,WAAaG,EAAQ,WAEvDD,GAAc,KAAA,KAAK,SAAU,IAAI,GAIhC,KAAA,WAAW,KAAOF,EAAM,WACxB,KAAA,YAAcF,EAAI,UAAU,EAC5B,KAAA,KAAK,SAAU,IAAI,GAG5B,MAAA,CAGAI,GAAc,KAAA,KAAK,SAAU,IAAI,CAAA,CASlC,OAAOE,EACd,CACS,KAAA,YAAcA,GAAe,KAAK,YAElC,KAAA,YAEA,KAAA,KAAK,SAAU,IAAI,CAAA,CAIrB,SACP,CACI,KAAK,UAAY,GAEZ,KAAA,KAAK,UAAW,IAAI,EACpB,KAAA,KAAK,SAAU,IAAI,EAExB,KAAK,MAAQ,KACZ,KAAK,WAAsB,KAE5B,KAAK,mBAAmB,CAAA,CAEhC,ECrSgB,SAAAC,GAAeC,EAAwCC,EACvE,CACQ,GAAA,EAAED,aAAkBE,GACxB,CACI,IAAIC,EAAgBF,EAAQG,EAAY,MAAQA,EAAY,OAGxDJ,aAAkB,QAEdC,GAESD,EAAA,IAAI,YAAYA,CAAM,EACvBG,EAAAC,EAAY,MAAQA,EAAY,WAK/BJ,EAAA,IAAI,aAAaA,CAAM,EACxBG,EAAAC,EAAY,OAASA,EAAY,WAIjDJ,EAAS,IAAIE,EAAO,CAChB,KAAMF,EACN,MAAOC,EAAQ,oBAAsB,qBACrC,MAAAE,CAAA,CACH,CAAA,CAGE,OAAAH,CACX,CClCgB,SAAAK,GAAkBC,EAAoBC,EAAqBC,EAC3E,CACU,IAAAC,EAAYH,EAAS,aAAaC,CAAW,EAEnD,GAAI,CAACE,EAED,OAAAD,EAAO,KAAO,EACdA,EAAO,KAAO,EACdA,EAAO,KAAO,EACdA,EAAO,KAAO,EAEPA,EAGL,IAAAE,EAAOD,EAAU,OAAO,KAE1BE,EAAO,IACPC,EAAO,IACPC,EAAO,KACPC,EAAO,KAELC,EAAWL,EAAK,kBAGhBM,GAAUP,EAAU,QAAU,GAAKM,EACnCE,GAAUR,EAAU,QAAW,EAAI,GAAMM,EAE/C,QAASG,EAAIF,EAAQE,EAAIR,EAAK,OAAQQ,GAAKD,EAC3C,CACU,IAAAE,EAAIT,EAAKQ,CAAC,EACVE,EAAIV,EAAKQ,EAAI,CAAC,EAEhBC,EAAIN,IAAYA,EAAAM,GAChBC,EAAIN,IAAYA,EAAAM,GAChBD,EAAIR,IAAYA,EAAAQ,GAChBC,EAAIR,IAAYA,EAAAQ,EAAA,CAGxB,OAAAZ,EAAO,KAAOG,EACdH,EAAO,KAAOI,EACdJ,EAAO,KAAOK,EACdL,EAAO,KAAOM,EAEPN,CACX,CCeA,SAASa,GAAkBC,EAC3B,CACI,OAAIA,aAAqBC,GAAU,MAAM,QAAQD,CAAS,GAAMA,EAAyB,qBAEzEA,EAAA,CACR,OAAQA,CAAA,GAIfA,EAAwB,OAASE,GAAeF,EAAU,OAA0C,EAAK,EAEnGA,CACX,CAmCO,IAAMG,GAAN,cAAuBC,CAI9B,CA8BI,YAAYC,EAA8B,CAAA,EAC1C,CACU,MAAA,EA5BM,KAAA,IAAcC,EAAI,UAAU,EAc5C,KAAO,WAAa,EAGpB,KAAO,cAAgB,EAEN,KAAA,QAAkB,IAAIC,EACvC,KAAQ,aAAe,GAUnB,GAAM,CAAE,WAAAC,EAAY,YAAAC,EAAa,SAAAC,CAAA,EAAaL,EAM9C,GAJA,KAAK,QAAU,CAAA,EAEf,KAAK,WAAa,CAAA,EAEdG,EAEA,QAAWG,KAAKH,EAEZ,KAAK,aAAaG,EAAGH,EAAWG,CAAC,CAAC,EAIrC,KAAA,cAAgBN,EAAQ,eAAiB,EAE1CI,GAEA,KAAK,SAASA,CAAW,EAG7B,KAAK,SAAWC,GAAY,eAAA,CAGtB,gBACV,CACI,KAAK,aAAe,GACf,KAAA,KAAK,SAAU,IAAI,CAAA,CAQrB,aAAaE,EACpB,CACW,OAAA,KAAK,WAAWA,CAAE,CAAA,CAOtB,UACP,CACI,OAAO,KAAK,WAAA,CAQT,UAAUA,EACjB,CACW,OAAA,KAAK,aAAaA,CAAE,EAAE,MAAA,CAO1B,SACP,CACe,QAAAD,KAAK,KAAK,WACrB,CACU,IAAAX,EAAY,KAAK,WAAWW,CAAC,EAInC,OAHeX,EAAU,OAGV,KAAa,QAAWA,EAAU,OAAS,GAAMA,EAAU,KAAA,CAGvE,MAAA,EAAA,CAQJ,aAAaa,EAAcC,EAClC,CACU,IAAAd,EAAYD,GAAkBe,CAAe,EAE/B,KAAK,QAAQ,QAAQd,EAAU,MAAM,IAErC,KAEX,KAAA,QAAQ,KAAKA,EAAU,MAAM,EAIlCA,EAAU,OAAO,GAAG,SAAU,KAAK,eAAgB,IAAI,EACvDA,EAAU,OAAO,GAAG,SAAU,KAAK,eAAgB,IAAI,GAEtD,KAAA,WAAWa,CAAI,EAAIb,CAAA,CAOrB,SAASS,EAChB,CACS,KAAA,YAAcP,GAAeO,EAAa,EAAI,EAC9C,KAAA,QAAQ,KAAK,KAAK,WAAW,CAAA,CAItC,IAAI,QACJ,CACI,OAAK,KAAK,cAEV,KAAK,aAAe,GAEbM,GAAkB,KAAM,YAAa,KAAK,OAAO,GAJzB,KAAK,OAIoB,CAOrD,QAAQC,EAAiB,GAChC,CACS,KAAA,KAAK,UAAW,IAAI,EAEzB,KAAK,mBAAmB,EAEpBA,GAEA,KAAK,QAAQ,QAASC,GAAWA,EAAO,QAAA,CAAS,EAGpD,KAAK,WAAsB,KAC3B,KAAK,QAAmB,KACxB,KAAK,YAAuB,KAC5B,KAAK,QAAmB,IAAA,CAEjC,EClSA,IAAMC,GAAwB,IAAI,aAAa,CAAC,EAC1CC,GAAuB,IAAI,YAAY,CAAC,EAEjCC,GAAN,cAA4BC,EACnC,CACI,aACA,CAGU,IAAAC,EAAkB,IAAIC,EAAO,CAC/B,KAAML,GACN,MAAO,yBACP,MAAOM,EAAY,OAASA,EAAY,SACxC,YAAa,EAAA,CAChB,EAEKC,EAAc,IAAIF,EAAO,CAC3B,KAAMJ,GACN,MAAO,qBACP,MAAOK,EAAY,MAAQA,EAAY,SACvC,YAAa,EAAA,CAChB,EAEKE,EAAS,EAAa,EAEtB,MAAA,CACF,WAAY,CACR,UAAW,CACP,OAAQJ,EACR,OAAQ,YACR,OAAAI,EACA,OAAQ,CAAA,EAEZ,IAAK,CACD,OAAQJ,EACR,OAAQ,YACR,OAAAI,EACA,OAAQ,EAAI,CAAA,EAEhB,OAAQ,CACJ,OAAQJ,EACR,OAAQ,WACR,OAAAI,EACA,OAAQ,EAAI,CAAA,EAEhB,mBAAoB,CAChB,OAAQJ,EACR,OAAQ,WACR,OAAAI,EACA,OAAQ,EAAI,CAAA,CAChB,EAEJ,YAAAD,CAAA,CACH,CAAA,CAET,EC3DA,IAAME,GAA0C,OAAA,OAAO,IAAI,EACrDC,GAAwC,OAAA,OAAO,IAAI,EAEzC,SAAAC,GAAmBC,EAAeC,EAClD,CACQ,IAAAC,EAAKJ,GAAOE,CAAK,EAErB,OAAIE,IAAO,SAEHL,GAASI,CAAO,IAAM,SAEtBJ,GAASI,CAAO,EAAI,GAGxBH,GAAOE,CAAK,EAAIE,EAAKL,GAASI,CAAO,KAGlCC,CACX,CCdA,IAAIC,GAEG,SAASC,IAChB,CACI,GAAI,CAACD,GACL,CAC2BA,GAAA,UACvB,IAAME,EAAKC,GAAe,EAEtBD,GAEIA,EAAG,2BAIoBF,GAFAE,EAAG,yBAAyBA,EAAG,gBAAiBA,EAAG,UAAU,EAE9C,UAAY,QAAU,UAEpE,CAGG,OAAAF,EACX,CCzBgB,SAAAI,GAAkBC,EAAaC,EAAkBC,EACjE,CACQ,OAAAD,EAAgBD,EAEhBE,GAEMF,EAAAA,EAAI,QAAQ,uBAAwB,EAAE,EAErC;;;;;;;UAOLA,CAAG;WAIF;;;;;;UAMDA,CAAG;SAEb,CCLgB,SAAAG,GACZC,EACAC,EACAC,EAEJ,CACI,IAAMC,EAAwBD,EAAaD,EAAQ,8BAAgCA,EAAQ,4BAE3F,GAAID,EAAI,UAAU,EAAG,CAAC,IAAM,YAC5B,CAEI,IAAII,EAAYF,EAAaD,EAAQ,2BAA6BA,EAAQ,yBAGtE,OAAAG,IAAc,SAAWD,IAA0B,UAEvCC,EAAA,WAGT,aAAaA,CAAS;EAAYJ,CAAG,EAAA,SAEvCG,IAA0B,SAAWH,EAAI,UAAU,EAAG,EAAE,IAAM,kBAG5D,OAAAA,EAAI,QAAQ,kBAAmB,mBAAmB,EAGtD,OAAAA,CACX,CClDgB,SAAAK,GAAcC,EAAaC,EAC3C,CACI,OAAKA,EAEE;EAAoBD,CAAG,GAFTA,CAGzB,CCLA,IAAME,GAA+C,CAAA,EAC/CC,GAA6C,CAAA,EAE5C,SAASC,GAAeC,EAAa,CAAE,KAAAC,EAAO,cAAe,EAAsBC,EAAa,GACvG,CACWD,EAAAA,EAAK,QAAQ,OAAQ,GAAG,EAE/BA,GAAQC,EAAa,YAAc,UAE7B,IAAAC,EAAYD,EAAaL,GAAoBC,GAa/C,OAXAK,EAAUF,CAAI,GAEdE,EAAUF,CAAI,IACNA,GAAA,IAAIE,EAAUF,CAAI,CAAC,IAI3BE,EAAUF,CAAI,EAAI,EAIlBD,EAAI,QAAQ,qBAAqB,IAAM,GAAWA,EAI/C,GAFY,uBAAuBC,CAAI,EAE1B;EAAKD,CAAG,EAChC,CC3BgB,SAAAI,GAAaC,EAAaC,EAC1C,CACI,OAAKA,EAEED,EAAI,QAAQ,kBAAmB,EAAE,EAFnBA,CAGzB,CCoDA,IAAME,GAA8F,CAEhG,aAAAC,GAEA,gBAAAC,GAEA,kBAAAC,GAEA,eAAAC,GAEA,cAAAC,EACJ,EAEMC,GAAiD,OAAA,OAAO,IAAI,EAgCrDC,GAAN,MAAMA,EACb,CA0CI,YAAYC,EACZ,CACIA,EAAU,CAAE,GAAGD,GAAU,eAAgB,GAAGC,CAAQ,EAIpD,IAAMC,EAAUD,EAAQ,SAAS,QAAQ,iBAAiB,IAAM,GAE1DE,EAAsB,CACxB,aAAcD,EACd,gBAAiB,CACb,2BAA4BD,EAAQ,2BACpC,yBAA0BA,EAAQ,yBAClC,4BAA6B,QAC7B,8BAA+BG,GAAwB,CAAA,EAE3D,eAAgB,CACZ,KAAMH,EAAQ,IAAA,EAElB,kBAAmBC,EACnB,cAAeA,CAAA,EAGfG,EAAWJ,EAAQ,SACnBK,EAASL,EAAQ,OAErB,OAAO,KAAKR,EAAS,EAAE,QAASc,GAChC,CACU,IAAAC,EAAiBL,EAAoBI,CAA8C,EAEzFF,EAAWZ,GAAUc,CAAU,EAAEF,EAAUG,EAAgB,EAAI,EAC/DF,EAASb,GAAUc,CAAU,EAAED,EAAQE,EAAgB,EAAK,CAAA,CAC/D,EAED,KAAK,SAAWH,EAChB,KAAK,OAASC,EAEd,KAAK,0BAA4BL,EAAQ,0BAEpC,KAAA,KAAOQ,GAAmB,GAAG,KAAK,MAAM,IAAI,KAAK,QAAQ,GAAI,YAAY,CAAA,CAI3E,SACP,CACK,KAAK,SAAoB,KACzB,KAAK,OAAkB,KAExB,KAAK,eAAiB,KACtB,KAAK,aAAe,KACpB,KAAK,kBAAoB,KAEzB,KAAK,0BAA4B,IAAA,CAUrC,OAAc,KAAKR,EACnB,CACI,IAAMS,EAAM,GAAGT,EAAQ,MAAM,IAAIA,EAAQ,QAAQ,GAE7C,OAACF,GAAaW,CAAG,IAEjBX,GAAaW,CAAG,EAAI,IAAIV,GAAUC,CAAO,GAGtCF,GAAaW,CAAG,CAAA,CAE/B,EApHaV,GAGK,eAA4C,CACtD,yBAA0B,QAC1B,2BAA4B,SAChC,EANG,IAAMW,GAANX,GCpGP,IAAMY,GAAsB,CACxB,QAAS,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACjD,QAAS,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACjD,QAAS,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACjD,QAAS,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACjD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EACjD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EACjD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EACjD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EACjD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAClD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAClD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAClD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAClD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EAClD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EAClD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EAClD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAK,EAClD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACnD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACnD,QAAS,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACjD,UAAW,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EACnD,UAAW,CAAE,KAAM,EAAG,OAAQ,GAAI,WAAY,EAAM,EACpD,UAAW,CAAE,KAAM,EAAG,OAAQ,GAAI,WAAY,EAAM,EACpD,OAAQ,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAChD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAClD,SAAU,CAAE,KAAM,EAAG,OAAQ,GAAI,WAAY,EAAM,EACnD,SAAU,CAAE,KAAM,EAAG,OAAQ,GAAI,WAAY,EAAM,EACnD,OAAQ,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAChD,SAAU,CAAE,KAAM,EAAG,OAAQ,EAAG,WAAY,EAAM,EAClD,SAAU,CAAE,KAAM,EAAG,OAAQ,GAAI,WAAY,EAAM,EACnD,SAAU,CAAE,KAAM,EAAG,OAAQ,GAAI,WAAY,EAAM,CACvD,EAEO,SAASC,GAA2BC,EAC3C,CACW,OAAAF,GAAoBE,CAAM,GAAKF,GAAoB,OAC9D,CChCA,IAAMG,GAAqD,CAEvD,IAAM,UACN,YAAa,YACb,YAAa,YACb,YAAa,YACb,MAAO,YACP,MAAO,YACP,MAAO,YAEP,IAAK,SACL,YAAa,WACb,YAAa,WACb,YAAa,WAEb,IAAK,SACL,YAAa,WACb,YAAa,WACb,YAAa,WAEb,KAAM,SACN,aAAc,WACd,aAAc,WACd,aAAc,UAClB,EAEO,SAASC,GACZ,CAAE,OAAAC,EAAQ,WAAAC,CAAA,EAEd,CACI,IAAMC,EAAkD,CAAA,EAGlDC,EAAgBH,EAAO,QAAQ,MAAMC,CAAU,EAAE,EAEvD,GAAIE,IAAkB,GACtB,CAEI,IAAMC,EAAqBJ,EAAO,QAAQ,KAAMG,CAAa,EAE7D,GAAIC,IAAuB,GAC3B,CACI,IAAMC,EAAwBL,EAAO,UAAUG,EAAeC,CAAkB,EAG1EE,EAAc,0EAChBC,EAEJ,MAAQA,EAAQD,EAAY,KAAKD,CAAqB,KAAO,MAC7D,CACI,IAAMG,EAASV,GAAqBS,EAAM,CAAC,CAAiB,GAAK,UAEzDL,EAAAK,EAAM,CAAC,CAAC,EAAI,CAChB,SAAU,SAASA,EAAM,CAAC,EAAG,EAAE,EAC/B,OAAAC,EACA,OAAQC,GAA2BD,CAAM,EAAE,OAC3C,OAAQ,EACR,SAAU,GACV,MAAO,CAAA,CACX,CACJ,CACJ,CAGG,OAAAN,CACX,CCxDO,SAASQ,GAAuBC,EACvC,CAEI,IAAMC,EAAc,yCACdC,EAAe,kBACfC,EAAiB,oBACjBC,EAAc,sBACdC,EAAc,YACdC,EAAgB,8BAChBC,EAAsB,2BACtBC,EAAa,iBAGbC,EAAST,EAAK,MAAMC,CAAW,GAAG,IAAKS,IAAU,CACnD,MAAO,SAASA,EAAK,MAAMR,CAAY,EAAE,CAAC,EAAG,EAAE,EAC/C,QAAS,SAASQ,EAAK,MAAMP,CAAc,EAAE,CAAC,EAAG,EAAE,EACnD,KAAMO,EAAK,MAAMN,CAAW,EAAE,CAAC,EAC/B,UAAWM,EAAK,MAAMN,CAAW,EAAE,CAAC,IAAM,YAC1C,KAAMM,EAAK,MAAML,CAAW,EAAE,CAAC,CAAA,EACjC,EAEF,GAAI,CAACI,EAEM,MAAA,CACH,OAAQ,CAAA,EACR,QAAS,CAAA,CAAC,EAKlB,IAAME,EAAUX,EACX,MAAMM,CAAa,GAClB,IAAKM,GACP,CACI,IAAMC,EAAOD,EAAO,MAAMJ,CAAU,EAAE,CAAC,EACjCM,EAAUF,EAAO,MAAML,CAAmB,EAAE,OAAO,CAACQ,EAA6BC,IACvF,CACI,GAAM,CAACH,EAAMI,CAAI,EAAID,EAAO,MAAM,GAAG,EAErC,OAAAD,EAAIF,EAAK,KAAA,CAAM,EAAII,EAAK,KAAK,EAEtBF,CAAA,EACR,CAAA,CAAE,EAEL,OAAKD,EAKE,CAAE,KAAAD,EAAM,QAAAC,CAAQ,EAHZ,IAGY,CAE1B,EACA,OAAO,CAAC,CAAE,KAAAD,CAAA,IAAWJ,EAAO,KAAMS,GAAUA,EAAM,OAASL,CAAI,CAAC,GAAK,CAAA,EAEnE,MAAA,CACH,OAAAJ,EACA,QAAAE,CAAA,CAER,CCzEY,IAAAQ,IAAAA,IAERA,EAAAA,EAAA,OAAS,CAAT,EAAA,SACAA,EAAAA,EAAA,SAAW,CAAX,EAAA,WACAA,EAAAA,EAAA,QAAU,CAAV,EAAA,UAJQA,IAAAA,IAAA,CAAA,CAAA,ECKI,SAAAC,GAAwB,CAAE,OAAAC,CAAA,EAC1C,CACI,IAAMC,EAA2C,CAAA,EAEjD,QAASC,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IACnC,CACU,IAAAC,EAAQH,EAAOE,CAAC,EAEjBD,EAAOE,EAAM,KAAK,IAEZF,EAAAE,EAAM,KAAK,EAAI,CAAA,GAGtBA,EAAM,UAECF,EAAAE,EAAM,KAAK,EAAE,KAAK,CACrB,QAASA,EAAM,QACf,WAAYC,GAAY,OAASA,GAAY,SAC7C,OAAQ,CACJ,KAAM,SAAA,CACV,CACH,EAEID,EAAM,OAAS,UAEbF,EAAAE,EAAM,KAAK,EAAE,KAAK,CACrB,QAASA,EAAM,QACf,WAAYC,GAAY,SACxB,QAAS,CACL,KAAM,WAAA,CACV,CACH,EAEID,EAAM,OAAS,cAEbF,EAAAE,EAAM,KAAK,EAAE,KAAK,CACrB,QAASA,EAAM,QACf,WAAYC,GAAY,SACxB,QAAS,CACL,WAAY,QACZ,cAAe,KACf,aAAc,EAAA,CAClB,CACH,CACL,CAGG,OAAAH,CACX,CClDgB,SAAAI,GAAmB,CAAE,OAAAC,CAAA,EACrC,CACI,IAAMC,EAAwB,CAAA,EAE9B,QAASC,EAAI,EAAGA,EAAIF,EAAO,OAAQE,IACnC,CACU,IAAAC,EAAQH,EAAOE,CAAC,EAEjBD,EAAOE,EAAM,KAAK,IAEZF,EAAAE,EAAM,KAAK,EAAI,CAAA,GAG1BF,EAAOE,EAAM,KAAK,EAAEA,EAAM,IAAI,EAAIA,EAAM,OAAA,CAGrC,OAAAF,CACX,CClBgB,SAAAG,GACZC,EACAC,EAEJ,CACU,IAAAC,EAAA,IAAoB,IACpBC,EAAA,IAAsB,IAEtBC,EAAU,CAAC,GAAGJ,EAAuB,QAAS,GAAGC,EAAyB,OAAO,EAClF,OAAQI,GAEDH,EAAc,IAAIG,EAAO,IAAI,EAEtB,IAEGH,EAAA,IAAIG,EAAO,IAAI,EAEtB,GACV,EAECC,EAAS,CAAC,GAAGN,EAAuB,OAAQ,GAAGC,EAAyB,MAAM,EAC/E,OAAQM,GACT,CACI,IAAMC,EAAM,GAAGD,EAAM,IAAI,IAAIA,EAAM,OAAO,GAEtC,OAAAJ,EAAgB,IAAIK,CAAG,EAEhB,IAEXL,EAAgB,IAAIK,CAAG,EAEhB,GAAA,CACV,EAEE,MAAA,CAAE,QAAAJ,EAAS,OAAAE,CAAO,CAC7B,CCkBA,IAAMG,GAAkD,OAAA,OAAO,IAAI,EAqCtDC,GAAN,MAAMC,CACb,CA+DI,YAAYC,EACZ,CA3BA,KAAO,WAAa,EAMpB,KAAO,uBAAyB,EAsB5B,GAAM,CAAE,SAAAC,EAAU,OAAAC,EAAQ,OAAAC,EAAQ,UAAAC,EAAW,KAAAC,CAAA,EAASL,EAQlD,GANJ,KAAK,KAAOK,EAEZ,KAAK,SAAWJ,EAChB,KAAK,OAASC,EAGVD,EAAS,SAAWC,EAAO,OAC/B,CACU,IAAAI,EAAmBC,GAAuBN,EAAS,MAAM,EAE/D,KAAK,iBAAmBK,CAAA,KAG5B,CACU,IAAAE,EAAyBD,GAAuBL,EAAO,MAAM,EAC7DO,EAA2BF,GAAuBN,EAAS,MAAM,EAElE,KAAA,iBAAmBS,GAA+BF,EAAwBC,CAAwB,CAAA,CAI3G,KAAK,OAASN,GAAUQ,GAAmB,KAAK,gBAAgB,EAIhE,KAAK,UAAYP,GAAaQ,GAAwB,KAAK,gBAAgB,EAE3E,KAAK,yBAA8B,KAAK,OAAO,CAAC,GAAG,iBAAmB,OACtE,KAAK,wBAA6B,KAAK,OAAO,CAAC,GAAG,gBAAkB,OAEpE,KAAK,oBAAoB,CAAA,CAIrB,qBACR,CACU,GAAA,CAAE,OAAAV,EAAQ,SAAAD,CAAA,EAAa,KAEvBY,EAASX,EAAO,OAASD,EAAS,OAASC,EAAO,WAAaD,EAAS,WAEzE,KAAA,WAAaa,GAAmBD,EAAQ,SAAS,CAAA,CAG1D,IAAI,eACJ,CACI,YAAK,iBAAL,KAAK,eAAmBE,GAAgC,KAAK,MAAM,GAE5D,KAAK,cAAA,CAGT,SACP,CACK,KAAK,UAAqB,KAC1B,KAAK,OAAkB,KACvB,KAAK,iBAA4B,KACjC,KAAK,SAAoB,KACzB,KAAK,OAAkB,IAAA,CAU5B,OAAc,KAAKf,EACnB,CAEI,IAAMgB,EAAM,GAAGhB,EAAQ,OAAO,MAAM,IAAIA,EAAQ,SAAS,MAAM,IAAIA,EAAQ,SAAS,UAAU,IAAIA,EAAQ,OAAO,UAAU,GAEvH,OAACH,GAAamB,CAAG,IAEjBnB,GAAamB,CAAG,EAAI,IAAIjB,EAAWC,CAAO,GAGvCH,GAAamB,CAAG,CAAA,CAE/B,ECtOgB,SAAAC,GAAQC,EAAkCC,EAAiCC,EAC3F,CACI,GAAIF,EAEA,QAAWG,KAAKH,EAChB,CACU,IAAAI,EAAKD,EAAE,kBAAkB,EAEzBE,EAAOJ,EAAMG,CAAE,EAErB,GAAIC,EACJ,CACQ,IAAAC,EAAgBN,EAASG,CAAC,EAE1BA,IAAM,WAENG,EAAgBA,EACX,QAAQ,mBAAoB,EAAE,EAC9B,QAAQ,oBAAqB,EAAE,GAGpCJ,GAEKG,EAAA,KAAK,SAASH,CAAI,QAAQ,EAEnCG,EAAK,KAAKC,CAAa,CAAA,MAMlBC,GAAA,GAAGJ,CAAC,0CAA0C,CAEvD,CAGZ,CC5CO,IAAMK,GAAc,iBAMpB,SAASC,GAAaC,EAC7B,CACI,IAAMC,EAAkC,CAAA,EAM5B,OAJQD,EACf,MAAMF,EAAW,GAChB,IAAKI,GAASA,EAAK,QAAQ,UAAW,EAAE,CAAC,GAAK,CAAA,GAExC,QAASA,GACrB,CACUD,EAAAC,CAAI,EAAI,CAAA,CAAC,CAClB,EAEMD,CACX,CCpBA,SAASE,GAAcC,EAAwBC,EAC/C,CACQ,IAAAC,EACEC,EAAQ,kBAEd,MAAQD,EAAQC,EAAM,KAAKH,CAAc,KAAO,MAExCC,EAAA,KAAKC,EAAM,CAAC,CAAC,CAEzB,CAEO,SAASE,GAAcC,EAAkBC,EAAkBC,EAAO,GACzE,CAEI,IAAMC,EAAoB,CAAA,EAE1BT,GAAcO,EAAUE,CAAO,EAErBH,EAAA,QAASI,GACnB,CACQA,EAAS,QAEKV,GAAAU,EAAS,OAAQD,CAAO,CAC1C,CACH,EAGD,IAAME,EAAYF,EAEdD,GAEAG,EAAU,KAAK,EAGnB,IAAMC,EAAcD,EACf,IAAI,CAACE,EAASC,IAAM,oBAAoBA,CAAC,KAAKD,CAAO,GAAG,EACxD,KAAK;CAAI,EAGVE,EAAgBR,EAAS,QAAQ,mBAAoB,EAAE,EAE3C,OAAAQ,EAAAA,EAAc,QAAQ,SAAU;EAAKH,CAAW;CAAI,EAE7DG,CACX,CC5CA,SAASC,GAAeC,EAAwBC,EAChD,CACQ,IAAAC,EACEC,EAAQ,mBAEd,MAAQD,EAAQC,EAAM,KAAKH,CAAc,KAAO,MAExCC,EAAA,KAAKC,EAAM,CAAC,CAAC,CAEzB,CAEA,SAASE,GAAoBC,EAC7B,CAGU,IAAAH,EAFQ,eAEM,KAAKG,CAAK,EAEvB,OAAAH,EAAQA,EAAM,CAAC,EAAI,EAC9B,CAEA,SAASI,GAAcD,EACvB,CACI,IAAMF,EAAQ,WAEP,OAAAE,EAAM,QAAQF,EAAO,EAAE,CAClC,CAEgB,SAAAI,GAAeC,EAAkBC,EACjD,CAEI,IAAMC,EAAoB,CAAA,EAE1BX,GAAeU,EAAUC,CAAO,EAEtBF,EAAA,QAASG,GACnB,CACQA,EAAS,QAEMZ,GAAAY,EAAS,OAAQD,CAAO,CAC3C,CACH,EAED,IAAIE,EAAQ,EAGNC,EAAaH,EACd,KAAA,EACA,IAAKI,GAEEA,EAAQ,QAAQ,SAAS,EAAI,GAEtBA,EAGJ,aAAaF,GAAO,KAAKE,CAAO,EAC1C,EACA,KAAK;CAAK,EAGTC,EAAYL,EACb,KAAK,EACL,IAAKI,GAAY,cAAcR,GAAcQ,CAAO,CAAC,GAAG,EACxD,KAAK;CAAI,EAGRE,EAAU;cACNN,EACG,KAAA,EACA,IAAKI,GAAY,IAAIV,GAAoBU,CAAO,CAAC,EAAE,EACnD,KAAK;CAAK,CAAC,KAGpBG,EAAeR,EAAS,QAAQ,oBAAqB,EAAE,EAE5C,OAAAQ,EAAAA,EAAa,QAAQ,aAAc;EAAKJ,CAAU;CAAI,EACtDI,EAAAA,EAAa,QAAQ,YAAa;EAAKF,CAAS;CAAI,EACpDE,EAAAA,EAAa,QAAQ,aAAc;EAAKD,CAAO;CAAI,EAE3DC,CACX,CC1EgB,SAAAC,GAAWC,EAAqBC,EAChD,CACI,IAAIC,EAAMF,EAEV,QAAWG,KAAKF,EAChB,CACU,IAAAG,EAAQH,EAAcE,CAAC,EAEZC,EAAM,KAAK;CAAI,EAEnB,OAETF,EAAMA,EAAI,QAAQ,KAAKC,CAAC,KAAM,UAAUA,CAAC;EAAkBC,EAAM,KAAK;CAAI,CAAC;QAAWD,CAAC,eAAe,EAKtGD,EAAMA,EAAI,QAAQ,KAAKC,CAAC,KAAM,EAAE,CACpC,CAGG,OAAAD,CACX,CCLA,IAAMG,EAAqD,OAAA,OAAO,IAAI,EAChEC,GAAA,IAA8C,IAEhDC,GAAY,EAQT,SAASC,GAAkB,CAC9B,SAAAC,EACA,KAAAC,CACJ,EACA,CACU,IAAAC,EAAUC,GAAgBH,EAAUC,CAAI,EAE9C,GAAIL,EAASM,CAAO,EAAG,OAAON,EAASM,CAAO,EAE9C,GAAM,CAAE,OAAAE,EAAQ,SAAAC,CAAA,EAAaC,GAAwBN,EAAUC,CAAI,EAEnE,OAAAL,EAASM,CAAO,EAAIK,GAAYH,EAAQC,EAAUJ,CAAI,EAE/CL,EAASM,CAAO,CAC3B,CAEO,SAASM,GAAoB,CAChC,SAAAR,EACA,KAAAC,CACJ,EACA,CACU,IAAAC,EAAUC,GAAgBH,EAAUC,CAAI,EAE9C,OAAIL,EAASM,CAAO,IAEpBN,EAASM,CAAO,EAAIK,GAAYP,EAAS,OAAQA,EAAS,SAAUC,CAAI,GAEjEL,EAASM,CAAO,CAC3B,CAEA,SAASI,GAAwBN,EAA8BC,EAC/D,CACI,IAAMQ,EAAkBR,EAAK,IAAKS,GAAcA,EAAU,MAAM,EAAE,OAAQC,GAAM,CAAC,CAACA,CAAC,EAC7EC,EAAoBX,EAAK,IAAKS,GAAcA,EAAU,QAAQ,EAAE,OAAQC,GAAM,CAAC,CAACA,CAAC,EAGnFE,EAAiBC,GAAcL,EAAiBT,EAAS,OAAQ,EAAI,EAExDa,EAAAE,GAAeN,EAAiBI,CAAc,EAE/D,IAAMG,EAAmBF,GAAcF,EAAmBZ,EAAS,SAAU,EAAI,EAE1E,MAAA,CACH,OAAQa,EACR,SAAUG,CAAA,CAElB,CAEA,SAASb,GAAgBH,EAA8BC,EACvD,CACW,OAAAA,EACF,IAAKgB,IAEGpB,GAAY,IAAIoB,CAAY,GAEjBpB,GAAA,IAAIoB,EAAcnB,IAAW,EAGtCD,GAAY,IAAIoB,CAAY,EACtC,EACA,KAAK,CAACC,EAAGC,IAAMD,EAAIC,CAAC,EACpB,KAAK,GAAG,EAAInB,EAAS,OAASA,EAAS,QAChD,CAEA,SAASO,GAAYH,EAAgBC,EAAkBJ,EACvD,CACU,IAAAmB,EAAcC,GAAajB,CAAM,EACjCkB,EAAgBD,GAAahB,CAAQ,EAEtC,OAAAJ,EAAA,QAASS,GACd,CACIa,GAAQb,EAAU,OAAQU,EAAaV,EAAU,IAAI,EACrDa,GAAQb,EAAU,SAAUY,EAAeZ,EAAU,IAAI,CAAA,CAC5D,EAEM,CACH,OAAQc,GAAWpB,EAAQgB,CAAW,EACtC,SAAUI,GAAWnB,EAAUiB,CAAa,CAAA,CAEpD,CChHM,IAAAG,GAA8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA8C9BC,GAAgC;;;;;;;;;;;;;;;;;;;;;;;EAyBhCC,GAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAsC7BC,GAA+B;;;;;;;;;;;;;;;;;;;;;EC7G9B,IAAMC,GAAoB,CAC7B,KAAM,sBACN,OAAQ,CACJ,OAAkB;;;;;;;;;SAAA,CAW1B,EAgBO,IAAMC,GAAsB,CAC/B,KAAM,sBACN,OAAQ,CACJ,OAAkB;;;;;SAAA,CAQ1B,ECjCO,SAASC,GAA4B,CAAE,KAAAC,EAAM,KAAAC,CAAA,EACpD,CACI,IAAMC,EAASC,GAAkB,CAC7B,SAAU,CACN,SAAUC,GACV,OAAQC,EAAA,EAEZ,KAAM,CACFC,GACA,GAAGN,CAAA,CACP,CACH,EAED,OAAOO,GAAW,KAAK,CACnB,KAAAN,EACA,OAAQ,CACJ,OAAQC,EAAO,OACf,WAAY,MAAA,EAEhB,SAAU,CACN,OAAQA,EAAO,SACf,WAAY,MAAA,CAChB,CACH,CACL,CAEO,SAASM,GAA2B,CAAE,KAAAR,EAAM,KAAAC,CAAA,EACnD,CACI,OAAO,IAAIQ,GAAU,CACjB,KAAAR,EACA,GAAGS,GAAoB,CACnB,SAAU,CACN,OAAQC,GACR,SAAUC,EAAA,EAEd,KAAM,CACFC,GACA,GAAGb,CAAA,CACP,CACH,CAAA,CACJ,CACL,CCjDO,IAAMc,GAAW,CACpB,KAAM,YACN,OAAQ,CACJ,OAAkB;;UAGlB,KAAgB;;SAAA,CAIxB,EAEaC,GAAa,CACtB,KAAM,YACN,OAAQ,CACJ,OAAkB;;UAGlB,KAAgB;;SAAA,CAIxB,ECpBA,IAAMC,GAAyD,CAAA,EAO/D,SAASC,GAAmBC,EAC5B,CACI,IAAMC,EAAM,CAAA,EAEZ,GAAID,IAAgB,EAEhBC,EAAI,KAAK,4DAA4D,EACrEA,EAAI,KAAK,qDAAqD,MAGlE,CACI,IAAIC,EAAe,EAEnB,QAASC,EAAI,EAAGA,EAAIH,EAAaG,IAE7BF,EAAI,KAAK,sBAAsBC,GAAc,sBAAsBC,EAAI,CAAC,oBAAoB,EAC5FF,EAAI,KAAK,sBAAsBC,GAAc,uBAAuBC,EAAI,CAAC,YAAY,CACzF,CAGG,OAAAF,EAAI,KAAK;CAAI,CACxB,CAEA,SAASG,GAAkBJ,EAC3B,CACI,IAAMC,EAAM,CAAA,EAEZ,GAAID,IAAgB,EAEhBC,EAAI,KAAK,iFAAiF,MAG9F,CACIA,EAAI,KAAK,qBAAqB,EAE9B,QAASE,EAAI,EAAGA,EAAIH,EAAaG,IAEzBA,IAAMH,EAAc,EAEpBC,EAAI,KAAK,aAAa,EAIlBA,EAAA,KAAK,UAAUE,CAAC,IAAI,EAE5BF,EAAI,KAAK,mDAAmDE,EAAI,CAAC,mBAAmBA,EAAI,CAAC,qBAAqB,EAC9GF,EAAI,KAAK,eAAe,EAG5BA,EAAI,KAAK,GAAG,CAAA,CAGT,OAAAA,EAAI,KAAK;CAAI,CACxB,CAEO,SAASI,GAAwBL,EACxC,CACQ,OAACF,GAAwBE,CAAW,IAEpCF,GAAwBE,CAAW,EAAI,CACnC,KAAM,oBACN,OAAQ,CACJ,OAAQ;;;cAIR,KAAM;;cAGN,IAAK;;;;;aAAA,EAOT,SAAU,CACN,OAAQ;;;kBAGND,GAAmBC,CAAW,CAAC;cAEjC,KAAM;;;;kBAIJI,GAAkBJ,CAAW,CAAC;aAAA,CAEpC,GAIDF,GAAwBE,CAAW,CAC9C,CAEA,IAAMM,GAAwD,CAAA,EAO9D,SAASC,GAAoBP,EAC7B,CACI,IAAMC,EAAM,CAAA,EAEZ,QAASE,EAAI,EAAGA,EAAIH,EAAaG,IAEzBA,EAAI,GAEJF,EAAI,KAAK,MAAM,EAGfE,EAAIH,EAAc,GAEdC,EAAA,KAAK,mBAAmBE,CAAC,KAAK,EAGtCF,EAAI,KAAK,GAAG,EACRA,EAAA,KAAK,iCAAkCE,CAAC,UAAU,EACtDF,EAAI,KAAK,GAAG,EAGT,OAAAA,EAAI,KAAK;CAAI,CACxB,CAEO,SAASO,GAA0BR,EAC1C,CACQ,OAACM,GAAuBN,CAAW,IAEnCM,GAAuBN,CAAW,EAAI,CAClC,KAAM,oBACN,OAAQ,CACJ,OAAQ;;;;cAKR,KAAM;;cAGN,IAAK;;;;;aAAA,EAOT,SAAU,CACN,OAAQ;;;8CAGsBA,CAAW;;cAGzC,KAAM;;kBAEJO,GAAoBP,CAAW,CAAC;aAAA,CAEtC,GAIDM,GAAuBN,CAAW,CAC7C,CC7KO,IAAMS,GAAiB,CAC1B,KAAM,mBACN,OAAQ,CACJ,OAAkB;;;;;SAAA,CAO1B,EAEaC,GAAmB,CAC5B,KAAM,mBACN,OAAQ,CACJ,OAAkB;;;;;SAAA,CAO1B,ECrBO,IAAMC,GAAuB,CAChC,MACA,MACA,YACA,YACA,YACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,cACA,YACA,YACA,WACJ,EAGaC,GAAoBD,GAAqB,OAAO,CAACE,EAAKC,KAE/DD,EAAIC,CAAI,EAAI,GAELD,GACR,CAAA,CAAoC,ECrBvB,SAAAE,GACZC,EACAC,EAEJ,CACI,OAAQD,EACR,CACI,IAAK,MACM,MAAA,GAEX,IAAK,YACM,OAAA,IAAI,aAAa,EAAIC,CAAI,EAEpC,IAAK,YACM,OAAA,IAAI,aAAa,EAAIA,CAAI,EAEpC,IAAK,YACM,OAAA,IAAI,aAAa,EAAIA,CAAI,EACpC,IAAK,cACD,OAAO,IAAI,aAAa,CAAC,EAAG,EACxB,EAAG,CAAA,CAAE,EAEb,IAAK,cACD,OAAO,IAAI,aAAa,CAAC,EAAG,EAAG,EAC3B,EAAG,EAAG,EACN,EAAG,EAAG,CAAA,CAAE,EAEhB,IAAK,cACD,OAAO,IAAI,aAAa,CAAC,EAAG,EAAG,EAAG,EAC9B,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,EACT,EAAG,EAAG,EAAG,CAAA,CAAE,CAAA,CAGhB,OAAA,IACX,CC2CO,IAAMC,GAAN,MAAMA,EACb,CAsDI,YAAYC,EAA6BC,EACzC,CA7CA,KAAO,SAAW,EAGF,KAAA,IAAcC,EAAI,SAAS,EAE3C,KAAO,cAAgB,eAEhB,KAAA,YAAcA,EAAI,UAAU,EAenC,KAAgB,eAAiB,GAMjC,KAAO,SAAW,EASlB,KAAgB,UAAY,GASxBD,EAAU,CAAE,GAAGF,GAAa,eAAgB,GAAGE,CAAQ,EAEvD,KAAK,kBAAoBD,EAEzB,IAAMG,EAAW,CAAA,EAEjB,QAAWC,KAAKJ,EAChB,CACU,IAAAK,EAAcL,EAAkBI,CAAC,EAKvC,GAHAC,EAAY,KAAOD,EACPC,EAAA,KAAOA,EAAY,MAAQ,EAEnC,CAACC,GAAkBD,EAAY,IAAI,EAG7B,MAAA,IAAI,MAAM,gBAAgBA,EAAY,IAAI,mDAAmDE,GAAqB,KAAK,IAAI,CAAC,EAAE,EAGxIF,EAAY,QAAZA,EAAY,MAAUG,GAAuBH,EAAY,KAAMA,EAAY,IAAI,GAEtEF,EAAAC,CAAC,EAAIC,EAAY,KAAA,CAG9B,KAAK,SAAWF,EAEhB,KAAK,SAAW,EAChB,KAAK,IAAMF,EAAQ,IACnB,KAAK,SAAWA,EAAQ,SAExB,KAAK,WAAaQ,GAAmB,OAAO,KAAKN,CAAQ,EAAE,IACtDC,GAAM,GAAGA,CAAC,IAAKJ,EAAkBI,CAAmC,EAAkB,IAAI,EAAA,EAC7F,KAAK,GAAG,EAAG,eAAe,CAAA,CAIzB,QACP,CACS,KAAA,UAAA,CAGb,EAlGaL,GAGK,eAAsC,CAEhD,IAAK,GAEL,SAAU,EACd,EARG,IAAMW,GAANX,GClFP,IAAMY,GAA8D,CAAA,EAQ7D,SAASC,GAA6BC,EAC7C,CACQ,IAAAC,EAA4BH,GAA8BE,CAAW,EAErE,GAAAC,EAAkC,OAAAA,EAEhC,IAAAC,EAAe,IAAI,WAAWF,CAAW,EAE/C,QAASG,EAAI,EAAGA,EAAIH,EAAaG,IAE7BD,EAAaC,CAAC,EAAIA,EAGtB,OAAAF,EAA4BH,GAA8BE,CAAW,EAAI,IAAII,GAAa,CACtF,UAAW,CAAE,MAAOF,EAAc,KAAM,MAAO,KAAMF,CAAY,CAAA,EAClE,CAAE,SAAU,EAAA,CAAM,EAEdC,CACX,CCqHO,IAAMI,GAAN,MAAMC,UAAeC,CAC5B,CA6CI,YAAYC,EACZ,CACU,MAAA,EA7CM,KAAA,IAAcC,EAAI,QAAQ,EAuBnC,KAAA,gBAAiE,OAAA,OAAO,IAAI,EACnF,KAAiB,iBAAgC,CAAA,EAwBzC,GAAA,CACA,WAAAC,EACA,UAAAC,EACA,OAAAC,EACA,UAAAC,EACA,oBAAAC,EACA,SAAAC,CAAA,EACAP,EAGJ,KAAK,WAAaE,EAClB,KAAK,UAAYC,EAEbG,IAAwB,SAEFA,EAAA,EAElBJ,IAAWI,GAAuBE,GAAa,QAC/CL,IAAUG,GAAuBE,GAAa,QAGtD,KAAK,oBAAsBF,EAE3B,IAAMG,EAAuC,CAAA,EAO7C,GALI,CAACJ,GAAa,CAACD,IAEfC,EAAY,CAAA,GAGZA,GAAaD,EAEP,MAAA,IAAI,MAAM,gDAAgD,EAE3D,GAAA,CAACF,GAAcE,GAAU,CAACG,EAEzB,MAAA,IAAI,MAAM,qFAAqF,EAEhG,GAAA,CAACL,GAAcE,GAAUG,EAE9B,QAAWG,KAAKH,EAED,QAAAI,KAAKJ,EAASG,CAAC,EAC1B,CACI,IAAME,EAAcL,EAASG,CAAC,EAAEC,CAAC,EAEjCF,EAASG,CAAW,EAAI,CACpB,MAAOF,EACP,QAASC,EACT,KAAMC,CAAA,CACV,SAIHV,GAAcE,GAAU,CAACG,EAClC,CACU,IAAAM,EAAYX,EAAW,iBAAiB,OAE9CK,EAAW,CAAA,EAEDM,EAAA,QAASC,GACnB,CACIP,EAASO,EAAK,KAAK,EAAIP,EAASO,EAAK,KAAK,GAAK,CAAA,EAC/CP,EAASO,EAAK,KAAK,EAAEA,EAAK,OAAO,EAAIA,EAAK,KAEjCL,EAAAK,EAAK,IAAI,EAAIA,CAAA,CACzB,CAAA,SAEIT,EACT,CACID,EAAS,CAAA,EACTG,EAAW,CAAA,EAEPL,GAEkBA,EAAW,iBAAiB,OAEpC,QAASY,GACnB,CACIP,EAASO,EAAK,KAAK,EAAIP,EAASO,EAAK,KAAK,GAAK,CAAA,EAC/CP,EAASO,EAAK,KAAK,EAAEA,EAAK,OAAO,EAAIA,EAAK,KAEjCL,EAAAK,EAAK,IAAI,EAAIA,CAAA,CACzB,EAGL,IAAIC,EAAW,EAEf,QAAWL,KAAKL,EAERI,EAASC,CAAC,IAGTN,EAAO,EAAE,IAEHA,EAAA,EAAE,EAAI,IAAIY,GACjB,KAAK,iBAAiB,KAAKZ,EAAO,EAAE,CAAC,GAKhCK,EAAAC,CAAC,EAAI,CAAE,MAAO,GAAI,QAASK,EAAU,KAAML,CAAE,EAEtDH,EAAS,EAAE,EAAIA,EAAS,EAAE,GAAK,CAAA,EACtBA,EAAA,EAAE,EAAEQ,CAAQ,EAAIL,EAEzBK,KAGJ,QAAWL,KAAKL,EAChB,CACI,IAAMY,EAAOP,EACTQ,EAAQb,EAAUK,CAAC,EAEnB,CAAEQ,EAAM,QAAW,CAAEA,EAAuB,gBAEpCA,EAAA,IAAIC,GAAaD,CAAK,GAG5B,IAAAJ,EAAOL,EAASQ,CAAI,EAEtBH,IAEKV,EAAOU,EAAK,KAAK,IAElBV,EAAOU,EAAK,KAAK,EAAI,IAAIE,GAEzB,KAAK,iBAAiB,KAAKZ,EAAOU,EAAK,KAAK,CAAC,GAGjDV,EAAOU,EAAK,KAAK,EAAE,YAAYI,EAAOJ,EAAK,OAAO,EACtD,CACJ,CAGJ,KAAK,OAASV,EACd,KAAK,gBAAkBG,EAEvB,KAAK,UAAY,KAAK,uBAAuBH,EAAQK,CAAQ,CAAA,CAU1D,YAAYQ,EAAcG,EAAoBC,EACrD,CAzVJ,IAAAC,EAAAC,GA0VaD,EAAA,KAAA,iBAALF,CAAA,IAAAE,EAAAF,CAAA,EAAqC,CAAA,IAEhCG,EAAA,KAAA,gBAAgBH,CAAU,GAA/BC,CAAgD,IAAAE,EAAAF,CAAA,EAAAJ,GAE3C,KAAK,OAAOG,CAAU,IAEvB,KAAK,OAAOA,CAAU,EAAI,IAAIJ,GAC9B,KAAK,iBAAiB,KAAK,KAAK,OAAOI,CAAU,CAAC,EACtD,CAGI,uBAAuBhB,EAAsBK,EACrD,CACI,IAAMe,EAAc,CAAA,EAEpB,QAAWd,KAAKD,EAChB,CACU,IAAAK,EAAOL,EAASC,CAAC,EAGhB,OAAA,eAAec,EAAaV,EAAK,KAAM,CAC1C,KACA,CACI,OAAOV,EAAOU,EAAK,KAAK,EAAE,YAAYA,EAAK,OAAO,CAAA,EAEtD,IAAII,EACJ,CACId,EAAOU,EAAK,KAAK,EAAE,YAAYI,EAAOJ,EAAK,OAAO,CAAA,CACtD,CACH,CAAA,CAGE,OAAAU,CAAA,CASJ,QAAQC,EAAkB,GACjC,CACS,KAAA,KAAK,UAAW,IAAI,EAErBA,IAEA,KAAK,YAAY,QAAQ,EACzB,KAAK,WAAW,QAAQ,GAG5B,KAAK,WAAa,KAClB,KAAK,UAAY,KAEjB,KAAK,mBAAmB,EAExB,KAAK,gBAAkB,KAElB,KAAA,iBAAiB,QAASC,GAC/B,CACIA,EAAU,QAAQ,CAAA,CACrB,EAEA,KAAK,iBAA4B,KAElC,KAAK,UAAY,KACjB,KAAK,OAAS,IAAA,CAUlB,OAAc,KAAK1B,EACnB,CACI,GAAM,CAAE,IAAA2B,EAAK,GAAAC,EAAI,GAAGC,CAAA,EAAS7B,EAEzBE,EACAC,EAEJ,OAAIwB,IAEazB,EAAA4B,GAAW,KAAKH,CAAG,GAGhCC,IAEYzB,EAAA4B,GAAU,KAAKH,CAAE,GAG1B,IAAI9B,EAAO,CACd,WAAAI,EACA,UAAAC,EACA,GAAG0B,CAAA,CACN,CAAA,CAET,EC7aO,IAAMG,GAAN,cAA4BC,EACnC,CACI,YAAYC,EACZ,CACI,IAAMC,EAAYC,GAA2B,CACzC,KAAM,QACN,KAAM,CACFC,GACAC,GAA0BJ,CAAW,EACrCK,EAAA,CACJ,CACH,EAEKC,EAAaC,GAA4B,CAC3C,KAAM,QACN,KAAM,CACFC,GACAC,GAAwBT,CAAW,EACnCU,EAAA,CACJ,CACH,EAEK,MAAA,CACF,UAAAT,EACA,WAAAK,EACA,UAAW,CACP,cAAeK,GAA6BX,CAAW,CAAA,CAC3D,CACH,CAAA,CAET,ECrCA,IAAIY,GAAwB,KAmDfC,GAAN,MAAMA,WAAuBC,EACpC,CADO,aAAA,CAAA,MAAA,GAAA,SAAA,EAUI,KAAA,SAAW,IAAIC,GACtB,KAAO,OAASH,KAAkBA,GAAgB,IAAII,GAAc,KAAK,WAAW,GAE7E,KAAA,KAAOH,GAAe,UAAU,KAGvC,KAAO,WAAa,CAAA,CAUb,eACHI,EACAC,EACAC,EACAC,EACAC,EAEJ,CACI,IAAMC,EAAqBD,GAAa,GAAOJ,EAAQ,YAAc,MAE/DM,EAAKN,EAAQ,UAEb,EAAIM,EAAG,EACPC,EAAID,EAAG,EACP,EAAIA,EAAG,EACPE,EAAIF,EAAG,EACPG,EAAKH,EAAG,GACRI,EAAKJ,EAAG,GAER,CAAE,UAAAK,EAAW,IAAAC,CAAA,EAAQZ,EAErBa,EAAOb,EAAQ,MAEfc,EAASd,EAAQ,gBACjBe,EAAMD,EAASd,EAAQ,cAE7B,QAASgB,EAAIF,EAAQE,EAAID,EAAKC,IAC9B,CACI,IAAMC,EAAKD,EAAI,EAETE,EAAIP,EAAUM,CAAE,EAChBE,GAAIR,EAAWM,EAAM,CAAC,EAE5BhB,EAAYE,GAAO,EAAK,EAAIe,EAAM,EAAIC,GAAKV,EAC3CR,EAAYE,GAAO,EAAKK,EAAIW,GAAMZ,EAAIW,EAAKR,EAE/BT,EAAAE,GAAO,EAAIS,EAAIK,CAAE,EAC7BhB,EAAYE,GAAO,EAAIS,EAAKK,EAAM,CAAC,EAEnCf,EAAWC,GAAO,EAAIU,EACtBX,EAAWC,GAAO,EAAIE,CAAA,CAC1B,CAWG,mBACHL,EACAC,EACAC,EACAC,EACAC,EAEJ,CACI,IAAMgB,EAAUpB,EAAQ,QAElBM,EAAKN,EAAQ,UAEb,EAAIM,EAAG,EACPC,EAAID,EAAG,EACP,EAAIA,EAAG,EACPE,EAAIF,EAAG,EACPG,EAAKH,EAAG,GACRI,EAAKJ,EAAG,GAERe,EAASrB,EAAQ,OAEjBsB,EAAKD,EAAO,KACZE,EAAKF,EAAO,KACZG,EAAKH,EAAO,KACZI,EAAKJ,EAAO,KAEZT,EAAMQ,EAAQ,IAIdP,EAAOb,EAAQ,MAEfK,EAAqBD,GAAa,GAAOJ,EAAQ,YAAc,MAErEC,EAAYE,EAAQ,CAAC,EAAK,EAAIoB,EAAO,EAAIE,EAAMhB,EAC/CR,EAAYE,EAAQ,CAAC,EAAKK,EAAIiB,EAAOlB,EAAIgB,EAAMb,EAEnCT,EAAAE,EAAQ,CAAC,EAAIS,EAAI,GACjBX,EAAAE,EAAQ,CAAC,EAAIS,EAAI,GAElBV,EAAAC,EAAQ,CAAC,EAAIU,EACbX,EAAAC,EAAQ,CAAC,EAAIE,EAGxBJ,EAAYE,EAAQ,CAAC,EAAK,EAAImB,EAAO,EAAIG,EAAMhB,EAC/CR,EAAYE,EAAQ,CAAC,EAAKK,EAAIiB,EAAOlB,EAAIe,EAAMZ,EAEnCT,EAAAE,EAAQ,CAAC,EAAIS,EAAI,GACjBX,EAAAE,EAAQ,CAAC,EAAIS,EAAI,GAElBV,EAAAC,EAAQ,EAAE,EAAIU,EACdX,EAAAC,EAAQ,EAAE,EAAIE,EAGzBJ,EAAYE,EAAQ,EAAE,EAAK,EAAImB,EAAO,EAAIE,EAAMf,EAChDR,EAAYE,EAAQ,EAAE,EAAKK,EAAIgB,EAAOjB,EAAIe,EAAMZ,EAEpCT,EAAAE,EAAQ,EAAE,EAAIS,EAAI,GAClBX,EAAAE,EAAQ,EAAE,EAAIS,EAAI,GAEnBV,EAAAC,EAAQ,EAAE,EAAIU,EACdX,EAAAC,EAAQ,EAAE,EAAIE,EAGzBJ,EAAYE,EAAQ,EAAE,EAAK,EAAIoB,EAAO,EAAIC,EAAMf,EAChDR,EAAYE,EAAQ,EAAE,EAAKK,EAAIgB,EAAOjB,EAAIgB,EAAMb,EAEpCT,EAAAE,EAAQ,EAAE,EAAIS,EAAI,GAClBX,EAAAE,EAAQ,EAAE,EAAIS,EAAI,GAEnBV,EAAAC,EAAQ,EAAE,EAAIU,EACdX,EAAAC,EAAQ,EAAE,EAAIE,CAAA,CAEjC,EAvJaT,GAGK,UAAY,CACtB,KAAM,CACF8B,EAAc,OAAA,EAElB,KAAM,SACV,EARG,IAAMC,GAAN/B,GC1DP,IAAMgC,GAAe,CACjB,OAAQ,EACR,IAAK,EACL,SAAU,EACV,OAAQ,EACR,QAAS,EACT,MAAO,EACP,aAAc,EACd,UAAW,EACX,aAAc,EACd,IAAK,EACL,IAAK,EACT,EACMC,GAAQ,EACRC,GAAS,EACTC,GAAU,EACVC,GAAa,EACbC,GAAU,EACVC,GAAa,EASNC,GAAN,MAAMA,EACb,CAWI,aACA,CACI,KAAK,KAAO,EAEZ,KAAK,UAAY,SACjB,KAAK,cAAgB,EAErB,KAAK,MAAQ,GACb,KAAK,UAAY,EAAA,CAOrB,IAAI,OACJ,CACI,MAAO,CAAC,EAAE,KAAK,KAAQ,GAAKN,GAAA,CAGhC,IAAI,MAAMO,EACV,CACQ,CAAC,EAAE,KAAK,KAAQ,GAAKP,MAAYO,IAEjC,KAAK,MAAS,GAAKP,GACvB,CAOJ,IAAI,SACJ,CACI,MAAO,CAAC,EAAE,KAAK,KAAQ,GAAKC,GAAA,CAGhC,IAAI,QAAQM,EACZ,CACQ,CAAC,EAAE,KAAK,KAAQ,GAAKN,MAAaM,IAElC,KAAK,MAAS,GAAKN,GACvB,CAIJ,IAAI,SAASM,EACb,CACI,GAAIA,IAAU,OACd,CACI,KAAK,QAAU,GAEf,MAAA,CAGJ,KAAK,QAAU,GACf,KAAK,mBAAqBA,IAAU,OAAA,CAGxC,IAAI,UACJ,CACQ,OAAC,KAAK,QAKH,KAAK,mBAAqB,QAAU,OAHhC,MAGgC,CAO/C,IAAI,SACJ,CACI,MAAO,CAAC,EAAE,KAAK,KAAQ,GAAKL,GAAA,CAGhC,IAAI,QAAQK,EACZ,CACQ,CAAC,EAAE,KAAK,KAAQ,GAAKL,MAAcK,IAEnC,KAAK,MAAS,GAAKL,GACvB,CAOJ,IAAI,WACJ,CACI,MAAO,CAAC,EAAE,KAAK,KAAQ,GAAKC,GAAA,CAGhC,IAAI,UAAUI,EACd,CACQ,CAAC,EAAE,KAAK,KAAQ,GAAKJ,MAAiBI,IAEtC,KAAK,MAAS,GAAKJ,GACvB,CAOJ,IAAI,WACJ,CACI,MAAO,CAAC,EAAE,KAAK,KAAQ,GAAKE,GAAA,CAGhC,IAAI,UAAUE,EACd,CACQ,CAAC,EAAE,KAAK,KAAQ,GAAKF,MAAiBE,IAEtC,KAAK,MAAS,GAAKF,GACvB,CAOJ,IAAI,oBACJ,CACI,MAAO,CAAC,EAAE,KAAK,KAAQ,GAAKD,GAAA,CAGhC,IAAI,mBAAmBG,EACvB,CACQ,CAAC,EAAE,KAAK,KAAQ,GAAKH,MAAcG,IAEnC,KAAK,MAAS,GAAKH,GACvB,CAQJ,IAAI,WACJ,CACI,OAAO,KAAK,UAAA,CAGhB,IAAI,UAAUG,EACd,CACI,KAAK,MAASA,IAAU,OACxB,KAAK,WAAaA,EACb,KAAA,aAAeR,GAAaQ,CAAkC,GAAK,CAAA,CAO5E,IAAI,eACJ,CACI,OAAO,KAAK,cAAA,CAGhB,IAAI,cAAcA,EAClB,CACS,KAAA,QAAU,CAAC,CAACA,EACjB,KAAK,eAAiBA,CAAA,CAInB,UACP,CACI,MAAO,iCACY,KAAK,SAAS,uBACL,KAAK,kBAAkB,YAClC,KAAK,OAAO,cACV,KAAK,SAAS,kBACV,KAAK,aAAa,GAAA,CAS7C,OAAc,OACd,CACU,IAAAC,EAAQ,IAAIF,GAElB,OAAAE,EAAM,UAAY,GAClBA,EAAM,MAAQ,GAEPA,CAAA,CAIf,EAjNaF,GAgNK,UAAYA,GAAM,MAAM,EAhNnC,IAAMG,GAANH,GCpBS,SAAAI,GAAoBC,EAAcC,EAAmBC,EACrE,CACU,IAAAC,GAAUH,GAAQ,GAAM,KAAQ,IAEtCC,EAAIC,GAAQ,GAAMF,EAAO,KAAQ,IAAOG,EACxCF,EAAIC,GAAQ,GAAOF,GAAQ,EAAK,KAAQ,IAAOG,EAC/CF,EAAIC,GAAQ,GAAOF,GAAQ,GAAM,KAAQ,IAAOG,EAChDF,EAAIC,GAAQ,EAAIC,CACpB,CCLO,IAAMC,GAAN,KACP,CADO,aAAA,CAEH,KAAO,YAAc,UACrB,KAAO,SAAqB,gBAG5B,KAAgB,cAAgB,EAChC,KAAgB,UAAY,EAC5B,KAAgB,WAAa,GAQ7B,KAAO,YAAqB,EAI5B,KAAO,gBAAkB,EACzB,KAAO,SAAoB,KAC3B,KAAO,OAAgB,IAAA,CAEvB,IAAI,WAAY,CAAE,OAAO,KAAK,WAAW,cAAA,CACzC,IAAI,OAAQ,CAAE,OAAO,KAAK,WAAW,eAAA,CAE9B,OACP,CACI,KAAK,WAAa,KAClB,KAAK,QAAU,KACf,KAAK,SAAW,KAChB,KAAK,OAAS,KACd,KAAK,OAAS,IAAA,CAEtB,EC/CO,IAAMC,GAAkB,CAC3B,KAAM,oBACN,OAAQ,CACJ,OAAkB;;;;;;;;;UAUlB,KAAgB;;;UAIhB,IAAe;;;;;SAAA,CAOvB,EAGaC,GAAwB,CACjC,GAAGD,GACH,OAAQ,CACJ,GAAGA,GAAgB,OAEnB,OAAQA,GAAgB,OAAO,OAAO,QAAQ,WAAY,UAAU,CAAA,CAE5E,EAEaE,GAAoB,CAC7B,KAAM,oBACN,OAAQ,CACJ,OAAkB;;;;;UAMlB,KAAgB;;;UAIhB,IAAe;;;;;SAAA,CAOvB",
  "names": ["require_eventemitter3", "__commonJSMin", "exports", "module", "has", "prefix", "Events", "EE", "fn", "context", "once", "addListener", "emitter", "event", "listener", "evt", "clearEvent", "EventEmitter", "names", "events", "name", "handlers", "i", "l", "ee", "listeners", "a1", "a2", "a3", "a4", "a5", "len", "args", "length", "j", "ExtensionType", "normalizeExtension", "ext", "normalizeExtensionPriority", "defaultPriority", "extensions", "type", "handlers", "queue", "onAdd", "onRemove", "addHandlers", "removeHandlers", "map", "extension", "item", "a", "b", "index", "list", "Target", "sources", "source", "import_index", "eventemitter3_default", "EventEmitter", "r", "t", "n", "e", "u", "a", "o", "i", "s", "h", "b", "g", "d", "f", "c", "l", "p", "v", "m", "y", "N", "x", "M", "r", "n", "c", "e", "H", "$", "j", "x", "o", "t", "u", "i", "a", "s", "d", "h", "w", "S", "k", "y", "names_default", "e", "f", "a", "d", "l", "i", "n", "o", "t", "b", "c", "u", "r", "k", "names_default", "_Color", "value", "value1", "value2", "type1", "v", "i", "keys1", "keys2", "key", "r", "g", "b", "a", "out", "alpha", "applyToRGB", "hexString", "alphaString", "int", "match", "color", "w", "min", "max", "Color", "cullingMixin", "PI_2", "RAD_TO_DEG", "DEG_TO_RAD", "Point", "_Point", "x", "y", "p", "tempPoint", "Matrix", "_Matrix", "a", "b", "c", "d", "tx", "ty", "array", "transpose", "out", "pos", "newPos", "Point", "x", "y", "id", "angle", "cos", "sin", "a1", "c1", "tx1", "matrix", "b1", "d1", "a2", "b2", "c2", "d2", "pivotX", "pivotY", "scaleX", "scaleY", "rotation", "skewX", "skewY", "transform", "pivot", "delta", "PI_2", "n", "identityMatrix", "tempMatrix", "ObservablePoint", "_ObservablePoint", "observer", "x", "y", "p", "value", "uidCache", "uid", "name", "warnings", "v8_0_0", "v8_3_4", "deprecation", "version", "message", "ignoreDepth", "stack", "Pool", "ClassType", "initialSize", "total", "i", "data", "item", "PoolGroupClass", "Class", "total", "data", "item", "ClassType", "Pool", "stats", "pool", "name", "BigPool", "cacheAsTextureMixin", "val", "deprecation", "removeItems", "arr", "startIdx", "removeCount", "length", "i", "len", "childrenHelperMixin", "beginIndex", "endIndex", "end", "range", "removed", "i", "child", "removeItems", "renderGroup", "index", "deprecation", "v8_0_0", "children", "currentIndex", "child2", "index1", "index2", "c", "childMat", "newMatrix", "collectRenderablesMixin", "instructionSet", "renderer", "currentLayer", "children", "length", "i", "renderPipes", "effect", "FilterEffect", "i", "MaskEffectManagerClass", "test", "item", "i", "BigPool", "effect", "MaskEffectManager", "extensions", "ExtensionType", "effectsMixin", "renderGroup", "effect", "a", "b", "index", "value", "MaskEffectManager", "options", "FilterEffect", "hasFilters", "hadFilters", "didChange", "findMixin", "deprecation", "v8_0_0", "value", "name", "deep", "label", "children", "i", "child", "found", "out", "tempPoints", "Point", "Rectangle", "_Rectangle", "x", "y", "width", "height", "bounds", "rectangle", "strokeWidth", "alignment", "_x", "_y", "strokeWidthOuter", "strokeWidthInner", "outerLeft", "outerRight", "outerTop", "outerBottom", "innerLeft", "innerRight", "innerTop", "innerBottom", "other", "transform", "x0", "y0", "x1", "y1", "lt", "lb", "rt", "rb", "s", "nx", "ny", "n00", "n10", "n01", "n11", "mx", "my", "m00", "m10", "m01", "m11", "paddingX", "paddingY", "x2", "y2", "resolution", "eps", "out", "defaultMatrix", "Matrix", "Bounds", "_Bounds", "minX", "minY", "maxX", "maxY", "Rectangle", "rectangle", "x0", "y0", "x1", "y1", "matrix", "a", "b", "c", "d", "tx", "ty", "x", "y", "rect", "bounds", "mask", "left", "right", "top", "bottom", "paddingX", "paddingY", "value", "width", "height", "vertexData", "beginOffset", "endOffset", "i", "localX", "localY", "matrixPool", "Pool", "Matrix", "boundsPool", "Bounds", "tempMatrix", "Matrix", "getFastGlobalBoundsMixin", "factorRenderLayers", "bounds", "Bounds", "renderGroup", "currentLayer", "localBounds", "manageEffects", "boundsPool", "viewBounds", "children", "i", "advanced", "getGlobalBounds", "target", "skipUpdateTransform", "bounds", "parentTransform", "pooledMatrix", "matrixPool", "updateTransformBackwards", "Matrix", "_getGlobalBounds", "worldTransform", "parentBounds", "preserveBounds", "boundsPool", "i", "parent", "multiplyHexColors", "color1", "color2", "r1", "g1", "b1", "r2", "g2", "b2", "r", "g", "b", "WHITE_BGR", "multiplyColors", "localBGRColor", "parentBGRColor", "multiplyHexColors", "bgr2rgb", "color", "getGlobalMixin", "skipUpdate", "alpha", "current", "matrix", "parentTransform", "updateTransformBackwards", "matrixPool", "multiplyColors", "parent", "warnCount", "maxWarnings", "warn", "args", "getLocalBounds", "target", "bounds", "relativeMatrix", "Matrix", "_getLocalBounds", "parentTransform", "rootContainer", "isRoot", "relativeTransform", "matrixPool", "localTransform", "parentBounds", "preserveBounds", "boundsPool", "children", "i", "checkChildrenDidChange", "container", "previousData", "children", "i", "child", "uid", "didChange", "index", "tempMatrix", "Matrix", "measureMixin", "value", "localWidth", "sign", "localHeight", "Bounds", "localBoundsCacheData", "checkChildrenDidChange", "getLocalBounds", "skipUpdate", "bounds", "getGlobalBounds", "onRenderMixin", "func", "renderGroup", "sortMixin", "value", "sortChildren", "a", "b", "toLocalGlobalMixin", "point", "Point", "skipUpdate", "position", "globalMatrix", "matrixPool", "from", "InstructionSet", "uid", "instruction", "nextPow2", "v", "isPow2", "definedProps", "obj", "result", "key", "idHash", "createResourceIdFromString", "value", "id", "uid", "_TextureStyle", "eventemitter3_default", "options", "deprecation", "v8_0_0", "bigKey", "TextureStyle", "_TextureSource", "eventemitter3_default", "options", "uid", "TextureStyle", "definedProps", "value", "resolution", "resource", "width", "height", "newPixelWidth", "newPixelHeight", "isPow2", "_resource", "TextureSource", "ux", "uy", "vx", "vy", "rotationCayley", "rotationMatrices", "signum", "init", "row", "j", "_ux", "_uy", "_vx", "_vy", "k", "mat", "Matrix", "groupD8", "ind", "rotation", "rotationSecond", "rotationFirst", "dx", "dy", "matrix", "tx", "ty", "NOOP", "BufferImageSource", "TextureSource", "options", "buffer", "format", "resource", "ExtensionType", "tempMat", "Matrix", "TextureMatrix", "texture", "clampMargin", "value", "uvs", "out", "mat", "i", "x", "y", "tex", "orig", "trim", "texBase", "frame", "margin", "offset", "Texture", "eventemitter3_default", "source", "label", "frame", "orig", "trim", "defaultAnchor", "defaultBorders", "rotate", "dynamic", "uid", "Rectangle", "TextureSource", "width", "height", "value", "TextureMatrix", "uvs", "nX", "nY", "nW", "nH", "w2", "h2", "cX", "cY", "groupD8", "destroySource", "deprecation", "v8_0_0", "NOOP", "BufferImageSource", "count", "TexturePoolClass", "textureOptions", "pixelWidth", "pixelHeight", "antialias", "textureSource", "TextureSource", "Texture", "frameWidth", "frameHeight", "resolution", "po2Width", "po2Height", "nextPow2", "key", "texture", "source", "renderTexture", "destroyTextures", "i", "textures", "j", "TexturePool", "RenderGroup", "Matrix", "InstructionSet", "root", "children", "i", "child", "options", "TexturePool", "childrenAtDepth", "renderGroupChild", "index", "childrenToUpdate", "renderable", "container", "renderer", "out", "parentCacheAsTexture", "assignWithIgnore", "target", "options", "ignore", "key", "defaultSkew", "ObservablePoint", "defaultPivot", "defaultScale", "UPDATE_COLOR", "UPDATE_BLEND", "UPDATE_VISIBLE", "Container", "_Container", "eventemitter3_default", "options", "uid", "Matrix", "ObservablePoint", "defaultScale", "defaultPivot", "defaultSkew", "assignWithIgnore", "child", "source", "deprecation", "extensions", "value", "children", "v8_0_0", "i", "renderGroup", "index", "point", "parentRenderGroup", "BigPool", "RenderGroup", "RAD_TO_DEG", "DEG_TO_RAD", "localWidth", "localHeight", "out", "bounds", "height", "size", "rotation", "skew", "opts", "matrix", "localTransformChangeId", "lt", "scale", "pivot", "position", "sx", "sy", "px", "py", "UPDATE_COLOR", "bgr", "Color", "bgr2rgb", "UPDATE_BLEND", "valueNumber", "UPDATE_VISIBLE", "oldChildren", "childrenHelperMixin", "getFastGlobalBoundsMixin", "toLocalGlobalMixin", "onRenderMixin", "measureMixin", "effectsMixin", "findMixin", "sortMixin", "cullingMixin", "cacheAsTextureMixin", "getGlobalMixin", "collectRenderablesMixin", "RendererType", "UPDATE_PRIORITY", "TickerListener", "fn", "context", "priority", "once", "ticker", "redirect", "previous", "hard", "_Ticker", "TickerListener", "time", "fn", "context", "priority", "UPDATE_PRIORITY", "listener", "current", "previous", "count", "currentTime", "elapsedMS", "delta", "head", "fps", "minFPS", "minFPMS", "maxFPS", "shared", "system", "Ticker", "ViewContainer", "Container", "options", "Bounds", "value", "point", "bounds", "x", "y", "renderGroup", "instructionSet", "renderer", "currentLayer", "renderPipes", "renderableGC", "children", "length", "i", "BrowserAdapter", "width", "height", "canvas", "url", "options", "xml", "currentAdapter", "BrowserAdapter", "DOMAdapter", "adapter", "updateQuadBounds", "bounds", "anchor", "texture", "width", "height", "trim", "sourceWidth", "sourceHeight", "Sprite", "_Sprite", "ViewContainer", "options", "Texture", "texture", "anchor", "roundPixels", "width", "height", "rest", "ObservablePoint", "source", "skipCache", "value", "currentTexture", "updateQuadBounds", "deprecation", "bounds", "destroyTextureSource", "out", "CanvasSource", "TextureSource", "options", "DOMAdapter", "width", "height", "resolution", "didResize", "resource", "ExtensionType", "BindGroup", "resources", "index", "i", "resource", "keyParts", "currentResource", "tick", "context", "getTestContext", "DOMAdapter", "fragTemplate", "generateIfTestSrc", "maxIfs", "src", "i", "checkMaxIfStatementsInShader", "gl", "shader", "fragmentSrc", "maxTexturesPerBatchCache", "getMaxTexturesPerBatch", "gl", "getTestContext", "checkMaxIfStatementsInShader", "ViewableBuffer", "sizeOrBuffer", "type", "fastCopy", "sourceBuffer", "destinationBuffer", "lengthDouble", "sourceFloat64View", "remainingBytes", "sourceUint8View", "BLEND_TO_NPM", "STENCIL_MODES", "getAdjustedBlendModeBlend", "blendMode", "textureSource", "BLEND_TO_NPM", "BatchTextureArray", "i", "t", "Batch", "BatchTextureArray", "batchPool", "batchPoolIndex", "getBatchFromPool", "returnBatchToPool", "batch", "BATCH_TICK", "_Batcher", "options", "uid", "getMaxTexturesPerBatch", "maxTextures", "attributesInitialSize", "indicesInitialSize", "ViewableBuffer", "i", "batchableObject", "texture", "textureId", "attributeBuffer", "instructionSet", "elements", "textureBatch", "firstElement", "blendMode", "getAdjustedBlendModeBlend", "topology", "f32", "u32", "indexBuffer", "size", "start", "action", "element", "source", "adjustedBlendMode", "breakRequired", "indexStart", "indexSize", "newSize", "newArrayBuffer", "fastCopy", "newIndexBuffer", "index", "indicesOffset", "indices", "indexOffset", "attributeOffset", "Batcher", "BufferUsage", "Buffer", "eventemitter3_default", "options", "data", "size", "usage", "label", "shrinkToFit", "uid", "mappedAtCreation", "value", "BufferUsage", "syncGPU", "oldData", "sizeInBytes", "ensureIsBuffer", "buffer", "index", "Buffer", "usage", "BufferUsage", "getGeometryBounds", "geometry", "attributeId", "bounds", "attribute", "data", "minX", "minY", "maxX", "maxY", "byteSize", "offset", "stride", "i", "x", "y", "ensureIsAttribute", "attribute", "Buffer", "ensureIsBuffer", "Geometry", "eventemitter3_default", "options", "uid", "Bounds", "attributes", "indexBuffer", "topology", "i", "id", "name", "attributeOption", "getGeometryBounds", "destroyBuffers", "buffer", "placeHolderBufferData", "placeHolderIndexData", "BatchGeometry", "Geometry", "attributeBuffer", "Buffer", "BufferUsage", "indexBuffer", "stride", "idCounts", "idHash", "createIdFromString", "value", "groupId", "id", "maxFragmentPrecision", "getMaxFragmentPrecision", "gl", "getTestContext", "addProgramDefines", "src", "isES300", "isFragment", "ensurePrecision", "src", "options", "isFragment", "maxSupportedPrecision", "precision", "insertVersion", "src", "isES300", "fragmentNameCache", "VertexNameCache", "setProgramName", "src", "name", "isFragment", "nameCache", "stripVersion", "src", "isES300", "processes", "stripVersion", "ensurePrecision", "addProgramDefines", "setProgramName", "insertVersion", "programCache", "_GlProgram", "options", "isES300", "preprocessorOptions", "getMaxFragmentPrecision", "fragment", "vertex", "processKey", "processOptions", "createIdFromString", "key", "GlProgram", "attributeFormatData", "getAttributeInfoFromFormat", "format", "WGSL_TO_VERTEX_TYPES", "extractAttributesFromGpuProgram", "source", "entryPoint", "results", "mainVertStart", "arrowFunctionStart", "functionArgsSubstring", "inputsRegex", "match", "format", "getAttributeInfoFromFormat", "extractStructAndGroups", "wgsl", "linePattern", "groupPattern", "bindingPattern", "namePattern", "typePattern", "structPattern", "structMemberPattern", "structName", "groups", "item", "structs", "struct", "name", "members", "acc", "member", "type", "group", "ShaderStage", "generateGpuLayoutGroups", "groups", "layout", "i", "group", "ShaderStage", "generateLayoutHash", "groups", "layout", "i", "group", "removeStructAndGroupDuplicates", "vertexStructsAndGroups", "fragmentStructsAndGroups", "structNameSet", "dupeGroupKeySet", "structs", "struct", "groups", "group", "key", "programCache", "GpuProgram", "_GpuProgram", "options", "fragment", "vertex", "layout", "gpuLayout", "name", "structsAndGroups", "extractStructAndGroups", "vertexStructsAndGroups", "fragmentStructsAndGroups", "removeStructAndGroupDuplicates", "generateLayoutHash", "generateGpuLayoutGroups", "bigKey", "createIdFromString", "extractAttributesFromGpuProgram", "key", "addBits", "srcParts", "parts", "name", "i", "id", "part", "sanitisedPart", "warn", "findHooksRx", "compileHooks", "programSrc", "parts", "hook", "extractInputs", "fragmentSource", "out", "match", "regex", "compileInputs", "fragments", "template", "sort", "results", "fragment", "mainInput", "finalString", "inValue", "i", "cleanedString", "extractOutputs", "fragmentSource", "out", "match", "regex", "extractVariableName", "value", "stripVariable", "compileOutputs", "fragments", "template", "results", "fragment", "index", "mainStruct", "inValue", "mainStart", "mainEnd", "compiledCode", "injectBits", "templateSrc", "fragmentParts", "out", "i", "parts", "cacheMap", "bitCacheMap", "CACHE_UID", "compileHighShader", "template", "bits", "cacheId", "generateCacheId", "vertex", "fragment", "compileInputsAndOutputs", "compileBits", "compileHighShaderGl", "vertexFragments", "shaderBit", "v", "fragmentFragments", "compiledVertex", "compileInputs", "compileOutputs", "compiledFragment", "highFragment", "a", "b", "vertexParts", "compileHooks", "fragmentParts", "addBits", "injectBits", "vertexGPUTemplate", "fragmentGPUTemplate", "vertexGlTemplate", "fragmentGlTemplate", "globalUniformsBit", "globalUniformsBitGl", "compileHighShaderGpuProgram", "bits", "name", "source", "compileHighShader", "fragmentGPUTemplate", "vertexGPUTemplate", "globalUniformsBit", "GpuProgram", "compileHighShaderGlProgram", "GlProgram", "compileHighShaderGl", "vertexGlTemplate", "fragmentGlTemplate", "globalUniformsBitGl", "colorBit", "colorBitGl", "textureBatchBitGpuCache", "generateBindingSrc", "maxTextures", "src", "bindingIndex", "i", "generateSampleSrc", "generateTextureBatchBit", "textureBatchBitGlCache", "generateSampleGlSrc", "generateTextureBatchBitGl", "roundPixelsBit", "roundPixelsBitGl", "UNIFORM_TYPES_VALUES", "UNIFORM_TYPES_MAP", "acc", "type", "getDefaultUniformValue", "type", "size", "_UniformGroup", "uniformStructures", "options", "uid", "uniforms", "i", "uniformData", "UNIFORM_TYPES_MAP", "UNIFORM_TYPES_VALUES", "getDefaultUniformValue", "createIdFromString", "UniformGroup", "batchSamplersUniformGroupHash", "getBatchSamplersUniformGroup", "maxTextures", "batchSamplersUniformGroup", "sampleValues", "i", "UniformGroup", "Shader", "_Shader", "eventemitter3_default", "options", "uid", "gpuProgram", "glProgram", "groups", "resources", "compatibleRenderers", "groupMap", "RendererType", "nameHash", "i", "j", "uniformName", "groupData", "data", "bindTick", "BindGroup", "name", "value", "UniformGroup", "groupIndex", "bindIndex", "_a", "_b", "uniformsOut", "destroyPrograms", "bindGroup", "gpu", "gl", "rest", "GpuProgram", "GlProgram", "DefaultShader", "Shader", "maxTextures", "glProgram", "compileHighShaderGlProgram", "colorBitGl", "generateTextureBatchBitGl", "roundPixelsBitGl", "gpuProgram", "compileHighShaderGpuProgram", "colorBit", "generateTextureBatchBit", "roundPixelsBit", "getBatchSamplersUniformGroup", "defaultShader", "_DefaultBatcher", "Batcher", "BatchGeometry", "DefaultShader", "element", "float32View", "uint32View", "index", "textureId", "textureIdAndRound", "wt", "b", "d", "tx", "ty", "positions", "uvs", "argb", "offset", "end", "i", "i2", "x", "y", "texture", "bounds", "w0", "w1", "h0", "h1", "ExtensionType", "DefaultBatcher", "blendModeIds", "BLEND", "OFFSET", "CULLING", "DEPTH_TEST", "WINDING", "DEPTH_MASK", "_State", "value", "state", "State", "color32BitToUniform", "abgr", "out", "offset", "alpha", "BatchableSprite", "localUniformBit", "localUniformBitGroup2", "localUniformBitGl"]
}
