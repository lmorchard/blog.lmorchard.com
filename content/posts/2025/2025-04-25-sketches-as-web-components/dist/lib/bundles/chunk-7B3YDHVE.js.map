{
  "version": 3,
  "sources": ["../../../node_modules/pixi.js/src/rendering/batcher/gpu/getTextureBatchBindGroup.ts", "../../../node_modules/pixi.js/src/rendering/renderers/shared/texture/CanvasPool.ts"],
  "sourcesContent": ["import { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport { Texture } from '../../renderers/shared/texture/Texture';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures';\n\nimport type { TextureSource } from '../../renderers/shared/texture/sources/TextureSource';\n\nconst cachedGroups: Record<number, BindGroup> = {};\n\nexport function getTextureBatchBindGroup(textures: TextureSource[], size: number)\n{\n    let uid = 2166136261; // FNV-1a 32-bit offset basis\n\n    for (let i = 0; i < size; i++)\n    {\n        uid ^= textures[i].uid;\n        uid = Math.imul(uid, 16777619);\n        uid >>>= 0;\n    }\n\n    return cachedGroups[uid] || generateTextureBatchBindGroup(textures, size, uid);\n}\n\nlet maxTextures = 0;\n\nfunction generateTextureBatchBindGroup(textures: TextureSource[], size: number, key: number): BindGroup\n{\n    const bindGroupResources: Record<string, any> = {};\n\n    let bindIndex = 0;\n\n    if (!maxTextures)maxTextures = getMaxTexturesPerBatch();\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        const texture = i < size ? textures[i] : Texture.EMPTY.source;\n\n        bindGroupResources[bindIndex++] = texture.source;\n        bindGroupResources[bindIndex++] = texture.style;\n    }\n\n    // pad out with empty textures\n    const bindGroup = new BindGroup(bindGroupResources);\n\n    cachedGroups[key] = bindGroup;\n\n    return bindGroup;\n}\n\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { nextPow2 } from '../../../../maths/misc/pow2';\n\nimport type { ICanvas, ICanvasRenderingContext2DSettings } from '../../../../environment/canvas/ICanvas';\nimport type { ICanvasRenderingContext2D } from '../../../../environment/canvas/ICanvasRenderingContext2D';\n\nexport interface CanvasAndContext\n{\n    canvas: ICanvas;\n    context: ICanvasRenderingContext2D;\n}\n\n/**\n * Texture pool, used by FilterSystem and plugins.\n *\n * Stores collection of temporary pow2 or screen-sized renderTextures\n *\n * If you use custom RenderTexturePool for your filters, you can use methods\n * `getFilterTexture` and `returnFilterTexture` same as in\n * @name CanvasPool\n * @memberof rendering\n */\nexport class CanvasPoolClass\n{\n    public canvasOptions: ICanvasRenderingContext2DSettings;\n\n    /**\n     * Allow renderTextures of the same size as screen, not just pow2\n     *\n     * Automatically sets to true after `setScreenSize`\n     * @default false\n     */\n    public enableFullScreen: boolean;\n    private _canvasPool: {[x in string | number]: CanvasAndContext[]};\n\n    constructor(canvasOptions?: ICanvasRenderingContext2DSettings)\n    {\n        this._canvasPool = Object.create(null);\n        this.canvasOptions = canvasOptions || {};\n        this.enableFullScreen = false;\n    }\n\n    /**\n     * Creates texture with params that were specified in pool constructor.\n     * @param pixelWidth - Width of texture in pixels.\n     * @param pixelHeight - Height of texture in pixels.\n     */\n    private _createCanvasAndContext(pixelWidth: number, pixelHeight: number): CanvasAndContext\n    {\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = pixelWidth;\n        canvas.height = pixelHeight;\n\n        const context = canvas.getContext('2d');\n\n        return { canvas, context };\n    }\n\n    /**\n     * Gets a Power-of-Two render texture or fullScreen texture\n     * @param minWidth - The minimum width of the render texture.\n     * @param minHeight - The minimum height of the render texture.\n     * @param resolution - The resolution of the render texture.\n     * @returns The new render texture.\n     */\n    public getOptimalCanvasAndContext(minWidth: number, minHeight: number, resolution = 1): CanvasAndContext\n    {\n        minWidth = Math.ceil((minWidth * resolution) - 1e-6);\n        minHeight = Math.ceil((minHeight * resolution) - 1e-6);\n        minWidth = nextPow2(minWidth);\n        minHeight = nextPow2(minHeight);\n\n        const key = (minWidth << 17) + (minHeight << 1);\n\n        if (!this._canvasPool[key])\n        {\n            this._canvasPool[key] = [];\n        }\n\n        let canvasAndContext = this._canvasPool[key].pop();\n\n        if (!canvasAndContext)\n        {\n            canvasAndContext = this._createCanvasAndContext(minWidth, minHeight);\n        }\n\n        return canvasAndContext;\n    }\n\n    /**\n     * Place a render texture back into the pool.\n     * @param canvasAndContext\n     */\n    public returnCanvasAndContext(canvasAndContext: CanvasAndContext): void\n    {\n        const canvas = canvasAndContext.canvas;\n        const { width, height } = canvas;\n\n        const key = (width << 17) + (height << 1);\n\n        canvasAndContext.context.clearRect(0, 0, width, height);\n\n        this._canvasPool[key].push(canvasAndContext);\n    }\n\n    public clear(): void\n    {\n        this._canvasPool = {};\n    }\n}\n\nexport const CanvasPool = new CanvasPoolClass();\n"],
  "mappings": "oEAMA,IAAMA,EAA0C,CAAA,EAEhC,SAAAC,EAAyBC,EAA2BC,EACpE,CACI,IAAIC,EAAM,WAEV,QAASC,EAAI,EAAGA,EAAIF,EAAME,IAEfD,GAAAF,EAASG,CAAC,EAAE,IACbD,EAAA,KAAK,KAAKA,EAAK,QAAQ,EACpBA,KAAA,EAGb,OAAOJ,EAAaI,CAAG,GAAKE,EAA8BJ,EAAUC,EAAMC,CAAG,CACjF,CAEA,IAAIG,EAAc,EAElB,SAASD,EAA8BJ,EAA2BC,EAAcK,EAChF,CACI,IAAMC,EAA0C,CAAA,EAE5CC,EAAY,EAEXH,IAAYA,EAAcI,EAAuB,GAEtD,QAASN,EAAI,EAAGA,EAAIE,EAAaF,IACjC,CACI,IAAMO,EAAUP,EAAIF,EAAOD,EAASG,CAAC,EAAIQ,EAAQ,MAAM,OAEpCJ,EAAAC,GAAW,EAAIE,EAAQ,OACvBH,EAAAC,GAAW,EAAIE,EAAQ,KAAA,CAIxC,IAAAE,EAAY,IAAIC,EAAUN,CAAkB,EAElD,OAAAT,EAAaQ,CAAG,EAAIM,EAEbA,CACX,CCxBO,IAAME,EAAN,KACP,CAYI,YAAYC,EACZ,CACS,KAAA,YAAqB,OAAA,OAAO,IAAI,EAChC,KAAA,cAAgBA,GAAiB,CAAA,EACtC,KAAK,iBAAmB,EAAA,CAQpB,wBAAwBC,EAAoBC,EACpD,CACI,IAAMC,EAASC,EAAW,IAAI,EAAE,aAAa,EAE7CD,EAAO,MAAQF,EACfE,EAAO,OAASD,EAEV,IAAAG,EAAUF,EAAO,WAAW,IAAI,EAE/B,MAAA,CAAE,OAAAA,EAAQ,QAAAE,CAAQ,CAAA,CAUtB,2BAA2BC,EAAkBC,EAAmBC,EAAa,EACpF,CACIF,EAAW,KAAK,KAAMA,EAAWE,EAAc,IAAI,EACnDD,EAAY,KAAK,KAAMA,EAAYC,EAAc,IAAI,EACrDF,EAAWG,EAASH,CAAQ,EAC5BC,EAAYE,EAASF,CAAS,EAExB,IAAAG,GAAOJ,GAAY,KAAOC,GAAa,GAExC,KAAK,YAAYG,CAAG,IAEhB,KAAA,YAAYA,CAAG,EAAI,CAAA,GAG5B,IAAIC,EAAmB,KAAK,YAAYD,CAAG,EAAE,IAAI,EAEjD,OAAKC,IAEkBA,EAAA,KAAK,wBAAwBL,EAAUC,CAAS,GAGhEI,CAAA,CAOJ,uBAAuBA,EAC9B,CACI,IAAMR,EAASQ,EAAiB,OAC1B,CAAE,MAAAC,EAAO,OAAAC,CAAA,EAAWV,EAEpBO,GAAOE,GAAS,KAAOC,GAAU,GAEvCF,EAAiB,QAAQ,UAAU,EAAG,EAAGC,EAAOC,CAAM,EAEtD,KAAK,YAAYH,CAAG,EAAE,KAAKC,CAAgB,CAAA,CAGxC,OACP,CACI,KAAK,YAAc,CAAA,CAAC,CAE5B,EAEaG,EAAa,IAAIf",
  "names": ["cachedGroups", "getTextureBatchBindGroup", "textures", "size", "uid", "i", "generateTextureBatchBindGroup", "maxTextures", "key", "bindGroupResources", "bindIndex", "getMaxTexturesPerBatch", "texture", "Texture", "bindGroup", "BindGroup", "CanvasPoolClass", "canvasOptions", "pixelWidth", "pixelHeight", "canvas", "DOMAdapter", "context", "minWidth", "minHeight", "resolution", "nextPow2", "key", "canvasAndContext", "width", "height", "CanvasPool"]
}
