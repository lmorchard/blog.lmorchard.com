8<--- { "draft": true, "title": "Miscellanea for 2025-12-19", "time": "23:59:00-07:00", "type": "miscellanea", "slug": "miscellanea", "tags": [ "miscellanea" ] }

- Hello world!

8<--- { "draft": true, "type": "entry", "title": "2025-12-19 @ 12:53:37", "slug": "", "tags": [ "" ], "time": "12:53:37-07:00" }

David Celis says "[Writing Code Is Fun](https://davidcel.is/articles/writing-code-is-fun)":

> I became a software engineer because writing code is fun. Thinking through hard problems, designing elegant solutions, seeing the things you've built working for the first time… these moments are all deeply satisfying, so why in the world would I ever surrender them to AI?

It's not really a secret that I've been spending a lot of time [using LLMs to generate code](https://blog.lmorchard.com/tag/codegen/) this year. My job and the industry at large has pushed for it—and [I don't feel like I can afford to just opt out](https://blog.lmorchard.com/2025/06/18/ai-anger-way-forward/). The thing is, though—and I feel like this is hugely looked down upon by folks I respect—this has been a fun and gratifying experience for me.

I haven't tried to be _too_ loud about this. These are tools, I pay for a subscription, and I'm trying [to be normal](https://www.anildash.com/2025/10/17/the-majority-ai-view/) about them. But I've had a hunch growing that code generation is highlighting a divide in how computer touchers approach software development.

In college, I remember seeing this divide in my computer science and math classes. Some of us were really jazzed to dig into proofs and algorithms for their own sakes. Some of us (like me) were only turned on by practical application. Linear algebra sticks out: roughly half the class aced tests on theorems and proofs, whereas I only really absorbed things like matrix multiplication when I understood how it could rotate shapes in 3D space—i.e. for graphics in video games.

This isn't a hard divide—more a Venn diagram, a shift in where the focus of craft and puzzle-solving is directed. Some folks smile at a Lisp or enjoy the tasteful syntax of Ruby and how it results in more poetic code. They might enjoy a Zachtronics game like [EXAPUNKS](https://www.zachtronics.com/exapunks/) where you compete to code-golf little robots into completing tasks with minimal cycles. Other folks see code as a means to an end—they smile at grungy Rube Goldberg assemblages of Unix pipes that get a job done, or lose themselves in [Factorio](https://www.factorio.com/) plugging things into other things to make things.

All of this is to say: I became a software engineer because making computers do things is fun. Writing code is just a means to that end. It's been that way since I was 7 years old and first delved into 6502 assembly on a Commodore 64—I didn't particularly appreciate elegance, I just liked that assembly drew lines in high-resolution graphics way faster than BASIC. (Again, video games.)

While I do have a great appreciation for elegance and clean code, my day-to-day focus is on what that enables. Does it keep our work humming along? Can we sleep better at night with fewer things breaking? I'm just as happy to see something less-than-Platonically-ideal ship to production if it does the job as an ongoing concern.

In my experience, using AI coding tools _has_ helped me move faster. They've also helped me move _at all_, in cases where I might not have started after facing down the mental cost of task initiation.

[Simon Willison has written a lot about this](https://simonwillison.net/2023/Mar/27/ai-enhanced-development/) from a practical perspective with which I agree:

> The thing I'm most excited about in our weird new AI-enhanced reality is the way it allows me to be more _ambitious_ with my projects.
> 
> As an experienced developer, ChatGPT (and GitHub Copilot) save me an enormous amount of "figuring things out" time. For everything from writing a for loop in Bash to remembering how to make a cross-domain CORS request in JavaScript—I don't need to even look things up any more, I can just prompt it and get the right answer 80% of the time.
> 
> This doesn't just make me more productive: it lowers my bar for when a project is worth investing time in at all.

Lately, with Claude's help, I've spun up a few tools that sat on my wishlist for years—things like [codenamer](https://github.com/lmorchard/codenamer) for generating project names, [feed-to-mastodon](https://github.com/lmorchard/feed-to-mastodon) for cross-posting, and various utilities for exporting my bookmarks and posts to Markdown.

I've also resumed work on older projects where I'd simply run out of energy, like [fossilizer](https://github.com/lmorchard/fossilizer) and [this blog itself](https://github.com/lmorchard/blog.lmorchard.com). In each case, writing the code was way less fun for me than having the end result working.

But AI coding tools have also been a forcing function on other aspects of development: where before I might dive right into riffing in code, I now spend more time writing prose—describing what I want to build, refining documentation.

I also spend more time setting up testing, linting, and automated quality controls. It turns out you can integrate all of these tightly into a code-generating agent's loop, and they serve as guardrails that help course-correct the spicy autocomplete as it does the needful.

I like making computers do things. I also like making them do things so I don't have to, because I am very lazy. But I also like ensuring they do things well and reliably, because I am also very tired. My experience with AI coding tools is that they've helped me be lazy and tired and still get a lot done. And that's fun for me.
