8<--- { "draft": true, "title": "Miscellanea for 2025-12-19", "time": "23:59:00-07:00", "type": "miscellanea", "slug": "miscellanea", "tags": [ "miscellanea" ] }

- Hello world!

8<--- { "draft": true, "type": "entry", "title": "2025-12-19 @ 12:53:37", "slug": "", "tags": [ "" ], "time": "12:53:37-07:00" }

David Celis says "[Writing Code Is Fun](https://davidcel.is/articles/writing-code-is-fun)":

> I became a software engineer because writing code is fun. Thinking through hard problems, designing elegant solutions, seeing the things you’ve built working for the first time… these moments are all deeply satisfying, so why in the world would I ever surrender them to AI? 

It's not really a secret that I've been spending a lot of time [using LLMs to generate code](https://blog.lmorchard.com/tag/codegen/), this year. My job and the industry at large has pushed for it—and [I don't feel like I can afford to just opt out](https://blog.lmorchard.com/2025/06/18/ai-anger-way-forward/). The thing is, though—and I feel like this is hugely looked down upon by folks I respect—this has been a fun and gratifying experience for me. 

So, I haven't tried to be *too* loud about this. And it's not like Anthropic or Google or OpenAI are tossing me affiliate kickbacks to shill for them. These are tools, I pay for a subscription, and I'm [trying to be normal about them](https://www.anildash.com/2025/10/17/the-majority-ai-view/). It's like grabbing a Makita or Dewalt cordless drill. (Although there's plenty of folks [not being normal](https://www.youtube.com/watch?v=5ui9FfxFDoA) about *that*.)

Anyway, public shaming and tech normality aside, I've had a hunch growing that this code-geneneration stuff is highlighting a divide between how computer touchers approach software development.

In one group, we have folks for whom, yes, writing code is fun. These might be folks who smile at a Lisp or a Haskell or enjoy the tasteful syntax elision of Ruby and how it results in more poetic code. They might also enjoy a Zachtronics game like [EXAPUNKS](https://www.zachtronics.com/exapunks/) where you can compete globally to [code golf](https://en.wikipedia.org/wiki/Code_golf) down the the least cycles spent making little robots complete tasks.

Then, in another group, we have folks who like to make the computer do things. These folks see code as a means to an end. They might smile at complex assemblies of Unix commands piped into each other, at grungy Rube Goldberg assemblages of components that get a job done. They might enjoy a game like [Factorio](https://www.factorio.com/) where you plug things into other things to make things.

In college, I remember seeing a divide in my computer science and math classes. Some of us were really jazzed to dig into proofs and algorithms for their own sakes. Some of us (like me) were only turned on by practical application. 

Linear algebra sticks out for me as a particular example: Roughly half of the class aced tests on theorems and proofs—whereas I and a handful of other students only really absorbed things like matrix multiplication when we understood how it could be used to rotate shapes in 3D space (i.e. for video games).

These aren't opposed or even fully distinct groups, I don't think. This is a Venn diagram. Maybe less a divide and more a shift in where the focus of craft and puzzle solving is directed?

All of this is to say, I became a software engineer because making computers do things is fun. For me, writing code is just a means to that end. It's been that way since I was 7 years old and first delved into 6502 assembly on a Commodore 64—I didn't particularly appreciate elegance, I just liked that assembly drew lines in high-resolution graphics way faster than BASIC.

While I do have a great appreciation for elegance and clean code, my day-to-day focus is on what that enables. That is, does it keep our work humming along? Can we sleep better at night with fewer things breaking? I'm just as happy to see something less-than-Platonically-ideal ship to production if it does the job.

In my experience, using AI coding tools *has* helped me move faster. They've also helped me move *at all*, in some cases where I might not even have started a thing after facing down the mental cost of task initiation. 

[Simon Willison has written a lot about this stuff](https://simonwillison.net/2023/Mar/27/ai-enhanced-development/) from a practical perspective with which I agree:

> The thing I’m most excited about in our weird new AI-enhanced reality is the way it allows me to be more _ambitious_ with my projects.
> 
> As an experienced developer, ChatGPT (and GitHub Copilot) save me an enormous amount of “figuring things out” time. For everything from writing a for loop in Bash to remembering how to make a cross-domain CORS request in JavaScript—I don’t need to even look things up any more, I can just prompt it and get the right answer 80% of the time.
>
> This doesn’t just make me more productive: it lowers my bar for when a project is worth investing time in at all.

For example, lately, with the help of Claude, I've spun up a few new tools that have been on my wishlist literally for years—e.g. [codenamer](https://github.com/lmorchard/codenamer), [feed-to-mastodon](https://github.com/lmorchard/feed-to-mastodon), [linkding-to-opml](https://github.com/lmorchard/linkding-to-opml), [linkding-to-markdown](https://github.com/lmorchard/linkding-to-markdown), [mastodon-to-markdown](https://github.com/lmorchard/mastodon-to-markdown). And I've resumed work on older efforts for which I ran out of energy—e.g. [fossilizer](https://github.com/lmorchard/fossilizer), [blog.lmorchard.com](https://github.com/lmorchard/blog.lmorchard.com).

In each of these cases, writing the code was way less fun for me than having the end result working and doing the stuff I wanted done.

But, also, I think AI coding tools have, for me, been a forcing function on aspects of software development besides writing code: Whereas before, I might just dive right into riffing away on something in code, these days I spend a lot more time writing prose and describing what I want to build. I write and refine a lot more documentation about the software, too.

And, I spend a lot more time these days on setting up testing, linting, and other automated quality controls. It turns out that you can tightly integrate all of these into the loop of a code-generating agent and those serve as guardrails that help course-correct the spicy autocomplete as it does the needful.

Again, I like making computers do things. Also I like making them do things so that I don't have to, because I am very lazy. But also, also, I like ensuring they do things well and reliably, because I am also very tired. And, all in all, my experience with AI coding tools is that they've helped me be lazy and tired and still get a lot done. And that's fun for me.
