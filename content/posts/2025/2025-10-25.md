8<--- { "draft": false, "title": "Miscellanea for 2025-10-25", "time": "23:59:00-07:00", "type": "miscellanea", "slug": "miscellanea", "tags": [ "miscellanea", "golang", "claude" ] }

- Hello world!
- I've been on a roll lately with ginning up little utilities with golang:
	- [feedspool-go](https://github.com/lmorchard/feedspool-go): A CLI tool for managing RSS/Atom feeds with SQLite storage and static website generation.
	- [linkding-to-opml](https://github.com/lmorchard/linkding-to-opml): Quick & dirty tool to turn Linkding bookmarks into an OPML file of feed subscriptions
	- [feed-to-mastodon](https://github.com/lmorchard/feed-to-mastodon): A command-line tool that fetches RSS/Atom feeds and posts new entries to Mastodon with customizable templates.
- These each follow a similar pattern:
	- They're each written in go, distributed as a standalone CLI binary with YAML configuration and a SQLite database.
	- I'm using GitHub Actions to run lint, test, and build rolling releases across Linux, macOS, and Windows.
	- I'm leaning on Claude Code to do boring boilerplate work and draft unit tests
- If I keep this up, I'm thinking I might need to throw together something like [tools.simonwillison.net](https://tools.simonwillison.net/) to inventory these things as I accumulate them.
	- It's kind of addicting to throw a boilerplate spec doc at Claude Code, go make coffee while it spews out all the usual code for one of these tools, then come back and sort of not-quite-vibe all the desired features into existence.
	- I'm feeling the mental dread cost of little ideas go way, way down.
	- Like, I went from thinking "something like feed-to-mastodon would be nice to have" to having a first version of feed-to-mastodon in the span of 45 minutes.
	- That first-version hump and all the initial startup ceremony is usually what stops me from starting.
- Also, for some reason, I' ha've been avoiding golang for my side-projects.
	- I'm not sure why? I think maybe I thought Rust was more solid for this stuff and turned my nose up at golang?
	- Though Rust is definitely solid, I'm finding golang to be way less ceremonial for these quick and dirty little tools.
	- The ceremony in Rust is also a frequent bouncer for me, especially when the stakes are so low.
	- I'm also finding the self-contained binary delivered by golang to be a lot easier to manage than node.js or Python scripts that pull down so many dependencies.
	- I'm also really appreciating the built-in stuff like [text/template](https://pkg.go.dev/text/template), to the point that I'm now even eyeing up my [Easy-Blog Oven](https://blog.lmorchard.com/2020/05/25/diy-easy-blog-oven/) and considering rewriting my blog's static site generator, currently implemented in node.js. (uh oh)

8<--- { "draft": false, "title": "GoToSocial split-domain redirects for a static website on AWS CloudFront", "slug": "gotosocial-cloudfront-redirect", "tags": [ "gotosocial","social","aws","webdev" ], "time": "13:19:27-07:00" }

For awhile now, I've wanted to set up an installation of [GoToSocial](https://gotosocial.org/) for my [lmorchard.com](https://lmorchard.com) domain and run my own tiny fediverse outpost. And what I *really* wanted to do was to be able to host handles like [@links@lmorchard.com](https://gts.lmorchard.com/@links), [@blog@lmorchard.com](https://gts.lmorchard.com/@blog), and [@lmorchard@lmorchard.com](https://gts.lmorchard.com/@lmorchard). ([I was thinking of doing @me@lmorchard.com](https://masto.hackers.town/@lmorchard/115413464705080292), just like my email address. But, that could be confusing, because I might look like my name is "me" everywhere.)

Per the GoToSocial documentation, [Split-domain deployments](https://docs.gotosocial.org/en/latest/advanced/host-account-domain/) are supported by way of a few server-side redirects on the vanity account domain:

> The way ActivityPub implementations discover how to map your account domain to your host domain is through a protocol called [webfinger](https://www.rfc-editor.org/rfc/rfc7033). This mapping is typically cached by servers and hence why you can't change it after the fact.
>
> It works by doing a request to `https://<account domain>/.well-known/webfinger?resource=acct:@me@example.org`. At this point, a server can return a redirect to where the actual webfinger endpoint is, `https://<host domain>/.well-known/webfinger?resource=acct:@me@example.org` or may respond directly. The JSON document that is returned informs you what the endpoint to query is for the user

So, I need `lmorchard.com/.well-known/webfinger` to redirect to `gts.lmorchard.com/.well-known/webfinger` with query parameters intact to make the magic happen.

There's a wrinkle, though: lmorchard.com points at a statically-generated site, uploaded to Amazon S3, hosted behind a CloudFront CDN. That's been low-hassle to keep running for years now, as opposed to say a full-featured nginx server. The trade-off has been that this hosting arrangement didn't support any smarts on the server side. So, I thought the redirects would be infeasible.

However, I'd missed that [CloudFront added support for edge functions](https://aws.amazon.com/blogs/aws/introducing-cloudfront-functions-run-your-code-at-the-edge-with-low-latency-at-any-scale/) a few years ago. That means redirects are *entirely* feasible these days!

Long story short, here's the edge function I came up with to do the needful for GoToSocial. Nothing super-special, just that a) it works and b) it took me a few rounds of mistakes before I got it working. So, this might be handy for someone else trying to do something similar! (Or me, if I ever lose it and need to set this up again.)

```javascript
function handler(event) {
    var request = event.request;
    var uri = request.uri;
    
    // Check if the request is for one of the well-known endpoints
    if (uri === '/.well-known/webfinger' || 
        uri === '/.well-known/host-meta' || 
        uri === '/.well-known/nodeinfo') {
        
        // Build redirect URL
        var redirectUrl = 'https://gts.lmorchard.com' + uri;
        
        // Manually build query string from querystring object
        var queryString = request.querystring;
        if (queryString && Object.keys(queryString).length > 0) {
            var params = [];
            for (var key in queryString) {
                if (queryString.hasOwnProperty(key)) {
                    var value = queryString[key].value;
                    // Don't re-encode - values are already URL-encoded
                    params.push(key + '=' + value);
                }
            }
            if (params.length > 0) {
                redirectUrl += '?' + params.join('&');
            }
        }
        
        return {
            statusCode: 301,
            statusDescription: 'Moved Permanently',
            headers: {
                'location': { value: redirectUrl },
                'access-control-allow-origin': { value: '*' },
                'access-control-allow-methods': { value: 'GET, HEAD, OPTIONS' },
                'access-control-allow-headers': { value: 'Content-Type' }
            }
        };
    }
    
    // Return the request unchanged for all other paths
    return request;
}
```
