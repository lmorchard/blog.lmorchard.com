8<--- { "draft": true, "title": "Miscellanea for 2025-10-25", "time": "23:59:00-07:00", "type": "miscellanea", "slug": "miscellanea", "tags": [ "miscellanea" ] }

- Hello world!

8<--- { "draft": true, "title": "GoToSocial split-domain redirects for a static website on AWS CloudFront", "slug": "gotosocial-cloudfront-redirect", "tags": [ "gotosocial","social","aws","webdev" ], "time": "13:19:27-07:00" }

For awhile now, I've been wanting to set up an installation of [GoToSocial](https://gotosocial.org/) for my [lmorchard.com](https://lmorchard.com) domain and run my own tiny fediverse outpost. And what I *really* wanted to do was to be able to host Webfinger addresses like [@links@lmorchard.com](https://gts.lmorchard.com/@links), [@blog@lmorchard.com](https://gts.lmorchard.com/@blog), and [@lmorchard@lmorchard.com](https://gts.lmorchard.com/@lmorchard). (I was thinking of doing @me@lmorchard.com, just like my email address. But, that could be confusing.)

The main wrinkle: My subdomain-less primary domain lmorchard.com points at a statically-generated site uploaded to Amazon S3 behind a CloudFront CDN for SSL and such. It's been that way for years and has been pretty low-hassle to keep running, versus say a full-featured nginx server.

But, per the GoToSocial documentation, [Split-domain deployments](https://docs.gotosocial.org/en/latest/advanced/host-account-domain/) are supported but require some redirects implemented on the vanity account domain:

> The way ActivityPub implementations discover how to map your account domain to your host domain is through a protocol called [webfinger](https://www.rfc-editor.org/rfc/rfc7033). This mapping is typically cached by servers and hence why you can't change it after the fact.
>
> It works by doing a request to `https://<account domain>/.well-known/webfinger?resource=acct:@me@example.org`. At this point, a server can return a redirect to where the actual webfinger endpoint is, `https://<host domain>/.well-known/webfinger?resource=acct:@me@example.org` or may respond directly. The JSON document that is returned informs you what the endpoint to query is for the user:

So, I need `lmorchard.com/.well-known/webfinger` to redirect to `gts.lmorchard.com/.well-known/webfinger` to make the magic happen.



```javascript
function handler(event) {
    var request = event.request;
    var uri = request.uri;
    
    // Check if the request is for one of the well-known endpoints
    if (uri === '/.well-known/webfinger' || 
        uri === '/.well-known/host-meta' || 
        uri === '/.well-known/nodeinfo') {
        
        // Build redirect URL
        var redirectUrl = 'https://gts.lmorchard.com' + uri;
        
        // Manually build query string from querystring object
        var queryString = request.querystring;
        if (queryString && Object.keys(queryString).length > 0) {
            var params = [];
            for (var key in queryString) {
                if (queryString.hasOwnProperty(key)) {
                    var value = queryString[key].value;
                    // Don't re-encode - values are already URL-encoded
                    params.push(key + '=' + value);
                }
            }
            if (params.length > 0) {
                redirectUrl += '?' + params.join('&');
            }
        }
        
        return {
            statusCode: 301,
            statusDescription: 'Moved Permanently',
            headers: {
                'location': { value: redirectUrl },
                'access-control-allow-origin': { value: '*' },
                'access-control-allow-methods': { value: 'GET, HEAD, OPTIONS' },
                'access-control-allow-headers': { value: 'Content-Type' }
            }
        };
    }
    
    // Return the request unchanged for all other paths
    return request;
}
```