{
  "version": 3,
  "sources": ["../../../node_modules/pixi.js/src/scene/graphics/gpu/GpuGraphicsAdaptor.ts", "../../../node_modules/pixi.js/src/scene/mesh/gpu/GpuMeshAdapter.ts", "../../../node_modules/pixi.js/src/rendering/batcher/gpu/GpuBatchAdaptor.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/BindGroupSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/GpuBufferSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuColorMaskSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuDeviceSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuEncoderSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuStencilSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboElementsWGSL.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/generateArraySyncWGSL.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/utils/createUboSyncFunctionWGSL.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUboSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/buffer/UboBatch.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/GpuUniformBatchPipe.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/pipeline/PipelineSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTarget.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/renderTarget/GpuRenderTargetSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/shader/GpuShaderSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuBlendModesToPixi.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/state/GpuStateSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadBufferImageResource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadCompressedTextureResource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadImageSource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/uploaders/gpuUploadVideoSource.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/utils/GpuMipmapGenerator.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/texture/GpuTextureSystem.ts", "../../../node_modules/pixi.js/src/rendering/renderers/gpu/WebGPURenderer.ts"],
  "sourcesContent": ["import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { getMaxTexturesPerBatch } from '../../../rendering/batcher/gl/utils/maxRecommendedTextures';\nimport { getTextureBatchBindGroup } from '../../../rendering/batcher/gpu/getTextureBatchBindGroup';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { colorBit } from '../../../rendering/high-shader/shader-bits/colorBit';\nimport { generateTextureBatchBit } from '../../../rendering/high-shader/shader-bits/generateTextureBatchBit';\nimport { localUniformBitGroup2 } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { UniformGroup } from '../../../rendering/renderers/shared/shader/UniformGroup';\n\nimport type { Batch } from '../../../rendering/batcher/shared/Batcher';\nimport type { GpuEncoderSystem } from '../../../rendering/renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Graphics } from '../shared/Graphics';\nimport type { GraphicsAdaptor, GraphicsPipe } from '../shared/GraphicsPipe';\n\n/**\n * A GraphicsAdaptor that uses the GPU to render graphics.\n * @memberof rendering\n * @ignore\n */\nexport class GpuGraphicsAdaptor implements GraphicsAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'graphics',\n    } as const;\n\n    public shader: Shader;\n\n    public init()\n    {\n        const localUniforms = new UniformGroup({\n            uTransformMatrix: { value: new Matrix(), type: 'mat3x3<f32>' },\n            uColor: { value: new Float32Array([1, 1, 1, 1]), type: 'vec4<f32>' },\n            uRound: { value: 0, type: 'f32' },\n        });\n\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'graphics',\n            bits: [\n                colorBit,\n                generateTextureBatchBit(getMaxTexturesPerBatch()),\n\n                localUniformBitGroup2,\n                roundPixelsBit\n            ]\n        });\n\n        this.shader = new Shader({\n            gpuProgram,\n            resources: {\n                // added on the fly!\n                localUniforms,\n            },\n        });\n    }\n\n    public execute(graphicsPipe: GraphicsPipe, renderable: Graphics): void\n    {\n        const context = renderable.context;\n        const shader = context.customShader || this.shader;\n        const renderer = graphicsPipe.renderer as WebGPURenderer;\n        const contextSystem = renderer.graphicsContext;\n\n        const {\n            batcher, instructions\n        } = contextSystem.getContextRenderData(context);\n\n        // WebGPU specific...\n\n        // TODO perf test this a bit...\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        encoder.setGeometry(batcher.geometry, shader.gpuProgram);\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, shader.gpuProgram);\n\n        const localBindGroup = (renderer as WebGPURenderer)\n            .renderPipes.uniformBatch.getUniformBindGroup(shader.resources.localUniforms, true);\n\n        encoder.setBindGroup(2, localBindGroup, shader.gpuProgram);\n\n        const batches = instructions.instructions as Batch[];\n\n        let topology: Topology = null;\n\n        for (let i = 0; i < instructions.instructionSize; i++)\n        {\n            const batch = batches[i];\n\n            if (batch.topology !== topology)\n            {\n                topology = batch.topology;\n\n                encoder.setPipelineFromGeometryProgramAndState(\n                    batcher.geometry,\n                    shader.gpuProgram,\n                    graphicsPipe.state,\n                    batch.topology\n                );\n            }\n\n            shader.groups[1] = batch.bindGroup;\n\n            if (!batch.gpuBindGroup)\n            {\n                const textureBatch = batch.textures;\n\n                batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n                batch.gpuBindGroup = renderer.bindGroup.getBindGroup(\n                    batch.bindGroup, shader.gpuProgram, 1\n                );\n            }\n\n            encoder.setBindGroup(1, batch.bindGroup, shader.gpuProgram);\n\n            encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n        }\n    }\n\n    public destroy(): void\n    {\n        this.shader.destroy(true);\n        this.shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Matrix } from '../../../maths/matrix/Matrix';\nimport { compileHighShaderGpuProgram } from '../../../rendering/high-shader/compileHighShaderToProgram';\nimport { localUniformBit } from '../../../rendering/high-shader/shader-bits/localUniformBit';\nimport { roundPixelsBit } from '../../../rendering/high-shader/shader-bits/roundPixelsBit';\nimport { textureBit } from '../../../rendering/high-shader/shader-bits/textureBit';\nimport { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { warn } from '../../../utils/logging/warn';\n\nimport type { WebGPURenderer } from '../../../rendering/renderers/gpu/WebGPURenderer';\nimport type { Mesh } from '../shared/Mesh';\nimport type { MeshAdaptor, MeshPipe } from '../shared/MeshPipe';\n\n/**\n * The WebGL adaptor for the mesh system. Allows the Mesh System to be used with the WebGl renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuMeshAdapter implements MeshAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'mesh',\n    } as const;\n\n    private _shader: Shader;\n\n    public init(): void\n    {\n        const gpuProgram = compileHighShaderGpuProgram({\n            name: 'mesh',\n            bits: [\n                localUniformBit,\n                textureBit,\n                roundPixelsBit,\n            ]\n        });\n\n        this._shader = new Shader({\n            gpuProgram,\n            resources: {\n                uTexture: Texture.EMPTY._source,\n                uSampler: Texture.EMPTY._source.style,\n                textureUniforms: {\n                    uTextureMatrix: { type: 'mat3x3<f32>', value: new Matrix() },\n                }\n            }\n        });\n    }\n\n    public execute(meshPipe: MeshPipe, mesh: Mesh)\n    {\n        const renderer = meshPipe.renderer as WebGPURenderer;\n\n        let shader: Shader = mesh._shader;\n\n        if (!shader)\n        {\n            shader = this._shader;\n\n            shader.groups[2] = renderer.texture.getTextureBindGroup(mesh.texture);\n        }\n        else if (!shader.gpuProgram)\n        {\n            // #if _DEBUG\n            warn('Mesh shader has no gpuProgram', mesh.shader);\n            // #endif\n\n            return;\n        }\n\n        const gpuProgram = shader.gpuProgram;\n        // GPU..\n\n        if (gpuProgram.autoAssignGlobalUniforms)\n        {\n            shader.groups[0] = renderer.globalUniforms.bindGroup;\n        }\n\n        if (gpuProgram.autoAssignLocalUniforms)\n        {\n            const localUniforms = meshPipe.localUniforms;\n\n            shader.groups[1] = (renderer as WebGPURenderer)\n                .renderPipes.uniformBatch.getUniformBindGroup(localUniforms, true);\n        }\n\n        renderer.encoder.draw({\n            geometry: mesh._geometry,\n            shader,\n            state: mesh.state\n        });\n    }\n\n    public destroy(): void\n    {\n        this._shader.destroy(true);\n        this._shader = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { State } from '../../renderers/shared/state/State';\nimport { getTextureBatchBindGroup } from './getTextureBatchBindGroup';\n\nimport type { GpuEncoderSystem } from '../../renderers/gpu/GpuEncoderSystem';\nimport type { WebGPURenderer } from '../../renderers/gpu/WebGPURenderer';\nimport type { Geometry } from '../../renderers/shared/geometry/Geometry';\nimport type { Shader } from '../../renderers/shared/shader/Shader';\nimport type { Batch } from '../shared/Batcher';\nimport type { BatcherAdaptor, BatcherPipe } from '../shared/BatcherPipe';\n\nconst tempState = State.for2d();\n\n/**\n * A BatcherAdaptor that uses the GPU to render batches.\n * @memberof rendering\n * @ignore\n */\nexport class GpuBatchAdaptor implements BatcherAdaptor\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipesAdaptor,\n        ],\n        name: 'batch',\n    } as const;\n\n    private _shader: Shader;\n    private _geometry: Geometry;\n\n    public start(batchPipe: BatcherPipe, geometry: Geometry, shader: Shader): void\n    {\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n        const program = shader.gpuProgram;\n\n        this._shader = shader;\n        this._geometry = geometry;\n\n        encoder.setGeometry(geometry, program);\n\n        tempState.blendMode = 'normal';\n\n        // this just initiates the pipeline, so we can then set bind groups on it\n        renderer.pipeline.getPipeline(\n            geometry,\n            program,\n            tempState\n        );\n\n        const globalUniformsBindGroup = renderer.globalUniforms.bindGroup;\n\n        // low level - we need to reset the bind group at location 1 to null\n        // this is because we directly manipulate the bound buffer in the execute function for\n        // performance reasons.\n        // setting it to null ensures that the next bind group we set at location 1 will\n        // be the one we want.\n        encoder.resetBindGroup(1);\n\n        encoder.setBindGroup(0, globalUniformsBindGroup, program);\n    }\n\n    public execute(batchPipe: BatcherPipe, batch: Batch): void\n    {\n        const program = this._shader.gpuProgram;\n        const renderer = batchPipe.renderer as WebGPURenderer;\n        const encoder = renderer.encoder as GpuEncoderSystem;\n\n        if (!batch.bindGroup)\n        {\n            const textureBatch = batch.textures;\n\n            batch.bindGroup = getTextureBatchBindGroup(textureBatch.textures, textureBatch.count);\n        }\n\n        tempState.blendMode = batch.blendMode;\n\n        const gpuBindGroup = renderer.bindGroup.getBindGroup(\n            batch.bindGroup, program, 1\n        );\n\n        const pipeline = renderer.pipeline.getPipeline(\n            this._geometry,\n            program,\n            tempState,\n            batch.topology\n        );\n\n        batch.bindGroup._touch(renderer.textureGC.count);\n\n        encoder.setPipeline(pipeline);\n\n        encoder.renderPassEncoder.setBindGroup(1, gpuBindGroup);\n        encoder.renderPassEncoder.drawIndexed(batch.size, 1, batch.start);\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { BufferResource } from '../shared/buffer/BufferResource';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { System } from '../shared/system/System';\nimport type { TextureSource } from '../shared/texture/sources/TextureSource';\nimport type { TextureStyle } from '../shared/texture/TextureStyle';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { BindResource } from './shader/BindResource';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the WebGPU bind groups. this is how data is bound to a shader when rendering\n * @memberof rendering\n */\nexport class BindGroupSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'bindGroup',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _hash: Record<string, GPUBindGroup> = Object.create(null);\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_hash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getBindGroup(bindGroup: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        bindGroup._updateKey();\n\n        const gpuBindGroup = this._hash[bindGroup._key] || this._createBindGroup(bindGroup, program, groupIndex);\n\n        return gpuBindGroup;\n    }\n\n    private _createBindGroup(group: BindGroup, program: GpuProgram, groupIndex: number): GPUBindGroup\n    {\n        const device = this._gpu.device;\n        const groupLayout = program.layout[groupIndex];\n        const entries: GPUBindGroupEntry[] = [];\n        const renderer = this._renderer;\n\n        for (const j in groupLayout)\n        {\n            const resource: BindResource = group.resources[j] ?? group.resources[groupLayout[j]];\n            let gpuResource: GPUSampler | GPUTextureView | GPUExternalTexture | GPUBufferBinding;\n            // TODO make this dynamic..\n\n            if (resource._resourceType === 'uniformGroup')\n            {\n                const uniformGroup = resource as UniformGroup;\n\n                renderer.ubo.updateUniformGroup(uniformGroup as UniformGroup);\n\n                const buffer = uniformGroup.buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'buffer')\n            {\n                const buffer = resource as Buffer;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(buffer),\n                    offset: 0,\n                    size: buffer.descriptor.size,\n                };\n            }\n            else if (resource._resourceType === 'bufferResource')\n            {\n                const bufferResource = resource as BufferResource;\n\n                gpuResource = {\n                    buffer: renderer.buffer.getGPUBuffer(bufferResource.buffer),\n                    offset: bufferResource.offset,\n                    size: bufferResource.size,\n                };\n            }\n            else if (resource._resourceType === 'textureSampler')\n            {\n                const sampler = resource as TextureStyle;\n\n                gpuResource = renderer.texture.getGpuSampler(sampler);\n            }\n            else if (resource._resourceType === 'textureSource')\n            {\n                const texture = resource as TextureSource;\n\n                gpuResource = renderer.texture.getGpuSource(texture).createView({\n\n                });\n            }\n\n            entries.push({\n                binding: groupLayout[j],\n                resource: gpuResource,\n            });\n        }\n\n        const layout = renderer.shader.getProgramData(program).bindGroups[groupIndex];\n\n        const gpuBindGroup = device.createBindGroup({\n            layout,\n            entries,\n        });\n\n        this._hash[group._key] = gpuBindGroup;\n\n        return gpuBindGroup;\n    }\n\n    public destroy(): void\n    {\n        for (const key of Object.keys(this._hash))\n        {\n            this._hash[key] = null;\n        }\n\n        this._hash = null;\n\n        (this._renderer as null) = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { fastCopy } from '../../shared/buffer/utils/fastCopy';\n\nimport type { Buffer } from '../../shared/buffer/Buffer';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * System plugin to the renderer to manage buffers.\n * @memberof rendering\n */\nexport class GpuBufferSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'buffer',\n    } as const;\n\n    protected CONTEXT_UID: number;\n    private _gpuBuffers: { [key: number]: GPUBuffer } = Object.create(null);\n    private readonly _managedBuffers: Buffer[] = [];\n\n    private _gpu: GPU;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        renderer.renderableGC.addManagedHash(this, '_gpuBuffers');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public getGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        return this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n    }\n\n    public updateBuffer(buffer: Buffer): GPUBuffer\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid] || this.createGPUBuffer(buffer);\n\n        const data = buffer.data;\n\n        // TODO this can be better...\n        if (buffer._updateID && data)\n        {\n            buffer._updateID = 0;\n\n            // make sure\n            this._gpu.device.queue.writeBuffer(\n                gpuBuffer, 0, data.buffer, 0,\n                // round to the nearest 4 bytes\n                ((buffer._updateSize || data.byteLength) + 3) & ~3\n            );\n        }\n\n        return gpuBuffer;\n    }\n\n    /** dispose all WebGL resources of all managed buffers */\n    public destroyAll(): void\n    {\n        for (const id in this._gpuBuffers)\n        {\n            this._gpuBuffers[id].destroy();\n        }\n\n        this._gpuBuffers = {};\n    }\n\n    public createGPUBuffer(buffer: Buffer): GPUBuffer\n    {\n        if (!this._gpuBuffers[buffer.uid])\n        {\n            buffer.on('update', this.updateBuffer, this);\n            buffer.on('change', this.onBufferChange, this);\n            buffer.on('destroy', this.onBufferDestroy, this);\n\n            this._managedBuffers.push(buffer);\n        }\n\n        const gpuBuffer = this._gpu.device.createBuffer(buffer.descriptor);\n\n        buffer._updateID = 0;\n\n        if (buffer.data)\n        {\n            // TODO if data is static, this can be mapped at creation\n            fastCopy(buffer.data.buffer, gpuBuffer.getMappedRange());\n\n            gpuBuffer.unmap();\n        }\n\n        this._gpuBuffers[buffer.uid] = gpuBuffer;\n\n        return gpuBuffer;\n    }\n\n    protected onBufferChange(buffer: Buffer)\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n        buffer._updateID = 0;\n        this._gpuBuffers[buffer.uid] = this.createGPUBuffer(buffer);\n    }\n\n    /**\n     * Disposes buffer\n     * @param buffer - buffer with data\n     */\n    protected onBufferDestroy(buffer: Buffer): void\n    {\n        this._managedBuffers.splice(this._managedBuffers.indexOf(buffer), 1);\n\n        this._destroyBuffer(buffer);\n    }\n\n    public destroy(): void\n    {\n        this._managedBuffers.forEach((buffer) => this._destroyBuffer(buffer));\n\n        (this._managedBuffers as null) = null;\n\n        this._gpuBuffers = null;\n    }\n\n    private _destroyBuffer(buffer: Buffer): void\n    {\n        const gpuBuffer = this._gpuBuffers[buffer.uid];\n\n        gpuBuffer.destroy();\n\n        buffer.off('update', this.updateBuffer, this);\n        buffer.off('change', this.onBufferChange, this);\n        buffer.off('destroy', this.onBufferDestroy, this);\n\n        this._gpuBuffers[buffer.uid] = null;\n    }\n}\n\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles color masking for the GPU.\n * @memberof rendering\n */\nexport class GpuColorMaskSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'colorMask',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _colorMaskCache = 0b1111;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public setMask(colorMask: number)\n    {\n        if (this._colorMaskCache === colorMask) return;\n        this._colorMaskCache = colorMask;\n\n        this._renderer.pipeline.setColorMask(colorMask);\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._colorMaskCache = null;\n    }\n}\n", "import { DOMAdapter } from '../../../environment/adapter';\nimport { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { System } from '../shared/system/System';\nimport type { GpuPowerPreference } from '../types';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/** The GPU object. */\nexport interface GPU\n{\n    /** The GPU adapter */\n    adapter: GPUAdapter;\n    /** The GPU device */\n    device: GPUDevice;\n}\n\n/**\n * Options for the WebGPU context.\n * @property {GpuPowerPreference} [powerPreference=default] - An optional hint indicating what configuration of GPU\n * is suitable for the WebGPU context, can be `'high-performance'` or `'low-power'`.\n * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n * while setting to `'low-power'` will prioritize power saving over rendering performance.\n * @property {boolean} [forceFallbackAdapter=false] - Force the use of the fallback adapter\n * @memberof rendering\n */\nexport interface GpuContextOptions\n{\n    /**\n     * An optional hint indicating what configuration of GPU is suitable for the WebGPU context,\n     * can be `'high-performance'` or `'low-power'`.\n     * Setting to `'high-performance'` will prioritize rendering performance over power consumption,\n     * while setting to `'low-power'` will prioritize power saving over rendering performance.\n     * @default undefined\n     * @memberof rendering.WebGPUOptions\n     */\n    powerPreference?: GpuPowerPreference;\n    /**\n     * Force the use of the fallback adapter\n     * @default false\n     * @memberof rendering.WebGPUOptions\n     */\n    forceFallbackAdapter: boolean;\n}\n\n/**\n * System plugin to the renderer to manage the context.\n * @class\n * @memberof rendering\n */\nexport class GpuDeviceSystem implements System<GpuContextOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'device',\n    } as const;\n\n    /** The default options for the GpuDeviceSystem. */\n    public static defaultOptions: GpuContextOptions = {\n        /**\n         * {@link WebGPUOptions.powerPreference}\n         * @default default\n         */\n        powerPreference: undefined,\n        /**\n         * Force the use of the fallback adapter\n         * @default false\n         */\n        forceFallbackAdapter: false,\n    };\n\n    /** The GPU device */\n    public gpu: GPU;\n\n    private _renderer: WebGPURenderer;\n    private _initPromise: Promise<void>;\n\n    /**\n     * @param {WebGPURenderer} renderer - The renderer this System works for.\n     */\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public async init(options: GpuContextOptions): Promise<void>\n    {\n        if (this._initPromise) return this._initPromise;\n\n        this._initPromise = this._createDeviceAndAdaptor(options)\n            .then((gpu) =>\n            {\n                this.gpu = gpu;\n\n                this._renderer.runners.contextChange.emit(this.gpu);\n            });\n\n        return this._initPromise;\n    }\n\n    /**\n     * Handle the context change event\n     * @param gpu\n     */\n    protected contextChange(gpu: GPU): void\n    {\n        this._renderer.gpu = gpu;\n    }\n\n    /**\n     * Helper class to create a WebGL Context\n     * @param {object} options - An options object that gets passed in to the canvas element containing the\n     *    context attributes\n     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext\n     * @returns {WebGLRenderingContext} the WebGL context\n     */\n    private async _createDeviceAndAdaptor(options: GpuContextOptions): Promise<GPU>\n    {\n        // TODO we only need one of these..\n        const adapter = await DOMAdapter.get().getNavigator().gpu.requestAdapter({\n            powerPreference: options.powerPreference,\n            forceFallbackAdapter: options.forceFallbackAdapter,\n        });\n\n        const requiredFeatures = [\n            'texture-compression-bc',\n            'texture-compression-astc',\n            'texture-compression-etc2',\n        ].filter((feature) => adapter.features.has(feature)) as GPUFeatureName[];\n\n        // TODO and one of these!\n        const device = await adapter.requestDevice({\n            requiredFeatures\n        });\n\n        return { adapter, device };\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n        this._renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\n\nimport type { Rectangle } from '../../../maths/shapes/Rectangle';\nimport type { Buffer } from '../shared/buffer/Buffer';\nimport type { Topology } from '../shared/geometry/const';\nimport type { Geometry } from '../shared/geometry/Geometry';\nimport type { Shader } from '../shared/shader/Shader';\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { State } from '../shared/state/State';\nimport type { System } from '../shared/system/System';\nimport type { GPU } from './GpuDeviceSystem';\nimport type { GpuRenderTarget } from './renderTarget/GpuRenderTarget';\nimport type { GpuRenderTargetAdaptor } from './renderTarget/GpuRenderTargetAdaptor';\nimport type { BindGroup } from './shader/BindGroup';\nimport type { GpuProgram } from './shader/GpuProgram';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * The system that handles encoding commands for the GPU.\n * @memberof rendering\n */\nexport class GpuEncoderSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'encoder',\n        priority: 1\n    } as const;\n\n    public commandEncoder: GPUCommandEncoder;\n    public renderPassEncoder: GPURenderPassEncoder;\n    public commandFinished: Promise<void>;\n\n    private _resolveCommandFinished: (value: void) => void;\n\n    private _gpu: GPU;\n    private _boundBindGroup: Record<number, BindGroup> = Object.create(null);\n    private _boundVertexBuffer: Record<number, Buffer> = Object.create(null);\n    private _boundIndexBuffer: Buffer;\n    private _boundPipeline: GPURenderPipeline;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    public renderStart(): void\n    {\n        this.commandFinished = new Promise((resolve) =>\n        {\n            this._resolveCommandFinished = resolve;\n        });\n\n        // generate a render pass description..\n        // create an encoder..\n        this.commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n    }\n\n    public beginRenderPass(gpuRenderTarget: GpuRenderTarget)\n    {\n        this.endRenderPass();\n\n        this._clearCache();\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(gpuRenderTarget.descriptor);\n    }\n\n    public endRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n        }\n\n        this.renderPassEncoder = null;\n    }\n\n    public setViewport(viewport: Rectangle): void\n    {\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n    }\n\n    public setPipelineFromGeometryProgramAndState(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: any,\n        topology?: Topology,\n    ): void\n    {\n        const pipeline = this._renderer.pipeline.getPipeline(geometry, program, state, topology);\n\n        this.setPipeline(pipeline);\n    }\n\n    public setPipeline(pipeline: GPURenderPipeline)\n    {\n        if (this._boundPipeline === pipeline) return;\n        this._boundPipeline = pipeline;\n\n        this.renderPassEncoder.setPipeline(pipeline);\n    }\n\n    private _setVertexBuffer(index: number, buffer: Buffer)\n    {\n        if (this._boundVertexBuffer[index] === buffer) return;\n\n        this._boundVertexBuffer[index] = buffer;\n\n        this.renderPassEncoder.setVertexBuffer(index, this._renderer.buffer.updateBuffer(buffer));\n    }\n\n    private _setIndexBuffer(buffer: Buffer)\n    {\n        if (this._boundIndexBuffer === buffer) return;\n\n        this._boundIndexBuffer = buffer;\n\n        const indexFormat = buffer.data.BYTES_PER_ELEMENT === 2 ? 'uint16' : 'uint32';\n\n        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(buffer), indexFormat);\n    }\n\n    public resetBindGroup(index: number)\n    {\n        this._boundBindGroup[index] = null;\n    }\n\n    public setBindGroup(index: number, bindGroup: BindGroup, program: GpuProgram)\n    {\n        if (this._boundBindGroup[index] === bindGroup) return;\n        this._boundBindGroup[index] = bindGroup;\n\n        bindGroup._touch(this._renderer.textureGC.count);\n\n        // TODO getting the bind group works as it looks at th e assets and generates a key\n        // should this just be hidden behind a dirty flag?\n        const gpuBindGroup = this._renderer.bindGroup.getBindGroup(bindGroup, program, index);\n\n        // mark each item as having been used..\n        this.renderPassEncoder.setBindGroup(index, gpuBindGroup);\n    }\n\n    public setGeometry(geometry: Geometry, program: GpuProgram)\n    {\n        // when binding a buffers for geometry, there is no need to bind a buffer more than once if it is interleaved.\n        // which is often the case for Pixi. This is a performance optimisation.\n        // Instead of looping through the attributes, we instead call getBufferNamesToBind\n        // which returns a list of buffer names that need to be bound.\n        // we can then loop through this list and bind the buffers.\n        // essentially only binding a single time for any buffers that are interleaved.\n        const buffersToBind = this._renderer.pipeline.getBufferNamesToBind(geometry, program);\n\n        for (const i in buffersToBind)\n        {\n            this._setVertexBuffer(i as any as number, geometry.attributes[buffersToBind[i]].buffer);\n        }\n\n        if (geometry.indexBuffer)\n        {\n            this._setIndexBuffer(geometry.indexBuffer);\n        }\n    }\n\n    private _setShaderBindGroups(shader: Shader, skipSync?: boolean)\n    {\n        for (const i in shader.groups)\n        {\n            const bindGroup = shader.groups[i] as BindGroup;\n\n            // update any uniforms?\n            if (!skipSync)\n            {\n                this._syncBindGroup(bindGroup);\n            }\n\n            this.setBindGroup(i as unknown as number, bindGroup, shader.gpuProgram);\n        }\n    }\n\n    private _syncBindGroup(bindGroup: BindGroup)\n    {\n        for (const j in bindGroup.resources)\n        {\n            const resource = bindGroup.resources[j];\n\n            if ((resource as UniformGroup).isUniformGroup)\n            {\n                this._renderer.ubo.updateUniformGroup(resource as UniformGroup);\n            }\n        }\n    }\n\n    public draw(options: {\n        geometry: Geometry;\n        shader: Shader;\n        state?: State;\n        topology?: Topology;\n        size?: number;\n        start?: number;\n        instanceCount?: number;\n        skipSync?: boolean;\n    })\n    {\n        const { geometry, shader, state, topology, size, start, instanceCount, skipSync } = options;\n\n        this.setPipelineFromGeometryProgramAndState(geometry, shader.gpuProgram, state, topology);\n        this.setGeometry(geometry, shader.gpuProgram);\n        this._setShaderBindGroups(shader, skipSync);\n\n        if (geometry.indexBuffer)\n        {\n            this.renderPassEncoder.drawIndexed(\n                size || geometry.indexBuffer.data.length,\n                instanceCount ?? geometry.instanceCount,\n                start || 0\n            );\n        }\n        else\n        {\n            this.renderPassEncoder.draw(size || geometry.getSize(), instanceCount ?? geometry.instanceCount, start || 0);\n        }\n    }\n\n    public finishRenderPass()\n    {\n        if (this.renderPassEncoder)\n        {\n            this.renderPassEncoder.end();\n            this.renderPassEncoder = null;\n        }\n    }\n\n    public postrender()\n    {\n        this.finishRenderPass();\n\n        this._gpu.device.queue.submit([this.commandEncoder.finish()]);\n\n        this._resolveCommandFinished();\n\n        this.commandEncoder = null;\n    }\n\n    // restores a render pass if finishRenderPass was called\n    // not optimised as really used for debugging!\n    // used when we want to stop drawing and log a texture..\n    public restoreRenderPass()\n    {\n        const descriptor = (this._renderer.renderTarget.adaptor as GpuRenderTargetAdaptor).getDescriptor(\n            this._renderer.renderTarget.renderTarget,\n            false,\n            [0, 0, 0, 1],\n        );\n\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass(descriptor);\n\n        const boundPipeline = this._boundPipeline;\n        const boundVertexBuffer = { ...this._boundVertexBuffer };\n        const boundIndexBuffer = this._boundIndexBuffer;\n        const boundBindGroup = { ...this._boundBindGroup };\n\n        this._clearCache();\n\n        const viewport = this._renderer.renderTarget.viewport;\n\n        this.renderPassEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n        // reinstate the cache...\n\n        this.setPipeline(boundPipeline);\n\n        for (const i in boundVertexBuffer)\n        {\n            this._setVertexBuffer(i as unknown as number, boundVertexBuffer[i]);\n        }\n\n        for (const i in boundBindGroup)\n        {\n            this.setBindGroup(i as unknown as number, boundBindGroup[i], null);\n        }\n\n        this._setIndexBuffer(boundIndexBuffer);\n    }\n\n    private _clearCache()\n    {\n        for (let i = 0; i < 16; i++)\n        {\n            this._boundBindGroup[i] = null;\n            this._boundVertexBuffer[i] = null;\n        }\n\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    public destroy()\n    {\n        (this._renderer as null) = null;\n        this._gpu = null;\n        this._boundBindGroup = null;\n        this._boundVertexBuffer = null;\n        this._boundIndexBuffer = null;\n        this._boundPipeline = null;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { STENCIL_MODES } from '../shared/state/const';\n\nimport type { RenderTarget } from '../shared/renderTarget/RenderTarget';\nimport type { System } from '../shared/system/System';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\n/**\n * This manages the stencil buffer. Used primarily for masking\n * @memberof rendering\n */\nexport class GpuStencilSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'stencil',\n    } as const;\n\n    private readonly _renderer: WebGPURenderer;\n\n    private _renderTargetStencilState: Record<number, {\n        stencilMode: STENCIL_MODES;\n        stencilReference: number;\n    }> = Object.create(null);\n\n    private _activeRenderTarget: RenderTarget;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n\n        renderer.renderTarget.onRenderTargetChange.add(this);\n    }\n\n    protected onRenderTargetChange(renderTarget: RenderTarget)\n    {\n        let stencilState = this._renderTargetStencilState[renderTarget.uid];\n\n        if (!stencilState)\n        {\n            stencilState = this._renderTargetStencilState[renderTarget.uid] = {\n                stencilMode: STENCIL_MODES.DISABLED,\n                stencilReference: 0,\n            };\n        }\n\n        this._activeRenderTarget = renderTarget;\n\n        this.setStencilMode(stencilState.stencilMode, stencilState.stencilReference);\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES, stencilReference: number)\n    {\n        const stencilState = this._renderTargetStencilState[this._activeRenderTarget.uid];\n\n        stencilState.stencilMode = stencilMode;\n        stencilState.stencilReference = stencilReference;\n\n        const renderer = this._renderer;\n\n        renderer.pipeline.setStencilMode(stencilMode);\n        renderer.encoder.renderPassEncoder.setStencilReference(stencilReference);\n    }\n\n    public destroy()\n    {\n        this._renderer.renderTarget.onRenderTargetChange.remove(this);\n\n        (this._renderer as null) = null;\n\n        this._activeRenderTarget = null;\n        this._renderTargetStencilState = null;\n    }\n}\n", "import type { UboElement, UboLayout, UNIFORM_TYPES, UniformData } from '../../../shared/shader/types';\n\nexport const WGSL_ALIGN_SIZE_DATA: Record<UNIFORM_TYPES | string, {align: number, size: number}> = {\n    i32: { align: 4, size: 4 },\n    u32: { align: 4, size: 4 },\n    f32: { align: 4, size: 4 },\n    f16: { align: 2, size: 2 },\n    'vec2<i32>': { align: 8, size: 8 },\n    'vec2<u32>': { align: 8, size: 8 },\n    'vec2<f32>': { align: 8, size: 8 },\n    'vec2<f16>': { align: 4, size: 4 },\n    'vec3<i32>': { align: 16, size: 12 },\n    'vec3<u32>': { align: 16, size: 12 },\n    'vec3<f32>': { align: 16, size: 12 },\n    'vec3<f16>': { align: 8, size: 6 },\n    'vec4<i32>': { align: 16, size: 16 },\n    'vec4<u32>': { align: 16, size: 16 },\n    'vec4<f32>': { align: 16, size: 16 },\n    'vec4<f16>': { align: 8, size: 8 },\n    'mat2x2<f32>': { align: 8, size: 16 },\n    'mat2x2<f16>': { align: 4, size: 8 },\n    'mat3x2<f32>': { align: 8, size: 24 },\n    'mat3x2<f16>': { align: 4, size: 12 },\n    'mat4x2<f32>': { align: 8, size: 32 },\n    'mat4x2<f16>': { align: 4, size: 16 },\n    'mat2x3<f32>': { align: 16, size: 32 },\n    'mat2x3<f16>': { align: 8, size: 16 },\n    'mat3x3<f32>': { align: 16, size: 48 },\n    'mat3x3<f16>': { align: 8, size: 24 },\n    'mat4x3<f32>': { align: 16, size: 64 },\n    'mat4x3<f16>': { align: 8, size: 32 },\n    'mat2x4<f32>': { align: 16, size: 32 },\n    'mat2x4<f16>': { align: 8, size: 16 },\n    'mat3x4<f32>': { align: 16, size: 48 },\n    'mat3x4<f16>': { align: 8, size: 24 },\n    'mat4x4<f32>': { align: 16, size: 64 },\n    'mat4x4<f16>': { align: 8, size: 32 },\n};\n\nexport function createUboElementsWGSL(uniformData: UniformData[]): UboLayout\n{\n    const uboElements: UboElement[] = uniformData.map((data: UniformData) =>\n        ({\n            data,\n            offset: 0,\n            size: 0,\n        }));\n\n    let offset = 0;\n\n    for (let i = 0; i < uboElements.length; i++)\n    {\n        const uboElement = uboElements[i];\n\n        let size = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].size;\n        const align = WGSL_ALIGN_SIZE_DATA[uboElement.data.type].align;\n\n        if (!WGSL_ALIGN_SIZE_DATA[uboElement.data.type])\n        {\n            throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${uboElement.data.type}`);\n        }\n\n        if (uboElement.data.size > 1)\n        {\n            size = Math.max(size, align) * uboElement.data.size;\n        }\n\n        offset = Math.ceil((offset) / align) * align;\n\n        // TODO deal with Arrays\n        uboElement.size = size;\n\n        uboElement.offset = offset;\n\n        offset += size;\n    }\n\n    // must align to 16 bits!\n    offset = Math.ceil(offset / 16) * 16;\n\n    return { uboElements, size: offset };\n}\n\n", "import { WGSL_ALIGN_SIZE_DATA } from './createUboElementsWGSL';\n\nimport type { UboElement } from '../../../shared/shader/types';\n\n/**\n * This generates a function that will sync an array to the uniform buffer\n * following the wgsl layout\n * @param uboElement - the element to generate the array sync for\n * @param offsetToAdd - the offset to append at the start of the code\n * @returns - the generated code\n */\nexport function generateArraySyncWGSL(uboElement: UboElement, offsetToAdd: number): string\n{\n    // this is in byte..\n    const { size, align } = WGSL_ALIGN_SIZE_DATA[uboElement.data.type];\n\n    const remainder = (align - size) / 4;\n    const data = uboElement.data.type.indexOf('i32') >= 0 ? 'dataInt32' : 'data';\n\n    return `\n         v = uv.${uboElement.data.name};\n         ${offsetToAdd !== 0 ? `offset += ${offsetToAdd};` : ''}\n\n         arrayOffset = offset;\n\n         t = 0;\n\n         for(var i=0; i < ${uboElement.data.size * (size / 4)}; i++)\n         {\n             for(var j = 0; j < ${size / 4}; j++)\n             {\n                 ${data}[arrayOffset++] = v[t++];\n             }\n             ${remainder !== 0 ? `arrayOffset += ${remainder};` : ''}\n         }\n     `;\n}\n", "import { createUboSyncFunction } from '../../../shared/shader/utils/createUboSyncFunction';\nimport { uboSyncFunctionsWGSL } from '../../../shared/shader/utils/uboSyncFunctions';\nimport { generateArraySyncWGSL } from './generateArraySyncWGSL';\n\nimport type { UboElement, UniformsSyncCallback } from '../../../shared/shader/types';\n\nexport function createUboSyncFunctionWGSL(\n    uboElements: UboElement[],\n): UniformsSyncCallback\n{\n    return createUboSyncFunction(\n        uboElements,\n        'uboWgsl',\n        generateArraySyncWGSL,\n        uboSyncFunctionsWGSL,\n    );\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { UboSystem } from '../shared/shader/UboSystem';\nimport { createUboElementsWGSL } from './shader/utils/createUboElementsWGSL';\nimport { createUboSyncFunctionWGSL } from './shader/utils/createUboSyncFunctionWGSL';\n\n/**\n * System plugin to the renderer to manage uniform buffers. With a WGSL twist!\n * @memberof rendering\n */\nexport class GpuUboSystem extends UboSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'ubo',\n    } as const;\n\n    constructor()\n    {\n        super({\n            createUboElements: createUboElementsWGSL,\n            generateUboSync: createUboSyncFunctionWGSL,\n        });\n    }\n}\n", "export class UboBatch\n{\n    public data: Float32Array;\n    private readonly _minUniformOffsetAlignment: number = 256;\n\n    public byteIndex = 0;\n\n    constructor({ minUniformOffsetAlignment }: {minUniformOffsetAlignment: number})\n    {\n        this._minUniformOffsetAlignment = minUniformOffsetAlignment;\n        this.data = new Float32Array(65535);\n    }\n\n    public clear(): void\n    {\n        this.byteIndex = 0;\n    }\n\n    public addEmptyGroup(size: number): number\n    {\n        // update the buffer.. only float32 for now!\n        if (size > this._minUniformOffsetAlignment / 4)\n        {\n            throw new Error(`UniformBufferBatch: array is too large: ${size * 4}`);\n        }\n\n        const start = this.byteIndex;\n\n        let newSize = start + (size * 4);\n\n        newSize = Math.ceil(newSize / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment;\n\n        if (newSize > this.data.length * 4)\n        {\n            // TODO push a new buffer\n            throw new Error('UniformBufferBatch: ubo batch got too big');\n        }\n\n        this.byteIndex = newSize;\n\n        return start;\n    }\n\n    public addGroup(array: Float32Array): number\n    {\n        const offset = this.addEmptyGroup(array.length);\n\n        for (let i = 0; i < array.length; i++)\n        {\n            this.data[(offset / 4) + i] = array[i];\n        }\n\n        return offset;\n    }\n\n    public destroy()\n    {\n        this.data = null;\n    }\n}\n", "import { ExtensionType } from '../../../extensions/Extensions';\nimport { Buffer } from '../shared/buffer/Buffer';\nimport { BufferResource } from '../shared/buffer/BufferResource';\nimport { BufferUsage } from '../shared/buffer/const';\nimport { UboBatch } from './buffer/UboBatch';\nimport { BindGroup } from './shader/BindGroup';\n\nimport type { UniformGroup } from '../shared/shader/UniformGroup';\nimport type { WebGPURenderer } from './WebGPURenderer';\n\nconst minUniformOffsetAlignment = 128;// 256 / 2;\n\n// TODO renderStart and renderFinish - perhaps just make them instructions to fit the architecture of the\n// rest of the system\nexport class GpuUniformBatchPipe\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUPipes,\n        ],\n        name: 'uniformBatch',\n    } as const;\n\n    private _renderer: WebGPURenderer;\n\n    private _bindGroupHash: Record<number, BindGroup> = Object.create(null);\n    private readonly _batchBuffer: UboBatch;\n\n    // number of buffers..\n    private _buffers: Buffer[] = [];\n\n    private _bindGroups: BindGroup[] = [];\n    private _bufferResources: BufferResource[] = [];\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        this._renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n\n        this._batchBuffer = new UboBatch({ minUniformOffsetAlignment });\n\n        const totalBuffers = (256 / minUniformOffsetAlignment);\n\n        for (let i = 0; i < totalBuffers; i++)\n        {\n            let usage = BufferUsage.UNIFORM | BufferUsage.COPY_DST;\n\n            if (i === 0) usage |= BufferUsage.COPY_SRC;\n\n            this._buffers.push(new Buffer({\n                data: this._batchBuffer.data,\n                usage\n            }));\n        }\n    }\n\n    public renderEnd()\n    {\n        this._uploadBindGroups();\n        this._resetBindGroups();\n    }\n\n    private _resetBindGroups()\n    {\n        for (const i in this._bindGroupHash)\n        {\n            this._bindGroupHash[i] = null;\n        }\n\n        this._batchBuffer.clear();\n    }\n\n    // just works for single bind groups for now\n    public getUniformBindGroup(group: UniformGroup<any>, duplicate: boolean): BindGroup\n    {\n        if (!duplicate && this._bindGroupHash[group.uid])\n        {\n            return this._bindGroupHash[group.uid];\n        }\n\n        this._renderer.ubo.ensureUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addEmptyGroup(data.length);\n\n        this._renderer.ubo.syncUniformGroup(group, this._batchBuffer.data, offset / 4);\n\n        this._bindGroupHash[group.uid] = this._getBindGroup(offset / minUniformOffsetAlignment);\n\n        return this._bindGroupHash[group.uid];\n    }\n\n    public getUboResource(group: UniformGroup<any>): BufferResource\n    {\n        this._renderer.ubo.updateUniformGroup(group);\n\n        const data = group.buffer.data as Float32Array;\n\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBufferResource(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBindGroup(data: Float32Array): BindGroup\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        return this._getBindGroup(offset / minUniformOffsetAlignment);\n    }\n\n    public getArrayBufferResource(data: Float32Array): BufferResource\n    {\n        const offset = this._batchBuffer.addGroup(data);\n\n        const index = offset / minUniformOffsetAlignment;\n\n        return this._getBufferResource(index);\n    }\n\n    private _getBufferResource(index: number): BufferResource\n    {\n        if (!this._bufferResources[index])\n        {\n            const buffer = this._buffers[index % 2];\n\n            this._bufferResources[index] = new BufferResource({\n                buffer,\n                offset: ((index / 2) | 0) * 256,\n                size: minUniformOffsetAlignment\n            });\n        }\n\n        return this._bufferResources[index];\n    }\n\n    private _getBindGroup(index: number): BindGroup\n    {\n        if (!this._bindGroups[index])\n        {\n            // even!\n            const bindGroup = new BindGroup({\n                0: this._getBufferResource(index),\n            });\n\n            this._bindGroups[index] = bindGroup;\n        }\n\n        return this._bindGroups[index];\n    }\n\n    private _uploadBindGroups()\n    {\n        const bufferSystem = this._renderer.buffer;\n\n        const firstBuffer = this._buffers[0];\n\n        firstBuffer.update(this._batchBuffer.byteIndex);\n\n        bufferSystem.updateBuffer(firstBuffer);\n\n        const commandEncoder = this._renderer.gpu.device.createCommandEncoder();\n\n        for (let i = 1; i < this._buffers.length; i++)\n        {\n            const buffer = this._buffers[i];\n\n            commandEncoder.copyBufferToBuffer(\n                bufferSystem.getGPUBuffer(firstBuffer),\n                minUniformOffsetAlignment,\n                bufferSystem.getGPUBuffer(buffer),\n                0,\n                this._batchBuffer.byteIndex\n            );\n        }\n\n        // TODO make a system that will que up all commands in to one array?\n        this._renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this._bindGroups.length; i++)\n        {\n            this._bindGroups[i].destroy();\n        }\n\n        this._bindGroups = null;\n        this._bindGroupHash = null;\n\n        for (let i = 0; i < this._buffers.length; i++)\n        {\n            this._buffers[i].destroy();\n        }\n        this._buffers = null;\n\n        for (let i = 0; i < this._bufferResources.length; i++)\n        {\n            this._bufferResources[i].destroy();\n        }\n\n        this._bufferResources = null;\n\n        this._batchBuffer.destroy();\n        this._bindGroupHash = null;\n\n        this._renderer = null;\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { warn } from '../../../../utils/logging/warn';\nimport { ensureAttributes } from '../../gl/shader/program/ensureAttributes';\nimport { STENCIL_MODES } from '../../shared/state/const';\nimport { createIdFromString } from '../../shared/utils/createIdFromString';\nimport { GpuStencilModesToPixi } from '../state/GpuStencilModesToPixi';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { State } from '../../shared/state/State';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuRenderTarget } from '../renderTarget/GpuRenderTarget';\nimport type { GpuProgram } from '../shader/GpuProgram';\nimport type { StencilState } from '../state/GpuStencilModesToPixi';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\nconst topologyStringToId = {\n    'point-list': 0,\n    'line-list': 1,\n    'line-strip': 2,\n    'triangle-list': 3,\n    'triangle-strip': 4,\n};\n\n// geometryLayouts = 256; // 8 bits // 256 states // value 0-255;\n// shaderKeys = 256; // 8 bits // 256 states // value 0-255;\n// state = 64; // 6 bits // 64 states // value 0-63;\n// blendMode = 32; // 5 bits // 32 states // value 0-31;\n// topology = 8; // 3 bits // 8 states // value 0-7;\nfunction getGraphicsStateKey(\n    geometryLayout: number,\n    shaderKey: number,\n    state: number,\n    blendMode: number,\n    topology: number,\n): number\n{\n    return (geometryLayout << 24) // Allocate the 8 bits for geometryLayouts at the top\n         | (shaderKey << 16) // Next 8 bits for shaderKeys\n         | (state << 10) // 6 bits for state\n         | (blendMode << 5) // 5 bits for blendMode\n         | topology; // And 3 bits for topology at the least significant position\n}\n\n// colorMask = 16;// 4 bits // 16 states // value 0-15;\n// stencilState = 8; // 3 bits // 8 states // value 0-7;\n// renderTarget = 1; // 2 bit // 3 states // value 0-3; // none, stencil, depth, depth-stencil\n// multiSampleCount = 1; // 1 bit // 2 states // value 0-1;\nfunction getGlobalStateKey(\n    stencilStateId: number,\n    multiSampleCount: number,\n    colorMask: number,\n    renderTarget: number,\n): number\n{\n    return (colorMask << 6) // Allocate the 4 bits for colorMask at the top\n         | (stencilStateId << 3) // Next 3 bits for stencilStateId\n         | (renderTarget << 1) // 2 bits for renderTarget\n         | multiSampleCount; // And 1 bit for multiSampleCount at the least significant position\n}\n\ntype PipeHash = Record<number, GPURenderPipeline>;\n\n/**\n * A system that creates and manages the GPU pipelines.\n *\n * Caching Mechanism: At its core, the system employs a two-tiered caching strategy to minimize\n * the redundant creation of GPU pipelines (or \"pipes\"). This strategy is based on generating unique\n * keys that represent the state of the graphics settings and the specific requirements of the\n * item being rendered. By caching these pipelines, subsequent draw calls with identical configurations\n * can reuse existing pipelines instead of generating new ones.\n *\n * State Management: The system differentiates between \"global\" state properties (like color masks\n * and stencil masks, which do not change frequently) and properties that may vary between draw calls\n * (such as geometry, shaders, and blend modes). Unique keys are generated for both these categories\n * using getStateKey for global state and getGraphicsStateKey for draw-specific settings. These keys are\n * then then used to caching the pipe. The next time we need a pipe we can check\n * the cache by first looking at the state cache and then the pipe cache.\n * @memberof rendering\n */\nexport class PipelineSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'pipeline',\n    } as const;\n    private readonly _renderer: WebGPURenderer;\n\n    protected CONTEXT_UID: number;\n\n    private _moduleCache: Record<string, GPUShaderModule> = Object.create(null);\n    private _bufferLayoutsCache: Record<number, GPUVertexBufferLayout[]> = Object.create(null);\n    private readonly _bindingNamesCache: Record<string, Record<string, string>> = Object.create(null);\n\n    private _pipeCache: PipeHash = Object.create(null);\n    private readonly _pipeStateCaches: Record<number, PipeHash> = Object.create(null);\n\n    private _gpu: GPU;\n    private _stencilState: StencilState;\n\n    private _stencilMode: STENCIL_MODES;\n    private _colorMask = 0b1111;\n    private _multisampleCount = 1;\n    private _depthStencilAttachment: 0 | 1;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n        this.setStencilMode(STENCIL_MODES.DISABLED);\n\n        this._updatePipeHash();\n    }\n\n    public setMultisampleCount(multisampleCount: number): void\n    {\n        if (this._multisampleCount === multisampleCount) return;\n\n        this._multisampleCount = multisampleCount;\n\n        this._updatePipeHash();\n    }\n\n    public setRenderTarget(renderTarget: GpuRenderTarget)\n    {\n        this._multisampleCount = renderTarget.msaaSamples;\n        this._depthStencilAttachment = renderTarget.descriptor.depthStencilAttachment ? 1 : 0;\n\n        this._updatePipeHash();\n    }\n\n    public setColorMask(colorMask: number): void\n    {\n        if (this._colorMask === colorMask) return;\n\n        this._colorMask = colorMask;\n\n        this._updatePipeHash();\n    }\n\n    public setStencilMode(stencilMode: STENCIL_MODES): void\n    {\n        if (this._stencilMode === stencilMode) return;\n\n        this._stencilMode = stencilMode;\n        this._stencilState = GpuStencilModesToPixi[stencilMode];\n\n        this._updatePipeHash();\n    }\n\n    public setPipeline(geometry: Geometry, program: GpuProgram, state: State, passEncoder: GPURenderPassEncoder): void\n    {\n        const pipeline = this.getPipeline(geometry, program, state);\n\n        passEncoder.setPipeline(pipeline);\n    }\n\n    public getPipeline(\n        geometry: Geometry,\n        program: GpuProgram,\n        state: State,\n        topology?: Topology,\n    ): GPURenderPipeline\n    {\n        if (!geometry._layoutKey)\n        {\n            ensureAttributes(geometry, program.attributeData);\n\n            // prepare the geometry for the pipeline\n            this._generateBufferKey(geometry);\n        }\n\n        topology ||= geometry.topology;\n\n        // now we have set the Ids - the key is different...\n        const key = getGraphicsStateKey(\n            geometry._layoutKey,\n            program._layoutKey,\n            state.data,\n            state._blendModeId,\n            topologyStringToId[topology],\n        );\n\n        if (this._pipeCache[key]) return this._pipeCache[key];\n\n        this._pipeCache[key] = this._createPipeline(geometry, program, state, topology);\n\n        return this._pipeCache[key];\n    }\n\n    private _createPipeline(geometry: Geometry, program: GpuProgram, state: State, topology: Topology): GPURenderPipeline\n    {\n        const device = this._gpu.device;\n\n        const buffers = this._createVertexBufferLayouts(geometry, program);\n\n        const blendModes = this._renderer.state.getColorTargets(state);\n\n        blendModes[0].writeMask = this._stencilMode === STENCIL_MODES.RENDERING_MASK_ADD ? 0 : this._colorMask;\n\n        const layout = this._renderer.shader.getProgramData(program).pipeline;\n\n        const descriptor: GPURenderPipelineDescriptor = {\n            // TODO later check if its helpful to create..\n            // layout,\n            vertex: {\n                module: this._getModule(program.vertex.source),\n                entryPoint: program.vertex.entryPoint,\n                // geometry..\n                buffers,\n            },\n            fragment: {\n                module: this._getModule(program.fragment.source),\n                entryPoint: program.fragment.entryPoint,\n                targets: blendModes,\n            },\n            primitive: {\n                topology,\n                cullMode: state.cullMode,\n            },\n            layout,\n            multisample: {\n                count: this._multisampleCount,\n            },\n            // depthStencil,\n            label: `PIXI Pipeline`,\n        };\n\n        // only apply if the texture has stencil or depth\n        if (this._depthStencilAttachment)\n        {\n            // mask states..\n            descriptor.depthStencil = {\n                ...this._stencilState,\n                format: 'depth24plus-stencil8',\n                depthWriteEnabled: state.depthTest,\n                depthCompare: state.depthTest ? 'less' : 'always',\n            };\n        }\n\n        const pipeline = device.createRenderPipeline(descriptor);\n\n        return pipeline;\n    }\n\n    private _getModule(code: string): GPUShaderModule\n    {\n        return this._moduleCache[code] || this._createModule(code);\n    }\n\n    private _createModule(code: string): GPUShaderModule\n    {\n        const device = this._gpu.device;\n\n        this._moduleCache[code] = device.createShaderModule({\n            code,\n        });\n\n        return this._moduleCache[code];\n    }\n\n    private _generateBufferKey(geometry: Geometry): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(geometry.attributes).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = geometry.attributes[attributeKeys[i]];\n\n            keyGen[index++] = attribute.offset;\n            keyGen[index++] = attribute.format;\n            keyGen[index++] = attribute.stride;\n            keyGen[index++] = attribute.instance;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        geometry._layoutKey = createIdFromString(stringKey, 'geometry');\n\n        return geometry._layoutKey;\n    }\n\n    private _generateAttributeLocationsKey(program: GpuProgram): number\n    {\n        const keyGen = [];\n        let index = 0;\n        // generate a key..\n\n        const attributeKeys = Object.keys(program.attributeData).sort();\n\n        for (let i = 0; i < attributeKeys.length; i++)\n        {\n            const attribute = program.attributeData[attributeKeys[i]];\n\n            keyGen[index++] = attribute.location;\n        }\n\n        const stringKey = keyGen.join('|');\n\n        program._attributeLocationsKey = createIdFromString(stringKey, 'programAttributes');\n\n        return program._attributeLocationsKey;\n    }\n\n    /**\n     * Returns a hash of buffer names mapped to bind locations.\n     * This is used to bind the correct buffer to the correct location in the shader.\n     * @param geometry - The geometry where to get the buffer names\n     * @param program - The program where to get the buffer names\n     * @returns An object of buffer names mapped to the bind location.\n     */\n    public getBufferNamesToBind(geometry: Geometry, program: GpuProgram): Record<string, string>\n    {\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bindingNamesCache[key]) return this._bindingNamesCache[key];\n\n        const data = this._createVertexBufferLayouts(geometry, program);\n\n        // now map the data to the buffers..\n        const bufferNamesToBind: Record<string, string> = Object.create(null);\n\n        const attributeData = program.attributeData;\n\n        for (let i = 0; i < data.length; i++)\n        {\n            const attributes = Object.values(data[i].attributes);\n\n            const shaderLocation = attributes[0].shaderLocation;\n\n            for (const j in attributeData)\n            {\n                if (attributeData[j].location === shaderLocation)\n                {\n                    bufferNamesToBind[i] = j;\n                    break;\n                }\n            }\n        }\n\n        this._bindingNamesCache[key] = bufferNamesToBind;\n\n        return bufferNamesToBind;\n    }\n\n    private _createVertexBufferLayouts(geometry: Geometry, program: GpuProgram): GPUVertexBufferLayout[]\n    {\n        if (!program._attributeLocationsKey) this._generateAttributeLocationsKey(program);\n\n        const key = (geometry._layoutKey << 16) | program._attributeLocationsKey;\n\n        if (this._bufferLayoutsCache[key])\n        {\n            return this._bufferLayoutsCache[key];\n        }\n\n        const vertexBuffersLayout: GPUVertexBufferLayout[] = [];\n\n        geometry.buffers.forEach((buffer) =>\n        {\n            const bufferEntry: GPUVertexBufferLayout = {\n                arrayStride: 0,\n                stepMode: 'vertex',\n                attributes: [],\n            };\n\n            const bufferEntryAttributes = bufferEntry.attributes as GPUVertexAttribute[];\n\n            for (const i in program.attributeData)\n            {\n                const attribute = geometry.attributes[i];\n\n                if ((attribute.divisor ?? 1) !== 1)\n                {\n                    // TODO: Maybe emulate divisor with storage_buffers/float_textures?\n                    // For now just issue a warning\n                    warn(`Attribute ${i} has an invalid divisor value of '${attribute.divisor}'. `\n                        + 'WebGPU only supports a divisor value of 1');\n                }\n\n                if (attribute.buffer === buffer)\n                {\n                    bufferEntry.arrayStride = attribute.stride;\n                    bufferEntry.stepMode = attribute.instance ? 'instance' : 'vertex';\n\n                    bufferEntryAttributes.push({\n                        shaderLocation: program.attributeData[i].location,\n                        offset: attribute.offset,\n                        format: attribute.format,\n                    });\n                }\n            }\n\n            if (bufferEntryAttributes.length)\n            {\n                vertexBuffersLayout.push(bufferEntry);\n            }\n        });\n\n        this._bufferLayoutsCache[key] = vertexBuffersLayout;\n\n        return vertexBuffersLayout;\n    }\n\n    private _updatePipeHash(): void\n    {\n        const key = getGlobalStateKey(\n            this._stencilMode,\n            this._multisampleCount,\n            this._colorMask,\n            this._depthStencilAttachment\n        );\n\n        if (!this._pipeStateCaches[key])\n        {\n            this._pipeStateCaches[key] = Object.create(null);\n        }\n\n        this._pipeCache = this._pipeStateCaches[key];\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n        this._bufferLayoutsCache = null;\n    }\n}\n", "import type { TextureSource } from '../../shared/texture/sources/TextureSource';\n\n/**\n * A class which holds the canvas contexts and textures for a render target.\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTarget\n{\n    public contexts: GPUCanvasContext[] = [];\n    public msaaTextures: TextureSource[] = [];\n    public msaa: boolean;\n    public msaaSamples = 1;\n    public width: number;\n    public height: number;\n    public descriptor: GPURenderPassDescriptor;\n}\n", "import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always false for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (CanvasSource.test(colorTexture.resource))\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public destroyGpuRenderTarget(gpuRenderTarget: GpuRenderTarget)\n    {\n        gpuRenderTarget.contexts.forEach((context) =>\n        {\n            context.unconfigure();\n        });\n\n        gpuRenderTarget.msaaTextures.forEach((texture) =>\n        {\n            texture.destroy();\n        });\n\n        gpuRenderTarget.msaaTextures.length = 0;\n        gpuRenderTarget.contexts.length = 0;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport { GpuRenderTargetAdaptor } from './GpuRenderTargetAdaptor';\n\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuRenderTarget } from './GpuRenderTarget';\n\n/**\n * The WebGL adaptor for the render target system. Allows the Render Target System to be used with the WebGl renderer\n * @memberof rendering\n */\nexport class GpuRenderTargetSystem extends RenderTargetSystem<GpuRenderTarget>\n{\n    /** @ignore */\n    public static extension = {\n        type: [ExtensionType.WebGPUSystem],\n        name: 'renderTarget',\n    } as const;\n\n    public adaptor = new GpuRenderTargetAdaptor();\n\n    constructor(renderer: WebGPURenderer)\n    {\n        super(renderer);\n\n        this.adaptor.init(renderer, this);\n    }\n}\n", "import { ExtensionType } from '../../../../extensions/Extensions';\n\nimport type { ShaderSystem } from '../../shared/shader/ShaderSystem';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { GpuProgram } from './GpuProgram';\n\nexport interface GPUProgramData\n{\n    bindGroups: GPUBindGroupLayout[]\n    pipeline: GPUPipelineLayout\n}\n\n/**\n * A system that manages the rendering of GpuPrograms.\n * @memberof rendering\n */\nexport class GpuShaderSystem implements ShaderSystem\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'shader',\n    } as const;\n\n    public maxTextures: number;\n\n    private _gpu: GPU;\n\n    private readonly _gpuProgramData: Record<number, GPUProgramData> = Object.create(null);\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n\n        this.maxTextures = gpu.device.limits.maxSampledTexturesPerShaderStage;\n    }\n\n    public getProgramData(program: GpuProgram)\n    {\n        return this._gpuProgramData[program._layoutKey] || this._createGPUProgramData(program);\n    }\n\n    private _createGPUProgramData(program: GpuProgram)\n    {\n        const device = this._gpu.device;\n\n        const bindGroups = program.gpuLayout.map((group) => device.createBindGroupLayout({ entries: group }));\n\n        const pipelineLayoutDesc = { bindGroupLayouts: bindGroups };\n\n        this._gpuProgramData[program._layoutKey] = {\n            bindGroups,\n            pipeline: device.createPipelineLayout(pipelineLayoutDesc),\n        };\n\n        // generally we avoid having to make this automatically\n        // keeping this for a reminder, if any issues popup\n        // program._gpuLayout = {\n        //     bindGroups: null,\n        //     pipeline: 'auto',\n        // };\n\n        return this._gpuProgramData[program._layoutKey];\n    }\n\n    public destroy(): void\n    {\n        // TODO destroy the _gpuProgramData\n        this._gpu = null;\n        (this._gpuProgramData as null) = null;\n    }\n}\n", "import type { BLEND_MODES } from '../../shared/state/const';\n\nexport const GpuBlendModesToPixi: Partial<Record<BLEND_MODES, GPUBlendState>> = {};\n\nGpuBlendModesToPixi.normal = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.add = {\n    alpha: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.multiply = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'dst',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.screen = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.overlay = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.none = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'zero',\n        operation: 'add',\n    },\n};\n\n// not-premultiplied blend modes\nGpuBlendModesToPixi['normal-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['add-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi['screen-npm'] = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'src-alpha',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.erase = {\n    alpha: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src-alpha',\n        operation: 'add',\n    },\n    color: {\n        srcFactor: 'zero',\n        dstFactor: 'one-minus-src',\n        operation: 'add',\n    },\n};\n\nGpuBlendModesToPixi.min = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'min',\n    },\n};\n\nGpuBlendModesToPixi.max = {\n    alpha: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n    color: {\n        srcFactor: 'one',\n        dstFactor: 'one',\n        operation: 'max',\n    },\n};\n\n// composite operations\n// GpuBlendModesToPixi[BLEND_MODES.SRC_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'zero',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.SRC_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OVER] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_IN] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_OUT] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'zero',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.DST_ATOP] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// GpuBlendModesToPixi[BLEND_MODES.XOR] = {\n//     alpha: {\n//         srcFactor: 'src-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n\n// TODO - fix me\n// GLBlendModesToPixi[BLEND_MODES.SUBTRACT] = {\n//     alpha: {\n//         srcFactor: 'one',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n//     color: {\n//         srcFactor: 'one-minus-dst-alpha',\n//         dstFactor: 'one-minus-src-alpha',\n//         operation: 'add',\n//     },\n// };\n", "import { ExtensionType } from '../../../../extensions/Extensions';\nimport { State } from '../../shared/state/State';\nimport { GpuBlendModesToPixi } from './GpuBlendModesToPixi';\n\nimport type { BLEND_MODES } from '../../shared/state/const';\nimport type { System } from '../../shared/system/System';\nimport type { GPU } from '../GpuDeviceSystem';\n\n/**\n * System plugin to the renderer to manage WebGL state machines.\n * @memberof rendering\n */\nexport class GpuStateSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'state',\n    } as const;\n    /**\n     * State ID\n     * @readonly\n     */\n    public stateId: number;\n\n    /**\n     * Polygon offset\n     * @readonly\n     */\n    public polygonOffset: number;\n\n    /**\n     * Blend mode\n     * @default 'none'\n     * @readonly\n     */\n    public blendMode: BLEND_MODES;\n\n    /** Whether current blend equation is different */\n    protected _blendEq: boolean;\n\n    /**\n     * GL context\n     * @member {WebGLRenderingContext}\n     * @readonly\n     */\n    protected gpu: GPU;\n\n    /**\n     * Default WebGL State\n     * @readonly\n     */\n    protected defaultState: State;\n\n    constructor()\n    {\n        this.defaultState = new State();\n        this.defaultState.blend = true;\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this.gpu = gpu;\n    }\n\n    /**\n     * Gets the blend mode data for the current state\n     * @param state - The state to get the blend mode from\n     */\n    public getColorTargets(state: State): GPUColorTargetState[]\n    {\n        const blend = GpuBlendModesToPixi[state.blendMode] || GpuBlendModesToPixi.normal;\n\n        return [\n            {\n                format: 'bgra8unorm',\n                writeMask: 0,\n                blend,\n            },\n        ];\n    }\n\n    public destroy(): void\n    {\n        this.gpu = null;\n    }\n}\n", "import type { BufferImageSource } from '../../../shared/texture/sources/BufferImageSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadBufferImageResource = {\n\n    type: 'image',\n\n    upload(source: BufferImageSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource;\n\n        const total = (source.pixelWidth | 0) * (source.pixelHeight | 0);\n\n        const bytesPerPixel = resource.byteLength / total;\n\n        gpu.device.queue.writeTexture(\n            { texture: gpuTexture },\n            resource,\n            {\n                offset: 0,\n                rowsPerImage: source.pixelHeight,\n                bytesPerRow: source.pixelHeight * bytesPerPixel,\n            },\n            {\n                width: source.pixelWidth,\n                height: source.pixelHeight,\n                depthOrArrayLayers: 1,\n            }\n        );\n    }\n} as GpuTextureUploader<BufferImageSource>;\n\n", "import type { CompressedSource } from '../../../shared/texture/sources/CompressedSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const blockDataMap: Record<string, {blockBytes: number, blockWidth: number, blockHeight: number}> = {\n    'bc1-rgba-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'bc2-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc3-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'bc7-rgba-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'etc1-rgb-unorm': { blockBytes: 8, blockWidth: 4, blockHeight: 4 },\n    'etc2-rgba8unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n    'astc-4x4-unorm': { blockBytes: 16, blockWidth: 4, blockHeight: 4 },\n};\n\nconst defaultBlockData = { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\nexport const gpuUploadCompressedTextureResource = {\n\n    type: 'compressed',\n\n    upload(source: CompressedSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        let mipWidth = source.pixelWidth;\n        let mipHeight = source.pixelHeight;\n\n        const blockData = blockDataMap[source.format] || defaultBlockData;\n\n        for (let i = 0; i < source.resource.length; i++)\n        {\n            const levelBuffer = source.resource[i];\n\n            const bytesPerRow = Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockBytes;\n\n            gpu.device.queue.writeTexture(\n                {\n                    texture: gpuTexture,\n                    mipLevel: i\n                },\n                levelBuffer,\n                {\n                    offset: 0,\n                    bytesPerRow,\n                },\n                {\n                    width: Math.ceil(mipWidth / blockData.blockWidth) * blockData.blockWidth,\n                    height: Math.ceil(mipHeight / blockData.blockHeight) * blockData.blockHeight,\n                    depthOrArrayLayers: 1,\n                }\n            );\n\n            mipWidth = Math.max(mipWidth >> 1, 1);\n            mipHeight = Math.max(mipHeight >> 1, 1);\n        }\n    }\n} as GpuTextureUploader<CompressedSource>;\n\n", "import type { TextureSource } from '../../../shared/texture/sources/TextureSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadImageResource = {\n\n    type: 'image',\n\n    upload(source: TextureSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        const resource = source.resource as ImageBitmap | HTMLCanvasElement | OffscreenCanvas;\n\n        if (!resource) return;\n\n        const width = Math.min(gpuTexture.width, source.resourceWidth || source.pixelWidth);\n        const height = Math.min(gpuTexture.height, source.resourceHeight || source.pixelHeight);\n\n        const premultipliedAlpha = source.alphaMode === 'premultiply-alpha-on-upload';\n\n        gpu.device.queue.copyExternalImageToTexture(\n            { source: resource },\n            { texture: gpuTexture, premultipliedAlpha },\n            {\n                width,\n                height,\n            }\n        );\n    }\n} as GpuTextureUploader<TextureSource>;\n\n", "import { gpuUploadImageResource } from './gpuUploadImageSource';\n\nimport type { VideoSource } from '../../../shared/texture/sources/VideoSource';\nimport type { GPU } from '../../GpuDeviceSystem';\nimport type { GpuTextureUploader } from './GpuTextureUploader';\n\nexport const gpuUploadVideoResource = {\n\n    type: 'video',\n\n    upload(source: VideoSource, gpuTexture: GPUTexture, gpu: GPU)\n    {\n        gpuUploadImageResource.upload(source, gpuTexture, gpu);\n    }\n} as GpuTextureUploader<VideoSource>;\n\n", "/**\n * A class which generates mipmaps for a GPUTexture.\n * Thanks to @toji for the original implementation\n * https://github.com/toji/web-texture-tool/blob/main/src/webgpu-mipmap-generator.js\n * @memberof rendering\n * @ignore\n */\nexport class GpuMipmapGenerator\n{\n    public device: GPUDevice;\n    public sampler: GPUSampler;\n    public pipelines: Record<string, GPURenderPipeline>;\n\n    public mipmapShaderModule: any;\n\n    constructor(device: GPUDevice)\n    {\n        this.device = device;\n        this.sampler = device.createSampler({ minFilter: 'linear' });\n        // We'll need a new pipeline for every texture format used.\n        this.pipelines = {};\n    }\n\n    private _getMipmapPipeline(format: GPUTextureFormat)\n    {\n        let pipeline = this.pipelines[format];\n\n        if (!pipeline)\n        {\n            // Shader modules is shared between all pipelines, so only create once.\n            if (!this.mipmapShaderModule)\n            {\n                this.mipmapShaderModule = this.device.createShaderModule({\n                    code: /* wgsl */ `\n                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(\n                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));\n\n                        struct VertexOutput {\n                        @builtin(position) position : vec4<f32>,\n                        @location(0) texCoord : vec2<f32>,\n                        };\n\n                        @vertex\n                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {\n                        var output : VertexOutput;\n                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);\n                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n                        return output;\n                        }\n\n                        @group(0) @binding(0) var imgSampler : sampler;\n                        @group(0) @binding(1) var img : texture_2d<f32>;\n\n                        @fragment\n                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {\n                        return textureSample(img, imgSampler, texCoord);\n                        }\n                    `,\n                });\n            }\n\n            pipeline = this.device.createRenderPipeline({\n                layout: 'auto',\n                vertex: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'vertexMain',\n                },\n                fragment: {\n                    module: this.mipmapShaderModule,\n                    entryPoint: 'fragmentMain',\n                    targets: [{ format }],\n                }\n            });\n\n            this.pipelines[format] = pipeline;\n        }\n\n        return pipeline;\n    }\n\n    /**\n     * Generates mipmaps for the given GPUTexture from the data in level 0.\n     * @param {module:External.GPUTexture} texture - Texture to generate mipmaps for.\n     * @returns {module:External.GPUTexture} - The originally passed texture\n     */\n    public generateMipmap(texture: GPUTexture)\n    {\n        const pipeline = this._getMipmapPipeline(texture.format);\n\n        if (texture.dimension === '3d' || texture.dimension === '1d')\n        {\n            throw new Error('Generating mipmaps for non-2d textures is currently unsupported!');\n        }\n\n        let mipTexture = texture;\n        const arrayLayerCount = texture.depthOrArrayLayers || 1; // Only valid for 2D textures.\n\n        // If the texture was created with RENDER_ATTACHMENT usage we can render directly between mip levels.\n        const renderToSource = texture.usage & GPUTextureUsage.RENDER_ATTACHMENT;\n\n        if (!renderToSource)\n        {\n            // Otherwise we have to use a separate texture to render into. It can be one mip level smaller than the source\n            // texture, since we already have the top level.\n            const mipTextureDescriptor = {\n                size: {\n                    width: Math.ceil(texture.width / 2),\n                    height: Math.ceil(texture.height / 2),\n                    depthOrArrayLayers: arrayLayerCount,\n                },\n                format: texture.format,\n                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,\n                mipLevelCount: texture.mipLevelCount - 1,\n            };\n\n            mipTexture = this.device.createTexture(mipTextureDescriptor);\n        }\n\n        const commandEncoder = this.device.createCommandEncoder({});\n        // TODO: Consider making this static.\n        const bindGroupLayout = pipeline.getBindGroupLayout(0);\n\n        for (let arrayLayer = 0; arrayLayer < arrayLayerCount; ++arrayLayer)\n        {\n            let srcView = texture.createView({\n                baseMipLevel: 0,\n                mipLevelCount: 1,\n                dimension: '2d',\n                baseArrayLayer: arrayLayer,\n                arrayLayerCount: 1,\n            });\n\n            let dstMipLevel = renderToSource ? 1 : 0;\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                const dstView = mipTexture.createView({\n                    baseMipLevel: dstMipLevel++,\n                    mipLevelCount: 1,\n                    dimension: '2d',\n                    baseArrayLayer: arrayLayer,\n                    arrayLayerCount: 1,\n                });\n\n                const passEncoder = commandEncoder.beginRenderPass({\n                    colorAttachments: [{\n                        view: dstView,\n                        storeOp: 'store',\n                        loadOp: 'clear',\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    }],\n                });\n\n                const bindGroup = this.device.createBindGroup({\n                    layout: bindGroupLayout,\n                    entries: [{\n                        binding: 0,\n                        resource: this.sampler,\n                    }, {\n                        binding: 1,\n                        resource: srcView,\n                    }],\n                });\n\n                passEncoder.setPipeline(pipeline);\n                passEncoder.setBindGroup(0, bindGroup);\n                passEncoder.draw(3, 1, 0, 0);\n\n                passEncoder.end();\n\n                srcView = dstView;\n            }\n        }\n\n        // If we didn't render to the source texture, finish by copying the mip results from the temporary mipmap texture\n        // to the source.\n        if (!renderToSource)\n        {\n            const mipLevelSize = {\n                width: Math.ceil(texture.width / 2),\n                height: Math.ceil(texture.height / 2),\n                depthOrArrayLayers: arrayLayerCount,\n            };\n\n            for (let i = 1; i < texture.mipLevelCount; ++i)\n            {\n                commandEncoder.copyTextureToTexture({\n                    texture: mipTexture,\n                    mipLevel: i - 1,\n                }, {\n                    texture,\n                    mipLevel: i,\n                }, mipLevelSize);\n\n                mipLevelSize.width = Math.ceil(mipLevelSize.width / 2);\n                mipLevelSize.height = Math.ceil(mipLevelSize.height / 2);\n            }\n        }\n\n        this.device.queue.submit([commandEncoder.finish()]);\n\n        if (!renderToSource)\n        {\n            mipTexture.destroy();\n        }\n\n        return texture;\n    }\n}\n", "import { DOMAdapter } from '../../../../environment/adapter';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { UniformGroup } from '../../shared/shader/UniformGroup';\nimport { CanvasPool } from '../../shared/texture/CanvasPool';\nimport { BindGroup } from '../shader/BindGroup';\nimport { gpuUploadBufferImageResource } from './uploaders/gpuUploadBufferImageResource';\nimport { blockDataMap, gpuUploadCompressedTextureResource } from './uploaders/gpuUploadCompressedTextureResource';\nimport { gpuUploadImageResource } from './uploaders/gpuUploadImageSource';\nimport { gpuUploadVideoResource } from './uploaders/gpuUploadVideoSource';\nimport { GpuMipmapGenerator } from './utils/GpuMipmapGenerator';\n\nimport type { ICanvas } from '../../../../environment/canvas/ICanvas';\nimport type { System } from '../../shared/system/System';\nimport type { CanvasGenerator, GetPixelsOutput } from '../../shared/texture/GenerateCanvas';\nimport type { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport type { BindableTexture, Texture } from '../../shared/texture/Texture';\nimport type { TextureStyle } from '../../shared/texture/TextureStyle';\nimport type { GPU } from '../GpuDeviceSystem';\nimport type { WebGPURenderer } from '../WebGPURenderer';\nimport type { GpuTextureUploader } from './uploaders/GpuTextureUploader';\n\n/**\n * The system that handles textures for the GPU.\n * @memberof rendering\n */\nexport class GpuTextureSystem implements System, CanvasGenerator\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'texture',\n    } as const;\n\n    public readonly managedTextures: TextureSource[] = [];\n\n    protected CONTEXT_UID: number;\n    private _gpuSources: Record<number, GPUTexture> = Object.create(null);\n    private _gpuSamplers: Record<string, GPUSampler> = Object.create(null);\n    private _bindGroupHash: Record<string, BindGroup> = Object.create(null);\n    private _textureViewHash: Record<string, GPUTextureView> = Object.create(null);\n\n    private readonly _uploads: Record<string, GpuTextureUploader> = {\n        image: gpuUploadImageResource,\n        buffer: gpuUploadBufferImageResource,\n        video: gpuUploadVideoResource,\n        compressed: gpuUploadCompressedTextureResource\n    };\n\n    private _gpu: GPU;\n    private _mipmapGenerator?: GpuMipmapGenerator;\n\n    private readonly _renderer: WebGPURenderer;\n\n    constructor(renderer: WebGPURenderer)\n    {\n        this._renderer = renderer;\n        renderer.renderableGC.addManagedHash(this, '_gpuSources');\n        renderer.renderableGC.addManagedHash(this, '_gpuSamplers');\n        renderer.renderableGC.addManagedHash(this, '_bindGroupHash');\n        renderer.renderableGC.addManagedHash(this, '_textureViewHash');\n    }\n\n    protected contextChange(gpu: GPU): void\n    {\n        this._gpu = gpu;\n    }\n\n    public initSource(source: TextureSource): GPUTexture\n    {\n        if (source.autoGenerateMipmaps)\n        {\n            const biggestDimension = Math.max(source.pixelWidth, source.pixelHeight);\n\n            source.mipLevelCount = Math.floor(Math.log2(biggestDimension)) + 1;\n        }\n\n        let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;\n\n        if (source.uploadMethodId !== 'compressed')\n        {\n            usage |= GPUTextureUsage.RENDER_ATTACHMENT;\n            usage |= GPUTextureUsage.COPY_SRC;\n        }\n\n        const blockData = blockDataMap[source.format] || { blockBytes: 4, blockWidth: 1, blockHeight: 1 };\n\n        const width = Math.ceil(source.pixelWidth / blockData.blockWidth) * blockData.blockWidth;\n        const height = Math.ceil(source.pixelHeight / blockData.blockHeight) * blockData.blockHeight;\n\n        const textureDescriptor: GPUTextureDescriptor = {\n            label: source.label,\n            size: { width, height },\n            format: source.format,\n            sampleCount: source.sampleCount,\n            mipLevelCount: source.mipLevelCount,\n            dimension: source.dimension,\n            usage\n        };\n\n        const gpuTexture = this._gpu.device.createTexture(textureDescriptor);\n\n        this._gpuSources[source.uid] = gpuTexture;\n\n        if (!this.managedTextures.includes(source))\n        {\n            source.on('update', this.onSourceUpdate, this);\n            source.on('resize', this.onSourceResize, this);\n            source.on('destroy', this.onSourceDestroy, this);\n            source.on('unload', this.onSourceUnload, this);\n            source.on('updateMipmaps', this.onUpdateMipmaps, this);\n\n            this.managedTextures.push(source);\n        }\n\n        this.onSourceUpdate(source);\n\n        return gpuTexture;\n    }\n\n    protected onSourceUpdate(source: TextureSource): void\n    {\n        const gpuTexture = this.getGpuSource(source);\n\n        // destroyed!\n        if (!gpuTexture) return;\n\n        if (this._uploads[source.uploadMethodId])\n        {\n            this._uploads[source.uploadMethodId].upload(source, gpuTexture, this._gpu);\n        }\n\n        if (source.autoGenerateMipmaps && source.mipLevelCount > 1)\n        {\n            this.onUpdateMipmaps(source);\n        }\n    }\n\n    protected onSourceUnload(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (gpuTexture)\n        {\n            this._gpuSources[source.uid] = null;\n\n            gpuTexture.destroy();\n        }\n    }\n\n    protected onUpdateMipmaps(source: TextureSource): void\n    {\n        if (!this._mipmapGenerator)\n        {\n            this._mipmapGenerator = new GpuMipmapGenerator(this._gpu.device);\n        }\n\n        const gpuTexture = this.getGpuSource(source);\n\n        this._mipmapGenerator.generateMipmap(gpuTexture);\n    }\n\n    protected onSourceDestroy(source: TextureSource): void\n    {\n        source.off('update', this.onSourceUpdate, this);\n        source.off('unload', this.onSourceUnload, this);\n        source.off('destroy', this.onSourceDestroy, this);\n        source.off('resize', this.onSourceResize, this);\n        source.off('updateMipmaps', this.onUpdateMipmaps, this);\n\n        this.managedTextures.splice(this.managedTextures.indexOf(source), 1);\n\n        this.onSourceUnload(source);\n    }\n\n    protected onSourceResize(source: TextureSource): void\n    {\n        const gpuTexture = this._gpuSources[source.uid];\n\n        if (!gpuTexture)\n        {\n            this.initSource(source);\n        }\n        else if (gpuTexture.width !== source.pixelWidth || gpuTexture.height !== source.pixelHeight)\n        {\n            this._textureViewHash[source.uid] = null;\n            this._bindGroupHash[source.uid] = null;\n\n            this.onSourceUnload(source);\n            this.initSource(source);\n        }\n    }\n\n    private _initSampler(sampler: TextureStyle): GPUSampler\n    {\n        this._gpuSamplers[sampler._resourceId] = this._gpu.device.createSampler(sampler);\n\n        return this._gpuSamplers[sampler._resourceId];\n    }\n\n    public getGpuSampler(sampler: TextureStyle): GPUSampler\n    {\n        return this._gpuSamplers[sampler._resourceId] || this._initSampler(sampler);\n    }\n\n    public getGpuSource(source: TextureSource): GPUTexture\n    {\n        return this._gpuSources[source.uid] || this.initSource(source);\n    }\n\n    /**\n     * this returns s bind group for a specific texture, the bind group contains\n     * - the texture source\n     * - the texture style\n     * - the texture matrix\n     * This is cached so the bind group should only be created once per texture\n     * @param texture - the texture you want the bindgroup for\n     * @returns the bind group for the texture\n     */\n    public getTextureBindGroup(texture: Texture)\n    {\n        return this._bindGroupHash[texture.uid] ?? this._createTextureBindGroup(texture);\n    }\n\n    private _createTextureBindGroup(texture: Texture)\n    {\n        const source = texture.source;\n\n        this._bindGroupHash[texture.uid] = new BindGroup({\n            0: source,\n            1: source.style,\n            2: new UniformGroup({\n                uTextureMatrix: { type: 'mat3x3<f32>', value: texture.textureMatrix.mapCoord },\n            })\n        });\n\n        return this._bindGroupHash[texture.uid];\n    }\n\n    public getTextureView(texture: BindableTexture)\n    {\n        const source = texture.source;\n\n        return this._textureViewHash[source.uid] ?? this._createTextureView(source);\n    }\n\n    private _createTextureView(texture: TextureSource)\n    {\n        this._textureViewHash[texture.uid] = this.getGpuSource(texture).createView();\n\n        return this._textureViewHash[texture.uid];\n    }\n\n    public generateCanvas(texture: Texture): ICanvas\n    {\n        const renderer = this._renderer;\n\n        const commandEncoder = renderer.gpu.device.createCommandEncoder();\n\n        // create canvas\n        const canvas = DOMAdapter.get().createCanvas();\n\n        canvas.width = texture.source.pixelWidth;\n        canvas.height = texture.source.pixelHeight;\n\n        const context = canvas.getContext('webgpu') as unknown as GPUCanvasContext;\n\n        context.configure({\n            device: renderer.gpu.device,\n\n            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,\n            format: DOMAdapter.get().getNavigator().gpu.getPreferredCanvasFormat(),\n            alphaMode: 'premultiplied',\n        });\n\n        commandEncoder.copyTextureToTexture({\n            texture: renderer.texture.getGpuSource(texture.source),\n            origin: {\n                x: 0,\n                y: 0,\n            },\n        }, {\n            texture: context.getCurrentTexture(),\n        }, {\n            width: canvas.width,\n            height: canvas.height,\n        });\n\n        renderer.gpu.device.queue.submit([commandEncoder.finish()]);\n\n        return canvas;\n    }\n\n    public getPixels(texture: Texture): GetPixelsOutput\n    {\n        const webGPUCanvas = this.generateCanvas(texture);\n\n        const canvasAndContext = CanvasPool.getOptimalCanvasAndContext(webGPUCanvas.width, webGPUCanvas.height);\n\n        const context = canvasAndContext.context;\n\n        context.drawImage(webGPUCanvas, 0, 0);\n\n        const { width, height } = webGPUCanvas;\n\n        const imageData = context.getImageData(0, 0, width, height);\n\n        const pixels = new Uint8ClampedArray(imageData.data.buffer);\n\n        CanvasPool.returnCanvasAndContext(canvasAndContext);\n\n        return { pixels, width, height };\n    }\n\n    public destroy(): void\n    {\n        // we copy the array as the aarry with a slice as onSourceDestroy\n        // will remove the source from the real managedTextures array\n        this.managedTextures\n            .slice()\n            .forEach((source) => this.onSourceDestroy(source));\n\n        (this.managedTextures as null) = null;\n\n        for (const k of Object.keys(this._bindGroupHash))\n        {\n            const key = Number(k);\n            const bindGroup = this._bindGroupHash[key];\n\n            bindGroup?.destroy();\n            this._bindGroupHash[key] = null;\n        }\n\n        this._gpu = null;\n        this._mipmapGenerator = null;\n        this._gpuSources = null;\n        this._bindGroupHash = null;\n        this._textureViewHash = null;\n        this._gpuSamplers = null;\n    }\n}\n", "import { extensions, ExtensionType } from '../../../extensions/Extensions';\nimport { GpuGraphicsAdaptor } from '../../../scene/graphics/gpu/GpuGraphicsAdaptor';\nimport { GpuMeshAdapter } from '../../../scene/mesh/gpu/GpuMeshAdapter';\nimport { GpuBatchAdaptor } from '../../batcher/gpu/GpuBatchAdaptor';\nimport { AbstractRenderer } from '../shared/system/AbstractRenderer';\nimport { SharedRenderPipes, SharedSystems } from '../shared/system/SharedSystems';\nimport { RendererType } from '../types';\nimport { BindGroupSystem } from './BindGroupSystem';\nimport { GpuBufferSystem } from './buffer/GpuBufferSystem';\nimport { GpuColorMaskSystem } from './GpuColorMaskSystem';\nimport { type GPU, GpuDeviceSystem } from './GpuDeviceSystem';\nimport { GpuEncoderSystem } from './GpuEncoderSystem';\nimport { GpuStencilSystem } from './GpuStencilSystem';\nimport { GpuUboSystem } from './GpuUboSystem';\nimport { GpuUniformBatchPipe } from './GpuUniformBatchPipe';\nimport { PipelineSystem } from './pipeline/PipelineSystem';\nimport { GpuRenderTargetSystem } from './renderTarget/GpuRenderTargetSystem';\nimport { GpuShaderSystem } from './shader/GpuShaderSystem';\nimport { GpuStateSystem } from './state/GpuStateSystem';\nimport { GpuTextureSystem } from './texture/GpuTextureSystem';\n\nimport type { ICanvas } from '../../../environment/canvas/ICanvas';\nimport type { PipeConstructor } from '../shared/instructions/RenderPipe';\nimport type { SharedRendererOptions } from '../shared/system/SharedSystems';\nimport type { SystemConstructor } from '../shared/system/System';\nimport type { ExtractRendererOptions, ExtractSystemTypes } from '../shared/system/utils/typeUtils';\n\nconst DefaultWebGPUSystems = [\n    ...SharedSystems,\n    GpuUboSystem,\n    GpuEncoderSystem,\n    GpuDeviceSystem,\n    GpuBufferSystem,\n    GpuTextureSystem,\n    GpuRenderTargetSystem,\n    GpuShaderSystem,\n    GpuStateSystem,\n    PipelineSystem,\n    GpuColorMaskSystem,\n    GpuStencilSystem,\n    BindGroupSystem,\n];\nconst DefaultWebGPUPipes = [...SharedRenderPipes, GpuUniformBatchPipe];\nconst DefaultWebGPUAdapters = [GpuBatchAdaptor, GpuMeshAdapter, GpuGraphicsAdaptor];\n\n// installed systems will bbe added to this array by the extensions manager..\nconst systems: { name: string; value: SystemConstructor }[] = [];\nconst renderPipes: { name: string; value: PipeConstructor }[] = [];\nconst renderPipeAdaptors: { name: string; value: any }[] = [];\n\nextensions.handleByNamedList(ExtensionType.WebGPUSystem, systems);\nextensions.handleByNamedList(ExtensionType.WebGPUPipes, renderPipes);\nextensions.handleByNamedList(ExtensionType.WebGPUPipesAdaptor, renderPipeAdaptors);\n\n// add all the default systems as well as any user defined ones from the extensions\nextensions.add(...DefaultWebGPUSystems, ...DefaultWebGPUPipes, ...DefaultWebGPUAdapters);\n\ntype WebGPUSystems = ExtractSystemTypes<typeof DefaultWebGPUSystems> &\nPixiMixins.RendererSystems &\nPixiMixins.WebGPUSystems;\n\nexport type WebGPUPipes = ExtractSystemTypes<typeof DefaultWebGPUPipes> &\nPixiMixins.RendererPipes &\nPixiMixins.WebGPUPipes;\n\n/**\n * Options for WebGPURenderer.\n * @memberof rendering\n */\nexport interface WebGPUOptions extends\n    SharedRendererOptions,\n    ExtractRendererOptions<typeof DefaultWebGPUSystems>,\n    PixiMixins.WebGPUOptions{}\n\nexport interface WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>,\n    WebGPUSystems {}\n\n/* eslint-disable max-len */\n/**\n * The WebGPU PixiJS Renderer. This renderer allows you to use the next-generation graphics API, WebGPU.\n * ```ts\n * // Create a new renderer\n * const renderer = new WebGPURenderer();\n * await renderer.init();\n *\n * // Add the renderer to the stage\n * document.body.appendChild(renderer.canvas);\n *\n * // Create a new stage\n * const stage = new Container();\n *\n * // Render the stage\n * renderer.render(stage);\n * ```\n *\n * You can use {@link rendering.autoDetectRenderer} to create a renderer that will automatically detect the best\n * renderer for the environment.\n * ```ts\n * // Create a new renderer\n * const renderer = await rendering.autoDetectRenderer();\n * ```\n *\n * The renderer is composed of systems that manage specific tasks. The following systems are added by default\n * whenever you create a WebGPU renderer:\n *\n * | WebGPU Core Systems                      | Systems that are specific to the WebGL renderer                               |\n * | ---------------------------------------- | ----------------------------------------------------------------------------- |\n * | {@link rendering.GpuUboSystem}           | This manages WebGPU uniform buffer objects feature for shaders                |\n * | {@link rendering.GpuEncoderSystem}       | This manages the WebGPU command encoder                                       |\n * | {@link rendering.GpuDeviceSystem}        | This manages the WebGPU Device and its extensions                             |\n * | {@link rendering.GpuBufferSystem}        | This manages buffers and their GPU resources, keeps everything in sync        |\n * | {@link rendering.GpuTextureSystem}       | This manages textures and their GPU resources, keeps everything in sync       |\n * | {@link rendering.GpuRenderTargetSystem}  | This manages what we render too. For example the screen, or another texture   |\n * | {@link rendering.GpuShaderSystem}        | This manages shaders, programs that run on the GPU to output lovely pixels    |\n * | {@link rendering.GpuStateSystem}         | This manages the state of the WebGPU Pipelines. eg the various flags that can be set blend modes / depthTesting etc |\n * | {@link rendering.PipelineSystem}         | This manages the WebGPU pipelines, used for rendering                         |\n * | {@link rendering.GpuColorMaskSystem}     | This manages the color mask. Used for color masking                           |\n * | {@link rendering.GpuStencilSystem}       | This manages the stencil buffer. Used primarily for masking                   |\n * | {@link rendering.BindGroupSystem}        | This manages the WebGPU bind groups. this is how data is bound to a shader when rendering |\n *\n * The breadth of the API surface provided by the renderer is contained within these systems.\n * @memberof rendering\n * @property {rendering.GpuUboSystem} ubo - UboSystem instance.\n * @property {rendering.GpuEncoderSystem} encoder - EncoderSystem instance.\n * @property {rendering.GpuDeviceSystem} device - DeviceSystem instance.\n * @property {rendering.GpuBufferSystem} buffer - BufferSystem instance.\n * @property {rendering.GpuTextureSystem} texture - TextureSystem instance.\n * @property {rendering.GpuRenderTargetSystem} renderTarget - RenderTargetSystem instance.\n * @property {rendering.GpuShaderSystem} shader - ShaderSystem instance.\n * @property {rendering.GpuStateSystem} state - StateSystem instance.\n * @property {rendering.PipelineSystem} pipeline - PipelineSystem instance.\n * @property {rendering.GpuColorMaskSystem} colorMask - ColorMaskSystem instance.\n * @property {rendering.GpuStencilSystem} stencil - StencilSystem instance.\n * @property {rendering.BindGroupSystem} bindGroup - BindGroupSystem instance.\n * @extends rendering.AbstractRenderer\n */\nexport class WebGPURenderer<T extends ICanvas = HTMLCanvasElement>\n    extends AbstractRenderer<WebGPUPipes, WebGPUOptions, T>\n    implements WebGPUSystems\n{\n    /** The WebGPU Device. */\n    public gpu: GPU;\n\n    constructor()\n    {\n        const systemConfig = {\n            name: 'webgpu',\n            type: RendererType.WEBGPU,\n            systems,\n            renderPipes,\n            renderPipeAdaptors,\n        };\n\n        super(systemConfig);\n    }\n}\n"],
  "mappings": "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",
  "names": ["GpuGraphicsAdaptor", "localUniforms", "UniformGroup", "Matrix", "gpuProgram", "compileHighShaderGpuProgram", "colorBit", "generateTextureBatchBit", "getMaxTexturesPerBatch", "localUniformBitGroup2", "roundPixelsBit", "Shader", "graphicsPipe", "renderable", "context", "shader", "renderer", "contextSystem", "batcher", "instructions", "encoder", "globalUniformsBindGroup", "localBindGroup", "batches", "topology", "i", "batch", "textureBatch", "getTextureBatchBindGroup", "ExtensionType", "GpuMeshAdapter", "gpuProgram", "compileHighShaderGpuProgram", "localUniformBit", "textureBit", "roundPixelsBit", "Shader", "Texture", "Matrix", "meshPipe", "mesh", "renderer", "shader", "warn", "localUniforms", "ExtensionType", "tempState", "State", "GpuBatchAdaptor", "batchPipe", "geometry", "shader", "renderer", "encoder", "program", "globalUniformsBindGroup", "batch", "textureBatch", "getTextureBatchBindGroup", "gpuBindGroup", "pipeline", "ExtensionType", "BindGroupSystem", "renderer", "gpu", "bindGroup", "program", "groupIndex", "group", "device", "groupLayout", "entries", "j", "resource", "gpuResource", "uniformGroup", "buffer", "bufferResource", "sampler", "texture", "layout", "gpuBindGroup", "key", "ExtensionType", "GpuBufferSystem", "renderer", "gpu", "buffer", "gpuBuffer", "data", "id", "fastCopy", "ExtensionType", "GpuColorMaskSystem", "renderer", "colorMask", "ExtensionType", "GpuDeviceSystem", "renderer", "options", "gpu", "adapter", "DOMAdapter", "requiredFeatures", "feature", "device", "ExtensionType", "GpuEncoderSystem", "renderer", "resolve", "gpuRenderTarget", "viewport", "geometry", "program", "state", "topology", "pipeline", "index", "buffer", "indexFormat", "bindGroup", "gpuBindGroup", "buffersToBind", "i", "shader", "skipSync", "j", "resource", "options", "size", "start", "instanceCount", "descriptor", "boundPipeline", "boundVertexBuffer", "boundIndexBuffer", "boundBindGroup", "gpu", "ExtensionType", "GpuStencilSystem", "renderer", "renderTarget", "stencilState", "STENCIL_MODES", "stencilMode", "stencilReference", "ExtensionType", "WGSL_ALIGN_SIZE_DATA", "createUboElementsWGSL", "uniformData", "uboElements", "data", "offset", "i", "uboElement", "size", "align", "generateArraySyncWGSL", "uboElement", "offsetToAdd", "size", "align", "WGSL_ALIGN_SIZE_DATA", "remainder", "data", "createUboSyncFunctionWGSL", "uboElements", "createUboSyncFunction", "generateArraySyncWGSL", "uboSyncFunctionsWGSL", "GpuUboSystem", "UboSystem", "createUboElementsWGSL", "createUboSyncFunctionWGSL", "ExtensionType", "UboBatch", "minUniformOffsetAlignment", "size", "start", "newSize", "array", "offset", "i", "minUniformOffsetAlignment", "GpuUniformBatchPipe", "renderer", "UboBatch", "totalBuffers", "i", "usage", "BufferUsage", "Buffer", "group", "duplicate", "data", "offset", "index", "buffer", "BufferResource", "bindGroup", "BindGroup", "bufferSystem", "firstBuffer", "commandEncoder", "ExtensionType", "topologyStringToId", "getGraphicsStateKey", "geometryLayout", "shaderKey", "state", "blendMode", "topology", "getGlobalStateKey", "stencilStateId", "multiSampleCount", "colorMask", "renderTarget", "PipelineSystem", "renderer", "gpu", "STENCIL_MODES", "multisampleCount", "stencilMode", "GpuStencilModesToPixi", "geometry", "program", "passEncoder", "pipeline", "ensureAttributes", "key", "device", "buffers", "blendModes", "layout", "descriptor", "code", "keyGen", "index", "attributeKeys", "i", "attribute", "stringKey", "createIdFromString", "data", "bufferNamesToBind", "attributeData", "shaderLocation", "j", "vertexBuffersLayout", "buffer", "bufferEntry", "bufferEntryAttributes", "warn", "ExtensionType", "GpuRenderTarget", "GpuRenderTargetAdaptor", "renderer", "renderTargetSystem", "sourceRenderSurfaceTexture", "destinationTexture", "originSrc", "size", "originDest", "baseGpuTexture", "backGpuTexture", "renderTarget", "clear", "clearColor", "viewport", "gpuRenderTarget", "descriptor", "clearValue", "CLEAR", "colorAttachments", "texture", "i", "context", "view", "resolveTarget", "loadOp", "depthStencilAttachment", "stencilLoadOp", "depthLoadOp", "gpu", "encoder", "device", "commandEncoder", "renderPassDescriptor", "passEncoder", "gpuCommands", "GpuRenderTarget", "colorTexture", "CanvasSource", "alphaMode", "e", "msaaTexture", "TextureSource", "GpuRenderTargetSystem", "RenderTargetSystem", "renderer", "GpuRenderTargetAdaptor", "ExtensionType", "GpuShaderSystem", "gpu", "program", "device", "bindGroups", "group", "pipelineLayoutDesc", "ExtensionType", "GpuBlendModesToPixi", "GpuStateSystem", "State", "gpu", "state", "GpuBlendModesToPixi", "ExtensionType", "gpuUploadBufferImageResource", "source", "gpuTexture", "gpu", "resource", "total", "bytesPerPixel", "blockDataMap", "defaultBlockData", "gpuUploadCompressedTextureResource", "source", "gpuTexture", "gpu", "mipWidth", "mipHeight", "blockData", "i", "levelBuffer", "bytesPerRow", "gpuUploadImageResource", "source", "gpuTexture", "gpu", "resource", "width", "height", "premultipliedAlpha", "gpuUploadVideoResource", "source", "gpuTexture", "gpu", "gpuUploadImageResource", "GpuMipmapGenerator", "device", "format", "pipeline", "texture", "mipTexture", "arrayLayerCount", "renderToSource", "mipTextureDescriptor", "commandEncoder", "bindGroupLayout", "arrayLayer", "srcView", "dstMipLevel", "i", "dstView", "passEncoder", "bindGroup", "mipLevelSize", "GpuTextureSystem", "renderer", "gpuUploadImageResource", "gpuUploadBufferImageResource", "gpuUploadVideoResource", "gpuUploadCompressedTextureResource", "gpu", "source", "biggestDimension", "usage", "blockData", "blockDataMap", "width", "height", "textureDescriptor", "gpuTexture", "GpuMipmapGenerator", "sampler", "texture", "BindGroup", "UniformGroup", "commandEncoder", "canvas", "DOMAdapter", "context", "webGPUCanvas", "canvasAndContext", "CanvasPool", "imageData", "pixels", "k", "key", "ExtensionType", "DefaultWebGPUSystems", "SharedSystems", "GpuUboSystem", "GpuEncoderSystem", "GpuDeviceSystem", "GpuBufferSystem", "GpuTextureSystem", "GpuRenderTargetSystem", "GpuShaderSystem", "GpuStateSystem", "PipelineSystem", "GpuColorMaskSystem", "GpuStencilSystem", "BindGroupSystem", "DefaultWebGPUPipes", "SharedRenderPipes", "GpuUniformBatchPipe", "DefaultWebGPUAdapters", "GpuBatchAdaptor", "GpuMeshAdapter", "GpuGraphicsAdaptor", "systems", "renderPipes", "renderPipeAdaptors", "extensions", "ExtensionType", "WebGPURenderer", "AbstractRenderer", "systemConfig", "RendererType"]
}
