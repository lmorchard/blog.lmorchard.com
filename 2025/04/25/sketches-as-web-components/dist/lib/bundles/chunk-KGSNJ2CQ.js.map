{
  "version": 3,
  "sources": ["../../../node_modules/pixi.js/src/events/FederatedEvent.ts", "../../../node_modules/ismobilejs/src/isMobile.ts", "../../../node_modules/pixi.js/src/utils/browser/isMobile.ts", "../../../node_modules/pixi.js/src/accessibility/AccessibilitySystem.ts", "../../../node_modules/pixi.js/src/accessibility/accessibilityTarget.ts", "../../../node_modules/pixi.js/src/events/EventTicker.ts", "../../../node_modules/pixi.js/src/events/FederatedMouseEvent.ts", "../../../node_modules/pixi.js/src/events/FederatedPointerEvent.ts", "../../../node_modules/pixi.js/src/events/FederatedWheelEvent.ts", "../../../node_modules/pixi.js/src/events/EventBoundary.ts", "../../../node_modules/pixi.js/src/events/EventSystem.ts", "../../../node_modules/pixi.js/src/events/FederatedEventTarget.ts", "../../../node_modules/pixi.js/src/dom/DOMPipe.ts"],
  "sourcesContent": ["import { Point } from '../maths/point/Point';\n\nimport type { Container } from '../scene/container/Container';\nimport type { EventBoundary } from './EventBoundary';\n\n/**\n * A PixiJS compatible {@code Touch} event.\n * @memberof events\n */\nexport interface PixiTouch extends Touch\n{\n    button: number;\n    buttons: number;\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    layerX: number;\n    layerY: number;\n    offsetX: number;\n    offsetY: number;\n    isNormalized: boolean;\n    type: string;\n}\n\n/**\n * An DOM-compatible synthetic event implementation that is \"forwarded\" on behalf of an original\n * FederatedEvent or native {@link https://dom.spec.whatwg.org/#event Event}.\n * @typeParam N - The type of native event held.\n * @memberof events\n */\nexport class FederatedEvent<N extends UIEvent | PixiTouch = UIEvent | PixiTouch> implements UIEvent\n{\n    /** Flags whether this event bubbles. This will take effect only if it is set before propagation. */\n    public bubbles = true;\n\n    /** @deprecated since 7.0.0 */\n    public cancelBubble = true;\n\n    /**\n     * Flags whether this event can be canceled using {@link FederatedEvent.preventDefault}. This is always\n     * false (for now).\n     */\n    public readonly cancelable = false;\n\n    /**\n     * Flag added for compatibility with DOM {@code Event}. It is not used in the Federated Events\n     * API.\n     * @see https://dom.spec.whatwg.org/#dom-event-composed\n     */\n    public readonly composed = false;\n\n    /** The listeners of the event target that are being notified. */\n    public currentTarget: Container;\n\n    /** Flags whether the default response of the user agent was prevent through this event. */\n    public defaultPrevented = false;\n\n    /**\n     * The propagation phase.\n     * @default {@link FederatedEvent.NONE}\n     */\n    public eventPhase = FederatedEvent.prototype.NONE;\n\n    /** Flags whether this is a user-trusted event */\n    public isTrusted: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public returnValue: boolean;\n\n    /** @deprecated since 7.0.0 */\n    public srcElement: EventTarget;\n\n    /** The event target that this will be dispatched to. */\n    public target: Container;\n\n    /** The timestamp of when the event was created. */\n    public timeStamp: number;\n\n    /** The type of event, e.g. {@code \"mouseup\"}. */\n    public type: string;\n\n    /** The native event that caused the foremost original event. */\n    public nativeEvent: N;\n\n    /** The original event that caused this event, if any. */\n    public originalEvent: FederatedEvent<N>;\n\n    /** Flags whether propagation was stopped. */\n    public propagationStopped = false;\n\n    /** Flags whether propagation was immediately stopped. */\n    public propagationImmediatelyStopped = false;\n\n    /** The composed path of the event's propagation. The {@code target} is at the end. */\n    public path: Container[];\n\n    /** The {@link EventBoundary} that manages this event. Null for root events. */\n    public readonly manager: EventBoundary;\n\n    /** Event-specific detail */\n    public detail: number;\n\n    /** The global Window object. */\n    public view: WindowProxy;\n\n    /**\n     * Not supported.\n     * @deprecated since 7.0.0\n     */\n    public which: number;\n\n    /** The coordinates of the event relative to the nearest DOM layer. This is a non-standard property. */\n    public layer: Point = new Point();\n\n    /** @readonly */\n    get layerX(): number { return this.layer.x; }\n\n    /** @readonly */\n    get layerY(): number { return this.layer.y; }\n\n    /** The coordinates of the event relative to the DOM document. This is a non-standard property. */\n    public page: Point = new Point();\n\n    /** @readonly */\n    get pageX(): number { return this.page.x; }\n\n    /** @readonly */\n    get pageY(): number { return this.page.y; }\n\n    /**\n     * @param manager - The event boundary which manages this event. Propagation can only occur\n     *  within the boundary's jurisdiction.\n     */\n    constructor(manager: EventBoundary)\n    {\n        this.manager = manager;\n    }\n\n    /**\n     * Fallback for the deprecated @code{InteractionEvent.data}.\n     * @deprecated since 7.0.0\n     */\n    get data(): this\n    {\n        return this;\n    }\n\n    /** The propagation path for this event. Alias for {@link EventBoundary.propagationPath}. */\n    public composedPath(): Container[]\n    {\n        // Find the propagation path if it isn't cached or if the target has changed since since\n        // the last evaluation.\n        if (this.manager && (!this.path || this.path[this.path.length - 1] !== this.target))\n        {\n            this.path = this.target ? this.manager.propagationPath(this.target) : [];\n        }\n\n        return this.path;\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code Event}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _type\n     * @param _bubbles\n     * @param _cancelable\n     */\n    public initEvent(_type: string, _bubbles?: boolean, _cancelable?: boolean): void\n    {\n        throw new Error('initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /**\n     * Unimplemented method included for implementing the DOM interface {@code UIEvent}. It will throw an {@code Error}.\n     * @deprecated\n     * @param _typeArg\n     * @param _bubblesArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     */\n    public initUIEvent(_typeArg: string, _bubblesArg?: boolean, _cancelableArg?: boolean, _viewArg?: Window | null,\n        _detailArg?: number): void\n    {\n        throw new Error('initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.');\n    }\n\n    /** Prevent default behavior of PixiJS and the user agent. */\n    public preventDefault(): void\n    {\n        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable)\n        {\n            this.nativeEvent.preventDefault();\n        }\n\n        this.defaultPrevented = true;\n    }\n\n    /**\n     * Stop this event from propagating to any addition listeners, including on the\n     * {@link FederatedEventTarget.currentTarget currentTarget} and also the following\n     * event targets on the propagation path.\n     */\n    public stopImmediatePropagation(): void\n    {\n        this.propagationImmediatelyStopped = true;\n    }\n\n    /**\n     * Stop this event from propagating to the next {@link FederatedEventTarget}. The rest of the listeners\n     * on the {@link FederatedEventTarget.currentTarget currentTarget} will still be notified.\n     */\n    public stopPropagation(): void\n    {\n        this.propagationStopped = true;\n    }\n\n    public readonly NONE = 0;\n    public readonly CAPTURING_PHASE = 1;\n    public readonly AT_TARGET = 2;\n    public readonly BUBBLING_PHASE = 3;\n}\n", "const appleIphone = /iPhone/i;\nconst appleIpod = /iPod/i;\nconst appleTablet = /iPad/i;\nconst appleUniversal = /\\biOS-universal(?:.+)Mac\\b/i;\nconst androidPhone = /\\bAndroid(?:.+)Mobile\\b/i; // Match 'Android' AND 'Mobile'\nconst androidTablet = /Android/i;\nconst amazonPhone = /(?:SD4930UR|\\bSilk(?:.+)Mobile\\b)/i; // Match 'Silk' AND 'Mobile'\nconst amazonTablet = /Silk/i;\nconst windowsPhone = /Windows Phone/i;\nconst windowsTablet = /\\bWindows(?:.+)ARM\\b/i; // Match 'Windows' AND 'ARM'\nconst otherBlackBerry = /BlackBerry/i;\nconst otherBlackBerry10 = /BB10/i;\nconst otherOpera = /Opera Mini/i;\nconst otherChrome = /\\b(CriOS|Chrome)(?:.+)Mobile/i;\nconst otherFirefox = /Mobile(?:.+)Firefox\\b/i; // Match 'Mobile' AND 'Firefox'\n\nexport type UserAgent = string;\nexport type Navigator = {\n  userAgent: string;\n  platform: string;\n  maxTouchPoints?: number;\n};\n\nconst isAppleTabletOnIos13 = (navigator?: Navigator): boolean => {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.platform === 'MacIntel' &&\n    typeof navigator.maxTouchPoints === 'number' &&\n    navigator.maxTouchPoints > 1 &&\n    typeof MSStream === 'undefined'\n  );\n};\n\nfunction createMatch(userAgent: UserAgent): (regex: RegExp) => boolean {\n  return (regex: RegExp): boolean => regex.test(userAgent);\n}\n\nexport type isMobileResult = {\n  apple: {\n    phone: boolean;\n    ipod: boolean;\n    tablet: boolean;\n    universal: boolean;\n    device: boolean;\n  };\n  amazon: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  android: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  windows: {\n    phone: boolean;\n    tablet: boolean;\n    device: boolean;\n  };\n  other: {\n    blackberry: boolean;\n    blackberry10: boolean;\n    opera: boolean;\n    firefox: boolean;\n    chrome: boolean;\n    device: boolean;\n  };\n  phone: boolean;\n  tablet: boolean;\n  any: boolean;\n};\n\nexport type IsMobileParameter = UserAgent | Navigator;\n\nexport default function isMobile(param?: IsMobileParameter): isMobileResult {\n  let nav: Navigator = {\n    userAgent: '',\n    platform: '',\n    maxTouchPoints: 0,\n  };\n\n  if (!param && typeof navigator !== 'undefined') {\n    nav = {\n      userAgent: navigator.userAgent,\n      platform: navigator.platform,\n      maxTouchPoints: navigator.maxTouchPoints || 0,\n    };\n  } else if (typeof param === 'string') {\n    nav.userAgent = param;\n  } else if (param && param.userAgent) {\n    nav = {\n      userAgent: param.userAgent,\n      platform: param.platform,\n      maxTouchPoints: param.maxTouchPoints || 0,\n    };\n  }\n\n  let userAgent = nav.userAgent;\n\n  // Facebook mobile app's integrated browser adds a bunch of strings that\n  // match everything. Strip it out if it exists.\n  let tmp = userAgent.split('[FBAN');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  // Twitter mobile app's integrated browser on iPad adds a \"Twitter for\n  // iPhone\" string. Same probably happens on other tablet platforms.\n  // This will confuse detection so strip it out if it exists.\n  tmp = userAgent.split('Twitter');\n  if (typeof tmp[1] !== 'undefined') {\n    userAgent = tmp[0];\n  }\n\n  const match = createMatch(userAgent);\n\n  const result: isMobileResult = {\n    apple: {\n      phone: match(appleIphone) && !match(windowsPhone),\n      ipod: match(appleIpod),\n      tablet:\n        !match(appleIphone) &&\n        (match(appleTablet) || isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n      universal: match(appleUniversal),\n      device:\n        (match(appleIphone) ||\n          match(appleIpod) ||\n          match(appleTablet) ||\n          match(appleUniversal) ||\n          isAppleTabletOnIos13(nav)) &&\n        !match(windowsPhone),\n    },\n    amazon: {\n      phone: match(amazonPhone),\n      tablet: !match(amazonPhone) && match(amazonTablet),\n      device: match(amazonPhone) || match(amazonTablet),\n    },\n    android: {\n      phone:\n        (!match(windowsPhone) && match(amazonPhone)) ||\n        (!match(windowsPhone) && match(androidPhone)),\n      tablet:\n        !match(windowsPhone) &&\n        !match(amazonPhone) &&\n        !match(androidPhone) &&\n        (match(amazonTablet) || match(androidTablet)),\n      device:\n        (!match(windowsPhone) &&\n          (match(amazonPhone) ||\n            match(amazonTablet) ||\n            match(androidPhone) ||\n            match(androidTablet))) ||\n        match(/\\bokhttp\\b/i),\n    },\n    windows: {\n      phone: match(windowsPhone),\n      tablet: match(windowsTablet),\n      device: match(windowsPhone) || match(windowsTablet),\n    },\n    other: {\n      blackberry: match(otherBlackBerry),\n      blackberry10: match(otherBlackBerry10),\n      opera: match(otherOpera),\n      firefox: match(otherFirefox),\n      chrome: match(otherChrome),\n      device:\n        match(otherBlackBerry) ||\n        match(otherBlackBerry10) ||\n        match(otherOpera) ||\n        match(otherFirefox) ||\n        match(otherChrome),\n    },\n    any: false,\n    phone: false,\n    tablet: false,\n  };\n\n  result.any =\n    result.apple.device ||\n    result.android.device ||\n    result.windows.device ||\n    result.other.device;\n  // excludes 'other' devices and ipods, targeting touchscreen phones\n  result.phone =\n    result.apple.phone || result.android.phone || result.windows.phone;\n  result.tablet =\n    result.apple.tablet || result.android.tablet || result.windows.tablet;\n\n  return result;\n}\n", "import isMobileJs from 'ismobilejs';\n\n// ismobilejs have different import behavior for CJS and ESM, so here is the hack\ntype isMobileJsType = typeof isMobileJs & { default?: typeof isMobileJs };\nconst isMobileCall = (isMobileJs as isMobileJsType).default ?? isMobileJs;\n\n/**\n * The result of the {@link utils.isMobile} function.\n * @ignore\n * @memberof utils\n */\nexport type isMobileResult = {\n    /**\n     * Whether the device is an Apple device.\n     * @memberof utils.isMobile\n     */\n    apple: {\n        phone: boolean;\n        ipod: boolean;\n        tablet: boolean;\n        universal: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is an Amazon device.\n     * @memberof utils.isMobile\n     */\n    amazon: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is an Android device.\n     * @memberof utils.isMobile\n     */\n    android: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a Windows device.\n     * @memberof utils.isMobile\n     */\n    windows: {\n        phone: boolean;\n        tablet: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a specific device.\n     * @memberof utils.isMobile\n     */\n    other: {\n        blackberry: boolean;\n        blackberry10: boolean;\n        opera: boolean;\n        firefox: boolean;\n        chrome: boolean;\n        device: boolean;\n    };\n    /**\n     * Whether the device is a phone device.\n     * @memberof utils.isMobile\n     */\n    phone: boolean;\n    /**\n     * Whether the device is a tablet device.\n     * @memberof utils.isMobile\n     */\n    tablet: boolean;\n    /**\n     * Whether the device is any kind of device.\n     * @memberof utils.isMobile\n     */\n    any: boolean;\n};\n\n/**\n * Detects whether the device is mobile and what type of mobile device it is.\n * ```js\n * import { isMobile } from 'pixi.js';\n *\n * if (isMobile.apple.tablet) {\n *    // The device is an Apple tablet device.\n * }\n * ```\n * @memberof utils\n */\nexport const isMobile: isMobileResult = isMobileCall(globalThis.navigator);\n", "import { FederatedEvent } from '../events/FederatedEvent';\nimport { ExtensionType } from '../extensions/Extensions';\nimport { isMobile } from '../utils/browser/isMobile';\nimport { removeItems } from '../utils/data/removeItems';\nimport { type AccessibleHTMLElement } from './accessibilityTarget';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\nimport type { isMobileResult } from '../utils/browser/isMobile';\n\n/**\n * The accessibility module provides screen reader and keyboard navigation support for PixiJS content.\n * This is very important as it can possibly help people with disabilities access PixiJS content.\n *\n * This module is a mixin for {@link AbstractRenderer} and needs to be imported if managing your own renderer:\n * ```js\n * import 'pixi.js/accessibility';\n * ```\n *\n * Make objects accessible by setting their properties:\n * ```js\n * container.accessible = true;        // Enable accessibility for this container\n * container.accessibleType = 'button' // Type of DOM element to create (default: 'button')\n * container.accessibleTitle = 'Play'  // Optional: Add screen reader labels\n * ```\n *\n * By default, the accessibility system activates when users press the tab key. For cases where\n * you need control over when accessibility features are active, configuration options are available:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *         enabledByDefault: true,    // Create accessibility elements immediately\n *         activateOnTab: false,      // Prevent tab key activation\n *         debug: false,               // Show accessibility divs\n *         deactivateOnMouseMove: false, // Prevent accessibility from being deactivated when mouse moves\n *     }\n * });\n * ```\n *\n * The system can also be controlled programmatically:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * See {@link accessibility.AccessibleOptions} for all configuration options.\n * @namespace accessibility\n */\n\n/** @ignore */\nconst KEY_CODE_TAB = 9;\n\nconst DIV_TOUCH_SIZE = 100;\nconst DIV_TOUCH_POS_X = 0;\nconst DIV_TOUCH_POS_Y = 0;\nconst DIV_TOUCH_ZINDEX = 2;\n\nconst DIV_HOOK_SIZE = 1;\nconst DIV_HOOK_POS_X = -1000;\nconst DIV_HOOK_POS_Y = -1000;\nconst DIV_HOOK_ZINDEX = 2;\n\n/** @ignore */\nexport interface AccessibilitySystemOptions\n{\n    accessibilityOptions?: AccessibilityOptions;\n}\n\n/** @ignore */\nexport interface AccessibilityOptions\n{\n    /** Whether to enable accessibility features on initialization instead of waiting for tab key */\n    enabledByDefault?: boolean;\n    /** Whether to visually show the accessibility divs for debugging */\n    debug?: boolean;\n    /** Whether to allow tab key press to activate accessibility features */\n    activateOnTab?: boolean;\n    /** Whether to deactivate accessibility when mouse moves */\n    deactivateOnMouseMove?: boolean;\n}\n\n/**\n * The Accessibility system provides screen reader and keyboard navigation support for PixiJS content.\n * It creates an accessible DOM layer over the canvas that can be controlled programmatically or through user interaction.\n *\n * By default, the system activates when users press the tab key. This behavior can be customized through options:\n * ```js\n * const app = new Application({\n *     accessibilityOptions: {\n *         enabledByDefault: true,    // Enable immediately instead of waiting for tab\n *         activateOnTab: false,      // Disable tab key activation\n *         debug: false,               // Show/hide accessibility divs\n *         deactivateOnMouseMove: false, // Prevent accessibility from being deactivated when mouse moves\n *     }\n * });\n * ```\n *\n * The system can also be controlled programmatically:\n * ```js\n * app.renderer.accessibility.setAccessibilityEnabled(true);\n * ```\n *\n * To make individual containers accessible:\n * ```js\n * container.accessible = true;\n * ```\n *\n * An instance of this class is automatically created at `renderer.accessibility`\n * @memberof accessibility\n */\nexport class AccessibilitySystem implements System<AccessibilitySystemOptions>\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'accessibility',\n    } as const;\n\n    /** default options used by the system */\n    public static defaultOptions: AccessibilityOptions = {\n        /**\n         * Whether to enable accessibility features on initialization\n         * @default false\n         */\n        enabledByDefault: false,\n        /**\n         * Whether to visually show the accessibility divs for debugging\n         * @default false\n         */\n        debug: false,\n        /**\n         * Whether to activate accessibility when tab key is pressed\n         * @default true\n         */\n        activateOnTab: true,\n        /**\n         * Whether to deactivate accessibility when mouse moves\n         * @default true\n         */\n        deactivateOnMouseMove: true,\n    };\n\n    /** Whether accessibility divs are visible for debugging */\n    public debug = false;\n\n    /** Whether to activate on tab key press */\n    private _activateOnTab = true;\n\n    /** Whether to deactivate accessibility when mouse moves */\n    private _deactivateOnMouseMove = true;\n\n    /**\n     * The renderer this accessibility manager works for.\n     * @type {WebGLRenderer|WebGPURenderer}\n     */\n    private _renderer: Renderer;\n\n    /** Internal variable, see isActive getter. */\n    private _isActive = false;\n\n    /** Internal variable, see isMobileAccessibility getter. */\n    private _isMobileAccessibility = false;\n\n    /** Button element for handling touch hooks. */\n    private _hookDiv: HTMLElement | null;\n\n    /** This is the dom element that will sit over the PixiJS element. This is where the div overlays will go. */\n    private _div: HTMLElement | null = null;\n\n    /** A simple pool for storing divs. */\n    private _pool: AccessibleHTMLElement[] = [];\n\n    /** This is a tick used to check if an object is no longer being rendered. */\n    private _renderId = 0;\n\n    /** The array of currently active accessible items. */\n    private _children: Container[] = [];\n\n    /** Count to throttle div updates on android devices. */\n    private _androidUpdateCount = 0;\n\n    /**  The frequency to update the div elements. */\n    private readonly _androidUpdateFrequency = 500; // 2fps\n\n    // eslint-disable-next-line jsdoc/require-param\n    /**\n     * @param {WebGLRenderer|WebGPURenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer: Renderer, private readonly _mobileInfo: isMobileResult = isMobile)\n    {\n        this._hookDiv = null;\n\n        if (_mobileInfo.tablet || _mobileInfo.phone)\n        {\n            this._createTouchHook();\n        }\n\n        this._renderer = renderer;\n    }\n\n    /**\n     * Value of `true` if accessibility is currently active and accessibility layers are showing.\n     * @member {boolean}\n     * @readonly\n     */\n    get isActive(): boolean\n    {\n        return this._isActive;\n    }\n\n    /**\n     * Value of `true` if accessibility is enabled for touch devices.\n     * @member {boolean}\n     * @readonly\n     */\n    get isMobileAccessibility(): boolean\n    {\n        return this._isMobileAccessibility;\n    }\n\n    get hookDiv()\n    {\n        return this._hookDiv;\n    }\n\n    /**\n     * Creates the touch hooks.\n     * @private\n     */\n    private _createTouchHook(): void\n    {\n        const hookDiv = document.createElement('button');\n\n        hookDiv.style.width = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.height = `${DIV_HOOK_SIZE}px`;\n        hookDiv.style.position = 'absolute';\n        hookDiv.style.top = `${DIV_HOOK_POS_X}px`;\n        hookDiv.style.left = `${DIV_HOOK_POS_Y}px`;\n        hookDiv.style.zIndex = DIV_HOOK_ZINDEX.toString();\n        hookDiv.style.backgroundColor = '#FF0000';\n        hookDiv.title = 'select to enable accessibility for this content';\n\n        hookDiv.addEventListener('focus', () =>\n        {\n            this._isMobileAccessibility = true;\n            this._activate();\n            this._destroyTouchHook();\n        });\n\n        document.body.appendChild(hookDiv);\n        this._hookDiv = hookDiv;\n    }\n\n    /**\n     * Destroys the touch hooks.\n     * @private\n     */\n    private _destroyTouchHook(): void\n    {\n        if (!this._hookDiv)\n        {\n            return;\n        }\n        document.body.removeChild(this._hookDiv);\n        this._hookDiv = null;\n    }\n\n    /**\n     * Activating will cause the Accessibility layer to be shown.\n     * This is called when a user presses the tab key.\n     * @private\n     */\n    private _activate(): void\n    {\n        if (this._isActive)\n        {\n            return;\n        }\n\n        this._isActive = true;\n\n        // Create and add div if needed\n        if (!this._div)\n        {\n            this._div = document.createElement('div');\n            this._div.style.width = `${DIV_TOUCH_SIZE}px`;\n            this._div.style.height = `${DIV_TOUCH_SIZE}px`;\n            this._div.style.position = 'absolute';\n            this._div.style.top = `${DIV_TOUCH_POS_X}px`;\n            this._div.style.left = `${DIV_TOUCH_POS_Y}px`;\n            this._div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            this._div.style.pointerEvents = 'none';\n        }\n\n        // Bind event handlers and add listeners when activating\n        if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        if (this._deactivateOnMouseMove)\n        {\n            this._onMouseMove = this._onMouseMove.bind(this);\n            globalThis.document.addEventListener('mousemove', this._onMouseMove, true);\n        }\n\n        // Check if canvas is in DOM\n        const canvas = this._renderer.view.canvas;\n\n        if (!canvas.parentNode)\n        {\n            const observer = new MutationObserver(() =>\n            {\n                if (canvas.parentNode)\n                {\n                    canvas.parentNode.appendChild(this._div);\n                    observer.disconnect();\n\n                    // Only start the postrender runner after div is ready\n                    this._initAccessibilitySetup();\n                }\n            });\n\n            observer.observe(document.body, { childList: true, subtree: true });\n        }\n        else\n        {\n            // Add to DOM\n            canvas.parentNode.appendChild(this._div);\n\n            // Div is ready, initialize accessibility\n            this._initAccessibilitySetup();\n        }\n    }\n\n    // New method to handle initialization after div is ready\n    private _initAccessibilitySetup(): void\n    {\n        // Add the postrender runner to start processing accessible objects\n        this._renderer.runners.postrender.add(this);\n\n        // Force an initial update of accessible objects\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n        }\n    }\n\n    /**\n     * Deactivates the accessibility system. Removes listeners and accessibility elements.\n     * @private\n     */\n    private _deactivate(): void\n    {\n        if (!this._isActive || this._isMobileAccessibility)\n        {\n            return;\n        }\n\n        this._isActive = false;\n\n        // Switch listeners\n        globalThis.document.removeEventListener('mousemove', this._onMouseMove, true);\n        if (this._activateOnTab)\n        {\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n\n        // Remove all active accessibility elements\n        for (const child of this._children)\n        {\n            if (child._accessibleDiv && child._accessibleDiv.parentNode)\n            {\n                child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n                child._accessibleDiv = null;\n            }\n            child._accessibleActive = false;\n        }\n\n        // Clear the pool of divs\n        this._pool.forEach((div) =>\n        {\n            if (div.parentNode)\n            {\n                div.parentNode.removeChild(div);\n            }\n        });\n\n        // Remove parent div from DOM\n        if (this._div && this._div.parentNode)\n        {\n            this._div.parentNode.removeChild(this._div);\n        }\n\n        this._pool = [];\n        this._children = [];\n    }\n\n    /**\n     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.\n     * @private\n     * @param {Container} container - The Container to check.\n     */\n    private _updateAccessibleObjects(container: Container): void\n    {\n        if (!container.visible || !container.accessibleChildren)\n        {\n            return;\n        }\n\n        // Separate check for accessibility without requiring interactivity\n        if (container.accessible)\n        {\n            if (!container._accessibleActive)\n            {\n                this._addChild(container);\n            }\n\n            container._renderId = this._renderId;\n        }\n\n        const children = container.children;\n\n        if (children)\n        {\n            for (let i = 0; i < children.length; i++)\n            {\n                this._updateAccessibleObjects(children[i] as Container);\n            }\n        }\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options?: AccessibilitySystemOptions): void\n    {\n        // Ensure we have the accessibilityOptions object\n        const defaultOpts = AccessibilitySystem.defaultOptions;\n        const mergedOptions = {\n            accessibilityOptions: {\n                ...defaultOpts,\n                ...(options?.accessibilityOptions || {})\n            }\n        };\n\n        this.debug = mergedOptions.accessibilityOptions.debug;\n        this._activateOnTab = mergedOptions.accessibilityOptions.activateOnTab;\n        this._deactivateOnMouseMove = mergedOptions.accessibilityOptions.deactivateOnMouseMove;\n\n        if (mergedOptions.accessibilityOptions.enabledByDefault)\n        {\n            this._activate();\n        }\n        else if (this._activateOnTab)\n        {\n            this._onKeyDown = this._onKeyDown.bind(this);\n            globalThis.addEventListener('keydown', this._onKeyDown, false);\n        }\n\n        this._renderer.runners.postrender.remove(this);\n    }\n\n    /**\n     * Updates the accessibility layer during rendering.\n     * - Removes divs for containers no longer in the scene\n     * - Updates the position and dimensions of the root div\n     * - Updates positions of active accessibility divs\n     * Only fires while the accessibility system is active.\n     * @ignore\n     */\n    public postrender(): void\n    {\n        /* On Android default web browser, tab order seems to be calculated by position rather than tabIndex,\n        *  moving buttons can cause focus to flicker between two buttons making it hard/impossible to navigate,\n        *  so I am just running update every half a second, seems to fix it.\n        */\n        const now = performance.now();\n\n        if (this._mobileInfo.android.device && now < this._androidUpdateCount)\n        {\n            return;\n        }\n\n        this._androidUpdateCount = now + this._androidUpdateFrequency;\n\n        if (!this._renderer.renderingToScreen || !this._renderer.view.canvas)\n        {\n            return;\n        }\n\n        // Track which containers are still active this frame\n        const activeIds = new Set<number>();\n\n        if (this._renderer.lastObjectRendered)\n        {\n            this._updateAccessibleObjects(this._renderer.lastObjectRendered as Container);\n\n            // Mark all updated containers as active\n            for (const child of this._children)\n            {\n                if (child._renderId === this._renderId)\n                {\n                    activeIds.add(this._children.indexOf(child));\n                }\n            }\n        }\n\n        // Remove any containers that weren't updated this frame\n        for (let i = this._children.length - 1; i >= 0; i--)\n        {\n            const child = this._children[i];\n\n            if (!activeIds.has(i))\n            {\n                // Container was removed, clean up its accessibility div\n                if (child._accessibleDiv && child._accessibleDiv.parentNode)\n                {\n                    child._accessibleDiv.parentNode.removeChild(child._accessibleDiv);\n\n                    this._pool.push(child._accessibleDiv);\n                    child._accessibleDiv = null;\n                }\n                child._accessibleActive = false;\n                removeItems(this._children, i, 1);\n            }\n        }\n\n        // Update root div dimensions if needed\n        if (this._renderer.renderingToScreen)\n        {\n            const { x, y, width: viewWidth, height: viewHeight } = this._renderer.screen;\n            const div = this._div;\n\n            div.style.left = `${x}px`;\n            div.style.top = `${y}px`;\n            div.style.width = `${viewWidth}px`;\n            div.style.height = `${viewHeight}px`;\n        }\n\n        // Update positions of existing divs\n        for (let i = 0; i < this._children.length; i++)\n        {\n            const child = this._children[i];\n\n            if (!child._accessibleActive || !child._accessibleDiv)\n            {\n                continue;\n            }\n\n            // Only update position-related properties\n            const div = child._accessibleDiv;\n            const hitArea = (child.hitArea || child.getBounds().rectangle) as Rectangle;\n\n            if (child.hitArea)\n            {\n                const wt = child.worldTransform;\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n\n                div.style.left = `${(wt.tx + (hitArea.x * wt.a)) * sx}px`;\n                div.style.top = `${(wt.ty + (hitArea.y * wt.d)) * sy}px`;\n                div.style.width = `${hitArea.width * wt.a * sx}px`;\n                div.style.height = `${hitArea.height * wt.d * sy}px`;\n            }\n            else\n            {\n                this._capHitArea(hitArea);\n                const sx = this._renderer.resolution;\n                const sy = this._renderer.resolution;\n\n                div.style.left = `${hitArea.x * sx}px`;\n                div.style.top = `${hitArea.y * sy}px`;\n                div.style.width = `${hitArea.width * sx}px`;\n                div.style.height = `${hitArea.height * sy}px`;\n            }\n        }\n\n        // increment the render id..\n        this._renderId++;\n    }\n\n    /**\n     * private function that will visually add the information to the\n     * accessibility div\n     * @param {HTMLElement} div -\n     */\n    private _updateDebugHTML(div: AccessibleHTMLElement): void\n    {\n        div.innerHTML = `type: ${div.type}</br> title : ${div.title}</br> tabIndex: ${div.tabIndex}`;\n    }\n\n    /**\n     * Adjust the hit area based on the bounds of a display object\n     * @param {Rectangle} hitArea - Bounds of the child\n     */\n    private _capHitArea(hitArea: Rectangle): void\n    {\n        if (hitArea.x < 0)\n        {\n            hitArea.width += hitArea.x;\n            hitArea.x = 0;\n        }\n\n        if (hitArea.y < 0)\n        {\n            hitArea.height += hitArea.y;\n            hitArea.y = 0;\n        }\n\n        const { width: viewWidth, height: viewHeight } = this._renderer;\n\n        if (hitArea.x + hitArea.width > viewWidth)\n        {\n            hitArea.width = viewWidth - hitArea.x;\n        }\n\n        if (hitArea.y + hitArea.height > viewHeight)\n        {\n            hitArea.height = viewHeight - hitArea.y;\n        }\n    }\n\n    /**\n     * Creates or reuses a div element for a Container and adds it to the accessibility layer.\n     * Sets up ARIA attributes, event listeners, and positioning based on the container's properties.\n     * @private\n     * @param {Container} container - The child to make accessible.\n     */\n    private _addChild<T extends Container>(container: T): void\n    {\n        let div = this._pool.pop();\n\n        if (!div)\n        {\n            if (container.accessibleType === 'button')\n            {\n                div = document.createElement('button');\n            }\n            else\n            {\n                div = document.createElement(container.accessibleType);\n                div.style.cssText = `\n                        color: transparent;\n                        pointer-events: none;\n                        padding: 0;\n                        margin: 0;\n                        border: 0;\n                        outline: 0;\n                        background: transparent;\n                        box-sizing: border-box;\n                        user-select: none;\n                        -webkit-user-select: none;\n                        -moz-user-select: none;\n                        -ms-user-select: none;\n                    `;\n                if (container.accessibleText)\n                {\n                    div.innerText = container.accessibleText;\n                }\n            }\n            div.style.width = `${DIV_TOUCH_SIZE}px`;\n            div.style.height = `${DIV_TOUCH_SIZE}px`;\n            div.style.backgroundColor = this.debug ? 'rgba(255,255,255,0.5)' : 'transparent';\n            div.style.position = 'absolute';\n            div.style.zIndex = DIV_TOUCH_ZINDEX.toString();\n            div.style.borderStyle = 'none';\n\n            // ARIA attributes ensure that button title and hint updates are announced properly\n            if (navigator.userAgent.toLowerCase().includes('chrome'))\n            {\n                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.\n                div.setAttribute('aria-live', 'off');\n            }\n            else\n            {\n                div.setAttribute('aria-live', 'polite');\n            }\n\n            if (navigator.userAgent.match(/rv:.*Gecko\\//))\n            {\n                // FireFox needs this to announce only the new button name\n                div.setAttribute('aria-relevant', 'additions');\n            }\n            else\n            {\n                // required by IE, other browsers don't much care\n                div.setAttribute('aria-relevant', 'text');\n            }\n\n            div.addEventListener('click', this._onClick.bind(this));\n            div.addEventListener('focus', this._onFocus.bind(this));\n            div.addEventListener('focusout', this._onFocusOut.bind(this));\n        }\n\n        // set pointer events\n        div.style.pointerEvents = container.accessiblePointerEvents;\n        // set the type, this defaults to button!\n        div.type = container.accessibleType;\n\n        if (container.accessibleTitle && container.accessibleTitle !== null)\n        {\n            div.title = container.accessibleTitle;\n        }\n        else if (!container.accessibleHint\n            || container.accessibleHint === null)\n        {\n            div.title = `container ${container.tabIndex}`;\n        }\n\n        if (container.accessibleHint\n            && container.accessibleHint !== null)\n        {\n            div.setAttribute('aria-label', container.accessibleHint);\n        }\n\n        if (this.debug)\n        {\n            this._updateDebugHTML(div);\n        }\n\n        container._accessibleActive = true;\n        container._accessibleDiv = div;\n        div.container = container;\n\n        this._children.push(container);\n        this._div.appendChild(container._accessibleDiv);\n        if (container.interactive)\n        {\n            container._accessibleDiv.tabIndex = container.tabIndex;\n        }\n    }\n\n    /**\n     * Dispatch events with the EventSystem.\n     * @param e\n     * @param type\n     * @private\n     */\n    private _dispatchEvent(e: UIEvent, type: string[]): void\n    {\n        const { container: target } = e.target as AccessibleHTMLElement;\n        const boundary = this._renderer.events.rootBoundary;\n        const event: FederatedEvent = Object.assign(new FederatedEvent(boundary), { target });\n\n        boundary.rootTarget = this._renderer.lastObjectRendered as Container;\n        type.forEach((type) => boundary.dispatchEvent(event, type));\n    }\n\n    /**\n     * Maps the div button press to pixi's EventSystem (click)\n     * @private\n     * @param {MouseEvent} e - The click event.\n     */\n    private _onClick(e: MouseEvent): void\n    {\n        this._dispatchEvent(e, ['click', 'pointertap', 'tap']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseover)\n     * @private\n     * @param {FocusEvent} e - The focus event.\n     */\n    private _onFocus(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'assertive');\n        }\n\n        this._dispatchEvent(e, ['mouseover']);\n    }\n\n    /**\n     * Maps the div focus events to pixi's EventSystem (mouseout)\n     * @private\n     * @param {FocusEvent} e - The focusout event.\n     */\n    private _onFocusOut(e: FocusEvent): void\n    {\n        if (!(e.target as Element).getAttribute('aria-live'))\n        {\n            (e.target as Element).setAttribute('aria-live', 'polite');\n        }\n\n        this._dispatchEvent(e, ['mouseout']);\n    }\n\n    /**\n     * Is called when a key is pressed\n     * @private\n     * @param {KeyboardEvent} e - The keydown event.\n     */\n    private _onKeyDown(e: KeyboardEvent): void\n    {\n        if (e.keyCode !== KEY_CODE_TAB || !this._activateOnTab)\n        {\n            return;\n        }\n\n        this._activate();\n    }\n\n    /**\n     * Is called when the mouse moves across the renderer element\n     * @private\n     * @param {MouseEvent} e - The mouse event.\n     */\n    private _onMouseMove(e: MouseEvent): void\n    {\n        if (e.movementX === 0 && e.movementY === 0)\n        {\n            return;\n        }\n\n        this._deactivate();\n    }\n\n    /** Destroys the accessibility system. Removes all elements and listeners. */\n    public destroy(): void\n    {\n        this._deactivate();\n        this._destroyTouchHook();\n\n        this._div = null;\n        this._pool = null;\n        this._children = null;\n        this._renderer = null;\n\n        if (this._activateOnTab)\n        {\n            globalThis.removeEventListener('keydown', this._onKeyDown);\n        }\n    }\n\n    /**\n     * Enables or disables the accessibility system.\n     * @param enabled - Whether to enable or disable accessibility.\n     */\n    public setAccessibilityEnabled(enabled: boolean): void\n    {\n        if (enabled)\n        {\n            this._activate();\n        }\n        else\n        {\n            this._deactivate();\n        }\n    }\n}\n", "import type { Container } from '../scene/container/Container';\n\n/**\n * The type of the pointer event to listen for.\n * Can be any of the following:\n * - `auto`\n * - `none`\n * - `visiblePainted`\n * - `visibleFill`\n * - `visibleStroke`\n * - `visible`\n * - `painted`\n * - `fill`\n * - `stroke`\n * - `all`\n * - `inherit`\n * @memberof accessibility\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/pointer-events\n */\nexport type PointerEvents = 'auto'\n| 'none'\n| 'visiblePainted'\n| 'visibleFill'\n| 'visibleStroke'\n| 'visible'\n| 'painted'\n| 'fill'\n| 'stroke'\n| 'all'\n| 'inherit';\n\n/**\n * When `accessible` is enabled on any display object, these properties will affect its accessibility.\n * @memberof accessibility\n */\nexport interface AccessibleOptions\n{\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @default false\n     */\n    accessible: boolean;\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @member {string}\n     */\n    accessibleTitle: string | null;\n    /** Sets the aria-label attribute of the shadow div */\n    accessibleHint: string | null;\n    /**\n     * @default 0\n     */\n    tabIndex: number;\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @default 'button'\n     */\n    accessibleType: keyof HTMLElementTagNameMap;\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @default 'auto'\n     * @type {accessibility.PointerEvents}\n     */\n\n    /** Sets the text content of the shadow div */\n    accessibleText: string | null;\n\n    accessiblePointerEvents: PointerEvents;\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @default true\n     */\n    accessibleChildren: boolean;\n}\n\n/**\n * The Accessibility object is attached to the {@link Container}.\n * @private\n */\nexport interface AccessibleTarget extends AccessibleOptions\n{\n    _accessibleActive: boolean;\n    _accessibleDiv: AccessibleHTMLElement | null;\n    _renderId: number;\n}\n\nexport interface AccessibleHTMLElement extends HTMLElement\n{\n    type?: string;\n    container?: Container;\n}\n\n/**\n * Default property values of accessible objects\n * used by {@link AccessibilitySystem}.\n * @private\n * @example\n * import { accessibleTarget } from 'pixi.js';\n *\n * function MyObject() {}\n * Object.assign(MyObject.prototype, accessibleTarget);\n */\nexport const accessibilityTarget: AccessibleTarget = {\n    /**\n     * Flag for if the object is accessible. If true AccessibilityManager will overlay a\n     * shadow div with attributes set\n     * @member {boolean}\n     * @memberof scene.Container#\n     */\n    accessible: false,\n\n    /**\n     * Sets the title attribute of the shadow div\n     * If accessibleTitle AND accessibleHint has not been this will default to 'container [tabIndex]'\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleTitle: null,\n\n    /**\n     * Sets the aria-label attribute of the shadow div\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleHint: null,\n\n    /**\n     * @member {number}\n     * @memberof scene.Container#\n     * @todo Needs docs.\n     */\n    tabIndex: 0,\n\n    /**\n     * @member {boolean}\n     * @memberof scene.Container#\n     * @private\n     */\n    _accessibleActive: false,\n\n    /**\n     * @memberof scene.Container#\n     * @private\n     */\n    _accessibleDiv: null,\n\n    /**\n     * Specify the type of div the accessible layer is. Screen readers treat the element differently\n     * depending on this type. Defaults to button.\n     * @member {string}\n     * @memberof scene.Container#\n     * @default 'button'\n     */\n    accessibleType: 'button',\n\n    /**\n     * Sets the text content of the shadow div\n     * @member {string}\n     * @memberof scene.Container#\n     */\n    accessibleText: null,\n\n    /**\n     * Specify the pointer-events the accessible div will use\n     * Defaults to auto.\n     * @type {PointerEvents}\n     * @memberof scene.Container#\n     * @default 'auto'\n     */\n    accessiblePointerEvents: 'auto',\n\n    /**\n     * Setting to false will prevent any children inside this container to\n     * be accessible. Defaults to true.\n     * @member {boolean}\n     * @memberof scene.Container#\n     * @default true\n     */\n    accessibleChildren: true,\n\n    /**\n     * @member {number}\n     * @memberof scene.Container#\n     * @private\n     */\n    _renderId: -1,\n};\n", "import { UPDATE_PRIORITY } from '../ticker/const';\nimport { Ticker } from '../ticker/Ticker';\n\nimport type { EventSystem } from './EventSystem';\n\n/**\n * This class handles automatic firing of PointerEvents\n * in the case where the pointer is stationary for too long.\n * This is to ensure that hit-tests are still run on moving objects.\n * @since 7.2.0\n * @memberof events\n * @class EventsTicker\n */\nclass EventsTickerClass\n{\n    /** The event system. */\n    public events: EventSystem;\n    /** The DOM element to listen to events on. */\n    public domElement: HTMLElement;\n    /** The frequency that fake events will be fired. */\n    public interactionFrequency = 10;\n\n    private _deltaTime = 0;\n    private _didMove = false;\n    private _tickerAdded = false;\n    private _pauseUpdate = true;\n\n    /**\n     * Initializes the event ticker.\n     * @param events - The event system.\n     */\n    public init(events: EventSystem): void\n    {\n        this.removeTickerListener();\n        this.events = events;\n        this.interactionFrequency = 10;\n        this._deltaTime = 0;\n        this._didMove = false;\n        this._tickerAdded = false;\n        this._pauseUpdate = true;\n    }\n\n    /** Whether to pause the update checks or not. */\n    get pauseUpdate(): boolean\n    {\n        return this._pauseUpdate;\n    }\n\n    set pauseUpdate(paused: boolean)\n    {\n        this._pauseUpdate = paused;\n    }\n\n    /** Adds the ticker listener. */\n    public addTickerListener(): void\n    {\n        if (this._tickerAdded || !this.domElement)\n        {\n            return;\n        }\n\n        Ticker.system.add(this._tickerUpdate, this, UPDATE_PRIORITY.INTERACTION);\n\n        this._tickerAdded = true;\n    }\n\n    /** Removes the ticker listener. */\n    public removeTickerListener(): void\n    {\n        if (!this._tickerAdded)\n        {\n            return;\n        }\n\n        Ticker.system.remove(this._tickerUpdate, this);\n\n        this._tickerAdded = false;\n    }\n\n    /** Sets flag to not fire extra events when the user has already moved there mouse */\n    public pointerMoved(): void\n    {\n        this._didMove = true;\n    }\n\n    /** Updates the state of interactive objects. */\n    private _update(): void\n    {\n        if (!this.domElement || this._pauseUpdate)\n        {\n            return;\n        }\n\n        // if the user move the mouse this check has already been done using the mouse move!\n        if (this._didMove)\n        {\n            this._didMove = false;\n\n            return;\n        }\n\n        // eslint-disable-next-line dot-notation\n        const rootPointerEvent = this.events['_rootPointerEvent'];\n\n        if (this.events.supportsTouchEvents && (rootPointerEvent as PointerEvent).pointerType === 'touch')\n        {\n            return;\n        }\n\n        globalThis.document.dispatchEvent(new PointerEvent('pointermove', {\n            clientX: rootPointerEvent.clientX,\n            clientY: rootPointerEvent.clientY,\n            pointerType: rootPointerEvent.pointerType,\n            pointerId: rootPointerEvent.pointerId,\n        }));\n    }\n\n    /**\n     * Updates the state of interactive objects if at least {@link interactionFrequency}\n     * milliseconds have passed since the last invocation.\n     *\n     * Invoked by a throttled ticker update from {@link Ticker.system}.\n     * @param ticker - The throttled ticker.\n     */\n    private _tickerUpdate(ticker: Ticker): void\n    {\n        this._deltaTime += ticker.deltaTime;\n\n        if (this._deltaTime < this.interactionFrequency)\n        {\n            return;\n        }\n\n        this._deltaTime = 0;\n\n        this._update();\n    }\n}\n\nexport const EventsTicker = new EventsTickerClass();\n", "import { Point } from '../maths/point/Point';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type { PointData } from '../maths/point/PointData';\nimport type { Container } from '../scene/container/Container';\nimport type { PixiTouch } from './FederatedEvent';\n\n/**\n * A {@link FederatedEvent} for mouse events.\n * @memberof events\n */\nexport class FederatedMouseEvent extends FederatedEvent<\nMouseEvent | PointerEvent | PixiTouch\n> implements MouseEvent\n{\n    /** Whether the \"alt\" key was pressed when this mouse event occurred. */\n    public altKey: boolean;\n\n    /** The specific button that was pressed in this mouse event. */\n    public button: number;\n\n    /** The button depressed when this event occurred. */\n    public buttons: number;\n\n    /** Whether the \"control\" key was pressed when this mouse event occurred. */\n    public ctrlKey: boolean;\n\n    /** Whether the \"meta\" key was pressed when this mouse event occurred. */\n    public metaKey: boolean;\n\n    /** This is currently not implemented in the Federated Events API. */\n    public relatedTarget: EventTarget;\n\n    /** Whether the \"shift\" key was pressed when this mouse event occurred. */\n    public shiftKey: boolean;\n\n    /** The coordinates of the mouse event relative to the canvas. */\n    public client: Point = new Point();\n\n    /** @readonly */\n    public get clientX(): number { return this.client.x; }\n\n    /** @readonly */\n    public get clientY(): number { return this.client.y; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientX this.clientX}.\n     * @readonly\n     */\n    get x(): number { return this.clientX; }\n\n    /**\n     * Alias for {@link FederatedMouseEvent.clientY this.clientY}.\n     * @readonly\n     */\n    get y(): number { return this.clientY; }\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    /** The movement in this pointer relative to the last `mousemove` event. */\n    public movement: Point = new Point();\n\n    /** @readonly */\n    get movementX(): number { return this.movement.x; }\n\n    /** @readonly */\n    get movementY(): number { return this.movement.y; }\n\n    /** The offset of the pointer coordinates w.r.t. target Container in world space. This is not supported at the moment. */\n    public offset: Point = new Point();\n\n    /** @readonly */\n    get offsetX(): number { return this.offset.x; }\n\n    /** @readonly */\n    get offsetY(): number { return this.offset.y; }\n\n    /** The pointer coordinates in world space. */\n    public global: Point = new Point();\n\n    /** @readonly */\n    get globalX(): number { return this.global.x; }\n\n    /** @readonly */\n    get globalY(): number { return this.global.y; }\n\n    /**\n     * The pointer coordinates in the renderer's {@link Renderer.screen screen}. This has slightly\n     * different semantics than native PointerEvent screenX/screenY.\n     */\n    public screen: Point = new Point();\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.x}.\n     * @readonly\n     */\n    get screenX(): number { return this.screen.x; }\n\n    /**\n     * The pointer coordinates in the renderer's screen. Alias for {@code screen.y}.\n     * @readonly\n     */\n    get screenY(): number { return this.screen.y; }\n\n    /**\n     * This will return the local coordinates of the specified container for this InteractionData\n     * @param {Container} container - The Container that you would like the local\n     *  coords off\n     * @param {PointData} point - A Point object in which to store the value, optional (otherwise\n     *  will create a new point)\n     * @param {PointData} globalPos - A Point object containing your custom global coords, optional\n     *  (otherwise will use the current global coords)\n     * @returns - A point containing the coordinates of the InteractionData position relative\n     *  to the Container\n     */\n    public getLocalPosition<P extends PointData = Point>(container: Container, point?: P, globalPos?: PointData): P\n    {\n        return container.worldTransform.applyInverse<P>(globalPos || this.global, point);\n    }\n\n    /**\n     * Whether the modifier key was pressed when this event natively occurred.\n     * @param key - The modifier key.\n     */\n    public getModifierState(key: string): boolean\n    {\n        return 'getModifierState' in this.nativeEvent && this.nativeEvent.getModifierState(key);\n    }\n\n    /**\n     * Not supported.\n     * @param _typeArg\n     * @param _canBubbleArg\n     * @param _cancelableArg\n     * @param _viewArg\n     * @param _detailArg\n     * @param _screenXArg\n     * @param _screenYArg\n     * @param _clientXArg\n     * @param _clientYArg\n     * @param _ctrlKeyArg\n     * @param _altKeyArg\n     * @param _shiftKeyArg\n     * @param _metaKeyArg\n     * @param _buttonArg\n     * @param _relatedTargetArg\n     * @deprecated since 7.0.0\n     */\n    // eslint-disable-next-line max-params\n    public initMouseEvent(\n        _typeArg: string,\n        _canBubbleArg: boolean,\n        _cancelableArg: boolean,\n        _viewArg: Window,\n        _detailArg: number,\n        _screenXArg: number,\n        _screenYArg: number,\n        _clientXArg: number,\n        _clientYArg: number,\n        _ctrlKeyArg: boolean,\n        _altKeyArg: boolean,\n        _shiftKeyArg: boolean,\n        _metaKeyArg: boolean,\n        _buttonArg: number,\n        _relatedTargetArg: EventTarget\n    ): void\n    {\n        throw new Error('Method not implemented.');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link FederatedEvent} for pointer events.\n * @memberof events\n */\nexport class FederatedPointerEvent extends FederatedMouseEvent implements PointerEvent\n{\n    /**\n     * The unique identifier of the pointer.\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId}\n     */\n    public pointerId: number;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     */\n    public width = 0;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring the vertical angle between\n     * the device's surface to the pointer or stylus.\n     * A stylus at 0 degrees would be directly parallel whereas at π/2 degrees it would be perpendicular.\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/altitudeAngle)\n     */\n    public altitudeAngle: number;\n\n    /**\n     * The angle in radians of a pointer or stylus measuring an arc from the X axis of the device to\n     * the pointer or stylus projected onto the screen's plane.\n     * A stylus at 0 degrees would be pointing to the \"0 o'clock\" whereas at π/2 degrees it would be pointing at \"6 o'clock\".\n     * @see https://developer.mozilla.org/docs/Web/API/PointerEvent/azimuthAngle)\n     */\n    public azimuthAngle: number;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     */\n    public height = 0;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     */\n    public isPrimary = false;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     */\n    public pointerType: string;\n\n    /**\n     * Pressure applied by the pointing device during the event.\n     *s\n     * A Touch's force property will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     */\n    public pressure: number;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public tangentialPressure: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     */\n    public tiltX: number;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     */\n    public tiltY: number;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     */\n    public twist: number;\n\n    /** This is the number of clicks that occurs in 200ms/click of each other. */\n    public detail: number;\n\n    // Only included for completeness for now\n    public getCoalescedEvents(): PointerEvent[]\n    {\n        if (this.type === 'pointermove' || this.type === 'mousemove' || this.type === 'touchmove')\n        {\n            return [this];\n        }\n\n        return [];\n    }\n\n    // Only included for completeness for now\n    public getPredictedEvents(): PointerEvent[]\n    {\n        throw new Error('getPredictedEvents is not supported!');\n    }\n}\n", "import { FederatedMouseEvent } from './FederatedMouseEvent';\n\n/**\n * A {@link FederatedEvent} for wheel events.\n * @memberof events\n */\nexport class FederatedWheelEvent extends FederatedMouseEvent implements WheelEvent\n{\n    /**\n     * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,\n     * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.\n     */\n    public deltaMode: number;\n\n    /** Horizontal scroll amount */\n    public deltaX: number;\n\n    /** Vertical scroll amount */\n    public deltaY: number;\n\n    /** z-axis scroll amount. */\n    public deltaZ: number;\n\n    /** Units specified in pixels. */\n    public static readonly DOM_DELTA_PIXEL = 0;\n\n    /** Units specified in pixels. */\n    public readonly DOM_DELTA_PIXEL = 0;\n\n    /** Units specified in lines. */\n    public static readonly DOM_DELTA_LINE = 1;\n\n    /** Units specified in lines. */\n    public readonly DOM_DELTA_LINE = 1;\n\n    /** Units specified in pages. */\n    public static readonly DOM_DELTA_PAGE = 2;\n\n    /** Units specified in pages. */\n    public readonly DOM_DELTA_PAGE = 2;\n}\n", "import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof events\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: Container[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: Container[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: Container): Container[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable || !container.measurable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._maskEffect} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        if (!e.currentTarget.isInteractive())\n        {\n            return;\n        }\n\n        type ??= e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof Container;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: Container[]): Container\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: Container\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as Container\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.defaultPrevented = false;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { EventBoundary } from './EventBoundary';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\nimport type { PointData } from '../maths/point/PointData';\nimport type { System } from '../rendering/renderers/shared/system/System';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { PixiTouch } from './FederatedEvent';\nimport type { EventMode } from './FederatedEventTarget';\nimport type { FederatedMouseEvent } from './FederatedMouseEvent';\n\nconst MOUSE_POINTER_ID = 1;\nconst TOUCH_TO_POINTER: Record<string, string> = {\n    touchstart: 'pointerdown',\n    touchend: 'pointerup',\n    touchendoutside: 'pointerupoutside',\n    touchmove: 'pointermove',\n    touchcancel: 'pointercancel',\n};\n\n/** @ignore */\nexport interface EventSystemOptions\n{\n    /**\n     * The default event mode mode for all display objects.\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     */\n    eventMode?: EventMode;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @example\n     * const app = new Application({\n     *   view: canvas,\n     *   events: {\n     *     move: true,\n     *     globalMove: false,\n     *     click: true,\n     *     wheel: true,\n     *   },\n     * });\n     */\n    eventFeatures?: Partial<EventSystemFeatures>\n}\n\n/**\n * The event features that are enabled by the EventSystem\n * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n * @since 7.2.0\n * @memberof events\n */\nexport interface EventSystemFeatures\n{\n    /**\n     * Enables pointer events associated with pointer movement:\n     * - `pointermove` / `mousemove` / `touchmove`\n     * - `pointerout` / `mouseout`\n     * - `pointerover` / `mouseover`\n     */\n    move: boolean;\n    // eslint-disable-next-line jsdoc/multiline-blocks\n    /**\n     * Enables global pointer move events:\n     * - `globalpointermove`\n     * - `globalmousemove`\n     * - `globaltouchemove`\n     */\n    globalMove: boolean;\n    /**\n     * Enables pointer events associated with clicking:\n     * - `pointerup` / `mouseup` / `touchend` / 'rightup'\n     * - `pointerupoutside` / `mouseupoutside` / `touchendoutside` / 'rightupoutside'\n     * - `pointerdown` / 'mousedown' / `touchstart` / 'rightdown'\n     * - `click` / `tap`\n     */\n    click: boolean;\n    /** - Enables wheel events. */\n    wheel: boolean;\n}\n\n/**\n * The system for handling UI events.\n * @memberof events\n */\nexport class EventSystem implements System<EventSystemOptions>\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'events',\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.CanvasSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        priority: -1,\n    };\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     */\n    public static defaultEventFeatures: EventSystemFeatures = {\n        /** Enables pointer events associated with pointer movement. */\n        move: true,\n        /** Enables global pointer move events. */\n        globalMove: true,\n        /** Enables pointer events associated with clicking. */\n        click: true,\n        /** Enables wheel events. */\n        wheel: true,\n    };\n\n    private static _defaultEventMode: EventMode;\n\n    /**\n     * The default interaction mode for all display objects.\n     * @see Container.eventMode\n     * @type {EventMode}\n     * @readonly\n     * @since 7.2.0\n     */\n    public static get defaultEventMode()\n    {\n        return this._defaultEventMode;\n    }\n\n    /**\n     * The {@link EventBoundary} for the stage.\n     *\n     * The {@link EventBoundary#rootTarget rootTarget} of this root boundary is automatically set to\n     * the last rendered object before any event processing is initiated. This means the main scene\n     * needs to be rendered atleast once before UI events will start propagating.\n     *\n     * The root boundary should only be changed during initialization. Otherwise, any state held by the\n     * event boundary may be lost (like hovered & pressed Containers).\n     */\n    public readonly rootBoundary: EventBoundary;\n\n    /** Does the device support touch events https://www.w3.org/TR/touch-events/ */\n    public readonly supportsTouchEvents = 'ontouchstart' in globalThis;\n\n    /** Does the device support pointer events https://www.w3.org/Submission/pointer-events/ */\n    public readonly supportsPointerEvents = !!globalThis.PointerEvent;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     * @default true\n     */\n    public autoPreventDefault: boolean;\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for {@code domElement},\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     */\n    public cursorStyles: Record<string, string | ((mode: string) => void) | CSSStyleDeclaration>;\n\n    /**\n     * The DOM element to which the root event listeners are bound. This is automatically set to\n     * the renderer's {@link Renderer#view view}.\n     */\n    public domElement: HTMLElement = null;\n\n    /** The resolution used to convert between the DOM client space into world space. */\n    public resolution = 1;\n\n    /** The renderer managing this {@link EventSystem}. */\n    public renderer: Renderer;\n\n    /**\n     * The event features that are enabled by the EventSystem\n     * (included in the **pixi.js** and **pixi.js-legacy** bundle), otherwise it will be ignored.\n     * @since 7.2.0\n     * @example\n     * const app = new Application()\n     * app.renderer.events.features.globalMove = false\n     *\n     * // to override all features use Object.assign\n     * Object.assign(app.renderer.events.features, {\n     *  move: false,\n     *  globalMove: false,\n     *  click: false,\n     *  wheel: false,\n     * })\n     */\n    public readonly features: EventSystemFeatures;\n\n    private _currentCursor: string;\n    private readonly _rootPointerEvent: FederatedPointerEvent;\n    private readonly _rootWheelEvent: FederatedWheelEvent;\n    private _eventsAdded: boolean;\n\n    /**\n     * @param {Renderer} renderer\n     */\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n        this.rootBoundary = new EventBoundary(null);\n        EventsTicker.init(this);\n\n        this.autoPreventDefault = true;\n        this._eventsAdded = false;\n\n        this._rootPointerEvent = new FederatedPointerEvent(null);\n        this._rootWheelEvent = new FederatedWheelEvent(null);\n\n        this.cursorStyles = {\n            default: 'inherit',\n            pointer: 'pointer',\n        };\n\n        this.features = new Proxy({ ...EventSystem.defaultEventFeatures }, {\n            set: (target, key, value) =>\n            {\n                if (key === 'globalMove')\n                {\n                    this.rootBoundary.enableGlobalMoveEvents = value;\n                }\n                target[key as keyof EventSystemFeatures] = value;\n\n                return true;\n            }\n        });\n\n        this._onPointerDown = this._onPointerDown.bind(this);\n        this._onPointerMove = this._onPointerMove.bind(this);\n        this._onPointerUp = this._onPointerUp.bind(this);\n        this._onPointerOverOut = this._onPointerOverOut.bind(this);\n        this.onWheel = this.onWheel.bind(this);\n    }\n\n    /**\n     * Runner init called, view is available at this point.\n     * @ignore\n     */\n    public init(options: EventSystemOptions): void\n    {\n        const { canvas, resolution } = this.renderer;\n\n        this.setTargetElement(canvas as HTMLCanvasElement);\n        this.resolution = resolution;\n        EventSystem._defaultEventMode = options.eventMode ?? 'passive';\n        Object.assign(this.features, options.eventFeatures ?? {});\n        this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove;\n    }\n\n    /**\n     * Handle changing resolution.\n     * @ignore\n     */\n    public resolutionChange(resolution: number): void\n    {\n        this.resolution = resolution;\n    }\n\n    /** Destroys all event listeners and detaches the renderer. */\n    public destroy(): void\n    {\n        this.setTargetElement(null);\n        this.renderer = null;\n        this._currentCursor = null;\n    }\n\n    /**\n     * Sets the current cursor mode, handling any callbacks or CSS style changes.\n     * @param mode - cursor mode, a key from the cursorStyles dictionary\n     */\n    public setCursor(mode: string): void\n    {\n        mode ||= 'default';\n        let applyStyles = true;\n\n        // offscreen canvas does not support setting styles, but cursor modes can be functions,\n        // in order to handle pixi rendered cursors, so we can't bail\n        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas)\n        {\n            applyStyles = false;\n        }\n        // if the mode didn't actually change, bail early\n        if (this._currentCursor === mode)\n        {\n            return;\n        }\n        this._currentCursor = mode;\n        const style = this.cursorStyles[mode];\n\n        // only do things if there is a cursor style for it\n        if (style)\n        {\n            switch (typeof style)\n            {\n                case 'string':\n                    // string styles are handled as cursor CSS\n                    if (applyStyles)\n                    {\n                        this.domElement.style.cursor = style;\n                    }\n                    break;\n                case 'function':\n                    // functions are just called, and passed the cursor mode\n                    style(mode);\n                    break;\n                case 'object':\n                    // if it is an object, assume that it is a dictionary of CSS styles,\n                    // apply it to the interactionDOMElement\n                    if (applyStyles)\n                    {\n                        Object.assign(this.domElement.style, style);\n                    }\n                    break;\n            }\n        }\n        else if (applyStyles && typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode))\n        {\n            // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n            // for the mode, then assume that the dev wants it to be CSS for the cursor.\n            this.domElement.style.cursor = mode;\n        }\n    }\n\n    /**\n     * The global pointer event.\n     * Useful for getting the pointer position without listening to events.\n     * @since 7.2.0\n     */\n    public get pointer(): Readonly<FederatedPointerEvent>\n    {\n        return this._rootPointerEvent;\n    }\n\n    /**\n     * Event handler for pointer down events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerDown(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const events = this._normalizeToPointerData(nativeEvent);\n\n        /*\n         * No need to prevent default on natural pointer events, as there are no side effects\n         * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n         * so still need to be prevented.\n         */\n\n        // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n        if (this.autoPreventDefault && (events[0] as any).isNormalized)\n        {\n            const cancelable = nativeEvent.cancelable || !('cancelable' in nativeEvent);\n\n            if (cancelable)\n            {\n                nativeEvent.preventDefault();\n            }\n        }\n\n        for (let i = 0, j = events.length; i < j; i++)\n        {\n            const nativeEvent = events[i];\n            const federatedEvent = this._bootstrapEvent(this._rootPointerEvent, nativeEvent);\n\n            this.rootBoundary.mapEvent(federatedEvent);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer move events on on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch events.\n     */\n    private _onPointerMove(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.move) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        EventsTicker.pointerMoved();\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer up events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerUp(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        let target = nativeEvent.target;\n\n        // if in shadow DOM use composedPath to access target\n        if (nativeEvent.composedPath && nativeEvent.composedPath().length > 0)\n        {\n            target = nativeEvent.composedPath()[0];\n        }\n\n        const outside = target !== this.domElement ? 'outside' : '';\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            event.type += outside;\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Event handler for pointer over & out events on {@link EventSystem#domElement this.domElement}.\n     * @param nativeEvent - The native mouse/pointer/touch event.\n     */\n    private _onPointerOverOut(nativeEvent: MouseEvent | PointerEvent | TouchEvent): void\n    {\n        if (!this.features.click) return;\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n\n        const normalizedEvents = this._normalizeToPointerData(nativeEvent);\n\n        for (let i = 0, j = normalizedEvents.length; i < j; i++)\n        {\n            const event = this._bootstrapEvent(this._rootPointerEvent, normalizedEvents[i]);\n\n            this.rootBoundary.mapEvent(event);\n        }\n\n        this.setCursor(this.rootBoundary.cursor);\n    }\n\n    /**\n     * Passive handler for `wheel` events on {@link EventSystem.domElement this.domElement}.\n     * @param nativeEvent - The native wheel event.\n     */\n    protected onWheel(nativeEvent: WheelEvent): void\n    {\n        if (!this.features.wheel) return;\n        const wheelEvent = this.normalizeWheelEvent(nativeEvent);\n\n        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;\n        this.rootBoundary.mapEvent(wheelEvent);\n    }\n\n    /**\n     * Sets the {@link EventSystem#domElement domElement} and binds event listeners.\n     *\n     * To deregister the current DOM element without setting a new one, pass {@code null}.\n     * @param element - The new DOM element.\n     */\n    public setTargetElement(element: HTMLElement): void\n    {\n        this._removeEvents();\n        this.domElement = element;\n        EventsTicker.domElement = element;\n        this._addEvents();\n    }\n\n    /** Register event listeners on {@link Renderer#domElement this.domElement}. */\n    private _addEvents(): void\n    {\n        if (this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.addTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = 'none';\n                style.msTouchAction = 'none';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = 'none';\n            }\n        }\n\n        /*\n         * These events are added first, so that if pointer events are normalized, they are fired\n         * in the same order as non-normalized events. ie. pointer event 1st, mouse / touch 2nd\n         */\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.addEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.addEventListener('pointerdown', this._onPointerDown, true);\n            // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n            // we already handle those, so for the purposes of what we do in onPointerOut, we only\n            // care about the pointerleave event\n            this.domElement.addEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.addEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.addEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.addEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.addEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.addEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.addEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.addEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.addEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.addEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.addEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.addEventListener('touchend', this._onPointerUp, true);\n                this.domElement.addEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.addEventListener('wheel', this.onWheel, {\n            passive: true,\n            capture: true,\n        });\n\n        this._eventsAdded = true;\n    }\n\n    /** Unregister event listeners on {@link EventSystem#domElement this.domElement}. */\n    private _removeEvents(): void\n    {\n        if (!this._eventsAdded || !this.domElement)\n        {\n            return;\n        }\n\n        EventsTicker.removeTickerListener();\n\n        const style = this.domElement.style as CrossCSSStyleDeclaration;\n\n        // offscreen canvas does not have style, so check first\n        if (style)\n        {\n            if ((globalThis.navigator as any).msPointerEnabled)\n            {\n                style.msContentZooming = '';\n                style.msTouchAction = '';\n            }\n            else if (this.supportsPointerEvents)\n            {\n                style.touchAction = '';\n            }\n        }\n\n        if (this.supportsPointerEvents)\n        {\n            globalThis.document.removeEventListener('pointermove', this._onPointerMove, true);\n            this.domElement.removeEventListener('pointerdown', this._onPointerDown, true);\n            this.domElement.removeEventListener('pointerleave', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('pointerover', this._onPointerOverOut, true);\n            // globalThis.removeEventListener('pointercancel', this.onPointerCancel, true);\n            globalThis.removeEventListener('pointerup', this._onPointerUp, true);\n        }\n        else\n        {\n            globalThis.document.removeEventListener('mousemove', this._onPointerMove, true);\n            this.domElement.removeEventListener('mousedown', this._onPointerDown, true);\n            this.domElement.removeEventListener('mouseout', this._onPointerOverOut, true);\n            this.domElement.removeEventListener('mouseover', this._onPointerOverOut, true);\n            globalThis.removeEventListener('mouseup', this._onPointerUp, true);\n\n            if (this.supportsTouchEvents)\n            {\n                this.domElement.removeEventListener('touchstart', this._onPointerDown, true);\n                // this.domElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n                this.domElement.removeEventListener('touchend', this._onPointerUp, true);\n                this.domElement.removeEventListener('touchmove', this._onPointerMove, true);\n            }\n        }\n\n        this.domElement.removeEventListener('wheel', this.onWheel, true);\n\n        this.domElement = null;\n        this._eventsAdded = false;\n    }\n\n    /**\n     * Maps x and y coords from a DOM object and maps them correctly to the PixiJS view. The\n     * resulting value is stored in the point. This takes into account the fact that the DOM\n     * element could be scaled and positioned anywhere on the screen.\n     * @param  {PointData} point - the point that the result will be stored in\n     * @param  {number} x - the x coord of the position to map\n     * @param  {number} y - the y coord of the position to map\n     */\n    public mapPositionToPoint(point: PointData, x: number, y: number): void\n    {\n        const rect = this.domElement.isConnected\n            ? this.domElement.getBoundingClientRect()\n            : {\n                x: 0,\n                y: 0,\n                width: (this.domElement as any).width,\n                height: (this.domElement as any).height,\n                left: 0,\n                top: 0\n            };\n\n        const resolutionMultiplier = 1.0 / this.resolution;\n\n        point.x = ((x - rect.left) * ((this.domElement as any).width / rect.width)) * resolutionMultiplier;\n        point.y = ((y - rect.top) * ((this.domElement as any).height / rect.height)) * resolutionMultiplier;\n    }\n\n    /**\n     * Ensures that the original event object contains all data that a regular pointer event would have\n     * @param event - The original event data from a touch or mouse event\n     * @returns An array containing a single normalized pointer event, in the case of a pointer\n     *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n     */\n    private _normalizeToPointerData(event: TouchEvent | MouseEvent | PointerEvent): PointerEvent[]\n    {\n        const normalizedEvents = [];\n\n        if (this.supportsTouchEvents && event instanceof TouchEvent)\n        {\n            for (let i = 0, li = event.changedTouches.length; i < li; i++)\n            {\n                const touch = event.changedTouches[i] as PixiTouch;\n\n                if (typeof touch.button === 'undefined') touch.button = 0;\n                if (typeof touch.buttons === 'undefined') touch.buttons = 1;\n                if (typeof touch.isPrimary === 'undefined')\n                {\n                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n                }\n                if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n                if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n                if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n                if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n                if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n                if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n                if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n                if (typeof touch.twist === 'undefined') touch.twist = 0;\n                if (typeof touch.tangentialPressure === 'undefined') touch.tangentialPressure = 0;\n                // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n                // support, and the fill ins are not quite the same\n                // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n                // left is not 0,0 on the page\n                if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n                if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n                // mark the touch as normalized, just so that we know we did it\n                touch.isNormalized = true;\n                touch.type = event.type;\n\n                normalizedEvents.push(touch);\n            }\n        }\n        // apparently PointerEvent subclasses MouseEvent, so yay\n        else if (!globalThis.MouseEvent\n            || (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof globalThis.PointerEvent))))\n        {\n            const tempEvent = event as PixiPointerEvent;\n\n            if (typeof tempEvent.isPrimary === 'undefined') tempEvent.isPrimary = true;\n            if (typeof tempEvent.width === 'undefined') tempEvent.width = 1;\n            if (typeof tempEvent.height === 'undefined') tempEvent.height = 1;\n            if (typeof tempEvent.tiltX === 'undefined') tempEvent.tiltX = 0;\n            if (typeof tempEvent.tiltY === 'undefined') tempEvent.tiltY = 0;\n            if (typeof tempEvent.pointerType === 'undefined') tempEvent.pointerType = 'mouse';\n            if (typeof tempEvent.pointerId === 'undefined') tempEvent.pointerId = MOUSE_POINTER_ID;\n            if (typeof tempEvent.pressure === 'undefined') tempEvent.pressure = 0.5;\n            if (typeof tempEvent.twist === 'undefined') tempEvent.twist = 0;\n            if (typeof tempEvent.tangentialPressure === 'undefined') tempEvent.tangentialPressure = 0;\n\n            // mark the mouse event as normalized, just so that we know we did it\n            tempEvent.isNormalized = true;\n\n            normalizedEvents.push(tempEvent);\n        }\n        else\n        {\n            normalizedEvents.push(event);\n        }\n\n        return normalizedEvents as PointerEvent[];\n    }\n\n    /**\n     * Normalizes the native {@link https://w3c.github.io/uievents/#interface-wheelevent WheelEvent}.\n     *\n     * The returned {@link FederatedWheelEvent} is a shared instance. It will not persist across\n     * multiple native wheel events.\n     * @param nativeEvent - The native wheel event that occurred on the canvas.\n     * @returns A federated wheel event.\n     */\n    protected normalizeWheelEvent(nativeEvent: WheelEvent): FederatedWheelEvent\n    {\n        const event = this._rootWheelEvent;\n\n        this._transferMouseData(event, nativeEvent);\n\n        // When WheelEvent is triggered by scrolling with mouse wheel, reading WheelEvent.deltaMode\n        // before deltaX/deltaY/deltaZ on Firefox will result in WheelEvent.DOM_DELTA_LINE (1),\n        // while reading WheelEvent.deltaMode after deltaX/deltaY/deltaZ on Firefox or reading\n        // in any order on other browsers will result in WheelEvent.DOM_DELTA_PIXEL (0).\n        // Therefore, we need to read WheelEvent.deltaMode after deltaX/deltaY/deltaZ in order to\n        // make its behavior more consistent across browsers.\n        // @see https://github.com/pixijs/pixijs/issues/8970\n        event.deltaX = nativeEvent.deltaX;\n        event.deltaY = nativeEvent.deltaY;\n        event.deltaZ = nativeEvent.deltaZ;\n        event.deltaMode = nativeEvent.deltaMode;\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);\n        event.offset.copyFrom(event.screen);\n\n        event.nativeEvent = nativeEvent;\n        event.type = nativeEvent.type;\n\n        return event;\n    }\n\n    /**\n     * Normalizes the `nativeEvent` into a federateed {@link FederatedPointerEvent}.\n     * @param event\n     * @param nativeEvent\n     */\n    private _bootstrapEvent(event: FederatedPointerEvent, nativeEvent: PointerEvent): FederatedPointerEvent\n    {\n        event.originalEvent = null;\n        event.nativeEvent = nativeEvent;\n\n        event.pointerId = nativeEvent.pointerId;\n        event.width = nativeEvent.width;\n        event.height = nativeEvent.height;\n        event.isPrimary = nativeEvent.isPrimary;\n        event.pointerType = nativeEvent.pointerType;\n        event.pressure = nativeEvent.pressure;\n        event.tangentialPressure = nativeEvent.tangentialPressure;\n        event.tiltX = nativeEvent.tiltX;\n        event.tiltY = nativeEvent.tiltY;\n        event.twist = nativeEvent.twist;\n        this._transferMouseData(event, nativeEvent);\n\n        this.mapPositionToPoint(event.screen, nativeEvent.clientX, nativeEvent.clientY);\n        event.global.copyFrom(event.screen);// global = screen for top-level\n        event.offset.copyFrom(event.screen);// EventBoundary recalculates using its rootTarget\n\n        event.isTrusted = nativeEvent.isTrusted;\n        if (event.type === 'pointerleave')\n        {\n            event.type = 'pointerout';\n        }\n        if (event.type.startsWith('mouse'))\n        {\n            event.type = event.type.replace('mouse', 'pointer');\n        }\n        if (event.type.startsWith('touch'))\n        {\n            event.type = TOUCH_TO_POINTER[event.type] || event.type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Transfers base & mouse event data from the {@code nativeEvent} to the federated event.\n     * @param event\n     * @param nativeEvent\n     */\n    private _transferMouseData(event: FederatedMouseEvent, nativeEvent: MouseEvent): void\n    {\n        event.isTrusted = nativeEvent.isTrusted;\n        event.srcElement = nativeEvent.srcElement;\n        event.timeStamp = performance.now();\n        event.type = nativeEvent.type;\n\n        event.altKey = nativeEvent.altKey;\n        event.button = nativeEvent.button;\n        event.buttons = nativeEvent.buttons;\n        event.client.x = nativeEvent.clientX;\n        event.client.y = nativeEvent.clientY;\n        event.ctrlKey = nativeEvent.ctrlKey;\n        event.metaKey = nativeEvent.metaKey;\n        event.movement.x = nativeEvent.movementX;\n        event.movement.y = nativeEvent.movementY;\n        event.page.x = nativeEvent.pageX;\n        event.page.y = nativeEvent.pageY;\n        event.relatedTarget = null;\n        event.shiftKey = nativeEvent.shiftKey;\n    }\n}\n\ninterface CrossCSSStyleDeclaration extends CSSStyleDeclaration\n{\n    msContentZooming: string;\n    msTouchAction: string;\n}\n\ninterface PixiPointerEvent extends PointerEvent\n{\n    isPrimary: boolean;\n    width: number;\n    height: number;\n    tiltX: number;\n    tiltY: number;\n    pointerType: string;\n    pointerId: number;\n    pressure: number;\n    twist: number;\n    tangentialPressure: number;\n    isNormalized: boolean;\n    type: string;\n}\n", "import { EventSystem } from './EventSystem';\nimport { FederatedEvent } from './FederatedEvent';\n\nimport type EventEmitter from 'eventemitter3';\nimport type { Container } from '../scene/container/Container';\nimport type { AllFederatedEventMap } from './FederatedEventMap';\nimport type { FederatedPointerEvent } from './FederatedPointerEvent';\nimport type { FederatedWheelEvent } from './FederatedWheelEvent';\n\n/**\n * The type of cursor to use when the mouse pointer is hovering over.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/cursor\n *\n * Can be any valid CSS cursor value:\n * `auto`, `default`, `none`, `context-menu`, `help`, `pointer`, `progress`,\n * `wait`, `cell`, `crosshair`, `text`, `verticaltext`, `alias`, `copy`, `move`,\n * `nodrop`, `notallowed`, `eresize`, `nresize`, `neresize`, `nwresize`, `sresize`,\n *  `seresize`, `swresize`, `wresize`, `nsresize`, `ewresize`, `neswresize`, `colresize`,\n *  `nwseresize`, `rowresize`, `allscroll`, `zoomin`, `zoomout`, `grab`, `grabbing`\n * @memberof events\n */\nexport type Cursor = 'auto'\n| 'default'\n| 'none'\n| 'context-menu'\n| 'help'\n| 'pointer'\n| 'progress'\n| 'wait'\n| 'cell'\n| 'crosshair'\n| 'text'\n| 'vertical-text'\n| 'alias'\n| 'copy'\n| 'move'\n| 'no-drop'\n| 'not-allowed'\n| 'e-resize'\n| 'n-resize'\n| 'ne-resize'\n| 'nw-resize'\n| 's-resize'\n| 'se-resize'\n| 'sw-resize'\n| 'w-resize'\n| 'ns-resize'\n| 'ew-resize'\n| 'nesw-resize'\n| 'col-resize'\n| 'nwse-resize'\n| 'row-resize'\n| 'all-scroll'\n| 'zoom-in'\n| 'zoom-out'\n| 'grab'\n| 'grabbing';\n\n/**\n * The hit area specifies the area for which pointer events should be captured by this event target.\n * @memberof events\n */\nexport interface IHitArea\n{\n    /**\n     * Checks if the x and y coordinates given are contained within this hit area.\n     * @returns Whether the x and y coordinates are contained within this hit area.\n     */\n    contains(x: number, y: number): boolean;\n}\n\n/**\n * Function type for handlers, e.g., onclick\n * @memberof events\n */\nexport type FederatedEventHandler<T = FederatedPointerEvent> = (event: T) => void;\n\n/**\n * The type of interaction a Container can be.\n * This is the {@link scene.Container#eventMode|Container.eventMode} property of any {@link scene.Container}.\n *\n * Can be one of the following:\n * - `'none'`: Ignores all interaction events, even on its children.\n * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n * Interactive children will still emit events.\n * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7\n * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n * allow for interaction when the mouse isn't moving\n *\n * `none` and `passive` are useful for optimizing interaction events on objects as it reduces the number of hit tests\n * PixiJS has to do. `auto` is useful for when you want to recreate how the DOM handles interaction events with\n * `pointer-events: auto`.\n * @since 7.2.0\n * @memberof events\n */\nexport type EventMode = 'none' | 'passive' | 'auto' | 'static' | 'dynamic';\n\n/**\n * The properties available for any interactive object.\n * @memberof events\n */\nexport interface FederatedOptions\n{\n    /** The cursor preferred when the mouse pointer is hovering over. */\n    cursor?: Cursor | string;\n    /** The mode of interaction for this object */\n    eventMode?: EventMode;\n    /** Whether this event target should fire UI events. */\n    interactive?: boolean\n    /** Whether this event target has any children that need UI events. This can be used optimize event propagation. */\n    interactiveChildren?: boolean;\n    /** The hit-area specifies the area for which pointer events should be captured by this event target. */\n    hitArea?: IHitArea | null;\n    /** Handler for 'click' event */\n    onclick?: FederatedEventHandler | null;\n    /** Handler for 'mousedown' event */\n    onmousedown?: FederatedEventHandler | null;\n    /** Handler for 'mouseenter' event */\n    onmouseenter?: FederatedEventHandler | null;\n    /** Handler for 'mouseleave' event */\n    onmouseleave?: FederatedEventHandler | null;\n    /** Handler for 'mousemove' event */\n    onmousemove?: FederatedEventHandler | null;\n    /** Handler for 'globalmousemove' event */\n    onglobalmousemove?: FederatedEventHandler | null;\n    /** Handler for 'mouseout' event */\n    onmouseout?: FederatedEventHandler | null;\n    /** Handler for 'mouseover' event */\n    onmouseover?: FederatedEventHandler | null;\n    /** Handler for 'mouseup' event */\n    onmouseup?: FederatedEventHandler | null;\n    /** Handler for 'mouseupoutside' event */\n    onmouseupoutside?: FederatedEventHandler | null;\n    /** Handler for 'pointercancel' event */\n    onpointercancel?: FederatedEventHandler | null;\n    /** Handler for 'pointerdown' event */\n    onpointerdown?: FederatedEventHandler | null;\n    /** Handler for 'pointerenter' event */\n    onpointerenter?: FederatedEventHandler | null;\n    /** Handler for 'pointerleave' event */\n    onpointerleave?: FederatedEventHandler | null;\n    /** Handler for 'pointermove' event */\n    onpointermove?: FederatedEventHandler | null;\n    /** Handler for 'globalpointermove' event */\n    onglobalpointermove?: FederatedEventHandler | null;\n    /** Handler for 'pointerout' event */\n    onpointerout?: FederatedEventHandler | null;\n    /** Handler for 'pointerover' event */\n    onpointerover?: FederatedEventHandler | null;\n    /** Handler for 'pointertap' event */\n    onpointertap?: FederatedEventHandler | null;\n    /** Handler for 'pointerup' event */\n    onpointerup?: FederatedEventHandler | null;\n    /** Handler for 'pointerupoutside' event */\n    onpointerupoutside?: FederatedEventHandler | null;\n    /** Handler for 'rightclick' event */\n    onrightclick?: FederatedEventHandler | null;\n    /** Handler for 'rightdown' event */\n    onrightdown?: FederatedEventHandler | null;\n    /** Handler for 'rightup' event */\n    onrightup?: FederatedEventHandler | null;\n    /** Handler for 'rightupoutside' event */\n    onrightupoutside?: FederatedEventHandler | null;\n    /** Handler for 'tap' event */\n    ontap?: FederatedEventHandler | null;\n    /** Handler for 'touchcancel' event */\n    ontouchcancel?: FederatedEventHandler | null;\n    /** Handler for 'touchend' event */\n    ontouchend?: FederatedEventHandler | null;\n    /** Handler for 'touchendoutside' event */\n    ontouchendoutside?: FederatedEventHandler | null;\n    /** Handler for 'touchmove' event */\n    ontouchmove?: FederatedEventHandler | null;\n    /** Handler for 'globaltouchmove' event */\n    onglobaltouchmove?: FederatedEventHandler | null;\n    /** Handler for 'touchstart' event */\n    ontouchstart?: FederatedEventHandler | null;\n    /** Handler for 'wheel' event */\n    onwheel?: FederatedEventHandler<FederatedWheelEvent> | null;\n}\n\ntype AddListenerOptions = boolean | AddEventListenerOptions;\ntype RemoveListenerOptions = boolean | EventListenerOptions;\n\nexport interface IFederatedContainer extends FederatedOptions\n{\n    /** The parent of this event target. */\n    readonly parent?: Container;\n\n    /** The children of this event target. */\n    readonly children?: ReadonlyArray<Container>;\n\n    _internalEventMode: EventMode;\n\n    /** Returns true if the Container has interactive 'static' or 'dynamic' */\n    isInteractive: () => boolean;\n    addEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: AddListenerOptions\n    ): void;\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    ): void;\n    removeEventListener<K extends keyof AllFederatedEventMap>(\n        type: K,\n        listener: (e: AllFederatedEventMap[K]) => any,\n        options?: RemoveListenerOptions\n    ): void;\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    ): void;\n    dispatchEvent(e: FederatedEvent): boolean;\n}\n\nexport const FederatedContainer: IFederatedContainer = {\n\n    /**\n     * Property-based event handler for the `click` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onclick = (event) => {\n     *  //some function here that happens on click\n     * }\n     */\n    onclick: null,\n\n    /**\n     * Property-based event handler for the `mousedown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmousedown = (event) => {\n     *  //some function here that happens on mousedown\n     * }\n     */\n    onmousedown: null,\n\n    /**\n     * Property-based event handler for the `mouseenter` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseenter = (event) => {\n     *  //some function here that happens on mouseenter\n     * }\n     */\n    onmouseenter: null,\n\n    /**\n     * Property-based event handler for the `mouseleave` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseleave = (event) => {\n     *  //some function here that happens on mouseleave\n     * }\n     */\n    onmouseleave: null,\n\n    /**\n     * Property-based event handler for the `mousemove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmousemove = (event) => {\n     *  //some function here that happens on mousemove\n     * }\n     */\n    onmousemove: null,\n\n    /**\n     * Property-based event handler for the `globalmousemove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobalmousemove = (event) => {\n     *  //some function here that happens on globalmousemove\n     * }\n     */\n    onglobalmousemove: null,\n\n    /**\n     * Property-based event handler for the `mouseout` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseout = (event) => {\n     *  //some function here that happens on mouseout\n     * }\n     */\n    onmouseout: null,\n\n    /**\n     * Property-based event handler for the `mouseover` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseover = (event) => {\n     *  //some function here that happens on mouseover\n     * }\n     */\n    onmouseover:  null,\n\n    /**\n     * Property-based event handler for the `mouseup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseup = (event) => {\n     *  //some function here that happens on mouseup\n     * }\n     */\n    onmouseup:  null,\n\n    /**\n     * Property-based event handler for the `mouseupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onmouseupoutside = (event) => {\n     *  //some function here that happens on mouseupoutside\n     * }\n     */\n    onmouseupoutside: null,\n\n    /**\n     * Property-based event handler for the `pointercancel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointercancel = (event) => {\n     *  //some function here that happens on pointercancel\n     * }\n     */\n    onpointercancel: null,\n\n    /**\n     * Property-based event handler for the `pointerdown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerdown = (event) => {\n     *  //some function here that happens on pointerdown\n     * }\n     */\n    onpointerdown:  null,\n\n    /**\n     * Property-based event handler for the `pointerenter` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerenter = (event) => {\n     *  //some function here that happens on pointerenter\n     * }\n     */\n    onpointerenter: null,\n\n    /**\n     * Property-based event handler for the `pointerleave` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerleave = (event) => {\n     *  //some function here that happens on pointerleave\n     * }\n     */\n    onpointerleave:  null,\n\n    /**\n     * Property-based event handler for the `pointermove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointermove = (event) => {\n     *  //some function here that happens on pointermove\n     * }\n     */\n    onpointermove:  null,\n\n    /**\n     * Property-based event handler for the `globalpointermove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobalpointermove = (event) => {\n     *  //some function here that happens on globalpointermove\n     * }\n     */\n    onglobalpointermove:  null,\n\n    /**\n     * Property-based event handler for the `pointerout` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerout = (event) => {\n     *  //some function here that happens on pointerout\n     * }\n     */\n    onpointerout:  null,\n\n    /**\n     * Property-based event handler for the `pointerover` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerover = (event) => {\n     *  //some function here that happens on pointerover\n     * }\n     */\n    onpointerover:  null,\n\n    /**\n     * Property-based event handler for the `pointertap` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointertap = (event) => {\n     *  //some function here that happens on pointertap\n     * }\n     */\n    onpointertap:  null,\n\n    /**\n     * Property-based event handler for the `pointerup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerup = (event) => {\n     *  //some function here that happens on pointerup\n     * }\n     */\n    onpointerup:  null,\n\n    /**\n     * Property-based event handler for the `pointerupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onpointerupoutside = (event) => {\n     *  //some function here that happens on pointerupoutside\n     * }\n     */\n    onpointerupoutside:  null,\n\n    /**\n     * Property-based event handler for the `rightclick` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightclick = (event) => {\n     *  //some function here that happens on rightclick\n     * }\n     */\n    onrightclick:  null,\n\n    /**\n     * Property-based event handler for the `rightdown` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightdown = (event) => {\n     *  //some function here that happens on rightdown\n     * }\n     */\n    onrightdown:  null,\n\n    /**\n     * Property-based event handler for the `rightup` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightup = (event) => {\n     *  //some function here that happens on rightup\n     * }\n     */\n    onrightup:  null,\n\n    /**\n     * Property-based event handler for the `rightupoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onrightupoutside = (event) => {\n     *  //some function here that happens on rightupoutside\n     * }\n     */\n    onrightupoutside:  null,\n\n    /**\n     * Property-based event handler for the `tap` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontap = (event) => {\n     *  //some function here that happens on tap\n     * }\n     */\n    ontap:  null,\n\n    /**\n     * Property-based event handler for the `touchcancel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchcancel = (event) => {\n     *  //some function here that happens on touchcancel\n     * }\n     */\n    ontouchcancel:  null,\n\n    /**\n     * Property-based event handler for the `touchend` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchend = (event) => {\n     *  //some function here that happens on touchend\n     * }\n     */\n    ontouchend:  null,\n\n    /**\n     * Property-based event handler for the `touchendoutside` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchendoutside = (event) => {\n     *  //some function here that happens on touchendoutside\n     * }\n     */\n    ontouchendoutside:  null,\n\n    /**\n     * Property-based event handler for the `touchmove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchmove = (event) => {\n     *  //some function here that happens on touchmove\n     * }\n     */\n    ontouchmove:  null,\n\n    /**\n     * Property-based event handler for the `globaltouchmove` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onglobaltouchmove = (event) => {\n     *  //some function here that happens on globaltouchmove\n     * }\n     */\n    onglobaltouchmove:  null,\n\n    /**\n     * Property-based event handler for the `touchstart` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.ontouchstart = (event) => {\n     *  //some function here that happens on touchstart\n     * }\n     */\n    ontouchstart:  null,\n\n    /**\n     * Property-based event handler for the `wheel` event.\n     * @memberof scene.Container#\n     * @default null\n     * @example\n     * this.onwheel = (event) => {\n     *  //some function here that happens on wheel\n     * }\n     */\n    onwheel:  null,\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse\n     * @memberof scene.Container#\n     */\n    get interactive()\n    {\n        return this.eventMode === 'dynamic' || this.eventMode === 'static';\n    },\n    set interactive(value: boolean)\n    {\n        this.eventMode = value ? 'static' : 'passive';\n    },\n    /**\n     * @ignore\n     */\n    _internalEventMode: undefined,\n    /**\n     * Enable interaction events for the Container. Touch, pointer and mouse.\n     * There are 5 types of interaction settings:\n     * - `'none'`: Ignores all interaction events, even on its children.\n     * - `'passive'`: **(default)** Does not emit events and ignores all hit testing on itself and non-interactive children.\n     * Interactive children will still emit events.\n     * - `'auto'`: Does not emit events but is hit tested if parent is interactive. Same as `interactive = false` in v7\n     * - `'static'`: Emit events and is hit tested. Same as `interaction = true` in v7\n     * - `'dynamic'`: Emits events and is hit tested but will also receive mock interaction events fired from a ticker to\n     * allow for interaction when the mouse isn't moving\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.on('tap', (event) => {\n     *     // Handle event\n     * });\n     * @memberof scene.Container#\n     * @since 7.2.0\n     */\n    get eventMode()\n    {\n        return this._internalEventMode ?? EventSystem.defaultEventMode;\n    },\n    set eventMode(value)\n    {\n        this._internalEventMode = value;\n    },\n\n    /**\n     * Determines if the container is interactive or not\n     * @returns {boolean} Whether the container is interactive or not\n     * @memberof scene.Container#\n     * @since 7.2.0\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.eventMode = 'static';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'dynamic';\n     * sprite.isInteractive(); // true\n     *\n     * sprite.eventMode = 'none';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'passive';\n     * sprite.isInteractive(); // false\n     *\n     * sprite.eventMode = 'auto';\n     * sprite.isInteractive(); // false\n     */\n    isInteractive(): boolean\n    {\n        return this.eventMode === 'static' || this.eventMode === 'dynamic';\n    },\n\n    /**\n     * Determines if the children to the container can be clicked/touched\n     * Setting this to false allows PixiJS to bypass a recursive `hitTest` function\n     * @memberof scene.Container#\n     */\n    interactiveChildren: true,\n\n    /**\n     * Interaction shape. Children will be hit first, then this shape will be checked.\n     * Setting this will cause this shape to be checked in hit tests rather than the container's bounds.\n     * @example\n     * import { Rectangle, Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite(texture);\n     * sprite.interactive = true;\n     * sprite.hitArea = new Rectangle(0, 0, 100, 100);\n     * @member {IHitArea}\n     * @memberof scene.Container#\n     */\n    hitArea: null,\n\n    /**\n     * Unlike `on` or `addListener` which are methods from EventEmitter, `addEventListener`\n     * seeks to be compatible with the DOM's `addEventListener` with support for options.\n     * @memberof scene.Container\n     * @param type - The type of event to listen to.\n     * @param listener - The listener callback or object.\n     * @param options - Listener options, used for capture phase.\n     * @example\n     * // Tell the user whether they did a single, double, triple, or nth click.\n     * button.addEventListener('click', {\n     *     handleEvent(e): {\n     *         let prefix;\n     *\n     *         switch (e.detail) {\n     *             case 1: prefix = 'single'; break;\n     *             case 2: prefix = 'double'; break;\n     *             case 3: prefix = 'triple'; break;\n     *             default: prefix = e.detail + 'th'; break;\n     *         }\n     *\n     *         console.log('That was a ' + prefix + 'click');\n     *     }\n     * });\n     *\n     * // But skip the first click!\n     * button.parent.addEventListener('click', function blockClickOnce(e) {\n     *     e.stopImmediatePropagation();\n     *     button.parent.removeEventListener('click', blockClickOnce, true);\n     * }, {\n     *     capture: true,\n     * });\n     */\n    addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: AddListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n        || (typeof options === 'object' && options.capture);\n        const signal = typeof options === 'object' ? options.signal : undefined;\n        const once = typeof options === 'object' ? (options.once === true) : false;\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        const listenerFn = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        const emitter = (this as unknown as EventEmitter);\n\n        if (signal)\n        {\n            signal.addEventListener('abort', () =>\n            {\n                emitter.off(type, listenerFn, context);\n            });\n        }\n\n        if (once)\n        {\n            emitter.once(type, listenerFn, context);\n        }\n        else\n        {\n            emitter.on(type, listenerFn, context);\n        }\n    },\n\n    /**\n     * Unlike `off` or `removeListener` which are methods from EventEmitter, `removeEventListener`\n     * seeks to be compatible with the DOM's `removeEventListener` with support for options.\n     * @memberof scene.Container\n     * @param type - The type of event the listener is bound to.\n     * @param listener - The listener callback or object.\n     * @param options - The original listener options. This is required to deregister a capture phase listener.\n     */\n    removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: RemoveListenerOptions\n    )\n    {\n        const capture = (typeof options === 'boolean' && options)\n            || (typeof options === 'object' && options.capture);\n        const context = typeof listener === 'function' ? undefined : listener;\n\n        type = capture ? `${type}capture` : type;\n        listener = typeof listener === 'function' ? listener : listener.handleEvent;\n\n        (this as unknown as EventEmitter).off(type, listener, context);\n    },\n\n    /**\n     * Dispatch the event on this {@link Container} using the event's {@link EventBoundary}.\n     *\n     * The target of the event is set to `this` and the `defaultPrevented` flag is cleared before dispatch.\n     * @memberof scene.Container\n     * @param e - The event to dispatch.\n     * @returns Whether the {@link FederatedEvent.preventDefault preventDefault}() method was not invoked.\n     * @example\n     * // Reuse a click event!\n     * button.dispatchEvent(clickEvent);\n     */\n    dispatchEvent(e: Event): boolean\n    {\n        if (!(e instanceof FederatedEvent))\n        {\n            throw new Error('Container cannot propagate events outside of the Federated Events API');\n        }\n\n        e.defaultPrevented = false;\n        e.path = null;\n        e.target = this as Container;\n        e.manager.dispatchEvent(e);\n\n        return !e.defaultPrevented;\n    }\n};\n", "import { ExtensionType } from '../extensions/Extensions';\nimport { type DOMContainer } from './DOMContainer';\n\nimport type { InstructionSet } from '../rendering/renderers/shared/instructions/InstructionSet';\nimport type { RenderPipe } from '../rendering/renderers/shared/instructions/RenderPipe';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { Container } from '../scene/container/Container';\n\n/**\n * The DOMPipe class is responsible for managing and rendering DOM elements within a PixiJS scene.\n * It maps dom elements to the canvas and ensures they are correctly positioned and visible.\n */\nexport class DOMPipe implements RenderPipe<DOMContainer>\n{\n    /**\n     * Static property defining the extension type and name for the DOMPipe.\n     * This is used to register the DOMPipe with different rendering pipelines.\n     */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'dom',\n    } as const;\n\n    private _renderer: Renderer;\n    private readonly _destroyRenderableBound = this.destroyRenderable.bind(this) as (renderable: Container) => void;\n\n    /** Array to keep track of attached DOM elements */\n    private readonly _attachedDomElements: DOMContainer[] = [];\n    /** The main DOM element that acts as a container for other DOM elements */\n    private readonly _domElement: HTMLDivElement;\n\n    /**\n     * Constructor for the DOMPipe class.\n     * @param renderer - The renderer instance that this DOMPipe will be associated with.\n     */\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n\n        // Add this DOMPipe to the postrender runner of the renderer\n        // we want to dom elements are calculated after all things have been rendered\n        this._renderer.runners.postrender.add(this);\n\n        // Create a main DOM element to contain other DOM elements\n        this._domElement = document.createElement('div');\n        this._domElement.style.position = 'absolute';\n        this._domElement.style.top = '0';\n        this._domElement.style.left = '0';\n        this._domElement.style.pointerEvents = 'none';\n        this._domElement.style.zIndex = '1000';\n    }\n\n    /**\n     * Adds a renderable DOM container to the list of attached elements.\n     * @param domContainer - The DOM container to be added.\n     * @param _instructionSet - The instruction set (unused).\n     */\n    public addRenderable(domContainer: DOMContainer, _instructionSet: InstructionSet): void\n    {\n        if (!this._attachedDomElements.includes(domContainer))\n        {\n            this._attachedDomElements.push(domContainer);\n            domContainer.on('destroyed', this._destroyRenderableBound);\n        }\n    }\n\n    /**\n     * Updates a renderable DOM container.\n     * @param _domContainer - The DOM container to be updated (unused).\n     */\n    public updateRenderable(_domContainer: DOMContainer): void\n    {\n        // Updates happen in postrender\n    }\n\n    /**\n     * Validates a renderable DOM container.\n     * @param _domContainer - The DOM container to be validated (unused).\n     * @returns Always returns true as validation is not required.\n     */\n    public validateRenderable(_domContainer: DOMContainer): boolean\n    {\n        return true;\n    }\n\n    /**\n     * Destroys a renderable DOM container, removing it from the list of attached elements.\n     * @param domContainer - The DOM container to be destroyed.\n     */\n    public destroyRenderable(domContainer: DOMContainer): void\n    {\n        const index = this._attachedDomElements.indexOf(domContainer);\n\n        if (index !== -1)\n        {\n            this._attachedDomElements.splice(index, 1);\n        }\n\n        domContainer.off('destroyed', this._destroyRenderableBound);\n    }\n\n    /** Handles the post-rendering process, ensuring DOM elements are correctly positioned and visible. */\n    public postrender(): void\n    {\n        const attachedDomElements = this._attachedDomElements;\n\n        if (attachedDomElements.length === 0)\n        {\n            this._domElement.remove();\n\n            return;\n        }\n\n        const canvas = this._renderer.view.canvas as HTMLCanvasElement;\n\n        if (this._domElement.parentNode !== canvas.parentNode)\n        {\n            canvas.parentNode?.appendChild(this._domElement);\n        }\n\n        this._domElement.style.transform = `translate(${canvas.offsetLeft}px, ${canvas.offsetTop}px)`;\n\n        for (let i = 0; i < attachedDomElements.length; i++)\n        {\n            const domContainer = attachedDomElements[i];\n            const element = domContainer.element;\n\n            if (!domContainer.parent || domContainer.globalDisplayStatus < 0b111)\n            {\n                element.remove();\n                attachedDomElements.splice(i, 1);\n                i--;\n            }\n            else\n            {\n                if (!this._domElement.contains(element))\n                {\n                    element.style.position = 'absolute';\n                    element.style.pointerEvents = 'auto';\n                    this._domElement.appendChild(element);\n                }\n\n                const wt = domContainer.worldTransform;\n                const anchor = domContainer._anchor;\n                const ax = domContainer.width * anchor.x;\n                const ay = domContainer.height * anchor.y;\n\n                element.style.transformOrigin = `${ax}px ${ay}px`;\n                element.style.transform = `matrix(${wt.a}, ${wt.b}, ${wt.c}, ${wt.d}, ${wt.tx - ax}, ${wt.ty - ay})`;\n                element.style.opacity = domContainer.groupAlpha.toString();\n            }\n        }\n    }\n\n    /** Destroys the DOMPipe, removing all attached DOM elements and cleaning up resources. */\n    public destroy(): void\n    {\n        this._renderer.runners.postrender.remove(this);\n\n        for (let i = 0; i < this._attachedDomElements.length; i++)\n        {\n            const domContainer = this._attachedDomElements[i];\n\n            domContainer.off('destroyed', this._destroyRenderableBound);\n            domContainer.element.remove();\n        }\n\n        this._attachedDomElements.length = 0;\n        this._domElement.remove();\n        this._renderer = null;\n    }\n}\n"],
  "mappings": "kFAqCO,IAAMA,EAAN,MAAMC,CACb,CAsGI,YAAYC,EACZ,CArGA,KAAO,QAAU,GAGjB,KAAO,aAAe,GAMtB,KAAgB,WAAa,GAO7B,KAAgB,SAAW,GAM3B,KAAO,iBAAmB,GAMnB,KAAA,WAAaD,EAAe,UAAU,KA2B7C,KAAO,mBAAqB,GAG5B,KAAO,8BAAgC,GAqBhC,KAAA,MAAe,IAAIE,EASnB,KAAA,KAAc,IAAIA,EAgGzB,KAAgB,KAAO,EACvB,KAAgB,gBAAkB,EAClC,KAAgB,UAAY,EAC5B,KAAgB,eAAiB,EArF7B,KAAK,QAAUD,CAAA,CApBnB,IAAI,QAAiB,CAAE,OAAO,KAAK,MAAM,CAAA,CAGzC,IAAI,QAAiB,CAAE,OAAO,KAAK,MAAM,CAAA,CAMzC,IAAI,OAAgB,CAAE,OAAO,KAAK,KAAK,CAAA,CAGvC,IAAI,OAAgB,CAAE,OAAO,KAAK,KAAK,CAAA,CAevC,IAAI,MACJ,CACW,OAAA,IAAA,CAIJ,cACP,CAGI,OAAI,KAAK,UAAY,CAAC,KAAK,MAAQ,KAAK,KAAK,KAAK,KAAK,OAAS,CAAC,IAAM,KAAK,UAEnE,KAAA,KAAO,KAAK,OAAS,KAAK,QAAQ,gBAAgB,KAAK,MAAM,EAAI,CAAA,GAGnE,KAAK,IAAA,CAUT,UAAUE,EAAeC,EAAoBC,EACpD,CACU,MAAA,IAAI,MAAM,qFAAqF,CAAA,CAYlG,YAAYC,EAAkBC,EAAuBC,EAA0BC,EAClFC,EACJ,CACU,MAAA,IAAI,MAAM,uFAAuF,CAAA,CAIpG,gBACP,CACQ,KAAK,uBAAuB,OAAS,KAAK,YAAY,YAEtD,KAAK,YAAY,eAAe,EAGpC,KAAK,iBAAmB,EAAA,CAQrB,0BACP,CACI,KAAK,8BAAgC,EAAA,CAOlC,iBACP,CACI,KAAK,mBAAqB,EAAA,CAOlC,ECpOA,IAAMC,EAAc,UACdC,EAAY,QACZC,EAAc,QACdC,EAAiB,8BACjBC,EAAe,2BACfC,EAAgB,WAChBC,EAAc,qCACdC,EAAe,QACfC,EAAe,iBACfC,EAAgB,wBAChBC,EAAkB,cAClBC,EAAoB,QACpBC,EAAa,cACbC,EAAc,gCACdC,EAAe,yBASfC,EAAuB,SAACC,EAAqB,CACjD,OACE,OAAOA,EAAc,KACrBA,EAAU,WAAa,YACvB,OAAOA,EAAU,gBAAmB,UACpCA,EAAU,eAAiB,GAC3B,OAAO,SAAa,GAExB,EAEA,SAASC,GAAYC,EAAoB,CACvC,OAAO,SAACC,EAAa,CAAc,OAAAA,EAAM,KAAKD,CAAS,CAApB,CACrC,CAwCc,SAAPE,EAA0BC,EAAyB,CACxD,IAAIC,EAAiB,CACnB,UAAW,GACX,SAAU,GACV,eAAgB,GAGd,CAACD,GAAS,OAAO,UAAc,IACjCC,EAAM,CACJ,UAAW,UAAU,UACrB,SAAU,UAAU,SACpB,eAAgB,UAAU,gBAAkB,GAErC,OAAOD,GAAU,SAC1BC,EAAI,UAAYD,EACPA,GAASA,EAAM,YACxBC,EAAM,CACJ,UAAWD,EAAM,UACjB,SAAUA,EAAM,SAChB,eAAgBA,EAAM,gBAAkB,IAI5C,IAAIH,EAAYI,EAAI,UAIhBC,EAAML,EAAU,MAAM,OAAO,EAC7B,OAAOK,EAAI,CAAC,EAAM,MACpBL,EAAYK,EAAI,CAAC,GAMnBA,EAAML,EAAU,MAAM,SAAS,EAC3B,OAAOK,EAAI,CAAC,EAAM,MACpBL,EAAYK,EAAI,CAAC,GAGnB,IAAMC,EAAQP,GAAYC,CAAS,EAE7BO,EAAyB,CAC7B,MAAO,CACL,MAAOD,EAAMxB,CAAW,GAAK,CAACwB,EAAMhB,CAAY,EAChD,KAAMgB,EAAMvB,CAAS,EACrB,OACE,CAACuB,EAAMxB,CAAW,IACjBwB,EAAMtB,CAAW,GAAKa,EAAqBO,CAAG,IAC/C,CAACE,EAAMhB,CAAY,EACrB,UAAWgB,EAAMrB,CAAc,EAC/B,QACGqB,EAAMxB,CAAW,GAChBwB,EAAMvB,CAAS,GACfuB,EAAMtB,CAAW,GACjBsB,EAAMrB,CAAc,GACpBY,EAAqBO,CAAG,IAC1B,CAACE,EAAMhB,CAAY,GAEvB,OAAQ,CACN,MAAOgB,EAAMlB,CAAW,EACxB,OAAQ,CAACkB,EAAMlB,CAAW,GAAKkB,EAAMjB,CAAY,EACjD,OAAQiB,EAAMlB,CAAW,GAAKkB,EAAMjB,CAAY,GAElD,QAAS,CACP,MACG,CAACiB,EAAMhB,CAAY,GAAKgB,EAAMlB,CAAW,GACzC,CAACkB,EAAMhB,CAAY,GAAKgB,EAAMpB,CAAY,EAC7C,OACE,CAACoB,EAAMhB,CAAY,GACnB,CAACgB,EAAMlB,CAAW,GAClB,CAACkB,EAAMpB,CAAY,IAClBoB,EAAMjB,CAAY,GAAKiB,EAAMnB,CAAa,GAC7C,OACG,CAACmB,EAAMhB,CAAY,IACjBgB,EAAMlB,CAAW,GAChBkB,EAAMjB,CAAY,GAClBiB,EAAMpB,CAAY,GAClBoB,EAAMnB,CAAa,IACvBmB,EAAM,aAAa,GAEvB,QAAS,CACP,MAAOA,EAAMhB,CAAY,EACzB,OAAQgB,EAAMf,CAAa,EAC3B,OAAQe,EAAMhB,CAAY,GAAKgB,EAAMf,CAAa,GAEpD,MAAO,CACL,WAAYe,EAAMd,CAAe,EACjC,aAAcc,EAAMb,CAAiB,EACrC,MAAOa,EAAMZ,CAAU,EACvB,QAASY,EAAMV,CAAY,EAC3B,OAAQU,EAAMX,CAAW,EACzB,OACEW,EAAMd,CAAe,GACrBc,EAAMb,CAAiB,GACvBa,EAAMZ,CAAU,GAChBY,EAAMV,CAAY,GAClBU,EAAMX,CAAW,GAErB,IAAK,GACL,MAAO,GACP,OAAQ,IAGV,OAAAY,EAAO,IACLA,EAAO,MAAM,QACbA,EAAO,QAAQ,QACfA,EAAO,QAAQ,QACfA,EAAO,MAAM,OAEfA,EAAO,MACLA,EAAO,MAAM,OAASA,EAAO,QAAQ,OAASA,EAAO,QAAQ,MAC/DA,EAAO,OACLA,EAAO,MAAM,QAAUA,EAAO,QAAQ,QAAUA,EAAO,QAAQ,OAE1DA,CACT,CC3LA,IAAMC,GAAgBC,EAA8B,SAAWA,EAsFlDA,EAA2BD,GAAa,WAAW,SAAS,ECvCzE,IAAME,GAAe,EAEfC,EAAiB,IACjBC,GAAkB,EAClBC,GAAkB,EAClBC,EAAmB,EAEnBC,GAAgB,EAChBC,GAAiB,KACjBC,GAAiB,KACjBC,GAAkB,EAkDXC,EAAN,MAAMA,EACb,CAgFI,YAAYC,EAAqCC,EAA8BC,EAC/E,CADiD,KAAA,YAAAD,EA7CjD,KAAO,MAAQ,GAGf,KAAQ,eAAiB,GAGzB,KAAQ,uBAAyB,GASjC,KAAQ,UAAY,GAGpB,KAAQ,uBAAyB,GAMjC,KAAQ,KAA2B,KAGnC,KAAQ,MAAiC,CAAA,EAGzC,KAAQ,UAAY,EAGpB,KAAQ,UAAyB,CAAA,EAGjC,KAAQ,oBAAsB,EAG9B,KAAiB,wBAA0B,IAQvC,KAAK,SAAW,MAEZA,EAAY,QAAUA,EAAY,QAElC,KAAK,iBAAiB,EAG1B,KAAK,UAAYD,CAAA,CAQrB,IAAI,UACJ,CACI,OAAO,KAAK,SAAA,CAQhB,IAAI,uBACJ,CACI,OAAO,KAAK,sBAAA,CAGhB,IAAI,SACJ,CACI,OAAO,KAAK,QAAA,CAOR,kBACR,CACU,IAAAG,EAAU,SAAS,cAAc,QAAQ,EAEvCA,EAAA,MAAM,MAAQ,GAAGR,EAAa,KAC9BQ,EAAA,MAAM,OAAS,GAAGR,EAAa,KACvCQ,EAAQ,MAAM,SAAW,WACjBA,EAAA,MAAM,IAAM,GAAGP,EAAc,KAC7BO,EAAA,MAAM,KAAO,GAAGN,EAAc,KAC9BM,EAAA,MAAM,OAASL,GAAgB,SAAS,EAChDK,EAAQ,MAAM,gBAAkB,UAChCA,EAAQ,MAAQ,kDAERA,EAAA,iBAAiB,QAAS,IAClC,CACI,KAAK,uBAAyB,GAC9B,KAAK,UAAU,EACf,KAAK,kBAAkB,CAAA,CAC1B,EAEQ,SAAA,KAAK,YAAYA,CAAO,EACjC,KAAK,SAAWA,CAAA,CAOZ,mBACR,CACS,KAAK,WAID,SAAA,KAAK,YAAY,KAAK,QAAQ,EACvC,KAAK,SAAW,KAAA,CAQZ,WACR,CACI,GAAI,KAAK,UAEL,OAGJ,KAAK,UAAY,GAGZ,KAAK,OAED,KAAA,KAAO,SAAS,cAAc,KAAK,EACxC,KAAK,KAAK,MAAM,MAAQ,GAAGZ,CAAc,KACzC,KAAK,KAAK,MAAM,OAAS,GAAGA,CAAc,KACrC,KAAA,KAAK,MAAM,SAAW,WAC3B,KAAK,KAAK,MAAM,IAAM,GAAGC,EAAe,KACxC,KAAK,KAAK,MAAM,KAAO,GAAGC,EAAe,KACzC,KAAK,KAAK,MAAM,OAASC,EAAiB,SAAS,EAC9C,KAAA,KAAK,MAAM,cAAgB,QAIhC,KAAK,iBAEL,KAAK,WAAa,KAAK,WAAW,KAAK,IAAI,EAC3C,WAAW,iBAAiB,UAAW,KAAK,WAAY,EAAK,GAG7D,KAAK,yBAEL,KAAK,aAAe,KAAK,aAAa,KAAK,IAAI,EAC/C,WAAW,SAAS,iBAAiB,YAAa,KAAK,aAAc,EAAI,GAIvE,IAAAU,EAAS,KAAK,UAAU,KAAK,OAE/B,GAACA,EAAO,WAmBDA,EAAA,WAAW,YAAY,KAAK,IAAI,EAGvC,KAAK,wBAAwB,MArBjC,CACU,IAAAC,EAAW,IAAI,iBAAiB,IACtC,CACQD,EAAO,aAEAA,EAAA,WAAW,YAAY,KAAK,IAAI,EACvCC,EAAS,WAAW,EAGpB,KAAK,wBAAwB,EACjC,CACH,EAEQA,EAAA,QAAQ,SAAS,KAAM,CAAE,UAAW,GAAM,QAAS,EAAA,CAAM,CAAA,CAStE,CAII,yBACR,CAEI,KAAK,UAAU,QAAQ,WAAW,IAAI,IAAI,EAGtC,KAAK,UAAU,oBAEV,KAAA,yBAAyB,KAAK,UAAU,kBAA+B,CAChF,CAOI,aACR,CACI,GAAI,GAAC,KAAK,WAAa,KAAK,wBAK5B,MAAK,UAAY,GAGjB,WAAW,SAAS,oBAAoB,YAAa,KAAK,aAAc,EAAI,EACxE,KAAK,gBAEL,WAAW,iBAAiB,UAAW,KAAK,WAAY,EAAK,EAGjE,KAAK,UAAU,QAAQ,WAAW,OAAO,IAAI,EAGlC,QAAAC,KAAS,KAAK,UAEjBA,EAAM,gBAAkBA,EAAM,eAAe,aAE7CA,EAAM,eAAe,WAAW,YAAYA,EAAM,cAAc,EAChEA,EAAM,eAAiB,MAE3BA,EAAM,kBAAoB,GAIzB,KAAA,MAAM,QAASC,GACpB,CACQA,EAAI,YAEAA,EAAA,WAAW,YAAYA,CAAG,CAClC,CACH,EAGG,KAAK,MAAQ,KAAK,KAAK,YAEvB,KAAK,KAAK,WAAW,YAAY,KAAK,IAAI,EAG9C,KAAK,MAAQ,CAAA,EACb,KAAK,UAAY,CAAA,EAAC,CAQd,yBAAyBC,EACjC,CACI,GAAI,CAACA,EAAU,SAAW,CAACA,EAAU,mBAEjC,OAIAA,EAAU,aAELA,EAAU,mBAEX,KAAK,UAAUA,CAAS,EAG5BA,EAAU,UAAY,KAAK,WAG/B,IAAMC,EAAWD,EAAU,SAE3B,GAAIC,EAEA,QAAS,EAAI,EAAG,EAAIA,EAAS,OAAQ,IAE5B,KAAA,yBAAyBA,EAAS,CAAC,CAAc,CAE9D,CAOG,KAAKC,EACZ,CAGI,IAAMC,EAAgB,CAClB,qBAAsB,CAClB,GAHYZ,GAAoB,eAIhC,GAAIW,GAAS,sBAAwB,CAAA,CAAC,CAC1C,EAGC,KAAA,MAAQC,EAAc,qBAAqB,MAC3C,KAAA,eAAiBA,EAAc,qBAAqB,cACpD,KAAA,uBAAyBA,EAAc,qBAAqB,sBAE7DA,EAAc,qBAAqB,iBAEnC,KAAK,UAAU,EAEV,KAAK,iBAEV,KAAK,WAAa,KAAK,WAAW,KAAK,IAAI,EAC3C,WAAW,iBAAiB,UAAW,KAAK,WAAY,EAAK,GAGjE,KAAK,UAAU,QAAQ,WAAW,OAAO,IAAI,CAAA,CAW1C,YACP,CAKU,IAAAC,EAAM,YAAY,IAAI,EASxB,GAPA,KAAK,YAAY,QAAQ,QAAUA,EAAM,KAAK,sBAK7C,KAAA,oBAAsBA,EAAM,KAAK,wBAElC,CAAC,KAAK,UAAU,mBAAqB,CAAC,KAAK,UAAU,KAAK,QAE1D,OAIE,IAAAC,EAAA,IAAgB,IAElB,GAAA,KAAK,UAAU,mBACnB,CACS,KAAA,yBAAyB,KAAK,UAAU,kBAA+B,EAGjE,QAAAP,KAAS,KAAK,UAEjBA,EAAM,YAAc,KAAK,WAEzBO,EAAU,IAAI,KAAK,UAAU,QAAQP,CAAK,CAAC,CAEnD,CAIJ,QAAS,EAAI,KAAK,UAAU,OAAS,EAAG,GAAK,EAAG,IAChD,CACU,IAAAA,EAAQ,KAAK,UAAU,CAAC,EAEzBO,EAAU,IAAI,CAAC,IAGZP,EAAM,gBAAkBA,EAAM,eAAe,aAE7CA,EAAM,eAAe,WAAW,YAAYA,EAAM,cAAc,EAE3D,KAAA,MAAM,KAAKA,EAAM,cAAc,EACpCA,EAAM,eAAiB,MAE3BA,EAAM,kBAAoB,GACdQ,EAAA,KAAK,UAAW,EAAG,CAAC,EACpC,CAIA,GAAA,KAAK,UAAU,kBACnB,CACU,GAAA,CAAE,EAAAC,EAAG,EAAAC,EAAG,MAAOC,EAAW,OAAQC,CAAA,EAAe,KAAK,UAAU,OAChEX,EAAM,KAAK,KAEbA,EAAA,MAAM,KAAO,GAAGQ,CAAC,KACjBR,EAAA,MAAM,IAAM,GAAGS,CAAC,KAChBT,EAAA,MAAM,MAAQ,GAAGU,CAAS,KAC1BV,EAAA,MAAM,OAAS,GAAGW,CAAU,IAAA,CAIpC,QAAS,EAAI,EAAG,EAAI,KAAK,UAAU,OAAQ,IAC3C,CACU,IAAAZ,EAAQ,KAAK,UAAU,CAAC,EAE9B,GAAI,CAACA,EAAM,mBAAqB,CAACA,EAAM,eAEnC,SAIJ,IAAMC,EAAMD,EAAM,eACZa,EAAWb,EAAM,SAAWA,EAAM,UAAA,EAAY,UAEpD,GAAIA,EAAM,QACV,CACI,IAAMc,EAAKd,EAAM,eACXe,EAAK,KAAK,UAAU,WACpBC,EAAK,KAAK,UAAU,WAEtBf,EAAA,MAAM,KAAO,IAAIa,EAAG,GAAMD,EAAQ,EAAIC,EAAG,GAAMC,CAAE,KACjDd,EAAA,MAAM,IAAM,IAAIa,EAAG,GAAMD,EAAQ,EAAIC,EAAG,GAAME,CAAE,KACpDf,EAAI,MAAM,MAAQ,GAAGY,EAAQ,MAAQC,EAAG,EAAIC,CAAE,KAC9Cd,EAAI,MAAM,OAAS,GAAGY,EAAQ,OAASC,EAAG,EAAIE,CAAE,IAAA,KAGpD,CACI,KAAK,YAAYH,CAAO,EAClB,IAAAE,EAAK,KAAK,UAAU,WACpBC,EAAK,KAAK,UAAU,WAE1Bf,EAAI,MAAM,KAAO,GAAGY,EAAQ,EAAIE,CAAE,KAClCd,EAAI,MAAM,IAAM,GAAGY,EAAQ,EAAIG,CAAE,KACjCf,EAAI,MAAM,MAAQ,GAAGY,EAAQ,MAAQE,CAAE,KACvCd,EAAI,MAAM,OAAS,GAAGY,EAAQ,OAASG,CAAE,IAAA,CAC7C,CAIC,KAAA,WAAA,CAQD,iBAAiBf,EACzB,CACQA,EAAA,UAAY,SAASA,EAAI,IAAI,iBAAiBA,EAAI,KAAK,mBAAmBA,EAAI,QAAQ,EAAA,CAOtF,YAAYY,EACpB,CACQA,EAAQ,EAAI,IAEZA,EAAQ,OAASA,EAAQ,EACzBA,EAAQ,EAAI,GAGZA,EAAQ,EAAI,IAEZA,EAAQ,QAAUA,EAAQ,EAC1BA,EAAQ,EAAI,GAGhB,GAAM,CAAE,MAAOF,EAAW,OAAQC,CAAA,EAAe,KAAK,UAElDC,EAAQ,EAAIA,EAAQ,MAAQF,IAEpBE,EAAA,MAAQF,EAAYE,EAAQ,GAGpCA,EAAQ,EAAIA,EAAQ,OAASD,IAErBC,EAAA,OAASD,EAAaC,EAAQ,EAC1C,CASI,UAA+BX,EACvC,CACQ,IAAAD,EAAM,KAAK,MAAM,IAAI,EAEpBA,IAEGC,EAAU,iBAAmB,SAEvBD,EAAA,SAAS,cAAc,QAAQ,GAI/BA,EAAA,SAAS,cAAcC,EAAU,cAAc,EACrDD,EAAI,MAAM,QAAU;;;;;;;;;;;;;sBAchBC,EAAU,iBAEVD,EAAI,UAAYC,EAAU,iBAG9BD,EAAA,MAAM,MAAQ,GAAGhB,CAAc,KAC/BgB,EAAA,MAAM,OAAS,GAAGhB,CAAc,KACpCgB,EAAI,MAAM,gBAAkB,KAAK,MAAQ,wBAA0B,cACnEA,EAAI,MAAM,SAAW,WACjBA,EAAA,MAAM,OAASb,EAAiB,SAAS,EAC7Ca,EAAI,MAAM,YAAc,OAGpB,UAAU,UAAU,YAAA,EAAc,SAAS,QAAQ,EAG/CA,EAAA,aAAa,YAAa,KAAK,EAI/BA,EAAA,aAAa,YAAa,QAAQ,EAGtC,UAAU,UAAU,MAAM,cAAc,EAGpCA,EAAA,aAAa,gBAAiB,WAAW,EAKzCA,EAAA,aAAa,gBAAiB,MAAM,EAG5CA,EAAI,iBAAiB,QAAS,KAAK,SAAS,KAAK,IAAI,CAAC,EACtDA,EAAI,iBAAiB,QAAS,KAAK,SAAS,KAAK,IAAI,CAAC,EACtDA,EAAI,iBAAiB,WAAY,KAAK,YAAY,KAAK,IAAI,CAAC,GAI5DA,EAAA,MAAM,cAAgBC,EAAU,wBAEpCD,EAAI,KAAOC,EAAU,eAEjBA,EAAU,iBAAmBA,EAAU,kBAAoB,KAE3DD,EAAI,MAAQC,EAAU,iBAEjB,CAACA,EAAU,gBACbA,EAAU,iBAAmB,QAE5BD,EAAA,MAAQ,aAAaC,EAAU,QAAQ,IAG3CA,EAAU,gBACPA,EAAU,iBAAmB,MAE5BD,EAAA,aAAa,aAAcC,EAAU,cAAc,EAGvD,KAAK,OAEL,KAAK,iBAAiBD,CAAG,EAG7BC,EAAU,kBAAoB,GAC9BA,EAAU,eAAiBD,EAC3BA,EAAI,UAAYC,EAEX,KAAA,UAAU,KAAKA,CAAS,EACxB,KAAA,KAAK,YAAYA,EAAU,cAAc,EAC1CA,EAAU,cAEAA,EAAA,eAAe,SAAWA,EAAU,SAClD,CASI,eAAe,EAAYe,EACnC,CACI,GAAM,CAAE,UAAWC,CAAO,EAAI,EAAE,OAC1BC,EAAW,KAAK,UAAU,OAAO,aACjCC,EAAwB,OAAO,OAAO,IAAIC,EAAeF,CAAQ,EAAG,CAAE,OAAAD,CAAA,CAAQ,EAE3EC,EAAA,WAAa,KAAK,UAAU,mBACrCF,EAAK,QAASA,GAASE,EAAS,cAAcC,EAAOH,CAAI,CAAC,CAAA,CAQtD,SAAS,EACjB,CACI,KAAK,eAAe,EAAG,CAAC,QAAS,aAAc,KAAK,CAAC,CAAA,CAQjD,SAAS,EACjB,CACU,EAAE,OAAmB,aAAa,WAAW,GAE9C,EAAE,OAAmB,aAAa,YAAa,WAAW,EAG/D,KAAK,eAAe,EAAG,CAAC,WAAW,CAAC,CAAA,CAQhC,YAAY,EACpB,CACU,EAAE,OAAmB,aAAa,WAAW,GAE9C,EAAE,OAAmB,aAAa,YAAa,QAAQ,EAG5D,KAAK,eAAe,EAAG,CAAC,UAAU,CAAC,CAAA,CAQ/B,WAAW,EACnB,CACQ,EAAE,UAAYjC,IAAgB,CAAC,KAAK,gBAKxC,KAAK,UAAU,CAAA,CAQX,aAAa,EACrB,CACQ,EAAE,YAAc,GAAK,EAAE,YAAc,GAKzC,KAAK,YAAY,CAAA,CAId,SACP,CACI,KAAK,YAAY,EACjB,KAAK,kBAAkB,EAEvB,KAAK,KAAO,KACZ,KAAK,MAAQ,KACb,KAAK,UAAY,KACjB,KAAK,UAAY,KAEb,KAAK,gBAEM,WAAA,oBAAoB,UAAW,KAAK,UAAU,CAC7D,CAOG,wBAAwBsC,EAC/B,CACQA,EAEA,KAAK,UAAU,EAIf,KAAK,YAAY,CACrB,CAER,EA5uBa7B,EAGK,UAAY,CACtB,KAAM,CACF8B,EAAc,YACdA,EAAc,YAAA,EAElB,KAAM,eACV,EATS9B,EAYK,eAAuC,CAKjD,iBAAkB,GAKlB,MAAO,GAKP,cAAe,GAKf,sBAAuB,EAC3B,EAjCG,IAAM+B,GAAN/B,ECJA,IAAMgC,GAAwC,CAOjD,WAAY,GAQZ,gBAAiB,KAOjB,eAAgB,KAOhB,SAAU,EAOV,kBAAmB,GAMnB,eAAgB,KAShB,eAAgB,SAOhB,eAAgB,KAShB,wBAAyB,OASzB,mBAAoB,GAOpB,UAAW,EACf,EClLA,IAAMC,EAAN,KACA,CADA,aAAA,CAOI,KAAO,qBAAuB,GAE9B,KAAQ,WAAa,EACrB,KAAQ,SAAW,GACnB,KAAQ,aAAe,GACvB,KAAQ,aAAe,EAAA,CAMhB,KAAKC,EACZ,CACI,KAAK,qBAAqB,EAC1B,KAAK,OAASA,EACd,KAAK,qBAAuB,GAC5B,KAAK,WAAa,EAClB,KAAK,SAAW,GAChB,KAAK,aAAe,GACpB,KAAK,aAAe,EAAA,CAIxB,IAAI,aACJ,CACI,OAAO,KAAK,YAAA,CAGhB,IAAI,YAAYC,EAChB,CACI,KAAK,aAAeA,CAAA,CAIjB,mBACP,CACQ,KAAK,cAAgB,CAAC,KAAK,aAK/BC,EAAO,OAAO,IAAI,KAAK,cAAe,KAAMC,EAAgB,WAAW,EAEvE,KAAK,aAAe,GAAA,CAIjB,sBACP,CACS,KAAK,eAKVD,EAAO,OAAO,OAAO,KAAK,cAAe,IAAI,EAE7C,KAAK,aAAe,GAAA,CAIjB,cACP,CACI,KAAK,SAAW,EAAA,CAIZ,SACR,CACI,GAAI,CAAC,KAAK,YAAc,KAAK,aAEzB,OAIJ,GAAI,KAAK,SACT,CACI,KAAK,SAAW,GAEhB,MAAA,CAIE,IAAAE,EAAmB,KAAK,OAAO,kBAEjC,KAAK,OAAO,qBAAwBA,EAAkC,cAAgB,SAK1F,WAAW,SAAS,cAAc,IAAI,aAAa,cAAe,CAC9D,QAASA,EAAiB,QAC1B,QAASA,EAAiB,QAC1B,YAAaA,EAAiB,YAC9B,UAAWA,EAAiB,SAAA,CAC/B,CAAC,CAAA,CAUE,cAAcC,EACtB,CACI,KAAK,YAAcA,EAAO,UAEtB,OAAK,WAAa,KAAK,wBAK3B,KAAK,WAAa,EAElB,KAAK,QAAQ,EAAA,CAErB,EAEaC,EAAe,IAAIP,EChIzB,IAAMQ,EAAN,cAAkCC,CAGzC,CAHO,aAAA,CAAA,MAAA,GAAA,SAAA,EA0BI,KAAA,OAAgB,IAAIC,EAwBpB,KAAA,SAAkB,IAAIA,EAStB,KAAA,OAAgB,IAAIA,EASpB,KAAA,OAAgB,IAAIA,EAYpB,KAAA,OAAgB,IAAIA,CAAM,CAnDjC,IAAW,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAGlD,IAAW,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAMlD,IAAI,GAAY,CAAE,OAAO,KAAK,OAAA,CAM9B,IAAI,GAAY,CAAE,OAAO,KAAK,OAAA,CAS9B,IAAI,WAAoB,CAAE,OAAO,KAAK,SAAS,CAAA,CAG/C,IAAI,WAAoB,CAAE,OAAO,KAAK,SAAS,CAAA,CAM/C,IAAI,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAG3C,IAAI,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAM3C,IAAI,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAG3C,IAAI,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAY3C,IAAI,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAM3C,IAAI,SAAkB,CAAE,OAAO,KAAK,OAAO,CAAA,CAapC,iBAA8CC,EAAsBC,EAAWC,EACtF,CACI,OAAOF,EAAU,eAAe,aAAgBE,GAAa,KAAK,OAAQD,CAAK,CAAA,CAO5E,iBAAiBE,EACxB,CACI,MAAO,qBAAsB,KAAK,aAAe,KAAK,YAAY,iBAAiBA,CAAG,CAAA,CAuBnF,eACHC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEJ,CACU,MAAA,IAAI,MAAM,yBAAyB,CAAA,CAEjD,ECpKO,IAAMC,EAAN,cAAoCC,CAC3C,CADO,aAAA,CAAA,MAAA,GAAA,SAAA,EAaH,KAAO,MAAQ,EAuBf,KAAO,OAAS,EAMhB,KAAO,UAAY,EAAA,CA4CZ,oBACP,CACQ,OAAA,KAAK,OAAS,eAAiB,KAAK,OAAS,aAAe,KAAK,OAAS,YAEnE,CAAC,IAAI,EAGT,CAAA,CAAC,CAIL,oBACP,CACU,MAAA,IAAI,MAAM,sCAAsC,CAAA,CAE9D,ECrGO,IAAMC,EAAN,cAAkCC,CACzC,CADO,aAAA,CAAA,MAAA,GAAA,SAAA,EAqBH,KAAgB,gBAAkB,EAMlC,KAAgB,eAAiB,EAMjC,KAAgB,eAAiB,CAAA,CACrC,EAlCaD,EAkBc,gBAAkB,EAlBhCA,EAwBc,eAAiB,EAxB/BA,EA8Bc,eAAiB,ECnB5C,IAAME,GAAoB,KAEpBC,GAAkB,IAAIC,EACtBC,EAAmB,IAAID,EA0DhBE,EAAN,KACP,CAqEI,YAAYC,EACZ,CAtDO,KAAA,SAAyB,IAAIC,EAWpC,KAAO,UAAY,GAGnB,KAAO,uBAAyB,GAkBhC,KAAU,aAAoC,CAC1C,aAAc,CAAA,CAAC,EAQT,KAAA,UAAA,IAA8D,IAGxE,KAAiB,wBAAuC,CAAA,EAExD,KAAQ,aAA4B,CAAA,EAEpC,KAAQ,oBAAsB,GAO1B,KAAK,WAAaD,EAElB,KAAK,WAAa,KAAK,WAAW,KAAK,IAAI,EAC3C,KAAK,UAAY,KAAK,UAAU,KAAK,IAAI,EACzC,KAAK,eAAiB,KAAK,eAAe,KAAK,IAAI,EACnD,KAAK,eAAiB,KAAK,eAAe,KAAK,IAAI,EACnD,KAAK,cAAgB,KAAK,cAAc,KAAK,IAAI,EACjD,KAAK,eAAiB,KAAK,eAAe,KAAK,IAAI,EACnD,KAAK,aAAe,KAAK,aAAa,KAAK,IAAI,EAC/C,KAAK,oBAAsB,KAAK,oBAAoB,KAAK,IAAI,EAC7D,KAAK,SAAW,KAAK,SAAS,KAAK,IAAI,EAEvC,KAAK,aAAe,CAAA,EACf,KAAA,gBAAgB,cAAe,KAAK,cAAc,EAClD,KAAA,gBAAgB,cAAe,KAAK,cAAc,EAClD,KAAA,gBAAgB,aAAc,KAAK,aAAa,EAChD,KAAA,gBAAgB,eAAgB,KAAK,aAAa,EAClD,KAAA,gBAAgB,cAAe,KAAK,cAAc,EAClD,KAAA,gBAAgB,YAAa,KAAK,YAAY,EAC9C,KAAA,gBAAgB,mBAAoB,KAAK,mBAAmB,EAC5D,KAAA,gBAAgB,QAAS,KAAK,QAAQ,CAAA,CAexC,gBAAgBE,EAAcC,EACrC,CACS,KAAK,aAAaD,CAAI,IAElB,KAAA,aAAaA,CAAI,EAAI,CAAA,GAGzB,KAAA,aAAaA,CAAI,EAAE,KAAK,CACzB,GAAAC,EACA,SAAU,CAAA,CACb,EACI,KAAA,aAAaD,CAAI,EAAE,KAAK,CAACE,EAAGC,IAAMD,EAAE,SAAWC,EAAE,QAAQ,CAAA,CAQ3D,cAAc,EAAmBH,EACxC,CACI,EAAE,mBAAqB,GACvB,EAAE,8BAAgC,GAE7B,KAAA,UAAU,EAAGA,CAAI,EACtB,KAAK,SAAS,KAAKA,GAAQ,EAAE,KAAM,CAAC,CAAA,CAOjC,SAAS,EAChB,CACQ,GAAA,CAAC,KAAK,WAEN,OAGJ,IAAMI,EAAU,KAAK,aAAa,EAAE,IAAI,EAExC,GAAIA,EAEA,QAAS,EAAI,EAAGC,EAAID,EAAQ,OAAQ,EAAIC,EAAG,IAE/BD,EAAA,CAAC,EAAE,GAAG,CAAC,OAMdE,EAAA,kDAAkD,EAAE,IAAI,EAAE,CAEnE,CAUG,QACHC,EACAC,EAEJ,CACIC,EAAa,YAAc,GAGrB,IAAAR,EADU,KAAK,qBAAuB,KAAK,uBAC5B,uBAAyB,mBACxCS,EAAe,KAAKT,CAAE,EACxB,KAAK,WACL,KAAK,WAAW,UAChBP,GAAgB,IAAIa,EAAGC,CAAC,EACxB,KAAK,UACL,KAAK,UAAA,EAGF,OAAAE,GAAgBA,EAAa,CAAC,CAAA,CASlC,UAAU,EAAmBV,EACpC,CACQ,GAAA,CAAC,EAAE,OAGH,OAGE,IAAAW,EAAe,EAAE,aAAa,EAGpC,EAAE,WAAa,EAAE,gBAER,QAAAC,EAAI,EAAGP,EAAIM,EAAa,OAAS,EAAGC,EAAIP,EAAGO,IAM5C,GAJF,EAAA,cAAgBD,EAAaC,CAAC,EAE3B,KAAA,aAAa,EAAGZ,CAAI,EAErB,EAAE,oBAAsB,EAAE,8BAA+B,OAS7D,GALJ,EAAE,WAAa,EAAE,UACjB,EAAE,cAAgB,EAAE,OAEf,KAAA,aAAa,EAAGA,CAAI,EAErB,IAAE,oBAAsB,EAAE,+BAG9B,GAAE,WAAa,EAAE,eAEjB,QAASY,EAAID,EAAa,OAAS,EAAGC,GAAK,EAAGA,IAMtC,GAJF,EAAA,cAAgBD,EAAaC,CAAC,EAE3B,KAAA,aAAa,EAAGZ,CAAI,EAErB,EAAE,oBAAsB,EAAE,8BAA+B,OACjE,CAWG,IAAI,EAAmBA,EAA0Ba,EAAU,KAAK,wBACvE,CACI,GAAIA,EAAQ,SAAW,EAAG,OAE1B,EAAE,WAAa,EAAE,eAEjB,IAAMC,EAAS,MAAM,QAAQd,CAAI,EAAIA,EAAO,CAACA,CAAI,EAIjD,QAASY,EAAIC,EAAQ,OAAS,EAAGD,GAAK,EAAGA,IAE9BE,EAAA,QAASC,GAChB,CACM,EAAA,cAAgBF,EAAQD,CAAC,EACtB,KAAA,aAAa,EAAGG,CAAK,CAAA,CAC7B,CACL,CAQG,gBAAgBC,EACvB,CACU,IAAAC,EAAkB,CAACD,CAAM,EAEtB,QAAA,EAAI,EAAG,EAAIvB,IAAsBuB,IAAW,KAAK,YAAcA,EAAO,OAAS,IACxF,CACQ,GAAA,CAACA,EAAO,OAEF,MAAA,IAAI,MAAM,qDAAqD,EAGzDC,EAAA,KAAKD,EAAO,MAAM,EAElCA,EAASA,EAAO,MAAA,CAGpB,OAAAC,EAAgB,QAAQ,EAEjBA,CAAA,CAGD,qBACNC,EACAC,EACAC,EACAC,EACAC,EACAC,EAAS,GAEb,CACI,IAAIC,EAAe,GAGf,GAAA,KAAK,kBAAkBN,CAAa,EAAU,OAAA,KAO9C,IALAA,EAAc,YAAc,WAAaC,IAAc,aAEvDV,EAAa,YAAc,IAG3BS,EAAc,qBAAuBA,EAAc,SACvD,CACI,IAAMO,EAAWP,EAAc,SAE/B,QAASN,EAAIa,EAAS,OAAS,EAAGb,GAAK,EAAGA,IAC1C,CACU,IAAAc,EAAQD,EAASb,CAAC,EAElBe,EAAY,KAAK,qBACnBD,EACA,KAAK,eAAeP,CAAS,EAAIA,EAAYO,EAAM,UACnDN,EACAC,EACAC,EACAC,GAAUD,EAAQJ,EAAeE,CAAQ,CAAA,EAG7C,GAAIO,EACJ,CAGQ,GAAAA,EAAU,OAAS,GAAK,CAACA,EAAUA,EAAU,OAAS,CAAC,EAAE,OAEzD,SAME,IAAAC,EAAgBV,EAAc,cAAc,GAE9CS,EAAU,OAAS,GAAKC,KAEpBA,GAAoB,KAAA,wBAAwB,KAAKV,CAAa,EAClES,EAAU,KAAKT,CAAa,GAI5B,KAAK,aAAa,SAAW,IAAG,KAAK,aAAeS,GAEzCH,EAAA,EAAA,CACnB,CACJ,CAGE,IAAAK,EAAoB,KAAK,eAAeV,CAAS,EACjDW,EAAsBZ,EAAc,cAAc,EAMpD,OAJAY,GAAuBA,GAA0B,KAAA,wBAAwB,KAAKZ,CAAa,EAI3FK,GAAU,KAAK,aAAa,OAAS,EAAU,KAE/CC,EAAqB,KAAK,aAG1BK,GAAsB,CAACP,EAAQJ,EAAeE,CAAQ,GAAKC,EAAOH,EAAeE,CAAQ,EAIlFU,EAAsB,CAACZ,CAAa,EAAI,CAAA,EAG5C,IAAA,CAiBD,iBACNA,EACAC,EACAC,EACAC,EACAC,EAEJ,CAEI,GAAI,KAAK,kBAAkBJ,CAAa,GAAKI,EAAQJ,EAAeE,CAAQ,EAEjE,OAAA,KAQP,IANAF,EAAc,YAAc,WAAaC,IAAc,aAEvDV,EAAa,YAAc,IAI3BS,EAAc,qBAAuBA,EAAc,SACvD,CACI,IAAMO,EAAWP,EAAc,SACzBa,EAAmBX,EAEzB,QAASR,EAAIa,EAAS,OAAS,EAAGb,GAAK,EAAGA,IAC1C,CACU,IAAAc,EAAQD,EAASb,CAAC,EAElBe,EAAY,KAAK,iBACnBD,EACA,KAAK,eAAeP,CAAS,EAAIA,EAAYO,EAAM,UACnDK,EACAV,EACAC,CAAA,EAGJ,GAAIK,EACJ,CAGQ,GAAAA,EAAU,OAAS,GAAK,CAACA,EAAUA,EAAU,OAAS,CAAC,EAAE,OAEzD,SAME,IAAAC,EAAgBV,EAAc,cAAc,EAE9C,OAAAS,EAAU,OAAS,GAAKC,IAAeD,EAAU,KAAKT,CAAa,EAEhES,CAAA,CACX,CACJ,CAGE,IAAAE,EAAoB,KAAK,eAAeV,CAAS,EACjDW,EAAsBZ,EAAc,cAAc,EAGxD,OAAIW,GAAqBR,EAAOH,EAAeE,CAAQ,EAI5CU,EAAsB,CAACZ,CAAa,EAAI,CAAA,EAG5C,IAAA,CAGH,eAAec,EACvB,CACW,OAAAA,IAAQ,UAAYA,IAAQ,SAAA,CAG/B,kBAAkBC,EAC1B,CAcI,MAZI,CAACA,GAAa,CAACA,EAAU,SAAW,CAACA,EAAU,YAAc,CAACA,EAAU,YAMxEA,EAAU,YAAc,QAMxBA,EAAU,YAAc,WAAa,CAACA,EAAU,mBAK7C,CAWD,WAAWA,EAAsBb,EAC3C,CACI,GAAIa,EAAU,UAEAA,EAAA,eAAe,aAAab,EAAUxB,CAAgB,EAE5D,CAACqC,EAAU,QAAQ,SAASrC,EAAiB,EAAGA,EAAiB,CAAC,GAE3D,MAAA,GAIf,GAAIqC,EAAU,SAAWA,EAAU,QAAQ,OAEvC,QAAS,EAAI,EAAG,EAAIA,EAAU,QAAQ,OAAQ,IAC9C,CACU,IAAAC,EAASD,EAAU,QAAQ,CAAC,EAElC,GAAIC,EAAO,eAIH,CAFwBA,EAAO,cAAcd,EAAU,KAAK,SAAS,EAI9D,MAAA,EAEf,CAID,MAAA,EAAA,CASD,UAAUa,EAAsBb,EAC1C,CAEI,OAAIa,EAAU,QAEH,GAGNA,GAA0B,eAEjBA,EAAA,eAAe,aAAab,EAAUxB,CAAgB,EAExDqC,EAAyB,cAAcrC,CAAgB,GAK5D,EAAA,CAWD,aAAa,EAAmBI,EAC1C,CACI,GAAI,CAAC,EAAE,cAAc,cAAA,EAEjB,OAGJA,IAAAA,EAAS,EAAE,MAGL,IAAAmC,EAAa,KAAKnC,CAAI,GAE3B,EAAE,cAAcmC,CAAU,IAA8C,CAAC,EAEpE,IAAAC,EAAM,EAAE,aAAe,EAAE,iBAAmB,EAAE,aAAe,EAAE,UAAY,GAAGpC,CAAI,UAAYA,EAE/F,KAAA,iBAAiB,EAAGoC,CAAG,EAExB,EAAE,aAAe,EAAE,WAEd,KAAA,iBAAiB,EAAGpC,CAAI,CACjC,CASM,eAAeqC,EACzB,CACQ,GAAA,EAAEA,aAAgBC,GACtB,CAEIhC,EAAK,iEAAiE,EAGtE,MAAA,CAGE,IAAAiC,EAAI,KAAK,mBAAmBF,CAAI,EAIlC,GAFC,KAAA,cAAcE,EAAG,aAAa,EAE/BA,EAAE,cAAgB,QAEb,KAAA,cAAcA,EAAG,YAAY,UAE7BA,EAAE,cAAgB,SAAWA,EAAE,cAAgB,MACxD,CACU,IAAAC,EAAgBD,EAAE,SAAW,EAEnC,KAAK,cAAcA,EAAGC,EAAgB,YAAc,WAAW,CAAA,CAGnE,IAAMC,EAAe,KAAK,aAAaJ,EAAK,SAAS,EAErDI,EAAa,qBAAqBJ,EAAK,MAAM,EAAIE,EAAE,aAAa,EAEhE,KAAK,UAAUA,CAAC,CAAA,CAUV,eAAeF,EACzB,CACQ,GAAA,EAAEA,aAAgBC,GACtB,CAEIhC,EAAK,iEAAiE,EAGtE,MAAA,CAGJ,KAAK,wBAAwB,OAAS,EACtC,KAAK,aAAa,OAAS,EAC3B,KAAK,oBAAsB,GACrB,IAAAiC,EAAI,KAAK,mBAAmBF,CAAI,EAEtC,KAAK,oBAAsB,GAC3B,IAAMK,EAAUH,EAAE,cAAgB,SAAWA,EAAE,cAAgB,MACzDE,EAAe,KAAK,aAAaJ,EAAK,SAAS,EAC/CM,EAAY,KAAK,kBAAkBF,EAAa,WAAW,EAGjE,GAAIA,EAAa,aAAa,OAAS,GAAKE,IAAcJ,EAAE,OAC5D,CAEI,IAAMK,EAAUP,EAAK,OAAS,YAAc,WAAa,aACnDQ,EAAW,KAAK,mBAAmBR,EAAMO,EAASD,CAAS,EAOjE,GALK,KAAA,cAAcE,EAAU,YAAY,EACrCH,GAAc,KAAA,cAAcG,EAAU,UAAU,EAIhD,CAACN,EAAE,aAAA,EAAe,SAASI,CAAS,EACxC,CACI,IAAMG,EAAa,KAAK,mBAAmBT,EAAM,eAAgBM,CAAS,EAInE,IAFPG,EAAW,WAAaA,EAAW,UAE5BA,EAAW,QAAU,CAACP,EAAE,aAAA,EAAe,SAASO,EAAW,MAAM,GAEpEA,EAAW,cAAgBA,EAAW,OAEtC,KAAK,aAAaA,CAAU,EACxBJ,GAAc,KAAA,aAAaI,EAAY,YAAY,EAE5CA,EAAA,OAASA,EAAW,OAAO,OAG1C,KAAK,UAAUA,CAAU,CAAA,CAG7B,KAAK,UAAUD,CAAQ,CAAA,CAIvB,GAAAF,IAAcJ,EAAE,OACpB,CAEI,IAAMQ,EAAWV,EAAK,OAAS,YAAc,YAAc,cACrDW,EAAY,KAAK,kBAAkBT,EAAGQ,CAAQ,EAE/C,KAAA,cAAcC,EAAW,aAAa,EACvCN,GAAc,KAAA,cAAcM,EAAW,WAAW,EAGtD,IAAIC,EAAqBN,GAAW,OAEpC,KAAOM,GAAsBA,IAAuB,KAAK,WAAW,QAE5DA,IAAuBV,EAAE,QAE7BU,EAAqBA,EAAmB,OAO5C,GAFwB,CAACA,GAAsBA,IAAuB,KAAK,WAAW,OAGtF,CACI,IAAMC,EAAa,KAAK,kBAAkBX,EAAG,cAAc,EAIpD,IAFPW,EAAW,WAAaA,EAAW,UAE5BA,EAAW,QACPA,EAAW,SAAWP,GACtBO,EAAW,SAAW,KAAK,WAAW,QAE7CA,EAAW,cAAgBA,EAAW,OAEtC,KAAK,aAAaA,CAAU,EACxBR,GAAc,KAAA,aAAaQ,EAAY,YAAY,EAE5CA,EAAA,OAASA,EAAW,OAAO,OAG1C,KAAK,UAAUA,CAAU,CAAA,CAG7B,KAAK,UAAUF,CAAS,CAAA,CAG5B,IAAMG,EAAuB,CAAA,EACvBC,EAA2B,KAAK,wBAA0B,GAE3D,KAAA,UAAYD,EAAW,KAAK,aAAa,EAAI,KAAK,cAAcZ,EAAG,aAAa,EACzDa,GAAAD,EAAW,KAAK,mBAAmB,EAG3DZ,EAAE,cAAgB,UAEb,KAAA,UAAYY,EAAW,OAAO,EAAG,EAAG,WAAW,EAAI,KAAK,cAAcZ,EAAG,WAAW,EAC7Da,GAAAD,EAAW,KAAK,iBAAiB,GAG7DT,IAEK,KAAA,UAAYS,EAAW,OAAO,EAAG,EAAG,WAAW,EAAI,KAAK,cAAcZ,EAAG,WAAW,EAC7Da,GAAAD,EAAW,KAAK,iBAAiB,EACxD,KAAA,OAASZ,EAAE,QAAQ,QAGxBY,EAAW,OAAS,GAEf,KAAA,IAAIZ,EAAGY,CAAU,EAE1B,KAAK,wBAAwB,OAAS,EACtC,KAAK,aAAa,OAAS,EAEdV,EAAA,YAAcF,EAAE,aAAa,EAE1C,KAAK,UAAUA,CAAC,CAAA,CASV,eAAeF,EACzB,CACQ,GAAA,EAAEA,aAAgBC,GACtB,CAEIhC,EAAK,iEAAiE,EAGtE,MAAA,CAGJ,IAAMmC,EAAe,KAAK,aAAaJ,EAAK,SAAS,EAC/CE,EAAI,KAAK,mBAAmBF,CAAI,EAChCK,EAAUH,EAAE,cAAgB,SAAWA,EAAE,cAAgB,MAE1D,KAAA,cAAcA,EAAG,aAAa,EAC/BG,GAAc,KAAA,cAAcH,EAAG,WAAW,EAC1CA,EAAE,cAAgB,UAAc,KAAA,OAASA,EAAE,QAAQ,QAGvD,IAAMW,EAAa,KAAK,kBAAkBX,EAAG,cAAc,EAI3D,IAFAW,EAAW,WAAaA,EAAW,UAE5BA,EAAW,QAAUA,EAAW,SAAW,KAAK,WAAW,QAE9DA,EAAW,cAAgBA,EAAW,OAEtC,KAAK,aAAaA,CAAU,EACxBR,GAAc,KAAA,aAAaQ,EAAY,YAAY,EAE5CA,EAAA,OAASA,EAAW,OAAO,OAG7BT,EAAA,YAAcF,EAAE,aAAa,EAE1C,KAAK,UAAUA,CAAC,EAChB,KAAK,UAAUW,CAAU,CAAA,CASnB,cAAcb,EACxB,CACQ,GAAA,EAAEA,aAAgBC,GACtB,CAEIhC,EAAK,iEAAiE,EAGtE,MAAA,CAGJ,IAAMmC,EAAe,KAAK,aAAaJ,EAAK,SAAS,EAErD,GAAII,EAAa,YACjB,CACI,IAAMC,EAAUL,EAAK,cAAgB,SAAWA,EAAK,cAAgB,MAC/DM,EAAY,KAAK,kBAAkBF,EAAa,WAAW,EAG3DI,EAAW,KAAK,mBAAmBR,EAAM,aAAcM,CAAS,EAEtE,KAAK,cAAcE,CAAQ,EACvBH,GAAc,KAAA,cAAcG,EAAU,UAAU,EAIpD,IAAMC,EAAa,KAAK,mBAAmBT,EAAM,eAAgBM,CAAS,EAI1E,IAFAG,EAAW,WAAaA,EAAW,UAE5BA,EAAW,QAAUA,EAAW,SAAW,KAAK,WAAW,QAE9DA,EAAW,cAAgBA,EAAW,OAEtC,KAAK,aAAaA,CAAU,EACxBJ,GAAc,KAAA,aAAaI,EAAY,YAAY,EAE5CA,EAAA,OAASA,EAAW,OAAO,OAG1CL,EAAa,YAAc,KAE3B,KAAK,UAAUI,CAAQ,EACvB,KAAK,UAAUC,CAAU,CAAA,CAG7B,KAAK,OAAS,IAAA,CAaR,aAAaT,EACvB,CACQ,GAAA,EAAEA,aAAgBC,GACtB,CAEIhC,EAAK,iEAAiE,EAGtE,MAAA,CAGE,IAAA+C,EAAM,YAAY,IAAI,EACtBd,EAAI,KAAK,mBAAmBF,CAAI,EAIlC,GAFC,KAAA,cAAcE,EAAG,WAAW,EAE7BA,EAAE,cAAgB,QAEb,KAAA,cAAcA,EAAG,UAAU,UAE3BA,EAAE,cAAgB,SAAWA,EAAE,cAAgB,MACxD,CACU,IAAAC,EAAgBD,EAAE,SAAW,EAEnC,KAAK,cAAcA,EAAGC,EAAgB,UAAY,SAAS,CAAA,CAG/D,IAAMC,EAAe,KAAK,aAAaJ,EAAK,SAAS,EAC/CiB,EAAc,KAAK,kBAAkBb,EAAa,qBAAqBJ,EAAK,MAAM,CAAC,EAErFkB,EAAcD,EAIlB,GAAIA,GAAe,CAACf,EAAE,aAAA,EAAe,SAASe,CAAW,EACzD,CACI,IAAIpC,EAAgBoC,EAEpB,KAAOpC,GAAiB,CAACqB,EAAE,aAAA,EAAe,SAASrB,CAAa,GAChE,CAKQ,GAJJqB,EAAE,cAAgBrB,EAEb,KAAA,aAAaqB,EAAG,kBAAkB,EAEnCA,EAAE,cAAgB,QAEb,KAAA,aAAaA,EAAG,iBAAiB,UAEjCA,EAAE,cAAgB,SAAWA,EAAE,cAAgB,MACxD,CACU,IAAAC,EAAgBD,EAAE,SAAW,EAEnC,KAAK,aAAaA,EAAGC,EAAgB,iBAAmB,gBAAgB,CAAA,CAG5EtB,EAAgBA,EAAc,MAAA,CAG3B,OAAAuB,EAAa,qBAAqBJ,EAAK,MAAM,EAItCkB,EAAArC,CAAA,CAIlB,GAAIqC,EACJ,CACI,IAAMC,EAAa,KAAK,kBAAkBjB,EAAG,OAAO,EAEpDiB,EAAW,OAASD,EACpBC,EAAW,KAAO,KAEbf,EAAa,eAAeJ,EAAK,MAAM,IAE3BI,EAAA,eAAeJ,EAAK,MAAM,EAAI,CACvC,WAAY,EACZ,OAAQmB,EAAW,OACnB,UAAWH,CAAA,GAInB,IAAMI,EAAehB,EAAa,eAAeJ,EAAK,MAAM,EAiBxD,GAfAoB,EAAa,SAAWD,EAAW,QAChCH,EAAMI,EAAa,UAAY,IAElC,EAAEA,EAAa,WAIfA,EAAa,WAAa,EAG9BA,EAAa,OAASD,EAAW,OACjCC,EAAa,UAAYJ,EAEzBG,EAAW,OAASC,EAAa,WAE7BD,EAAW,cAAgB,QAC/B,CACU,IAAAhB,EAAgBgB,EAAW,SAAW,EAE5C,KAAK,cAAcA,EAAYhB,EAAgB,aAAe,OAAO,CAAA,MAEhEgB,EAAW,cAAgB,SAE3B,KAAA,cAAcA,EAAY,KAAK,EAGnC,KAAA,cAAcA,EAAY,YAAY,EAE3C,KAAK,UAAUA,CAAU,CAAA,CAG7B,KAAK,UAAUjB,CAAC,CAAA,CAcV,oBAAoBF,EAC9B,CACQ,GAAA,EAAEA,aAAgBC,GACtB,CAEIhC,EAAK,iEAAiE,EAGtE,MAAA,CAGJ,IAAMmC,EAAe,KAAK,aAAaJ,EAAK,SAAS,EAC/CiB,EAAc,KAAK,kBAAkBb,EAAa,qBAAqBJ,EAAK,MAAM,CAAC,EACnFE,EAAI,KAAK,mBAAmBF,CAAI,EAEtC,GAAIiB,EACJ,CACI,IAAIpC,EAAgBoC,EAEpB,KAAOpC,GAEHqB,EAAE,cAAgBrB,EAEb,KAAA,aAAaqB,EAAG,kBAAkB,EAEnCA,EAAE,cAAgB,QAEb,KAAA,aAAaA,EAAG,iBAAiB,GAEjCA,EAAE,cAAgB,SAAWA,EAAE,cAAgB,QAEpD,KAAK,aAAaA,EAAGA,EAAE,SAAW,EAAI,iBAAmB,gBAAgB,EAG7ErB,EAAgBA,EAAc,OAG3B,OAAAuB,EAAa,qBAAqBJ,EAAK,MAAM,CAAA,CAGxD,KAAK,UAAUE,CAAC,CAAA,CAOV,SAASF,EACnB,CACQ,GAAA,EAAEA,aAAgBqB,GACtB,CAEIpD,EAAK,6DAA6D,EAGlE,MAAA,CAGE,IAAAqD,EAAa,KAAK,iBAAiBtB,CAAI,EAE7C,KAAK,cAAcsB,CAAU,EAC7B,KAAK,UAAUA,CAAU,CAAA,CAWnB,kBAAkB1C,EAC5B,CACI,GAAI,CAACA,EAEM,OAAA,KAGP,IAAAC,EAAgBD,EAAgB,CAAC,EAErC,QAAS,EAAI,EAAG,EAAIA,EAAgB,QAI5BA,EAAgB,CAAC,EAAE,SAAWC,EAJM,IAMpCA,EAAgBD,EAAgB,CAAC,EAQlC,OAAAC,CAAA,CAWD,mBACNmB,EACArC,EACAgB,EAEJ,CACU,IAAAD,EAAQ,KAAK,cAAcuB,CAAqB,EAEjD,YAAA,gBAAgBD,EAAMtB,CAAK,EAC3B,KAAA,cAAcsB,EAAMtB,CAAK,EACzB,KAAA,SAASsB,EAAMtB,CAAK,EAEzBA,EAAM,YAAcsB,EAAK,YACzBtB,EAAM,cAAgBsB,EACtBtB,EAAM,OAASC,GACR,KAAK,QAAQD,EAAM,OAAO,EAAGA,EAAM,OAAO,CAAC,GAC3C,KAAK,aAAa,CAAC,EAEtB,OAAOf,GAAS,WAEhBe,EAAM,KAAOf,GAGVe,CAAA,CASD,iBAAiBsB,EAC3B,CACU,IAAAtB,EAAQ,KAAK,cAAc2C,CAAmB,EAE/C,YAAA,cAAcrB,EAAMtB,CAAK,EACzB,KAAA,cAAcsB,EAAMtB,CAAK,EACzB,KAAA,SAASsB,EAAMtB,CAAK,EAEzBA,EAAM,YAAcsB,EAAK,YACzBtB,EAAM,cAAgBsB,EAChBtB,EAAA,OAAS,KAAK,QAAQA,EAAM,OAAO,EAAGA,EAAM,OAAO,CAAC,EAEnDA,CAAA,CAUD,kBAAkBsB,EAA6BrC,EACzD,CACU,IAAAe,EAAQ,KAAK,cAAcuB,CAAqB,EAEtD,OAAAvB,EAAM,YAAcsB,EAAK,YACzBtB,EAAM,cAAgBsB,EAAK,cAEtB,KAAA,gBAAgBA,EAAMtB,CAAK,EAC3B,KAAA,cAAcsB,EAAMtB,CAAK,EACzB,KAAA,SAASsB,EAAMtB,CAAK,EAGzBA,EAAM,OAASsB,EAAK,OACpBtB,EAAM,KAAOsB,EAAK,aAAa,EAAE,MAAM,EACjCtB,EAAA,KAAOf,GAAQe,EAAM,KAEpBA,CAAA,CAcD,cAAcsB,EAA2BuB,EACnD,CACIA,EAAG,UAAYvB,EAAK,UACpBuB,EAAG,OAASvB,EAAK,OACjBuB,EAAG,OAASvB,EAAK,OACjBuB,EAAG,OAASvB,EAAK,MAAA,CAmBX,gBAAgBA,EAAsBuB,EAChD,CACUvB,aAAgBC,GAAyBsB,aAActB,IAE7DsB,EAAG,UAAYvB,EAAK,UACpBuB,EAAG,MAAQvB,EAAK,MAChBuB,EAAG,OAASvB,EAAK,OACjBuB,EAAG,UAAYvB,EAAK,UACpBuB,EAAG,YAAcvB,EAAK,YACtBuB,EAAG,SAAWvB,EAAK,SACnBuB,EAAG,mBAAqBvB,EAAK,mBAC7BuB,EAAG,MAAQvB,EAAK,MAChBuB,EAAG,MAAQvB,EAAK,MAChBuB,EAAG,MAAQvB,EAAK,MAAA,CAyBV,cAAcA,EAAsBuB,EAC9C,CACUvB,aAAgBwB,GAAuBD,aAAcC,IAE3DD,EAAG,OAASvB,EAAK,OACjBuB,EAAG,OAASvB,EAAK,OACjBuB,EAAG,QAAUvB,EAAK,QACfuB,EAAA,OAAO,SAASvB,EAAK,MAAM,EAC9BuB,EAAG,QAAUvB,EAAK,QAClBuB,EAAG,QAAUvB,EAAK,QACfuB,EAAA,SAAS,SAASvB,EAAK,QAAQ,EAC/BuB,EAAA,OAAO,SAASvB,EAAK,MAAM,EAC9BuB,EAAG,SAAWvB,EAAK,SAChBuB,EAAA,OAAO,SAASvB,EAAK,MAAM,EAAA,CAcxB,SAASA,EAAsBuB,EACzC,CACIA,EAAG,UAAYvB,EAAK,UACpBuB,EAAG,WAAavB,EAAK,WAClBuB,EAAA,UAAY,YAAY,IAAI,EAC/BA,EAAG,KAAOvB,EAAK,KACfuB,EAAG,OAASvB,EAAK,OACjBuB,EAAG,KAAOvB,EAAK,KACfuB,EAAG,MAAQvB,EAAK,MACbuB,EAAA,MAAM,SAASvB,EAAK,KAAK,EACzBuB,EAAA,KAAK,SAASvB,EAAK,IAAI,CAAA,CAQpB,aAAayB,EACvB,CACI,OAAK,KAAK,aAAa,aAAaA,CAAE,IAE7B,KAAA,aAAa,aAAaA,CAAE,EAAI,CACjC,qBAAsB,CAAA,EACtB,eAAgB,CAAA,EAChB,WAAY,IAAA,GAIb,KAAK,aAAa,aAAaA,CAAE,CAAA,CAUlC,cACNC,EAEJ,CACS,KAAK,UAAU,IAAIA,CAAkB,GAEtC,KAAK,UAAU,IAAIA,EAAoB,CAAA,CAAE,EAGvC,IAAAhD,EAAQ,KAAK,UAAU,IAAIgD,CAAkB,EAAE,IAAI,GAClD,IAAIA,EAAY,IAAI,EAE3B,OAAAhD,EAAM,WAAaA,EAAM,KACzBA,EAAM,cAAgB,KACtBA,EAAM,iBAAmB,GACzBA,EAAM,KAAO,KACbA,EAAM,OAAS,KAERA,CAAA,CAcD,UAAoCA,EAC9C,CACI,GAAIA,EAAM,UAAY,KAAY,MAAA,IAAI,MAAM,mEAAmE,EAE/G,IAAMgD,EAAchD,EAAM,YAErB,KAAK,UAAU,IAAIgD,CAAkB,GAEtC,KAAK,UAAU,IAAIA,EAAoB,CAAA,CAAE,EAG7C,KAAK,UAAU,IAAIA,CAAkB,EAAE,KAAKhD,CAAK,CAAA,CAS7C,iBAAiB,EAAmBf,EAC5C,CACI,IAAMgE,EAAc,EAAE,cAAsB,QAA6BhE,CAAI,EAE7E,GAAKgE,EAEL,GAAI,OAAQA,EAEJA,EAAU,MAAM,EAAE,cAAc,eAAehE,EAAMgE,EAAU,GAAI,OAAW,EAAI,EACtFA,EAAU,GAAG,KAAKA,EAAU,QAAS,CAAC,MAK9B,SAAApD,EAAI,EAAGP,EAAI2D,EAAU,OACzBpD,EAAIP,GAAK,CAAC,EAAE,8BACZO,IAEIoD,EAAUpD,CAAC,EAAE,MAAQ,EAAA,cAAc,eAAeZ,EAAMgE,EAAUpD,CAAC,EAAE,GAAI,OAAW,EAAI,EAClFoD,EAAApD,CAAC,EAAE,GAAG,KAAKoD,EAAUpD,CAAC,EAAE,QAAS,CAAC,CAEpD,CAER,EC77CA,IAAMqD,GAAmB,EACnBC,GAA2C,CAC7C,WAAY,cACZ,SAAU,YACV,gBAAiB,mBACjB,UAAW,cACX,YAAa,eACjB,EAmEaC,EAAN,MAAMA,CACb,CAmHI,YAAYC,EACZ,CA7DA,KAAgB,oBAAsB,iBAAkB,WAGxC,KAAA,sBAAwB,CAAC,CAAC,WAAW,aAuBrD,KAAO,WAA0B,KAGjC,KAAO,WAAa,EAiChB,KAAK,SAAWA,EACX,KAAA,aAAe,IAAIC,EAAc,IAAI,EAC1CC,EAAa,KAAK,IAAI,EAEtB,KAAK,mBAAqB,GAC1B,KAAK,aAAe,GAEf,KAAA,kBAAoB,IAAIC,EAAsB,IAAI,EAClD,KAAA,gBAAkB,IAAIC,EAAoB,IAAI,EAEnD,KAAK,aAAe,CAChB,QAAS,UACT,QAAS,SAAA,EAGb,KAAK,SAAW,IAAI,MAAM,CAAE,GAAGL,EAAY,oBAAA,EAAwB,CAC/D,IAAK,CAACM,EAAQC,EAAKC,KAEXD,IAAQ,eAER,KAAK,aAAa,uBAAyBC,GAE/CF,EAAOC,CAAgC,EAAIC,EAEpC,GACX,CACH,EAED,KAAK,eAAiB,KAAK,eAAe,KAAK,IAAI,EACnD,KAAK,eAAiB,KAAK,eAAe,KAAK,IAAI,EACnD,KAAK,aAAe,KAAK,aAAa,KAAK,IAAI,EAC/C,KAAK,kBAAoB,KAAK,kBAAkB,KAAK,IAAI,EACzD,KAAK,QAAU,KAAK,QAAQ,KAAK,IAAI,CAAA,CAhHzC,WAAkB,kBAClB,CACI,OAAO,KAAK,iBAAA,CAqHT,KAAKC,EACZ,CACI,GAAM,CAAE,OAAAC,EAAQ,WAAAC,CAAW,EAAI,KAAK,SAEpC,KAAK,iBAAiBD,CAA2B,EACjD,KAAK,WAAaC,EACNX,EAAA,kBAAoBS,EAAQ,WAAa,UACrD,OAAO,OAAO,KAAK,SAAUA,EAAQ,eAAiB,CAAA,CAAE,EACnD,KAAA,aAAa,uBAAyB,KAAK,SAAS,UAAA,CAOtD,iBAAiBE,EACxB,CACI,KAAK,WAAaA,CAAA,CAIf,SACP,CACI,KAAK,iBAAiB,IAAI,EAC1B,KAAK,SAAW,KAChB,KAAK,eAAiB,IAAA,CAOnB,UAAUC,EACjB,CACaA,IAAAA,EAAA,WACT,IAAIC,EAAc,GASd,GALA,WAAW,iBAAmB,KAAK,sBAAsB,kBAE3CA,EAAA,IAGd,KAAK,iBAAmBD,EAExB,OAEJ,KAAK,eAAiBA,EAChB,IAAAE,EAAQ,KAAK,aAAaF,CAAI,EAGpC,GAAIE,EAEA,OAAQ,OAAOA,EACf,CACI,IAAK,SAEGD,IAEK,KAAA,WAAW,MAAM,OAASC,GAEnC,MACJ,IAAK,WAEDA,EAAMF,CAAI,EACV,MACJ,IAAK,SAGGC,GAEA,OAAO,OAAO,KAAK,WAAW,MAAOC,CAAK,EAE9C,KAAA,MAGHD,GAAe,OAAOD,GAAS,UAAY,CAAC,OAAO,UAAU,eAAe,KAAK,KAAK,aAAcA,CAAI,IAIxG,KAAA,WAAW,MAAM,OAASA,EACnC,CAQJ,IAAW,SACX,CACI,OAAO,KAAK,iBAAA,CAOR,eAAeG,EACvB,CACQ,GAAA,CAAC,KAAK,SAAS,MAAO,OACrB,KAAA,aAAa,WAAa,KAAK,SAAS,mBAEvC,IAAAC,EAAS,KAAK,wBAAwBD,CAAW,EAUnD,KAAK,oBAAuBC,EAAO,CAAC,EAAU,eAE3BD,EAAY,YAAc,EAAE,eAAgBA,KAI3DA,EAAY,eAAe,EAInC,QAAS,EAAI,EAAGE,EAAID,EAAO,OAAQ,EAAIC,EAAG,IAC1C,CACUF,IAAAA,EAAcC,EAAO,CAAC,EACtBE,EAAiB,KAAK,gBAAgB,KAAK,kBAAmBH,CAAW,EAE1E,KAAA,aAAa,SAASG,CAAc,CAAA,CAGxC,KAAA,UAAU,KAAK,aAAa,MAAM,CAAA,CAOnC,eAAeH,EACvB,CACQ,GAAA,CAAC,KAAK,SAAS,KAAM,OACpB,KAAA,aAAa,WAAa,KAAK,SAAS,mBAE7CZ,EAAa,aAAa,EAEpB,IAAAgB,EAAmB,KAAK,wBAAwBJ,CAAW,EAEjE,QAAS,EAAI,EAAGE,EAAIE,EAAiB,OAAQ,EAAIF,EAAG,IACpD,CACI,IAAMG,EAAQ,KAAK,gBAAgB,KAAK,kBAAmBD,EAAiB,CAAC,CAAC,EAEzE,KAAA,aAAa,SAASC,CAAK,CAAA,CAG/B,KAAA,UAAU,KAAK,aAAa,MAAM,CAAA,CAOnC,aAAaL,EACrB,CACQ,GAAA,CAAC,KAAK,SAAS,MAAO,OACrB,KAAA,aAAa,WAAa,KAAK,SAAS,mBAE7C,IAAIT,EAASS,EAAY,OAGrBA,EAAY,cAAgBA,EAAY,aAAa,EAAE,OAAS,IAEvDT,EAAAS,EAAY,aAAa,EAAE,CAAC,GAGzC,IAAMM,EAAUf,IAAW,KAAK,WAAa,UAAY,GACnDa,EAAmB,KAAK,wBAAwBJ,CAAW,EAEjE,QAASO,EAAI,EAAGL,EAAIE,EAAiB,OAAQG,EAAIL,EAAGK,IACpD,CACI,IAAMF,EAAQ,KAAK,gBAAgB,KAAK,kBAAmBD,EAAiBG,CAAC,CAAC,EAE9EF,EAAM,MAAQC,EAET,KAAA,aAAa,SAASD,CAAK,CAAA,CAG/B,KAAA,UAAU,KAAK,aAAa,MAAM,CAAA,CAOnC,kBAAkBL,EAC1B,CACQ,GAAA,CAAC,KAAK,SAAS,MAAO,OACrB,KAAA,aAAa,WAAa,KAAK,SAAS,mBAEvC,IAAAI,EAAmB,KAAK,wBAAwBJ,CAAW,EAEjE,QAAS,EAAI,EAAGE,EAAIE,EAAiB,OAAQ,EAAIF,EAAG,IACpD,CACI,IAAMG,EAAQ,KAAK,gBAAgB,KAAK,kBAAmBD,EAAiB,CAAC,CAAC,EAEzE,KAAA,aAAa,SAASC,CAAK,CAAA,CAG/B,KAAA,UAAU,KAAK,aAAa,MAAM,CAAA,CAOjC,QAAQL,EAClB,CACQ,GAAA,CAAC,KAAK,SAAS,MAAO,OACpB,IAAAQ,EAAa,KAAK,oBAAoBR,CAAW,EAElD,KAAA,aAAa,WAAa,KAAK,SAAS,mBACxC,KAAA,aAAa,SAASQ,CAAU,CAAA,CASlC,iBAAiBC,EACxB,CACI,KAAK,cAAc,EACnB,KAAK,WAAaA,EAClBrB,EAAa,WAAaqB,EAC1B,KAAK,WAAW,CAAA,CAIZ,YACR,CACI,GAAI,KAAK,cAAgB,CAAC,KAAK,WAE3B,OAGJrB,EAAa,kBAAkB,EAEzB,IAAAW,EAAQ,KAAK,WAAW,MAE1BA,IAEK,WAAW,UAAkB,kBAE9BA,EAAM,iBAAmB,OACzBA,EAAM,cAAgB,QAEjB,KAAK,wBAEVA,EAAM,YAAc,SAQxB,KAAK,uBAEL,WAAW,SAAS,iBAAiB,cAAe,KAAK,eAAgB,EAAI,EAC7E,KAAK,WAAW,iBAAiB,cAAe,KAAK,eAAgB,EAAI,EAIzE,KAAK,WAAW,iBAAiB,eAAgB,KAAK,kBAAmB,EAAI,EAC7E,KAAK,WAAW,iBAAiB,cAAe,KAAK,kBAAmB,EAAI,EAE5E,WAAW,iBAAiB,YAAa,KAAK,aAAc,EAAI,IAIhE,WAAW,SAAS,iBAAiB,YAAa,KAAK,eAAgB,EAAI,EAC3E,KAAK,WAAW,iBAAiB,YAAa,KAAK,eAAgB,EAAI,EACvE,KAAK,WAAW,iBAAiB,WAAY,KAAK,kBAAmB,EAAI,EACzE,KAAK,WAAW,iBAAiB,YAAa,KAAK,kBAAmB,EAAI,EAC1E,WAAW,iBAAiB,UAAW,KAAK,aAAc,EAAI,EAE1D,KAAK,sBAEL,KAAK,WAAW,iBAAiB,aAAc,KAAK,eAAgB,EAAI,EAExE,KAAK,WAAW,iBAAiB,WAAY,KAAK,aAAc,EAAI,EACpE,KAAK,WAAW,iBAAiB,YAAa,KAAK,eAAgB,EAAI,IAI/E,KAAK,WAAW,iBAAiB,QAAS,KAAK,QAAS,CACpD,QAAS,GACT,QAAS,EAAA,CACZ,EAED,KAAK,aAAe,EAAA,CAIhB,eACR,CACI,GAAI,CAAC,KAAK,cAAgB,CAAC,KAAK,WAE5B,OAGJX,EAAa,qBAAqB,EAE5B,IAAAW,EAAQ,KAAK,WAAW,MAG1BA,IAEK,WAAW,UAAkB,kBAE9BA,EAAM,iBAAmB,GACzBA,EAAM,cAAgB,IAEjB,KAAK,wBAEVA,EAAM,YAAc,KAIxB,KAAK,uBAEL,WAAW,SAAS,oBAAoB,cAAe,KAAK,eAAgB,EAAI,EAChF,KAAK,WAAW,oBAAoB,cAAe,KAAK,eAAgB,EAAI,EAC5E,KAAK,WAAW,oBAAoB,eAAgB,KAAK,kBAAmB,EAAI,EAChF,KAAK,WAAW,oBAAoB,cAAe,KAAK,kBAAmB,EAAI,EAE/E,WAAW,oBAAoB,YAAa,KAAK,aAAc,EAAI,IAInE,WAAW,SAAS,oBAAoB,YAAa,KAAK,eAAgB,EAAI,EAC9E,KAAK,WAAW,oBAAoB,YAAa,KAAK,eAAgB,EAAI,EAC1E,KAAK,WAAW,oBAAoB,WAAY,KAAK,kBAAmB,EAAI,EAC5E,KAAK,WAAW,oBAAoB,YAAa,KAAK,kBAAmB,EAAI,EAC7E,WAAW,oBAAoB,UAAW,KAAK,aAAc,EAAI,EAE7D,KAAK,sBAEL,KAAK,WAAW,oBAAoB,aAAc,KAAK,eAAgB,EAAI,EAE3E,KAAK,WAAW,oBAAoB,WAAY,KAAK,aAAc,EAAI,EACvE,KAAK,WAAW,oBAAoB,YAAa,KAAK,eAAgB,EAAI,IAIlF,KAAK,WAAW,oBAAoB,QAAS,KAAK,QAAS,EAAI,EAE/D,KAAK,WAAa,KAClB,KAAK,aAAe,EAAA,CAWjB,mBAAmBW,EAAkBC,EAAWC,EACvD,CACI,IAAMC,EAAO,KAAK,WAAW,YACvB,KAAK,WAAW,sBAAA,EAChB,CACE,EAAG,EACH,EAAG,EACH,MAAQ,KAAK,WAAmB,MAChC,OAAS,KAAK,WAAmB,OACjC,KAAM,EACN,IAAK,CAAA,EAGPC,EAAuB,EAAM,KAAK,WAElCJ,EAAA,GAAMC,EAAIE,EAAK,OAAU,KAAK,WAAmB,MAAQA,EAAK,OAAUC,EACxEJ,EAAA,GAAME,EAAIC,EAAK,MAAS,KAAK,WAAmB,OAASA,EAAK,QAAWC,CAAA,CAS3E,wBAAwBT,EAChC,CACI,IAAMD,EAAmB,CAAA,EAErB,GAAA,KAAK,qBAAuBC,aAAiB,WAEpC,QAAA,EAAI,EAAGU,EAAKV,EAAM,eAAe,OAAQ,EAAIU,EAAI,IAC1D,CACU,IAAAC,EAAQX,EAAM,eAAe,CAAC,EAEhC,OAAOW,EAAM,OAAW,MAAaA,EAAM,OAAS,GACpD,OAAOA,EAAM,QAAY,MAAaA,EAAM,QAAU,GACtD,OAAOA,EAAM,UAAc,MAE3BA,EAAM,UAAYX,EAAM,QAAQ,SAAW,GAAKA,EAAM,OAAS,cAE/D,OAAOW,EAAM,MAAU,MAAmBA,EAAA,MAAQA,EAAM,SAAW,GACnE,OAAOA,EAAM,OAAW,MAAmBA,EAAA,OAASA,EAAM,SAAW,GACrE,OAAOA,EAAM,MAAU,MAAaA,EAAM,MAAQ,GAClD,OAAOA,EAAM,MAAU,MAAaA,EAAM,MAAQ,GAClD,OAAOA,EAAM,YAAgB,MAAaA,EAAM,YAAc,SAC9D,OAAOA,EAAM,UAAc,MAAmBA,EAAA,UAAYA,EAAM,YAAc,GAC9E,OAAOA,EAAM,SAAa,MAAmBA,EAAA,SAAWA,EAAM,OAAS,IACvE,OAAOA,EAAM,MAAU,MAAaA,EAAM,MAAQ,GAClD,OAAOA,EAAM,mBAAuB,MAAaA,EAAM,mBAAqB,GAK5E,OAAOA,EAAM,OAAW,MAAmBA,EAAA,OAASA,EAAM,QAAUA,EAAM,SAC1E,OAAOA,EAAM,OAAW,MAAmBA,EAAA,OAASA,EAAM,QAAUA,EAAM,SAG9EA,EAAM,aAAe,GACrBA,EAAM,KAAOX,EAAM,KAEnBD,EAAiB,KAAKY,CAAK,CAAA,SAI1B,CAAC,WAAW,YACbX,aAAiB,aAAe,CAAC,KAAK,uBAAyB,EAAEA,aAAiB,WAAW,eACrG,CACI,IAAMY,EAAYZ,EAEd,OAAOY,EAAU,UAAc,MAAaA,EAAU,UAAY,IAClE,OAAOA,EAAU,MAAU,MAAaA,EAAU,MAAQ,GAC1D,OAAOA,EAAU,OAAW,MAAaA,EAAU,OAAS,GAC5D,OAAOA,EAAU,MAAU,MAAaA,EAAU,MAAQ,GAC1D,OAAOA,EAAU,MAAU,MAAaA,EAAU,MAAQ,GAC1D,OAAOA,EAAU,YAAgB,MAAaA,EAAU,YAAc,SACtE,OAAOA,EAAU,UAAc,MAAaA,EAAU,UAAYlC,IAClE,OAAOkC,EAAU,SAAa,MAAaA,EAAU,SAAW,IAChE,OAAOA,EAAU,MAAU,MAAaA,EAAU,MAAQ,GAC1D,OAAOA,EAAU,mBAAuB,MAAaA,EAAU,mBAAqB,GAGxFA,EAAU,aAAe,GAEzBb,EAAiB,KAAKa,CAAS,CAAA,MAI/Bb,EAAiB,KAAKC,CAAK,EAGxB,OAAAD,CAAA,CAWD,oBAAoBJ,EAC9B,CACI,IAAMK,EAAQ,KAAK,gBAEd,YAAA,mBAAmBA,EAAOL,CAAW,EAS1CK,EAAM,OAASL,EAAY,OAC3BK,EAAM,OAASL,EAAY,OAC3BK,EAAM,OAASL,EAAY,OAC3BK,EAAM,UAAYL,EAAY,UAE9B,KAAK,mBAAmBK,EAAM,OAAQL,EAAY,QAASA,EAAY,OAAO,EACxEK,EAAA,OAAO,SAASA,EAAM,MAAM,EAC5BA,EAAA,OAAO,SAASA,EAAM,MAAM,EAElCA,EAAM,YAAcL,EACpBK,EAAM,KAAOL,EAAY,KAElBK,CAAA,CAQH,gBAAgBA,EAA8BL,EACtD,CACI,OAAAK,EAAM,cAAgB,KACtBA,EAAM,YAAcL,EAEpBK,EAAM,UAAYL,EAAY,UAC9BK,EAAM,MAAQL,EAAY,MAC1BK,EAAM,OAASL,EAAY,OAC3BK,EAAM,UAAYL,EAAY,UAC9BK,EAAM,YAAcL,EAAY,YAChCK,EAAM,SAAWL,EAAY,SAC7BK,EAAM,mBAAqBL,EAAY,mBACvCK,EAAM,MAAQL,EAAY,MAC1BK,EAAM,MAAQL,EAAY,MAC1BK,EAAM,MAAQL,EAAY,MACrB,KAAA,mBAAmBK,EAAOL,CAAW,EAE1C,KAAK,mBAAmBK,EAAM,OAAQL,EAAY,QAASA,EAAY,OAAO,EACxEK,EAAA,OAAO,SAASA,EAAM,MAAM,EAC5BA,EAAA,OAAO,SAASA,EAAM,MAAM,EAElCA,EAAM,UAAYL,EAAY,UAC1BK,EAAM,OAAS,iBAEfA,EAAM,KAAO,cAEbA,EAAM,KAAK,WAAW,OAAO,IAE7BA,EAAM,KAAOA,EAAM,KAAK,QAAQ,QAAS,SAAS,GAElDA,EAAM,KAAK,WAAW,OAAO,IAE7BA,EAAM,KAAOrB,GAAiBqB,EAAM,IAAI,GAAKA,EAAM,MAGhDA,CAAA,CAQH,mBAAmBA,EAA4BL,EACvD,CACIK,EAAM,UAAYL,EAAY,UAC9BK,EAAM,WAAaL,EAAY,WACzBK,EAAA,UAAY,YAAY,IAAI,EAClCA,EAAM,KAAOL,EAAY,KAEzBK,EAAM,OAASL,EAAY,OAC3BK,EAAM,OAASL,EAAY,OAC3BK,EAAM,QAAUL,EAAY,QACtBK,EAAA,OAAO,EAAIL,EAAY,QACvBK,EAAA,OAAO,EAAIL,EAAY,QAC7BK,EAAM,QAAUL,EAAY,QAC5BK,EAAM,QAAUL,EAAY,QACtBK,EAAA,SAAS,EAAIL,EAAY,UACzBK,EAAA,SAAS,EAAIL,EAAY,UACzBK,EAAA,KAAK,EAAIL,EAAY,MACrBK,EAAA,KAAK,EAAIL,EAAY,MAC3BK,EAAM,cAAgB,KACtBA,EAAM,SAAWL,EAAY,QAAA,CAErC,EAttBaf,EAGK,UAA+B,CACzC,KAAM,SACN,KAAM,CACFiC,EAAc,YACdA,EAAc,aACdA,EAAc,YAAA,EAElB,SAAU,EACd,EAXSjC,EAkBK,qBAA4C,CAEtD,KAAM,GAEN,WAAY,GAEZ,MAAO,GAEP,MAAO,EACX,EA3BG,IAAMkC,GAANlC,ECoIA,IAAMmC,GAA0C,CAWnD,QAAS,KAWT,YAAa,KAWb,aAAc,KAWd,aAAc,KAWd,YAAa,KAWb,kBAAmB,KAWnB,WAAY,KAWZ,YAAc,KAWd,UAAY,KAWZ,iBAAkB,KAWlB,gBAAiB,KAWjB,cAAgB,KAWhB,eAAgB,KAWhB,eAAiB,KAWjB,cAAgB,KAWhB,oBAAsB,KAWtB,aAAe,KAWf,cAAgB,KAWhB,aAAe,KAWf,YAAc,KAWd,mBAAqB,KAWrB,aAAe,KAWf,YAAc,KAWd,UAAY,KAWZ,iBAAmB,KAWnB,MAAQ,KAWR,cAAgB,KAWhB,WAAa,KAWb,kBAAoB,KAWpB,YAAc,KAWd,kBAAoB,KAWpB,aAAe,KAWf,QAAU,KAKV,IAAI,aACJ,CACI,OAAO,KAAK,YAAc,WAAa,KAAK,YAAc,QAAA,EAE9D,IAAI,YAAYC,EAChB,CACS,KAAA,UAAYA,EAAQ,SAAW,SAAA,EAKxC,mBAAoB,OAsBpB,IAAI,WACJ,CACW,OAAA,KAAK,oBAAsBC,GAAY,gBAAA,EAElD,IAAI,UAAUD,EACd,CACI,KAAK,mBAAqBA,CAAA,EA2B9B,eACA,CACI,OAAO,KAAK,YAAc,UAAY,KAAK,YAAc,SAAA,EAQ7D,oBAAqB,GAcrB,QAAS,KAkCT,iBACIE,EACAC,EACAC,EAEJ,CACU,IAAAC,EAAW,OAAOD,GAAY,WAAaA,GAC7C,OAAOA,GAAY,UAAYA,EAAQ,QACrCE,EAAS,OAAOF,GAAY,SAAWA,EAAQ,OAAS,OACxDG,EAAO,OAAOH,GAAY,SAAYA,EAAQ,OAAS,GAAQ,GAC/DI,EAAU,OAAOL,GAAa,WAAa,OAAYA,EAEtDD,EAAAG,EAAU,GAAGH,CAAI,UAAYA,EACpC,IAAMO,EAAa,OAAON,GAAa,WAAaA,EAAWA,EAAS,YAElEO,EAAW,KAEbJ,GAEOA,EAAA,iBAAiB,QAAS,IACjC,CACYI,EAAA,IAAIR,EAAMO,EAAYD,CAAO,CAAA,CACxC,EAGDD,EAEQG,EAAA,KAAKR,EAAMO,EAAYD,CAAO,EAI9BE,EAAA,GAAGR,EAAMO,EAAYD,CAAO,CACxC,EAWJ,oBACIN,EACAC,EACAC,EAEJ,CACU,IAAAC,EAAW,OAAOD,GAAY,WAAaA,GACzC,OAAOA,GAAY,UAAYA,EAAQ,QACzCI,EAAU,OAAOL,GAAa,WAAa,OAAYA,EAEtDD,EAAAG,EAAU,GAAGH,CAAI,UAAYA,EACpCC,EAAW,OAAOA,GAAa,WAAaA,EAAWA,EAAS,YAE/D,KAAiC,IAAID,EAAMC,EAAUK,CAAO,CAAA,EAcjE,cAAcG,EACd,CACQ,GAAA,EAAEA,aAAaC,GAET,MAAA,IAAI,MAAM,uEAAuE,EAG3F,OAAAD,EAAE,iBAAmB,GACrBA,EAAE,KAAO,KACTA,EAAE,OAAS,KACTA,EAAA,QAAQ,cAAcA,CAAC,EAElB,CAACA,EAAE,gBAAA,CAElB,EChxBO,IAAME,EAAN,KACP,CA0BI,YAAYC,EACZ,CAZA,KAAiB,wBAA0B,KAAK,kBAAkB,KAAK,IAAI,EAG3E,KAAiB,qBAAuC,CAAA,EAUpD,KAAK,UAAYA,EAIjB,KAAK,UAAU,QAAQ,WAAW,IAAI,IAAI,EAGrC,KAAA,YAAc,SAAS,cAAc,KAAK,EAC1C,KAAA,YAAY,MAAM,SAAW,WAC7B,KAAA,YAAY,MAAM,IAAM,IACxB,KAAA,YAAY,MAAM,KAAO,IACzB,KAAA,YAAY,MAAM,cAAgB,OAClC,KAAA,YAAY,MAAM,OAAS,MAAA,CAQ7B,cAAcC,EAA4BC,EACjD,CACS,KAAK,qBAAqB,SAASD,CAAY,IAE3C,KAAA,qBAAqB,KAAKA,CAAY,EAC9BA,EAAA,GAAG,YAAa,KAAK,uBAAuB,EAC7D,CAOG,iBAAiBE,EACxB,CAAA,CASO,mBAAmBA,EAC1B,CACW,MAAA,EAAA,CAOJ,kBAAkBF,EACzB,CACI,IAAMG,EAAQ,KAAK,qBAAqB,QAAQH,CAAY,EAExDG,IAAU,IAEL,KAAA,qBAAqB,OAAOA,EAAO,CAAC,EAGhCH,EAAA,IAAI,YAAa,KAAK,uBAAuB,CAAA,CAIvD,YACP,CACI,IAAMI,EAAsB,KAAK,qBAE7B,GAAAA,EAAoB,SAAW,EACnC,CACI,KAAK,YAAY,OAAO,EAExB,MAAA,CAGE,IAAAC,EAAS,KAAK,UAAU,KAAK,OAE/B,KAAK,YAAY,aAAeA,EAAO,YAEhCA,EAAA,YAAY,YAAY,KAAK,WAAW,EAG9C,KAAA,YAAY,MAAM,UAAY,aAAaA,EAAO,UAAU,OAAOA,EAAO,SAAS,MAExF,QAAS,EAAI,EAAG,EAAID,EAAoB,OAAQ,IAChD,CACU,IAAAJ,EAAeI,EAAoB,CAAC,EACpCE,EAAUN,EAAa,QAE7B,GAAI,CAACA,EAAa,QAAUA,EAAa,oBAAsB,EAE3DM,EAAQ,OAAO,EACKF,EAAA,OAAO,EAAG,CAAC,EAC/B,QAGJ,CACS,KAAK,YAAY,SAASE,CAAO,IAElCA,EAAQ,MAAM,SAAW,WACzBA,EAAQ,MAAM,cAAgB,OACzB,KAAA,YAAY,YAAYA,CAAO,GAGxC,IAAMC,EAAKP,EAAa,eAClBQ,EAASR,EAAa,QACtBS,EAAKT,EAAa,MAAQQ,EAAO,EACjCE,EAAKV,EAAa,OAASQ,EAAO,EAExCF,EAAQ,MAAM,gBAAkB,GAAGG,CAAE,MAAMC,CAAE,KACrCJ,EAAA,MAAM,UAAY,UAAUC,EAAG,CAAC,KAAKA,EAAG,CAAC,KAAKA,EAAG,CAAC,KAAKA,EAAG,CAAC,KAAKA,EAAG,GAAKE,CAAE,KAAKF,EAAG,GAAKG,CAAE,IACjGJ,EAAQ,MAAM,QAAUN,EAAa,WAAW,SAAS,CAAA,CAC7D,CACJ,CAIG,SACP,CACI,KAAK,UAAU,QAAQ,WAAW,OAAO,IAAI,EAE7C,QAASW,EAAI,EAAGA,EAAI,KAAK,qBAAqB,OAAQA,IACtD,CACU,IAAAX,EAAe,KAAK,qBAAqBW,CAAC,EAEnCX,EAAA,IAAI,YAAa,KAAK,uBAAuB,EAC1DA,EAAa,QAAQ,OAAO,CAAA,CAGhC,KAAK,qBAAqB,OAAS,EACnC,KAAK,YAAY,OAAO,EACxB,KAAK,UAAY,IAAA,CAEzB,EAnKaF,EAMK,UAAY,CACtB,KAAM,CACFc,EAAc,WACdA,EAAc,YACdA,EAAc,WAAA,EAElB,KAAM,KACV",
  "names": ["FederatedEvent", "_FederatedEvent", "manager", "Point", "_type", "_bubbles", "_cancelable", "_typeArg", "_bubblesArg", "_cancelableArg", "_viewArg", "_detailArg", "appleIphone", "appleIpod", "appleTablet", "appleUniversal", "androidPhone", "androidTablet", "amazonPhone", "amazonTablet", "windowsPhone", "windowsTablet", "otherBlackBerry", "otherBlackBerry10", "otherOpera", "otherChrome", "otherFirefox", "isAppleTabletOnIos13", "navigator", "createMatch", "userAgent", "regex", "isMobile", "param", "nav", "tmp", "match", "result", "isMobileCall", "isMobile", "KEY_CODE_TAB", "DIV_TOUCH_SIZE", "DIV_TOUCH_POS_X", "DIV_TOUCH_POS_Y", "DIV_TOUCH_ZINDEX", "DIV_HOOK_SIZE", "DIV_HOOK_POS_X", "DIV_HOOK_POS_Y", "DIV_HOOK_ZINDEX", "_AccessibilitySystem", "renderer", "_mobileInfo", "isMobile", "hookDiv", "canvas", "observer", "child", "div", "container", "children", "options", "mergedOptions", "now", "activeIds", "removeItems", "x", "y", "viewWidth", "viewHeight", "hitArea", "wt", "sx", "sy", "type", "target", "boundary", "event", "FederatedEvent", "enabled", "ExtensionType", "AccessibilitySystem", "accessibilityTarget", "EventsTickerClass", "events", "paused", "Ticker", "UPDATE_PRIORITY", "rootPointerEvent", "ticker", "EventsTicker", "FederatedMouseEvent", "FederatedEvent", "Point", "container", "point", "globalPos", "key", "_typeArg", "_canBubbleArg", "_cancelableArg", "_viewArg", "_detailArg", "_screenXArg", "_screenYArg", "_clientXArg", "_clientYArg", "_ctrlKeyArg", "_altKeyArg", "_shiftKeyArg", "_metaKeyArg", "_buttonArg", "_relatedTargetArg", "FederatedPointerEvent", "FederatedMouseEvent", "FederatedWheelEvent", "FederatedMouseEvent", "PROPAGATION_LIMIT", "tempHitLocation", "Point", "tempLocalMapping", "EventBoundary", "rootTarget", "eventemitter3_default", "type", "fn", "a", "b", "mappers", "j", "warn", "x", "y", "EventsTicker", "invertedPath", "composedPath", "i", "targets", "events", "event", "target", "propagationPath", "currentTarget", "eventMode", "location", "testFn", "pruneFn", "ignore", "shouldReturn", "children", "child", "nestedHit", "isInteractive", "isInteractiveMode", "isInteractiveTarget", "relativeLocation", "int", "container", "effect", "handlerKey", "key", "from", "FederatedPointerEvent", "e", "isRightButton", "trackingData", "isMouse", "outTarget", "outType", "outEvent", "leaveEvent", "overType", "overEvent", "overTargetAncestor", "enterEvent", "allMethods", "allowGlobalPointerEvents", "now", "pressTarget", "clickTarget", "clickEvent", "clickHistory", "FederatedWheelEvent", "wheelEvent", "to", "FederatedMouseEvent", "id", "constructor", "listeners", "MOUSE_POINTER_ID", "TOUCH_TO_POINTER", "_EventSystem", "renderer", "EventBoundary", "EventsTicker", "FederatedPointerEvent", "FederatedWheelEvent", "target", "key", "value", "options", "canvas", "resolution", "mode", "applyStyles", "style", "nativeEvent", "events", "j", "federatedEvent", "normalizedEvents", "event", "outside", "i", "wheelEvent", "element", "point", "x", "y", "rect", "resolutionMultiplier", "li", "touch", "tempEvent", "ExtensionType", "EventSystem", "FederatedContainer", "value", "EventSystem", "type", "listener", "options", "capture", "signal", "once", "context", "listenerFn", "emitter", "e", "FederatedEvent", "DOMPipe", "renderer", "domContainer", "_instructionSet", "_domContainer", "index", "attachedDomElements", "canvas", "element", "wt", "anchor", "ax", "ay", "i", "ExtensionType"]
}
