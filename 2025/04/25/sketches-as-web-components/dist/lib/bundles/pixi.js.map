{
  "version": 3,
  "sources": ["../../../node_modules/pixi.js/src/environment-browser/browserExt.ts", "../../../node_modules/pixi.js/src/environment-webworker/webworkerExt.ts", "../../../node_modules/pixi.js/src/utils/browser/isWebGLSupported.ts", "../../../node_modules/pixi.js/src/utils/browser/isWebGPUSupported.ts", "../../../node_modules/pixi.js/src/rendering/renderers/autoDetectRenderer.ts", "../../../node_modules/pixi.js/src/app/Application.ts", "../../../node_modules/pixi.js/src/index.ts", "../../../node_modules/pixi-filters/lib/defaults/default.mjs", "../../../node_modules/pixi-filters/lib/defaults/default2.mjs", "../../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur.mjs", "../../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur2.mjs", "../../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp.mjs", "../../../node_modules/pixi-filters/lib/kawase-blur/kawase-blur-clamp2.mjs", "../../../node_modules/pixi-filters/src/kawase-blur/KawaseBlurFilter.ts", "../../../node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom.mjs", "../../../node_modules/pixi-filters/lib/advanced-bloom/advanced-bloom2.mjs", "../../../node_modules/pixi-filters/lib/advanced-bloom/extract-brightness.mjs", "../../../node_modules/pixi-filters/lib/advanced-bloom/extract-brightness2.mjs", "../../../node_modules/pixi-filters/src/advanced-bloom/ExtractBrightnessFilter.ts", "../../../node_modules/pixi-filters/src/advanced-bloom/AdvancedBloomFilter.ts"],
  "sourcesContent": ["import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the browser environment.\n * @memberof environment\n */\nexport const browserExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'browser',\n        priority: -1,\n    },\n    test: () => true,\n    load: async () =>\n    {\n        await import('./browserAll');\n    },\n};\n", "import { ExtensionType } from '../extensions/Extensions';\n\n/**\n * Extension for the webworker environment.\n * @memberof environment\n */\nexport const webworkerExt = {\n    extension: {\n        type: ExtensionType.Environment,\n        name: 'webworker',\n        priority: 0,\n    },\n    test: () => typeof self !== 'undefined' && self.WorkerGlobalScope !== undefined,\n    load: async () =>\n    {\n        await import('./webworkerAll');\n    },\n};\n", "import { DOMAdapter } from '../../environment/adapter';\nimport { AbstractRenderer } from '../../rendering/renderers/shared/system/AbstractRenderer';\n\nlet _isWebGLSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGL support.\n * @param failIfMajorPerformanceCaveat - whether to fail if there is a major performance caveat, defaults to false\n * @memberof utils\n * @function isWebGLSupported\n * @returns {boolean} Is WebGL supported.\n */\nexport function isWebGLSupported(\n    failIfMajorPerformanceCaveat?: boolean\n): boolean\n{\n    if (_isWebGLSupported !== undefined) return _isWebGLSupported;\n\n    _isWebGLSupported = ((): boolean =>\n    {\n        const contextOptions = {\n            stencil: true,\n            failIfMajorPerformanceCaveat:\n                failIfMajorPerformanceCaveat\n                ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat,\n        };\n\n        try\n        {\n            if (!DOMAdapter.get().getWebGLRenderingContext())\n            {\n                return false;\n            }\n\n            const canvas = DOMAdapter.get().createCanvas();\n            let gl = canvas.getContext('webgl', contextOptions);\n\n            const success = !!gl?.getContextAttributes()?.stencil;\n\n            if (gl)\n            {\n                const loseContext = gl.getExtension('WEBGL_lose_context');\n\n                if (loseContext)\n                {\n                    loseContext.loseContext();\n                }\n            }\n\n            gl = null;\n\n            return success;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGLSupported;\n}\n", "import { DOMAdapter } from '../../environment/adapter';\n\nlet _isWebGPUSupported: boolean | undefined;\n\n/**\n * Helper for checking for WebGPU support.\n * @param options - The options for requesting a GPU adapter.\n * @memberof utils\n * @function isWebGPUSupported\n * @returns Is WebGPU supported.\n */\nexport async function isWebGPUSupported(options: GPURequestAdapterOptions = {}): Promise<boolean>\n{\n    if (_isWebGPUSupported !== undefined) return _isWebGPUSupported;\n\n    _isWebGPUSupported = await (async (): Promise<boolean> =>\n    {\n        const gpu = DOMAdapter.get().getNavigator().gpu;\n\n        if (!gpu)\n        {\n            return false;\n        }\n\n        try\n        {\n            const adapter = await gpu.requestAdapter(options) as GPUAdapter;\n\n            // TODO and one of these!\n            await adapter.requestDevice();\n\n            return true;\n        }\n        catch (_e)\n        {\n            return false;\n        }\n    })();\n\n    return _isWebGPUSupported;\n}\n", "import { isWebGLSupported } from '../../utils/browser/isWebGLSupported';\nimport { isWebGPUSupported } from '../../utils/browser/isWebGPUSupported';\nimport { AbstractRenderer } from './shared/system/AbstractRenderer';\n\nimport type { WebGLOptions } from './gl/WebGLRenderer';\nimport type { WebGPUOptions } from './gpu/WebGPURenderer';\nimport type { Renderer, RendererOptions } from './types';\n\n/**\n * Options for {@link rendering.autoDetectRenderer}.\n * @memberof rendering\n */\nexport interface AutoDetectOptions extends RendererOptions\n{\n    /** The preferred renderer type. WebGPU is recommended as its generally faster than WebGL. */\n    preference?: 'webgl' | 'webgpu'// | 'canvas';\n    /** Optional WebGPUOptions to pass only to WebGPU renderer. */\n    webgpu?: Partial<WebGPUOptions>;\n    /** Optional WebGLOptions to pass only to the WebGL renderer */\n    webgl?: Partial<WebGLOptions>;\n}\n\nconst renderPriority = ['webgl', 'webgpu', 'canvas'];\n\n/**\n * Automatically determines the most appropriate renderer for the current environment.\n *\n * The function will prioritize the WebGL renderer as it is the most tested safe API to use.\n * In the near future as WebGPU becomes more stable and ubiquitous, it will be prioritized over WebGL.\n *\n * The selected renderer's code is then dynamically imported to optimize\n * performance and minimize the initial bundle size.\n *\n * To maximize the benefits of dynamic imports, it's recommended to use a modern bundler\n * that supports code splitting. This will place the renderer code in a separate chunk,\n * which is loaded only when needed.\n * @example\n *\n * // create a renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   antialias: true,\n * });\n *\n * // custom for each renderer\n * const renderer = await autoDetectRenderer({\n *   width: 800,\n *   height: 600,\n *   webgpu:{\n *     antialias: true,\n *     backgroundColor: 'red'\n *   },\n *   webgl:{\n *     antialias: true,\n *     backgroundColor: 'green'\n *   }\n *  });\n * @param options - A partial configuration object based on the `AutoDetectOptions` type.\n * @returns A Promise that resolves to an instance of the selected renderer.\n * @memberof rendering\n */\nexport async function autoDetectRenderer(options: Partial<AutoDetectOptions>): Promise<Renderer>\n{\n    let preferredOrder: string[] = [];\n\n    if (options.preference)\n    {\n        preferredOrder.push(options.preference);\n\n        renderPriority.forEach((item) =>\n        {\n            if (item !== options.preference)\n            {\n                preferredOrder.push(item);\n            }\n        });\n    }\n    else\n    {\n        preferredOrder = renderPriority.slice();\n    }\n\n    let RendererClass: new () => Renderer;\n    let finalOptions: Partial<AutoDetectOptions> = {};\n\n    for (let i = 0; i < preferredOrder.length; i++)\n    {\n        const rendererType = preferredOrder[i];\n\n        if (rendererType === 'webgpu' && (await isWebGPUSupported()))\n        {\n            const { WebGPURenderer } = await import('./gpu/WebGPURenderer');\n\n            RendererClass = WebGPURenderer;\n\n            finalOptions = { ...options, ...options.webgpu };\n\n            break;\n        }\n        else if (\n            rendererType === 'webgl'\n            && isWebGLSupported(\n                options.failIfMajorPerformanceCaveat\n                    ?? AbstractRenderer.defaultOptions.failIfMajorPerformanceCaveat\n            )\n        )\n        {\n            const { WebGLRenderer } = await import('./gl/WebGLRenderer');\n\n            RendererClass = WebGLRenderer;\n\n            finalOptions = { ...options, ...options.webgl };\n\n            break;\n        }\n        else if (rendererType === 'canvas')\n        {\n            finalOptions = { ...options };\n\n            throw new Error('CanvasRenderer is not yet implemented');\n        }\n    }\n\n    delete finalOptions.webgpu;\n    delete finalOptions.webgl;\n\n    if (!RendererClass)\n    {\n        throw new Error('No available renderer for the current environment');\n    }\n\n    const renderer = new RendererClass();\n\n    await renderer.init(finalOptions);\n\n    return renderer;\n}\n", "import { extensions, ExtensionType } from '../extensions/Extensions';\nimport { autoDetectRenderer } from '../rendering/renderers/autoDetectRenderer';\nimport { Container } from '../scene/container/Container';\nimport { ApplicationInitHook } from '../utils/global/globalHooks';\nimport { deprecation, v8_0_0 } from '../utils/logging/deprecation';\n\nimport type { Rectangle } from '../maths/shapes/Rectangle';\nimport type { AutoDetectOptions } from '../rendering/renderers/autoDetectRenderer';\nimport type { RendererDestroyOptions } from '../rendering/renderers/shared/system/AbstractRenderer';\nimport type { Renderer } from '../rendering/renderers/types';\nimport type { DestroyOptions } from '../scene/container/destroyTypes';\n\n/**\n * The app module provides a set of classes to use as a starting point when building applications.\n *\n * <aside>This module has a mixin for <code>TickerPlugin</code> and <code>ResizePlugin</code>.\n * These will need to be imported if you are managing your own renderer.</aside>\n *\n * ```js\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init();\n *\n * // don't forget to add the canvas to the DOM\n * document.body.appendChild(app.canvas);\n * ```\n * @namespace app\n */\n\n/**\n * Any plugin that's usable for Application should contain these methods.\n * @example\n * import { ApplicationPlugin } from 'pixi.js';\n *\n * const plugin: ApplicationPlugin = {\n *    init: (options: Partial<ApplicationOptions>) =>\n *    {\n *       // handle init here, use app options if needed\n *    },\n *    destroy: () =>\n *    {\n *       // handle destruction code here\n *    }\n * }\n * @memberof app\n * @see {@link app.ApplicationOptions}\n * @ignore\n */\nexport interface ApplicationPlugin\n{\n    /**\n     * Called when Application is constructed, scoped to Application instance.\n     * Passes in `options` as the only argument, which are Application `init()` options.\n     * @param {object} options - Application options.\n     */\n    init(options: Partial<ApplicationOptions>): void;\n    /** Called when destroying Application, scoped to Application instance. */\n    destroy(): void;\n}\n\n/**\n * Application options supplied to the {@link app.Application#init} method.\n * @memberof app\n * @example\n * import { Application } from 'pixi.js';\n *\n * const app = new Application();\n *\n * await app.init({\n *    autoStart: false,\n *    resizeTo: window,\n *    sharedTicker: true,\n * });\n */\nexport interface ApplicationOptions extends AutoDetectOptions, PixiMixins.ApplicationOptions { }\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface Application extends PixiMixins.Application { }\n\n/**\n * Convenience class to create a new PixiJS application.\n *\n * This class automatically creates the renderer, ticker and root container.\n * @example\n * import { Application, Sprite } from 'pixi.js';\n *\n * // Create the application\n * const app = new Application();\n *\n * await app.init({ width: 800, height: 600 });\n *\n * // Add the view to the DOM\n * document.body.appendChild(app.canvas);\n *\n * // ex, add display objects\n * app.stage.addChild(Sprite.from('something.png'));\n * @memberof app\n */\nexport class Application<R extends Renderer = Renderer>\n{\n    /**\n     * Collection of installed plugins.\n     * @alias _plugins\n     */\n    public static _plugins: ApplicationPlugin[] = [];\n\n    /** The root display container that's rendered. */\n    public stage: Container = new Container();\n\n    /**\n     * WebGL renderer if available, otherwise CanvasRenderer.\n     * @member {rendering.Renderer}\n     */\n    public renderer: R;\n\n    /** Create new Application instance */\n    constructor();\n\n    /** @deprecated since 8.0.0 */\n    constructor(options?: Partial<ApplicationOptions>);\n\n    /** @ignore */\n    constructor(...args: [Partial<ApplicationOptions>] | [])\n    {\n        // #if _DEBUG\n        if (args[0] !== undefined)\n        {\n            deprecation(v8_0_0, 'Application constructor options are deprecated, please use Application.init() instead.');\n        }\n        // #endif\n    }\n\n    /**\n     * @param options - The optional application and renderer parameters.\n     */\n    public async init(options?: Partial<ApplicationOptions>)\n    {\n        // The default options\n        options = { ...options };\n\n        this.renderer = await autoDetectRenderer(options as ApplicationOptions) as R;\n\n        // install plugins here\n        Application._plugins.forEach((plugin) =>\n        {\n            plugin.init.call(this, options);\n        });\n    }\n\n    /** Render the current stage. */\n    public render(): void\n    {\n        this.renderer.render({ container: this.stage });\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @readonly\n     * @member {HTMLCanvasElement}\n     */\n    get canvas(): R['canvas']\n    {\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's canvas element.\n     * @member {HTMLCanvasElement}\n     * @deprecated since 8.0.0\n     */\n    get view(): R['canvas']\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Application.view is deprecated, please use Application.canvas instead.');\n        // #endif\n\n        return this.renderer.canvas as R['canvas'];\n    }\n\n    /**\n     * Reference to the renderer's screen rectangle. Its safe to use as `filterArea` or `hitArea` for the whole screen.\n     * @readonly\n     */\n    get screen(): Rectangle\n    {\n        return this.renderer.screen;\n    }\n\n    /**\n     * Destroys the application and all of its resources.\n     * @param {object|boolean}[rendererDestroyOptions=false] - The options for destroying the renderer.\n     * @param {boolean}[rendererDestroyOptions.removeView=false] - Removes the Canvas element from the DOM.\n     * @param {object|boolean} [options=false] - The options for destroying the stage.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy method\n     * called as well. `options` will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for children with textures e.g. Sprites.\n     * If options.children is set to true,\n     * it should destroy the texture of the child sprite.\n     * @param {boolean} [options.textureSource=false] - Only used for children with textures e.g. Sprites.\n     *  If options.children is set to true,\n     * it should destroy the texture source of the child sprite.\n     * @param {boolean} [options.context=false] - Only used for children with graphicsContexts e.g. Graphics.\n     * If options.children is set to true,\n     * it should destroy the context of the child graphics.\n     */\n    public destroy(rendererDestroyOptions: RendererDestroyOptions = false, options: DestroyOptions = false): void\n    {\n        // Destroy plugins in the opposite order\n        // which they were constructed\n        const plugins = Application._plugins.slice(0);\n\n        plugins.reverse();\n        plugins.forEach((plugin) =>\n        {\n            plugin.destroy.call(this);\n        });\n\n        this.stage.destroy(options);\n        this.stage = null;\n\n        this.renderer.destroy(rendererDestroyOptions);\n        this.renderer = null;\n    }\n}\n\nextensions.handleByList(ExtensionType.Application, Application._plugins);\nextensions.add(ApplicationInitHook);\n", "import { browserExt } from './environment-browser/browserExt';\nimport { webworkerExt } from './environment-webworker/webworkerExt';\nimport { extensions } from './extensions/Extensions';\nimport './rendering/init';\nimport './spritesheet/init';\n\nexport * from './accessibility';\nexport * from './advanced-blend-modes';\nexport * from './app';\nexport * from './assets';\nexport * from './color';\nexport * from './compressed-textures';\nexport * from './culling';\nexport * from './dom';\nexport * from './environment';\nexport * from './environment-browser';\nexport * from './environment-webworker';\nexport * from './events';\nexport * from './extensions';\nexport * from './filters';\nexport * from './maths';\nexport * from './prepare';\nexport * from './rendering';\nexport * from './scene';\nexport * from './spritesheet';\nexport * from './ticker';\nexport * from './utils';\n\nextensions.add(browserExt, webworkerExt);\n", "var vertex = \"in vec2 aPosition;\\nout vec2 vTextureCoord;\\n\\nuniform vec4 uInputSize;\\nuniform vec4 uOutputFrame;\\nuniform vec4 uOutputTexture;\\n\\nvec4 filterVertexPosition( void )\\n{\\n    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;\\n    \\n    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nvec2 filterTextureCoord( void )\\n{\\n    return aPosition * (uOutputFrame.zw * uInputSize.zw);\\n}\\n\\nvoid main(void)\\n{\\n    gl_Position = filterVertexPosition();\\n    vTextureCoord = filterTextureCoord();\\n}\\n\";\n\nexport { vertex as default };\n//# sourceMappingURL=default.mjs.map\n", "var wgslVertex = \"struct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\nstruct VSOutput {\\n    @builtin(position) position: vec4<f32>,\\n    @location(0) uv : vec2<f32>\\n  };\\n\\nfn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>\\n{\\n    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;\\n\\n    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;\\n    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;\\n\\n    return vec4(position, 0.0, 1.0);\\n}\\n\\nfn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);\\n}\\n\\nfn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>\\n{\\n  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  \\n}\\n\\nfn getSize() -> vec2<f32>\\n{\\n  return gfu.uGlobalFrame.zw;\\n}\\n  \\n@vertex\\nfn mainVertex(\\n  @location(0) aPosition : vec2<f32>, \\n) -> VSOutput {\\n  return VSOutput(\\n   filterVertexPosition(aPosition),\\n   filterTextureCoord(aPosition)\\n  );\\n}\";\n\nexport { wgslVertex as default };\n//# sourceMappingURL=default2.mjs.map\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\";\n\nexport { fragment as default };\n//# sourceMappingURL=kawase-blur.mjs.map\n", "var source = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4<f32>(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y));\\n  // Average\\n  color *= 0.25;\\n\\n  return color;\\n}\";\n\nexport { source as default };\n//# sourceMappingURL=kawase-blur2.mjs.map\n", "var fragmentClamp = \"\\nprecision highp float;\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform vec2 uOffset;\\n\\nuniform vec4 uInputClamp;\\n\\nvoid main(void)\\n{\\n    vec4 color = vec4(0.0);\\n\\n    // Sample top left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample top right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom right pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Sample bottom left pixel\\n    color += texture(uTexture, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), uInputClamp.xy, uInputClamp.zw));\\n\\n    // Average\\n    color *= 0.25;\\n\\n    finalColor = color;\\n}\\n\";\n\nexport { fragmentClamp as default };\n//# sourceMappingURL=kawase-blur-clamp.mjs.map\n", "var sourceClamp = \"struct KawaseBlurUniforms {\\n  uOffset:vec2<f32>,\\n};\\n\\nstruct GlobalFilterUniforms {\\n  uInputSize:vec4<f32>,\\n  uInputPixel:vec4<f32>,\\n  uInputClamp:vec4<f32>,\\n  uOutputFrame:vec4<f32>,\\n  uGlobalFrame:vec4<f32>,\\n  uOutputTexture:vec4<f32>,\\n};\\n\\n@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> kawaseBlurUniforms : KawaseBlurUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let uOffset = kawaseBlurUniforms.uOffset;\\n  var color: vec4<f32> = vec4(0.0);\\n\\n  // Sample top left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample top right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y + uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom right pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x + uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Sample bottom left pixel\\n  color += textureSample(uTexture, uSampler, clamp(vec2<f32>(uv.x - uOffset.x, uv.y - uOffset.y), gfu.uInputClamp.xy, gfu.uInputClamp.zw));\\n  // Average\\n  color *= 0.25;\\n    \\n  return color;\\n}\";\n\nexport { sourceClamp as default };\n//# sourceMappingURL=kawase-blur-clamp2.mjs.map\n", "import { deprecation, Filter, GlProgram, GpuProgram, TexturePool } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './kawase-blur.frag';\nimport source from './kawase-blur.wgsl';\nimport fragmentClamp from './kawase-blur-clamp.frag';\nimport sourceClamp from './kawase-blur-clamp.wgsl';\n\nimport type { FilterSystem, PointData, RenderSurface, Texture } from 'pixi.js';\n\n/** Options for the KawaseBlurFilter constructor. */\nexport interface KawaseBlurFilterOptions\n{\n    /**\n     * The blur of the filter. Should be greater than `0`.\n     * If value is an Array, setting kernels.\n     * @default 4\n     */\n    strength?: number | [number, number];\n    /**\n     * The quality of the filter. Should be an integer greater than `1`\n     * @default 3\n     */\n    quality?: number;\n    /**\n     * Clamp edges, useful for removing dark edges from fullscreen filters or bleeding to the edge of filterArea.\n     * @default false\n     */\n    clamp?: boolean;\n    /**\n     * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number;\n}\n\n/**\n * A much faster blur than Gaussian blur, but more complicated to use.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/kawase-blur.png)\n *\n * @see https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms\n * @class\n * @extends Filter\n */\nexport class KawaseBlurFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: KawaseBlurFilterOptions = {\n        strength: 4,\n        quality: 3,\n        clamp: false,\n        pixelSize: { x: 1, y: 1 },\n    };\n\n    public uniforms: {\n        uOffset: Float32Array;\n    };\n\n    private _pixelSize = { x: 0, y: 0 };\n    private _clamp: boolean;\n    private _kernels: number[] = [];\n    private _blur!: number;\n    private _quality!: number;\n\n    /**\n     * @param options - Options for the KawaseBlurFilter constructor.\n     */\n    constructor(options?: KawaseBlurFilterOptions);\n    /**\n     * @deprecated since 6.0.0\n     *\n     * @param {number|number[]} [blur=4] - The blur of the filter. Should be greater than `0`. If\n     *        value is an Array, setting kernels.\n     * @param {number} [quality=3] - The quality of the filter. Should be an integer greater than `1`.\n     * @param {boolean} [clamp=false] - Clamp edges, useful for removing dark edges\n     *        from fullscreen filters or bleeding to the edge of filterArea.\n     */\n    constructor(blur?: number | number[], quality?: number, clamp?: boolean);\n    /** @ignore */\n    constructor(...args: [KawaseBlurFilterOptions?] | [(number | number[])?, number?, boolean?])\n    {\n        let options = args[0] ?? {};\n\n        if (typeof options === 'number' || Array.isArray(options))\n        {\n            // eslint-disable-next-line max-len\n            deprecation('6.0.0', 'KawaseBlurFilter constructor params are now options object. See params: { strength, quality, clamp, pixelSize }');\n\n            options = { strength: options as number | [number, number] };\n\n            if (args[1] !== undefined) options.quality = args[1];\n            if (args[2] !== undefined) options.clamp = args[2];\n        }\n\n        options = { ...KawaseBlurFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source: options?.clamp ? sourceClamp : source,\n                entryPoint: 'mainFragment',\n            },\n        });\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment: options?.clamp ? fragmentClamp : fragment,\n            name: 'kawase-blur-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                kawaseBlurUniforms: {\n                    uOffset: { value: new Float32Array(2), type: 'vec2<f32>' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.kawaseBlurUniforms.uniforms;\n\n        this.pixelSize = options.pixelSize ?? { x: 1, y: 1 };\n\n        if (Array.isArray(options.strength))\n        {\n            this.kernels = options.strength;\n        }\n        else if (typeof options.strength === 'number')\n        {\n            this._blur = options.strength;\n            this.quality = options.quality ?? 3;\n        }\n\n        this._clamp = !!options.clamp;\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const uvX = this.pixelSizeX / input.source.width;\n        const uvY = this.pixelSizeY / input.source.height;\n        let offset;\n\n        if (this._quality === 1 || this._blur === 0)\n        {\n            offset = this._kernels[0] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, input, output, clearMode);\n        }\n        else\n        {\n            const renderTarget = TexturePool.getSameSizeTexture(input);\n\n            let source = input;\n            let target = renderTarget;\n            let tmp;\n\n            const last = this._quality - 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                offset = this._kernels[i] + 0.5;\n                this.uniforms.uOffset[0] = offset * uvX;\n                this.uniforms.uOffset[1] = offset * uvY;\n                filterManager.applyFilter(this, source, target, true);\n\n                tmp = source;\n                source = target;\n                target = tmp;\n            }\n\n            offset = this._kernels[last] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n\n            filterManager.applyFilter(this, source, output, clearMode);\n            TexturePool.returnTexture(renderTarget);\n        }\n    }\n\n    /**\n      * The amount of blur, value greater than `0`.\n      * @default 4\n      */\n    get strength(): number { return this._blur; }\n    set strength(value: number)\n    {\n        this._blur = value;\n        this._generateKernels();\n    }\n\n    /**\n      * The quality of the filter, integer greater than `1`.\n      * @default 3\n      */\n    get quality(): number { return this._quality; }\n    set quality(value: number)\n    {\n        this._quality = Math.max(1, Math.round(value));\n        this._generateKernels();\n    }\n\n    /**\n      * The kernel size of the blur filter, for advanced usage\n      * @default [0]\n      */\n    get kernels(): number[] { return this._kernels; }\n    set kernels(value: number[])\n    {\n        if (Array.isArray(value) && value.length > 0)\n        {\n            this._kernels = value;\n            this._quality = value.length;\n            this._blur = Math.max(...value);\n        }\n        else\n        {\n            // If value is invalid, set default value\n            this._kernels = [0];\n            this._quality = 1;\n        }\n    }\n\n    /**\n      * The size of the pixels. Large size is blurrier. For advanced usage.\n      * @default {x:1,y:1}\n      */\n    get pixelSize(): PointData { return this._pixelSize; }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            this.pixelSizeX = this.pixelSizeY = value;\n\n            return;\n        }\n\n        if (Array.isArray(value))\n        {\n            this.pixelSizeX = value[0];\n            this.pixelSizeY = value[1];\n\n            return;\n        }\n\n        this._pixelSize = value;\n    }\n\n    /**\n      * The size of the pixels on the `x` axis. Large size is blurrier. For advanced usage.\n      * @default 1\n      */\n    get pixelSizeX(): number { return this.pixelSize.x; }\n    set pixelSizeX(value: number) { this.pixelSize.x = value; }\n\n    /**\n      * The size of the pixels on the `y` axis. Large size is blurrier. For advanced usage.\n      * @default 1\n      */\n    get pixelSizeY(): number { return this.pixelSize.y; }\n    set pixelSizeY(value: number) { this.pixelSize.y = value; }\n\n    /**\n      * Get the if the filter is clamped\n      * @default false\n      */\n    get clamp(): boolean { return this._clamp; }\n\n    /** Update padding based on kernel data */\n    private _updatePadding()\n    {\n        this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n    }\n\n    /** Auto generate kernels by blur & quality */\n    private _generateKernels()\n    {\n        const blur = this._blur;\n        const quality = this._quality;\n        const kernels: number[] = [blur];\n\n        if (blur > 0)\n        {\n            let k = blur;\n            const step = blur / quality;\n\n            for (let i = 1; i < quality; i++)\n            {\n                k -= step;\n                kernels.push(k);\n            }\n        }\n\n        this._kernels = kernels;\n        this._updatePadding();\n    }\n}\n", "var fragment = \"in vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform sampler2D uMapTexture;\\nuniform float uBloomScale;\\nuniform float uBrightness;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n    color.rgb *= uBrightness;\\n    vec4 bloomColor = vec4(texture(uMapTexture, vTextureCoord).rgb, 0.0);\\n    bloomColor.rgb *= uBloomScale;\\n    finalColor = color + bloomColor;\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=advanced-bloom.mjs.map\n", "var source = \"struct AdvancedBloomUniforms {\\n  uBloomScale: f32,\\n  uBrightness: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> advancedBloomUniforms : AdvancedBloomUniforms;\\n@group(1) @binding(1) var uMapTexture: texture_2d<f32>;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  var color = textureSample(uTexture, uSampler, uv);\\n  color = vec4<f32>(color.rgb * advancedBloomUniforms.uBrightness, color.a);\\n\\n  var bloomColor = vec4<f32>(textureSample(uMapTexture, uSampler, uv).rgb, 0.0);\\n  bloomColor = vec4<f32>(bloomColor.rgb * advancedBloomUniforms.uBloomScale, bloomColor.a);\\n  \\n  return color + bloomColor;\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=advanced-bloom2.mjs.map\n", "var fragment = \"\\nin vec2 vTextureCoord;\\nout vec4 finalColor;\\n\\nuniform sampler2D uTexture;\\nuniform float uThreshold;\\n\\nvoid main() {\\n    vec4 color = texture(uTexture, vTextureCoord);\\n\\n    // A simple & fast algorithm for getting brightness.\\n    // It's inaccuracy , but good enought for this feature.\\n    float _max = max(max(color.r, color.g), color.b);\\n    float _min = min(min(color.r, color.g), color.b);\\n    float brightness = (_max + _min) * 0.5;\\n\\n    if(brightness > uThreshold) {\\n        finalColor = color;\\n    } else {\\n        finalColor = vec4(0.0, 0.0, 0.0, 0.0);\\n    }\\n}\\n\";\n\nexport { fragment as default };\n//# sourceMappingURL=extract-brightness.mjs.map\n", "var source = \"struct ExtractBrightnessUniforms {\\n  uThreshold: f32,\\n};\\n\\n@group(0) @binding(1) var uTexture: texture_2d<f32>; \\n@group(0) @binding(2) var uSampler: sampler;\\n@group(1) @binding(0) var<uniform> extractBrightnessUniforms : ExtractBrightnessUniforms;\\n\\n@fragment\\nfn mainFragment(\\n  @builtin(position) position: vec4<f32>,\\n  @location(0) uv : vec2<f32>\\n) -> @location(0) vec4<f32> {\\n  let color: vec4<f32> = textureSample(uTexture, uSampler, uv);\\n\\n  // A simple & fast algorithm for getting brightness.\\n  // It's inaccurate, but good enough for this feature.\\n  let max: f32 = max(max(color.r, color.g), color.b);\\n  let min: f32 = min(min(color.r, color.g), color.b);\\n  let brightness: f32 = (max + min) * 0.5;\\n\\n  return select(vec4<f32>(0.), color, brightness > extractBrightnessUniforms.uThreshold);\\n}\\n\";\n\nexport { source as default };\n//# sourceMappingURL=extract-brightness2.mjs.map\n", "import { Filter, GlProgram, GpuProgram } from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport fragment from './extract-brightness.frag';\nimport source from './extract-brightness.wgsl';\n\nexport interface ExtractBrightnessFilterOptions\n{\n    /**\n     * Defines how bright a color needs to be extracted.\n     */\n    threshold?: number;\n}\n\n/**\n * Internal filter for retrieving the brightness of the source image.\n * @class\n * @private\n */\nexport class ExtractBrightnessFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: ExtractBrightnessFilterOptions = {\n        threshold: 0.5\n    };\n\n    public uniforms: {\n        uThreshold: number;\n    };\n\n    constructor(options?: ExtractBrightnessFilterOptions)\n    {\n        options = { ...ExtractBrightnessFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'extract-brightness-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                extractBrightnessUniforms: {\n                    uThreshold: { value: options.threshold, type: 'f32' },\n                }\n            },\n        });\n\n        this.uniforms = this.resources.extractBrightnessUniforms.uniforms;\n    }\n\n    /**\n     * Defines how bright a color needs to be extracted.\n     * @default 0.5\n     */\n    get threshold(): number { return this.uniforms.uThreshold; }\n    set threshold(value: number) { this.uniforms.uThreshold = value; }\n}\n", "import {\n    Filter,\n    FilterSystem,\n    GlProgram,\n    GpuProgram,\n    PointData,\n    RenderSurface,\n    Texture,\n    TexturePool,\n} from 'pixi.js';\nimport { vertex, wgslVertex } from '../defaults';\nimport { KawaseBlurFilter } from '../kawase-blur/KawaseBlurFilter';\nimport fragment from './advanced-bloom.frag';\nimport source from './advanced-bloom.wgsl';\nimport { ExtractBrightnessFilter } from './ExtractBrightnessFilter';\n\n/** Options for the AdvancedBloomFilter constructor. */\nexport interface AdvancedBloomFilterOptions\n{\n    /**\n     * Defines how bright a color needs to be to affect bloom.\n     * @default 1\n     */\n    threshold?: number,\n    /**\n     * To adjust the strength of the bloom. Higher values is more intense brightness.\n     * @default 1\n     */\n    bloomScale?: number,\n    /**\n     * The brightness, lower value is more subtle brightness, higher value is blown-out.\n     * @default 1\n     */\n    brightness?: number,\n    /** The strength of the Blur properties simultaneously */\n    blur?: number,\n    /**\n     * The kernel size of the blur filter.\n     */\n    kernels?: number[],\n    /** The quality of the Blur filter. */\n    quality?: number,\n    /**\n     * The pixel size of the blur filter. Large size is blurrier. For advanced usage.\n     * @default {x:1,y:1}\n     */\n    pixelSize?: PointData | number[] | number,\n}\n\n/**\n * The AdvancedBloomFilter applies a Bloom Effect to an object. Unlike the normal BloomFilter\n * this had some advanced controls for adjusting the look of the bloom. Note: this filter\n * is slower than normal BloomFilter.<br>\n * ![original](../screenshots/original.png)![filter](../screenshots/advanced-bloom.png)\n *\n * @class\n * @extends Filter\n */\nexport class AdvancedBloomFilter extends Filter\n{\n    /** Default values for options. */\n    public static readonly DEFAULT_OPTIONS: AdvancedBloomFilterOptions = {\n        threshold: 0.5,\n        bloomScale: 1,\n        brightness: 1,\n        blur: 8,\n        quality: 4,\n        pixelSize: { x: 1, y: 1 },\n    };\n\n    public uniforms: {\n        uBloomScale: number;\n        uBrightness: number;\n    };\n\n    /** To adjust the strength of the bloom. Higher values is more intense brightness. */\n    public bloomScale = 1;\n\n    /** The brightness, lower value is more subtle brightness, higher value is blown-out. */\n    public brightness = 1;\n\n    private _extractFilter: ExtractBrightnessFilter;\n    private _blurFilter: KawaseBlurFilter;\n\n    /**\n     * @param options - Options for the AdvancedBloomFilter constructor.\n     */\n    constructor(options?: AdvancedBloomFilterOptions)\n    {\n        options = { ...AdvancedBloomFilter.DEFAULT_OPTIONS, ...options };\n\n        const gpuProgram = GpuProgram.from({\n            vertex: {\n                source: wgslVertex,\n                entryPoint: 'mainVertex',\n            },\n            fragment: {\n                source,\n                entryPoint: 'mainFragment',\n            },\n        });\n\n        const glProgram = GlProgram.from({\n            vertex,\n            fragment,\n            name: 'advanced-bloom-filter',\n        });\n\n        super({\n            gpuProgram,\n            glProgram,\n            resources: {\n                advancedBloomUniforms: {\n                    uBloomScale: { value: options.bloomScale, type: 'f32' },\n                    uBrightness: { value: options.brightness, type: 'f32' },\n                },\n                uMapTexture: Texture.WHITE,\n            },\n        });\n\n        this.uniforms = this.resources.advancedBloomUniforms.uniforms;\n\n        this._extractFilter = new ExtractBrightnessFilter({\n            threshold: options.threshold\n        });\n\n        this._blurFilter = new KawaseBlurFilter({\n            strength: options.kernels as [number, number] ?? options.blur,\n            quality: options.kernels ? undefined : options.quality,\n        });\n\n        Object.assign(this, options);\n    }\n\n    /**\n     * Override existing apply method in `Filter`\n     * @override\n     * @ignore\n     */\n    public override apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        const brightTarget = TexturePool.getSameSizeTexture(input);\n\n        this._extractFilter.apply(filterManager, input, brightTarget, true);\n\n        const bloomTarget = TexturePool.getSameSizeTexture(input);\n\n        this._blurFilter.apply(filterManager, brightTarget, bloomTarget, true);\n\n        this.uniforms.uBloomScale = this.bloomScale;\n        this.uniforms.uBrightness = this.brightness;\n\n        this.resources.uMapTexture = bloomTarget.source;\n\n        filterManager.applyFilter(this, input, output, clearMode);\n\n        TexturePool.returnTexture(bloomTarget);\n        TexturePool.returnTexture(brightTarget);\n    }\n\n    /**\n     * Defines how bright a color needs to be extracted.\n     * @default 0.5\n     */\n    get threshold(): number { return this._extractFilter.threshold; }\n    set threshold(value: number) { this._extractFilter.threshold = value; }\n\n    /** The kernels of the Blur Filter */\n    get kernels(): number[] { return this._blurFilter.kernels; }\n    set kernels(value: number[]) { this._blurFilter.kernels = value; }\n\n    /**\n     * The strength of the Blur properties simultaneously\n     * @default 2\n     */\n    get blur(): number { return this._blurFilter.strength; }\n    set blur(value: number) { this._blurFilter.strength = value; }\n\n    /**\n     * The quality of the Blur Filter\n     * @default 4\n     */\n    get quality(): number { return this._blurFilter.quality; }\n    set quality(value: number) { this._blurFilter.quality = value; }\n\n    /**\n     * The pixel size of the Kawase Blur filter\n     * @default {x:1,y:1}\n     */\n    get pixelSize(): PointData { return this._blurFilter.pixelSize; }\n    set pixelSize(value: PointData | number[] | number)\n    {\n        if (typeof value === 'number')\n        {\n            value = { x: value, y: value };\n        }\n\n        if (Array.isArray(value))\n        {\n            value = { x: value[0], y: value[1] };\n        }\n\n        this._blurFilter.pixelSize = value;\n    }\n\n    /**\n     * The horizontal pixelSize of the Kawase Blur filter\n     * @default 1\n     */\n    get pixelSizeX(): number { return this._blurFilter.pixelSizeX; }\n    set pixelSizeX(value: number) { this._blurFilter.pixelSizeX = value; }\n\n    /**\n     * The vertical pixel size of the Kawase Blur filter\n     * @default 1\n     */\n    get pixelSizeY(): number { return this._blurFilter.pixelSizeY; }\n    set pixelSizeY(value: number) { this._blurFilter.pixelSizeY = value; }\n}\n"],
  "mappings": "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",
  "names": ["browserExt", "ExtensionType", "webworkerExt", "ExtensionType", "_isWebGLSupported", "isWebGLSupported", "failIfMajorPerformanceCaveat", "contextOptions", "AbstractRenderer", "DOMAdapter", "gl", "success", "loseContext", "_isWebGPUSupported", "isWebGPUSupported", "options", "gpu", "DOMAdapter", "renderPriority", "autoDetectRenderer", "options", "preferredOrder", "item", "RendererClass", "finalOptions", "rendererType", "isWebGPUSupported", "WebGPURenderer", "isWebGLSupported", "AbstractRenderer", "WebGLRenderer", "renderer", "_Application", "args", "Container", "deprecation", "v8_0_0", "options", "autoDetectRenderer", "plugin", "rendererDestroyOptions", "plugins", "Application", "extensions", "ExtensionType", "ApplicationInitHook", "extensions", "browserExt", "webworkerExt", "vertex", "wgslVertex", "fragment", "source", "fragmentClamp", "sourceClamp", "_KawaseBlurFilter", "Filter", "args", "options", "deprecation", "gpuProgram", "GpuProgram", "wgslVertex", "sourceClamp", "source", "glProgram", "GlProgram", "vertex", "fragmentClamp", "fragment", "__publicField", "filterManager", "input", "output", "clearMode", "uvX", "uvY", "offset", "renderTarget", "TexturePool", "target", "tmp", "last", "i", "value", "acc", "v", "blur", "quality", "kernels", "k", "step", "KawaseBlurFilter", "fragment", "source", "fragment", "source", "_ExtractBrightnessFilter", "Filter", "options", "gpuProgram", "GpuProgram", "wgslVertex", "source", "glProgram", "GlProgram", "vertex", "fragment", "__publicField", "value", "ExtractBrightnessFilter", "_AdvancedBloomFilter", "Filter", "options", "gpuProgram", "GpuProgram", "wgslVertex", "source", "glProgram", "GlProgram", "vertex", "fragment", "Texture", "__publicField", "ExtractBrightnessFilter", "KawaseBlurFilter", "filterManager", "input", "output", "clearMode", "brightTarget", "TexturePool", "bloomTarget", "value", "AdvancedBloomFilter"]
}
