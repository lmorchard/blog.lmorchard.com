<?xml version="1.0" encoding="UTF-8"?>
  <rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
      <title>Tag: xml - blog.lmorchard.com</title>
      <description>It&#39;s all spinning wheels &amp; self-doubt until the first pot of coffee.</description>
      <link>https://lmorchard.github.io/blog.lmorchard.com/tag/xml/</link>
      <atom:link href="https://lmorchard.github.io/blog.lmorchard.com/index.rss" rel="self" type="application/rss+xml" />
      <item>
          <title>OPML reading lists in FeedMagick2</title>
          
          
          <pubDate>Wed, 17 Oct 2007 07:22:47 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2007/10/17/opml-reading-lists-in-feedmagick2/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2007/10/17/opml-reading-lists-in-feedmagick2/</guid>
        </item><item>
          <title>Say hello to FeedMagick2</title>
          
          
          <pubDate>Mon, 30 Apr 2007 03:06:32 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2007/04/29/say-hello-to-feedmagick2/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2007/04/29/say-hello-to-feedmagick2/</guid>
        </item><item>
          <title>content sniffing sucks</title>
          
          
          <pubDate>Fri, 24 Nov 2006 06:28:11 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2006/11/24/content-sniffing-sucks/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2006/11/24/content-sniffing-sucks/</guid>
        </item><item>
          <title>XoxoOutliner and further outline addressing adventures</title>
          
          
          <pubDate>Wed, 15 Nov 2006 08:07:12 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2006/11/15/xoxooutliner-and-further-outline-addressing-adventures/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2006/11/15/xoxooutliner-and-further-outline-addressing-adventures/</guid>
        </item><item>
          <title>XoxoOutliner and suboutline addressing</title>
          
          
          <pubDate>Mon, 13 Nov 2006 09:34:02 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2006/11/13/xoxooutliner-and-suboutline-addressing/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2006/11/13/xoxooutliner-and-suboutline-addressing/</guid>
        </item><item>
          <title>Sometimes the lazyweb delivers with a deluge</title>
          
          
          <pubDate>Mon, 19 Dec 2005 23:15:03 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2005/12/19/sometimes-the-lazyweb-delivers-with-a-deluge/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2005/12/19/sometimes-the-lazyweb-delivers-with-a-deluge/</guid>
        </item><item>
          <title>Okay, okay, JSON is pretty hot</title>
          
          
          <pubDate>Mon, 19 Dec 2005 04:17:55 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2005/12/18/okay-okay-json-is-pretty-hot/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2005/12/18/okay-okay-json-is-pretty-hot/</guid>
        </item><item>
          <title>Templates:  Good or Evil?</title>
          
          
          <pubDate>Mon, 26 Sep 2005 01:12:46 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2005/09/25/templates-good-or-evil/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2005/09/25/templates-good-or-evil/</guid>
        </item><item>
          <title>Hacking RSS and Atom is out!</title>
          
          
          <pubDate>Tue, 13 Sep 2005 23:45:47 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2005/09/13/hacking-rss-and-atom-is-out/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2005/09/13/hacking-rss-and-atom-is-out/</guid>
        </item><item>
          <title>Building an Address Book as a Modern Web App</title>
          <description
                >&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;So, in the spirit of pico-projects, I&#39;ve started building that address book application I mentioned awhile ago and I want to start writing about it as I go.
First off, hopefully you&#39;ll notice the quick diagram I threw together in OmniGraffle.  This is a sort of rough sketch of the loosely-joined architecture I want to explore with this thing.  

Data: This is where address book entries live.
Model: A set of objects encapsulating the data, this is how address book entries will be accessed.
REST API: Model objects exposed as resources identified by URI, serialized and deserialized as XML, and manipulated by GET / PUT / POST / DELETE methods.
XSLT Filter: XML data produced by REST API calls can be first passed through XSL at a given URL before being served up as a response.  
HTML, CSS, JavaScript: Thanks to the XSLT filter layer, the XML vocabulary used to describe address book entries can be transformed into user interface presentation.
HTTP: Everything happens via HTTP...
Web Browser Client: ...and everything is viewed in a web browser.

Now, I call this a loosely-joined architecture because I want to stress that you should be able to swap out just about any part of this whenever you want.  
Want the Data to be in MySQL?  Fine.  Want it to be in flat files?  Fine.  Just make sure the Model can cope while maintaining a consistent interface for the REST API.  Want to change the user interface in the browser?  Great-- ideally, all you have to do is change some XSLT files.  I&#39;m writing everything from the XSLT Filter down to the Model in Python.  Don&#39;t like that?  Fine.  Rewrite it all in Perl, and hopefully everything from the XSLT up to the browser will still be useful to you.
At some point, you might even want to ditch the browser for a native desktop client.  Fabulous! Just ignore everything past the REST API and HTTP, don&#39;t use any XSLT in the Filter, and use the API and XML directly.
I don&#39;t think any of this is particularly revolutionary-- although I thought it was when I first saw Amazon Web Services doing some of this, and I hope to throw a little GMail in as well.  I hope that this will all be useful as I muddle through explaining what I&#39;m doing.  In the meantime, you can see me getting the stage set as I start checking things into my Subversion repository over here:

http://www.decafbad.com/svn/trunk/hacks/abook/&lt;/body&gt;&lt;/html&gt;</description
              >
          
          <pubDate>Thu, 23 Dec 2004 05:58:41 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2004/12/23/abook1/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2004/12/23/abook1/</guid>
        </item><item>
          <title>Cross-breeding XSLT and ZPT</title>
          <description
                >&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;I&#39;ve recently been doing some side work involving Zope and, along with the rest of the suite of technologies it offers, I&#39;ve been happy to be working with Zope Page Templates again.  I dabbled with them a bit when they first came out, and a Zope-free implementation named SimpleTAL was one of the core components of the iteration of my news aggregator which came before FeedReactor.
Out of all the templating and content generation approaches I&#39;ve used, Zope Page Templates are my favorite yet.  Pretty expressive, yet unobtrusive; nicely powerful, yet not quite something with which you&#39;d want to write an entire application (and that&#39;s a feature, not a bug).  
I&#39;ve yet to be in a work-a-day team that uses ZPT-- but I can see where a lot of production, delegation, and integration issues would have gone much smoother had I used ZPT instead of Template Toolkit for the web app framework I created at a previous company.  (Though I do have to say TT2 is very nicely done!)  And where I am now, I spend most of my days trying to pummel ASP 3.0 pages into some semblance of logic/presentation separation-- I would certainly dive at the chance to dump VBScript and &amp;lt;% cruft %&amp;gt; for a bit of Python and ZPT.  (But, you know, it&#39;s a living.)
A close second favorite is XSLT.  I&#39;ve really been hot on it lately, having worked it into the core of FeedReactor in place of SimpleTAL.  And in other hacks, I&#39;ve really come to appreciate it&#39;s role as a filter segment in pipelines between REST web services and URL-as-command-line invocations.
Granted, both ZPT and XSLT very different technologies, but they are often used in similar contexts.  More than once, I&#39;ve wished that XSLT was as simple as ZPT (i.e. less verbose and intrusive, more document centered), and I&#39;ve wished that ZPT had some of the features of XSLT (i.e. ability to be used as a transforming filter).
Reading Ryan Tomayko&#39;s description of Kid got me thinking, and googling.  One thing I turned up from a mailing list archive asked about an “XSL implementation of TAL?”  It struck me as a tad nutty at first, but then I started having inklings that just maybe it could be done.  (Whether it should be done, well...)  But the kernel of the idea grabbed me: Instead of using TALES path expressions to look up values in Pythonic space, why not use XPath expressions to look up values from a supplied XML document?
This strikes me as such an obvious idea that someone has to already have done it and possibly rejected it for good reason.  On the other hand, maybe this is the sort of thing Ryan&#39;s thinking about-- I wonder how hard it would be to hack this into Kid?  It would give only a subset of XSLT&#39;s capabilities in trade for simplicity, and would only offer the “pull” approach, but it would give XML-pipelining to a ZPT-ish technology.
I think this is something I want to look into a bit further at some point.&lt;/body&gt;&lt;/html&gt;</description
              >
          
          <pubDate>Fri, 03 Dec 2004 01:15:52 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2004/12/02/crossbreedingxsltzpt/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2004/12/02/crossbreedingxsltzpt/</guid>
        </item><item>
          <title>Next generation web apps using REST, XML, XSLT, and XmlHTTPRequest</title>
          <description
                >&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;So, like I was saying:  I&#39;ve been working on FeedReactor and have been doing some things with it that I find rather interesting, independent of news aggregation.  
One of the core goals I have for FeedReactor is to explore what it takes to build a web app that exploits principles of REST architecture.  Having already sung the praises of XML-RPC, I wanted to get immersed in REST and see what all the hubbub was about.  I&#39;ve got some ways to go, but I think I understand the major concepts now, and it&#39;s a pretty nifty frame within which to work.
But, two other things I&#39;ve added to my mix have really made things interesting for me:  

XSLT filtering
The XmlHTTPRequest object

XSLT and REST make a really good pair, as Amazon Web Services already demonstrate.  Inspired by that API (and earlier experiments), I use XML for all the input and output formats in my API and accept a query string parameter that contains the path to an XSLT file.  When this parameter is supplied, the XML output by the API is first processed using the given XSLT.  (Think of it like piping API output through xsltproc.)
So, with a properly constructed collection of XSLT, I can present a browser-viewable HTML user interface served up directly from REST API calls.  Links, frame sets, and iframes present in the HTML lead the user from that call to the next XSLT-wrapped REST API call. 
But, once the initial HTML-and-JavaScript payload reaches the browser, it gets better (ala Gmail):  
On older browsers (if I happen to care about them), I can make new HTTP requests back to the server from JavaScript using iframes.  In this case, XSLT filtering lets me retrofit the API&#39;s responses to the HTML-and-JavaScript crud I need to serve up to make things happen back in the browser client.  Unfortunately, passing data to the API (which expects XML, not form submissions) is still a bit wonky and requires some hacks and exceptions involving hidden forms and such.
However, on the newer browsers, it&#39;s all about the XmlHTTPRequest object.  With this facility, I can make clean asynchronous requests back to the REST API, including XML data in the request body if I feel like it.  Responses are handled by JavaScript callbacks, which twiddle the browser DOM to update the user interface in response.  
So, after the major initial contact with the API to supply the browser with HTML by way of XSLT, most future interactions take place in the form of direct calls to the REST API using XML.  Although for some things, it&#39;s easier to just reload a page of HTML, it&#39;s nicer for most interactions to be handled via DOM manipulations in-place.  I&#39;ve been amazed at the Gmail-like responsiveness I get from FeedReactor when I&#39;m skimming through news items, marking some as seen or flagged, and popping open the descriptions on others.  
I suppose I shouldn&#39;t be amazed at the responsiveness, since I&#39;m using some of the same techniques as Gmail.  However, my daily-use installation of FeedReactor is presently running on an old 300Mhz Debian Linux PC at home, and it&#39;s taking me through the daily produce of 600 subscribed feeds faster than any desktop aggregator has yet.  Of course, this is partly a product of my familiarity with the UI I&#39;ve cobbled together, but... the server&#39;s running on a 300Mhz PC with 256MB of RAM!  And the client is my 867Mhz G4 PowerBook, running Firefox or Safari, depending on my mood.
Although I can&#39;t see when I&#39;ll have time for it, I really want to explore this approach further using desktop apps on OS X and accessing the API from Flash movies (maybe using Laszlo).  I&#39;d also like to see how far I can go toward adapting the interface toward mobile devices like my Treo 600.
So anyway, this has been where most of my private hacking sessions have been taking me over the past year or so:  combining HTML, CSS, DOM, JavaScript, XML, XSLT, and REST to build what I consider to be a next-generation web app.  
Now, although I use FeedReactor on a daily basis to keep up with all my feeds, it&#39;s nowhere near any state suitable for public consumption.  I add new subscriptions from a command-line script and still fiddle with the database directly for some operations.  I&#39;d like to have a personal-server version of it ready for use by some alpha geeks before or not long into the new year, but I&#39;d like to share some of the things I&#39;ve been doing with it before then.
With that in mind, I think I&#39;ll wrap up this entry and think about putting together a quick tutorial pico-project to demonstrate some of the concepts.  Maybe an address book, or something equally simple-yet-useful.  
Stay tuned.&lt;/body&gt;&lt;/html&gt;</description
              >
          
          <pubDate>Tue, 30 Nov 2004 21:53:35 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2004/11/30/nextgenwebapps/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2004/11/30/nextgenwebapps/</guid>
        </item><item>
          <title>Using iTunes as a podcast aggregator, with a little help from XSLT</title>
          <description
                >&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;So I had an idea for a quick podcasting listening hack on the way into work this morning. Check it out:

Take one list of RSS feeds in OPML.
Throw in a bit of XSLT.
Combine using xsltproc to make a playlist that works in iTunes.

And, oh yeah, I just happen to have an xsltproc web service laying around, so:

Supply a URL to your OPML in this form.
Get a freshly-built playlist.

Now, this has been barely tested and is the product of a ten-minute hacking session.  There are likely an enormous number of things wrong with this.  That said, iTunes does seem to open the playlist happily, and it looks like only new streams are added with repeated openings of the playlist.
You will want to be careful to ensure that your OPML is valid XML (mine wasn&#39;t, on initial export from iPodderX - escape those freaking ampersands in URLs already!), and I have no idea what would happen if any of the RSS feeds in your subscriptions turn up invalid.  
Have I mentioned that, despite their unforgiving and sometimes fragile nature, I love XML technologies?
If this looks useful, maybe I&#39;ll work it over a bit more and pair it up with some python to handle actually downloading the MP3s and torrents.
Update: Oh yeah, and I&#39;m expecting this will be useful with an iTunes smart playlist crafted along these lines:

Date Added in the last 1 days
Play Count is less than 1

Update #2: Another use I just found for this playlist, is on my Xbox Media Center.  I generate this playlist via cronjob every few hours, and store it on an SMB share accessible to the XBMC.  Voila!  Listening to podcasts on my stereo system via the Xbox.  Yeah, nothing big, just kind of nifty.&lt;/body&gt;&lt;/html&gt;</description
              >
          
          <pubDate>Fri, 08 Oct 2004 17:07:49 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2004/10/08/itunesxslt/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2004/10/08/itunesxslt/</guid>
        </item><item>
          <title>dbagg3: Please excuse the mess</title>
          <description
                >&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Wow.  So it looks like there are some people starting to follow to what I&#39;m doing with dbagg3, and they&#39;re showing me how woefully prepared I am for the attention from tinkerers who are actually trying to, you know, run my code.  Things have been crazy busy for me at work, so I haven&#39;t been getting done what I&#39;ve planned.  But, I do need to pull a few things together and clean a few things up.  I&#39;ll soon be answering the smattering of email I&#39;ve gotten so far, but until then, a few quick thoughts:

My source control is a bit of a mess at the moment.  Not only have I switched from CVS to SVN-- but even if you followed me in that migration, I&#39;ve not kept committed code in working order.  I already know that this is a horrible habit, but since no one&#39;s really been looking, I haven&#39;t been called on it until now.  (Heh, heh--d&#39;oh.)  Planning this weekend (but hopefully today) to resolve this, so that moving forward, svn trunk will be (as far as possible) in a working state at any given moment.

I&#39;ve hacked one of my dependencies, SQLObject, by applying a patch to support SELECT DISTINCT queries.  This has understandably caused problems for some people who have no idea what I did.  This patch has turned out to be essential, though I don&#39;t know if/when it will or would be included in a release of SQLObject.  So...  I wonder if I should dump my working copy of SQLObject into source control?  Otherwise, applying the DISTINCT patch to your SQLObject install should work.

At some point very soon, I want to change the name of this thing to feedReactor.  Yes, I know there&#39;s already a feedparser, and a feeddemon, and a feedburner, and someone&#39;s probably got a feedkitchensink in the works, but I like this name and want to run with it.


So, in the meantime while I straighten some things out, please excuse the mess and thanks for bearing with me!&lt;/body&gt;&lt;/html&gt;</description
              >
          
          <pubDate>Fri, 17 Sep 2004 13:32:30 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2004/09/17/dbagg3mess/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2004/09/17/dbagg3mess/</guid>
        </item><item>
          <title>Moving time: From CVS to Subversion</title>
          
          
          <pubDate>Thu, 16 Sep 2004 15:29:04 GMT</pubDate>
          <link>https://lmorchard.github.io/blog.lmorchard.com/2004/09/16/moving-time-from-cvs-to-subversion/</link>
          <guid isPermaLink="true">https://lmorchard.github.io/blog.lmorchard.com/2004/09/16/moving-time-from-cvs-to-subversion/</guid>
        </item>
    </channel>
  </rss>