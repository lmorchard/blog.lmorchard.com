[
  {
    "title": "Adding Android to a multi-platform React app",
    "tags": [
      "webdev",
      "native",
      "react",
      "reactnative",
      "android",
      "ios",
      "mobile",
      "mozilla"
    ],
    "year": "2015",
    "month": "09",
    "day": "21",
    "isDir": false,
    "slug": "react-native-android",
    "date": "2015-09-21T12:00:00.000Z",
    "postName": "2015-09-21-react-native-android",
    "html": "<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\n<p>TL;DR: A couple of months back, <a href=\"http://blog.lmorchard.com/2015/07/22/react-multiplatform/\">I wrote about a TODO app built using React\nfor web and React Native for iOS</a>. </p>\n<p>Last week, the team at Facebook \n<a href=\"https://code.facebook.com/posts/1189117404435352/\">released React Native for Android</a>. So, I circled back to add\nAndroid support and revisit how code sharing looks now.</p>\n<h2 id=\"getting-up-to-speed\">Getting up to speed</h2>\n<p>With this <a href=\"https://code.facebook.com/posts/1189117404435352/\">new release of React Native</a>, I was able to add support\nfor Android to <a href=\"https://github.com/lmorchard/react-multiplatform\">my little TODO app</a>.</p>\n<p>The first task was to <a href=\"https://github.com/lmorchard/react-multiplatform/commit/38fb7afe67f8c339b8d51c69a1f515a5a91e97c7\">shuffle directories &amp; files around and add the base\nAndroid support</a>. In general, the project layout is now cleaner.\nAssets for each platform now live in separate sub-directories.</p>\n<p>Next, to start iterating &amp; experimenting, I copied the code from the iOS app\ninto Android-specific directories. I <a href=\"https://github.com/lmorchard/react-multiplatform/commit/fd80e9859400744ac5fcffc8f7d75d6703a3856d\">only needed to make some small\ntweaks</a> to account for differences in native component sets. That got my\nbase app functionality working.</p>\n<p>Then, <a href=\"https://github.com/lmorchard/react-multiplatform/commit/dd8b6b307c31b67fde23c6b090e7b1f1d8b0f579\">I squashed the iOS &amp; Android models together</a> when I realized that\ncode was identical between the React Native platforms. That could change in\nthe future, but there&#39;s no need for a difference right now.</p>\n<p>After sleeping on it, <a href=\"https://github.com/lmorchard/react-multiplatform/commit/ea7abb421b7e0486b2d3de42001724343f832901\">I refactored some common mixins</a> to take advantage of\nadditional sharing opportunities I found between iOS &amp; Android views. That\nhelped to further shrink the lines of duplicated code.</p>\n<p>This added what amounts to a new category of code sharing in my project. So,\n<a href=\"https://github.com/lmorchard/react-multiplatform/commit/cdbbff72cb941fac75f68c1c91279fa780997b26\">I separated that code into its own module</a> to make the distinction easier\nto see &amp; measure.  Now, I have code shared between web and native in general,\nand code shared between the iOS and Android native platforms.</p>\n<p>Finally, in an attempt to start automating my code metrics, <a href=\"https://github.com/lmorchard/react-multiplatform/commit/d5149768e116571d0a1a059d1ff16e1cfc45fcfd\">I added\n<code>loc-metrics.sh</code></a>.</p>\n<h2 id=\"visualizing-the-code-metrics\">Visualizing the code metrics</h2>\n<p>So, I tried drawing some Venn diagrams in my notebook. But, I&#39;m terrible at\ndrawing. That&#39;s when I remembered that SVG is a thing where I can draw by\nwriting code. So, <a href=\"https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial\">I spent an afternoon teaching myself some SVG</a>\nand <a href=\"https://github.com/lmorchard/react-multiplatform/commit/0014232c9858e082414e094be021170fda19aab0\">reworked my metrics shell script</a>.</p>\n<p>I&#39;m not going to bother trying to make the areas actually proportional to the\nlines of code. But, here&#39;s a rough picture of code sharing:</p>\n<img style=\"width: 240px\" src=\"/uploads/2015/react-native-android/shared-overall.svg\">\n<img style=\"width: 240px\" src=\"/uploads/2015/react-native-android/shared-models.svg\">\n<img style=\"width: 240px\" src=\"/uploads/2015/react-native-android/shared-views.svg\">\n\n<p>If you can&#39;t see those images, then you&#39;ll need to find a browser that understands\nSVG until I can be bothered to convert to PNG. (Pull requests welcome!)</p>\n<h2 id=\"conclusions-revisited\">Conclusions revisited</h2>\n<p>As before, most of the models code is shared between web and both native\nplatforms. What&#39;s unique is mostly boilerplate wrapping <a href=\"http://blog.lmorchard.com/2015/07/22/react-multiplatform/#forking-sharing-model-code-for-persistence\">the localStorage /\nasyncStorage split between web and native</a>.</p>\n<p>On the view side, however, things are a bit more spread out. In a nutshell,\nReact patterns in general allow a decent chunk of code to be shared between\nweb and native. And even more code can be shared between the iOS and Android\nplatforms.</p>\n<p>But, unique concerns in each platform - web, iOS, and Android - call for\nunique code for each case. This is not actually a failing, though: Varying the\nUX between web &amp; iOS &amp; Android is a flexibility you&#39;ll probably appreciate. </p>\n<p>In other words, use components &amp; conventions unique to each\nplatform without your app suffering from the lowest-common-denominator UX\nproblem historically found in a lot of multi-platform apps. In the case of this\nTODO app, that just boils down to trivialities like checkboxes &amp; switches &amp;\nsegmented controls. In a larger app, I&#39;d expect this concern to grow.</p>\n<p>I&#39;m being lazy and not coding up the math in percentages. This approach shared\nabout half the code from the web app, and even more than that for each of the\nnative apps. I think that&#39;s a significant advantage over writing separate\napps.</p>\n<p>Of course, <a href=\"http://blog.lmorchard.com/2015/07/22/react-multiplatform/#conclusion\">all my caveats from the first go\naround</a> still apply: This is a very simple app. The code devoted to\ndoing interesting things versus React boilerplate is probably not at a good\nratio. Also, as more view components arise, further overlap might be found.\nAnd, hopefully, common logic would remain the primary area of growth on the\nmodel site.</p>\n<p>I think this approach toward building apps remains interesting &amp; promising. </p>\n<!-- vim: set wrap wm=5 syntax=markdown textwidth=78: -->\n",
    "body": "<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\nTL;DR: A couple of months back, [I wrote about a TODO app built using React\nfor web and React Native for iOS][rnpart1]. \n\nLast week, the team at Facebook \n[released React Native for Android][rnandroid]. So, I circled back to add\nAndroid support and revisit how code sharing looks now.\n\n[rnandroid]: https://code.facebook.com/posts/1189117404435352/\n[rnpart1]: http://blog.lmorchard.com/2015/07/22/react-multiplatform/\n[reactmultiplatform]: https://github.com/lmorchard/react-multiplatform\n\n## Getting up to speed\n\nWith this [new release of React Native][rnandroid], I was able to add support\nfor Android to [my little TODO app][reactmultiplatform].\n  \nThe first task was to [shuffle directories & files around and add the base\nAndroid support][c1]. In general, the project layout is now cleaner.\nAssets for each platform now live in separate sub-directories.\n\n[c1]: https://github.com/lmorchard/react-multiplatform/commit/38fb7afe67f8c339b8d51c69a1f515a5a91e97c7\n\nNext, to start iterating & experimenting, I copied the code from the iOS app\ninto Android-specific directories. I [only needed to make some small\ntweaks][c2] to account for differences in native component sets. That got my\nbase app functionality working.\n\n[c2]: https://github.com/lmorchard/react-multiplatform/commit/fd80e9859400744ac5fcffc8f7d75d6703a3856d\n\nThen, [I squashed the iOS & Android models together][c3] when I realized that\ncode was identical between the React Native platforms. That could change in\nthe future, but there's no need for a difference right now.\n\n[c3]: https://github.com/lmorchard/react-multiplatform/commit/dd8b6b307c31b67fde23c6b090e7b1f1d8b0f579\n\nAfter sleeping on it, [I refactored some common mixins][c4] to take advantage of\nadditional sharing opportunities I found between iOS & Android views. That\nhelped to further shrink the lines of duplicated code.\n\n[c4]: https://github.com/lmorchard/react-multiplatform/commit/ea7abb421b7e0486b2d3de42001724343f832901\n\nThis added what amounts to a new category of code sharing in my project. So,\n[I separated that code into its own module][c5] to make the distinction easier\nto see & measure.  Now, I have code shared between web and native in general,\nand code shared between the iOS and Android native platforms.\n\n[c5]: https://github.com/lmorchard/react-multiplatform/commit/cdbbff72cb941fac75f68c1c91279fa780997b26\n\nFinally, in an attempt to start automating my code metrics, [I added\n`loc-metrics.sh`][c6].\n\n[c6]: https://github.com/lmorchard/react-multiplatform/commit/d5149768e116571d0a1a059d1ff16e1cfc45fcfd\n\n## Visualizing the code metrics\n\nSo, I tried drawing some Venn diagrams in my notebook. But, I'm terrible at\ndrawing. That's when I remembered that SVG is a thing where I can draw by\nwriting code. So, [I spent an afternoon teaching myself some SVG][svgtutorial]\nand [reworked my metrics shell script][c7].\n\n[c7]: https://github.com/lmorchard/react-multiplatform/commit/0014232c9858e082414e094be021170fda19aab0\n[svgtutorial]: https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial\n\nI'm not going to bother trying to make the areas actually proportional to the\nlines of code. But, here's a rough picture of code sharing:\n\n<img style=\"width: 240px\" src=\"/uploads/2015/react-native-android/shared-overall.svg\">\n<img style=\"width: 240px\" src=\"/uploads/2015/react-native-android/shared-models.svg\">\n<img style=\"width: 240px\" src=\"/uploads/2015/react-native-android/shared-views.svg\">\n\nIf you can't see those images, then you'll need to find a browser that understands\nSVG until I can be bothered to convert to PNG. (Pull requests welcome!)\n\n## Conclusions revisited\n\nAs before, most of the models code is shared between web and both native\nplatforms. What's unique is mostly boilerplate wrapping [the localStorage /\nasyncStorage split between web and native][storagesplit].\n\n[storagesplit]: http://blog.lmorchard.com/2015/07/22/react-multiplatform/#forking-sharing-model-code-for-persistence\n\nOn the view side, however, things are a bit more spread out. In a nutshell,\nReact patterns in general allow a decent chunk of code to be shared between\nweb and native. And even more code can be shared between the iOS and Android\nplatforms.\n\nBut, unique concerns in each platform - web, iOS, and Android - call for\nunique code for each case. This is not actually a failing, though: Varying the\nUX between web & iOS & Android is a flexibility you'll probably appreciate. \n\nIn other words, use components & conventions unique to each\nplatform without your app suffering from the lowest-common-denominator UX\nproblem historically found in a lot of multi-platform apps. In the case of this\nTODO app, that just boils down to trivialities like checkboxes & switches &\nsegmented controls. In a larger app, I'd expect this concern to grow.\n\nI'm being lazy and not coding up the math in percentages. This approach shared\nabout half the code from the web app, and even more than that for each of the\nnative apps. I think that's a significant advantage over writing separate\napps.\n\nOf course, [all my caveats from the first go\naround][caveats] still apply: This is a very simple app. The code devoted to\ndoing interesting things versus React boilerplate is probably not at a good\nratio. Also, as more view components arise, further overlap might be found.\nAnd, hopefully, common logic would remain the primary area of growth on the\nmodel site.\n\n[caveats]: http://blog.lmorchard.com/2015/07/22/react-multiplatform/#conclusion\n\nI think this approach toward building apps remains interesting & promising. \n\n<!-- vim: set wrap wm=5 syntax=markdown textwidth=78: -->\n",
    "parentPath": "../blog.lmorchard.com/posts/archives/2015",
    "path": "2015/09/21/react-native-android",
    "thumbnail": "https://lmorchard.github.io/uploads/2015/react-native-android/shared-overall.svg"
  },
  {
    "title": "Experimenting with a multi-platform app using React",
    "tags": [
      "webdev",
      "native",
      "react",
      "reactnative",
      "ios",
      "mobile",
      "mozilla"
    ],
    "year": "2015",
    "month": "07",
    "day": "22",
    "isDir": false,
    "slug": "react-multiplatform",
    "date": "2015-07-22T12:00:00.000Z",
    "postName": "2015-07-22-react-multiplatform",
    "html": "<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\n<p>TL;DR: I built <a href=\"https://github.com/lmorchard/react-multiplatform/\">a toy app using React for web and native</a> to get a feel for whether this hybrid approach is worth using. I think the answer is &quot;yes&quot; - but mainly for apps whose business logic &amp; data models are more complex than their views.</p>\n<!--more-->\n\n<h2 id=\"write-slightly-more-than-once-run-manywhere\">Write slightly more than once, run manywhere</h2>\n<p>At Mozilla, one of the things we try to champion is the efficiency of writing one web app versus building many separate native apps. In practice, your mileage varies based on goals, priorities, platform capabilities, and a dozen other factors.</p>\n<p><a href=\"https://facebook.github.io/react/\">React</a> and <a href=\"https://facebook.github.io/react-native/\">React Native</a> seem to offer a middle ground: Given the shared conventions and patterns and language, it should be possible to share a lot of code between platforms while still taking advantage of native capabilities.</p>\n<p>So, I figured I&#39;d give it a shot and try measuring the common lines of code as a rough success metric.</p>\n<h2 id=\"great-another-todo-app\">Great, another Todo app</h2>\n<p>I decided to build a Todo app, with lots of inspiration and a little code borrowed from <a href=\"http://todomvc.com/\">TodoMVC</a>.</p>\n<p>A basic Todo app demands just enough user interface and data management to get an initial feel for most app frameworks. Commit to something bigger and you may end up wasting your time. Build something smaller and you won&#39;t have explored deep enough into the framework&#39;s solution space.</p>\n<p>I think I&#39;ve erred on the shallow side, but that just gives me room to improve.</p>\n<h2 id=\"what-about-flux-vs-mvc\">What about Flux vs MVC?</h2>\n<p>It&#39;s said that React provides just the V in MVC (Model-View-Controller). But, there&#39;s also <a href=\"https://facebook.github.io/flux/docs/overview.html\">this Flux notion</a>. It&#39;s billed as an alternative to MVC, and React is intended to be a part of it. That said, I haven&#39;t quite yet wrapped my head around Flux. Luckily, React is focused and useful in isolation. So, I can defer buying into the rest of the conceptual package as I learn.</p>\n<p>In fact, I didn&#39;t even really end up building a proper MVC app. The Controller role got distributed between Views &amp; Models: UI event handlers in Views modify Models directly. Views subscribe to change events from Models to update their own state.</p>\n<p>I expect that when I grok Flux better, it&#39;s this reciprocal Model/View relationship that will get broken up &amp; mediated by a Dispatcher. But, in the spirit of iterative hacking, I forged ahead with my terrible code &amp; design.</p>\n<h2 id=\"building-shared-models\">Building shared Models</h2>\n<p>For the Model layer, I took a look at <a href=\"http://ampersandjs.com/\">Ampersand.js</a>. Based originally on <a href=\"http://backbonejs.org/\">Backbone.js</a> - a library of which I&#39;m a big fan - <a href=\"http://ampersandjs.com/\">Ampersand.js</a> breaks things up into a collection of small modules that work well together. But, like <a href=\"https://facebook.github.io/react/\">React</a>, most of the modules are handy in isolation or alongside substitutions from outside of the <a href=\"http://ampersandjs.com/\">Ampersand.js</a> family.</p>\n<p>For managing a single todo item, I liked the looks of <a href=\"https://github.com/AmpersandJS/ampersand-state\">ampersand-state</a>. With it, you can build JavaScript objects with properties that can be watched for changes. This is what <a href=\"https://github.com/lmorchard/react-multiplatform/blob/master/lib/models/Todo.js\">my todo item model</a> looks like, using <a href=\"https://github.com/tastejs/todomvc/blob/master/examples/ampersand/js/models/todo.js\">TodoMVC code</a> as a starting point:</p>\n<pre><code class=\"language-javascript\">var State = require(&#39;ampersand-state&#39;);\nmodule.exports = State.extend({\n  // Properties this model will store\n  props: {\n    title: { type: &#39;string&#39;, default: &#39;&#39; },\n    completed: { type: &#39;boolean&#39;, default: false }\n  },\n  // session properties are not included when serializing.\n  session: {\n    editing: { type: &#39;boolean&#39;, default: false }\n  },\n  destroy: function () {\n    if (this.collection) {\n      this.collection.remove(this);\n    }\n  }\n});</code></pre>\n<h2 id=\"forking-the-views-by-platform\">Forking the Views by platform</h2>\n<p>This Model code works on both the web and native sides of my app. So far, so good - and pretty straightforward.</p>\n<p>However, getting down to actually rendering this data across platforms reveals where things start to vary. For example, <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/web/TodoItem.js#L34\">the JSX in the <code>render()</code> method of my web view</a> looks like this:</p>\n<pre><code class=\"language-javascript\">return (\n  &lt;li style={itemStyles.container}&gt;\n    &lt;input type=&quot;checkbox&quot;\n      style={itemStyles.completed}\n      onChange={(event) =&gt; this.handleCompletedChange(event.target.checked)}\n      checked={this.state.item.completed} /&gt;\n    {title}\n  &lt;/li&gt;\n);</code></pre>\n<p>Meanwhile, <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/ios/TodoItem.js#L42\">the JSX in the <code>render()</code> method of my iOS view</a> looks like this:</p>\n<pre><code class=\"language-javascript\">return (\n  &lt;View style={styles.todoItem}&gt;\n    &lt;SwitchIOS\n      style={styles.todoCompleted}\n      onValueChange={this.handleCompletedChange}\n      value={this.state.item.completed} /&gt;\n    {title}\n  &lt;/View&gt;\n);</code></pre>\n<p>And, if you take a longer peek at those views, you&#39;ll see some slightly more complex JSX devoted to the <code>{title}</code> placeholders where rendering changes based on whether the item is being edited.</p>\n<p>It&#39;s not radically different; it&#39;s just enough to make things interesting.</p>\n<h2 id=\"code-sharing-with-react-mixins\">Code sharing with React mixins</h2>\n<p>What you might notice about these two divergent views, though, is they both start like this:</p>\n<pre><code class=\"language-javascript\">var TodoItem = module.exports = React.createClass({\n  mixins: [Views.TodoItemCommonMixin],\n  // ...</code></pre>\n<p>It turns out that, thanks to <a href=\"https://facebook.github.io/react/docs/reusable-components.html#mixins\">React mixins</a>, I can write <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/index.js#L35\">the bulk of the View logic</a> in a shared module. Since both sides use Models based on <a href=\"https://github.com/AmpersandJS/ampersand-state\">ampersand-state</a>, this includes subscribing to Model changes:</p>\n<pre><code class=\"language-javascript\">getInitialState() {\n  return { editing: false, item: this.props.item };\n},\ncomponentDidMount() {\n  this.state.item.on(&#39;change&#39;, () =&gt; this.forceUpdate(), this);\n},\ncomponentWillUnmount() {\n  this.state.item.off(null, null, this);\n},\ncomponentWillReceiveProps(props) {\n  this.setState({ item: props.item });\n},\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.item !== this.state.item) {\n    prevState.item.off(null, null, this);\n    this.state.item.on(&#39;change&#39;, () =&gt; this.forceUpdate(), this);\n  }\n}</code></pre>\n<p>And, since both sides use Views based on <a href=\"https://facebook.github.io/react/\">React</a>, many UI event handlers can also be shared despite the difference in platform specific JSX and view elements.</p>\n<p>(Of course, I recently learned that <a href=\"https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\">React mixins are dead</a>, so I&#39;m already behind the times. But, this code works for now. I&#39;ll get around to burning that bridge when I learn more about Flux.)</p>\n<h2 id=\"forking--sharing-model-code-for-persistence\">Forking &amp; sharing Model code for persistence</h2>\n<p>For multiple todo items, <a href=\"https://github.com/AmpersandJS/ampersand-collection\">ampersand-collection</a> is handy. It manages arrays of <a href=\"https://github.com/AmpersandJS/ampersand-state\">ampersand-state</a> objects and emits events when the set changes. This is useful for keeping <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/web/TodoList.js\">list</a> <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/ios/TodoList.js\">views</a> updated.</p>\n<p><a href=\"https://github.com/AmpersandJS/ampersand-collection\">ampersand-collection</a> also offers methods for serializing &amp; deserializing the models it contains. That&#39;s just what I need, because I&#39;d like to make my todo list items persistent between sessions with the app.</p>\n<p>Apropos of that, we have some storage capabilities on each platform: <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\">localStorage</a> for modern browsers, and <a href=\"https://facebook.github.io/react-native/docs/asyncstorage.html\">AsyncStorage</a> for React Native. Both allow you to store small amounts of persistent data on a device. For the purposes of this toy app, these data stores are just about right.</p>\n<p>But, these storage APIs differ. <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/models/web/TodoCollection.js#L14\">Using localStorage</a> looks like this:</p>\n<pre><code class=\"language-javascript\">readFromStorage: function () {\n  var existingData = localStorage[STORAGE_KEY];\n  if (existingData) {\n    this.set(JSON.parse(existingData));\n  }\n},\nwriteToStorage: function () {\n  localStorage[STORAGE_KEY] = JSON.stringify(this);\n}</code></pre>\n<p>Meanwhile, <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/models/ios/TodoCollection.js#L9\">using AsyncStorage</a> looks like this:</p>\n<pre><code class=\"language-javascript\">readFromStorage() {\n  AsyncStorage.getItem(STORAGE_KEY).then((existingData) =&gt; {\n    this.set(JSON.parse(existingData));\n  });\n},\nwriteToStorage() {\n  AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(this));\n}</code></pre>\n<p>If you peek at those last two links, though, you might notice they both define classes that start like this:</p>\n<pre><code class=\"language-javascript\">var TodoCollection = module.exports = BaseCollection.extend({</code></pre>\n<p>Since <a href=\"https://github.com/AmpersandJS/ampersand-collection\">ampersand-collection</a> supports class inheritance, the bulk of the logic for these collections can be housed in <a href=\"https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/models/TodoCollection.js#L8\">a shared superclass</a>. The subclasses just need to implement the platform-specific storage methods. A different mechanism than <a href=\"https://facebook.github.io/react/docs/reusable-components.html#mixins\">React mixins</a>, but for basically the same purpose.</p>\n<h2 id=\"sharing-by-the-numbers\">Sharing by the numbers</h2>\n<p>The main goal of this experiment is to get a feel as to whether a hybrid React approach is worth considering versus building totally separate apps for native and web platforms. The metric I decided to use for this is counting lines of code (LoC), and this is what I found:</p>\n<ul>\n<li><p>Overall, ~30% shared LoC (226 / 748).</p>\n</li>\n<li><p>For Models, ~74% shared LoC (159 / 215).</p>\n</li>\n<li><p>For Views, ~12% shared LoC (67 / 533).</p>\n</li>\n</ul>\n<p>Because I like showing my work, here&#39;s how I came up with those numbers:</p>\n<pre><code class=\"language-bash\"># Total LoC for models = 215\n$ cat lib/models/**/*.js | wc -l\n     215\n\n# ~74% common model code\n$ cat lib/models/*js | wc -l\n     159\n\n# ~12% iOS specific model code\n$ cat lib/models/ios/*js | wc -l\n      25\n\n# ~14% web specific model code\n$ cat lib/models/web/*js | wc -l\n      31\n\n# Total LoC for views = 533\n$ cat lib/views/**/*.js | wc -l\n     533\n\n# ~12% common view code\n$ cat lib/views/*js | wc -l\n      67\n\n# ~44% iOS specific view code\n$ cat lib/views/ios/*js | wc -l\n     235\n\n# ~43% web specific view code\n$ cat lib/views/web/*js | wc -l\n     231</code></pre>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Using React for both web &amp; native looks promising. However, the toy app I&#39;ve built is too simple to present an overwhemingly compelling case.</p>\n<p>What I tried to do here was get a quick feel for the shape of things and where the code multipliers can be found. Your mileage will vary on app features and code refactoring ability.</p>\n<p>In particular, this toy app&#39;s models are very simple. So, even though there&#39;s a lot of sharing, it doesn&#39;t make a big impact on the bottom line. In an app with more complex business logic, that could change favorably.</p>\n<p>On the other hand, Views between platforms will have a greater impact as they get more complex in dealing with divergent UI elements. You could paper over many platform differences with reusable components that normalize APIs &amp; usage patterns - hopefully while not squashing unique advantages of each platform. So far, this app is too simple to really expose those opportunities.</p>\n<p>And, of course, all bets are off once you&#39;ve left React for straight native development. My hunch is that there are qualitative &amp; quantitative benefits to reducing context switching. You can focus development &amp; testing efforts on JavaScript &amp; React as opposed to multiple native &amp; web toolkits (e.g. Objective-C &amp; Swift &amp; Java - oh my!). But, measuring that hunch is beyond the scope of what I tried doing here.</p>\n<p>Hopefully, I&#39;ve raised some interesting features of the terrain. But, I know this is a very shallow look at things and I&#39;m learning as I go along. Feel free to poke holes in this stuff and throw some suggestions at me!</p>\n",
    "body": "<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\nTL;DR: I built [a toy app using React for web and native][react-multiplatform] to get a feel for whether this hybrid approach is worth using. I think the answer is \"yes\" - but mainly for apps whose business logic & data models are more complex than their views.\n\n<!--more-->\n\n## Write slightly more than once, run manywhere\n\nAt Mozilla, one of the things we try to champion is the efficiency of writing one web app versus building many separate native apps. In practice, your mileage varies based on goals, priorities, platform capabilities, and a dozen other factors.\n\n[React][] and [React Native][] seem to offer a middle ground: Given the shared conventions and patterns and language, it should be possible to share a lot of code between platforms while still taking advantage of native capabilities.\n\nSo, I figured I'd give it a shot and try measuring the common lines of code as a rough success metric.\n\n## Great, another Todo app\n\nI decided to build a Todo app, with lots of inspiration and a little code borrowed from [TodoMVC][].\n\nA basic Todo app demands just enough user interface and data management to get an initial feel for most app frameworks. Commit to something bigger and you may end up wasting your time. Build something smaller and you won't have explored deep enough into the framework's solution space.\n\nI think I've erred on the shallow side, but that just gives me room to improve.\n\n## What about Flux vs MVC?\n\nIt's said that React provides just the V in MVC (Model-View-Controller). But, there's also [this Flux notion][flux]. It's billed as an alternative to MVC, and React is intended to be a part of it. That said, I haven't quite yet wrapped my head around Flux. Luckily, React is focused and useful in isolation. So, I can defer buying into the rest of the conceptual package as I learn.\n\nIn fact, I didn't even really end up building a proper MVC app. The Controller role got distributed between Views & Models: UI event handlers in Views modify Models directly. Views subscribe to change events from Models to update their own state.\n\nI expect that when I grok Flux better, it's this reciprocal Model/View relationship that will get broken up & mediated by a Dispatcher. But, in the spirit of iterative hacking, I forged ahead with my terrible code & design.\n\n## Building shared Models\n\nFor the Model layer, I took a look at [Ampersand.js][]. Based originally on [Backbone.js][] - a library of which I'm a big fan - [Ampersand.js][] breaks things up into a collection of small modules that work well together. But, like [React][], most of the modules are handy in isolation or alongside substitutions from outside of the [Ampersand.js][] family.\n\nFor managing a single todo item, I liked the looks of [ampersand-state][]. With it, you can build JavaScript objects with properties that can be watched for changes. This is what [my todo item model][todo-model] looks like, using [TodoMVC code][todo-model-ampersand] as a starting point:\n\n```javascript\nvar State = require('ampersand-state');\nmodule.exports = State.extend({\n  // Properties this model will store\n  props: {\n    title: { type: 'string', default: '' },\n    completed: { type: 'boolean', default: false }\n  },\n  // session properties are not included when serializing.\n  session: {\n    editing: { type: 'boolean', default: false }\n  },\n  destroy: function () {\n    if (this.collection) {\n      this.collection.remove(this);\n    }\n  }\n});\n```\n\n## Forking the Views by platform\n\nThis Model code works on both the web and native sides of my app. So far, so good - and pretty straightforward.\n\nHowever, getting down to actually rendering this data across platforms reveals where things start to vary. For example, [the JSX in the `render()` method of my web view][item-web-render] looks like this:\n\n```javascript\nreturn (\n  <li style={itemStyles.container}>\n    <input type=\"checkbox\"\n      style={itemStyles.completed}\n      onChange={(event) => this.handleCompletedChange(event.target.checked)}\n      checked={this.state.item.completed} />\n    {title}\n  </li>\n);\n```\n\nMeanwhile, [the JSX in the `render()` method of my iOS view][item-ios-render] looks like this:\n\n```javascript\nreturn (\n  <View style={styles.todoItem}>\n    <SwitchIOS\n      style={styles.todoCompleted}\n      onValueChange={this.handleCompletedChange}\n      value={this.state.item.completed} />\n    {title}\n  </View>\n);\n```\n\n[item-web-render]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/web/TodoItem.js#L34\n[item-ios-render]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/ios/TodoItem.js#L42\n\nAnd, if you take a longer peek at those views, you'll see some slightly more complex JSX devoted to the `{title}` placeholders where rendering changes based on whether the item is being edited.\n\nIt's not radically different; it's just enough to make things interesting.\n\n## Code sharing with React mixins\n\nWhat you might notice about these two divergent views, though, is they both start like this:\n\n```javascript\nvar TodoItem = module.exports = React.createClass({\n  mixins: [Views.TodoItemCommonMixin],\n  // ...\n```\n\nIt turns out that, thanks to [React mixins][], I can write [the bulk of the View logic][item-shared-view] in a shared module. Since both sides use Models based on [ampersand-state][], this includes subscribing to Model changes:\n\n[React mixins]: https://facebook.github.io/react/docs/reusable-components.html#mixins\n\n```javascript\ngetInitialState() {\n  return { editing: false, item: this.props.item };\n},\ncomponentDidMount() {\n  this.state.item.on('change', () => this.forceUpdate(), this);\n},\ncomponentWillUnmount() {\n  this.state.item.off(null, null, this);\n},\ncomponentWillReceiveProps(props) {\n  this.setState({ item: props.item });\n},\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.item !== this.state.item) {\n    prevState.item.off(null, null, this);\n    this.state.item.on('change', () => this.forceUpdate(), this);\n  }\n}\n```\n\n[item-shared-view]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/index.js#L35\n\nAnd, since both sides use Views based on [React][], many UI event handlers can also be shared despite the difference in platform specific JSX and view elements.\n\n(Of course, I recently learned that [React mixins are dead][dead-mixins], so I'm already behind the times. But, this code works for now. I'll get around to burning that bridge when I learn more about Flux.)\n\n[dead-mixins]: https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750\n\n## Forking & sharing Model code for persistence\n\nFor multiple todo items, [ampersand-collection][] is handy. It manages arrays of [ampersand-state][] objects and emits events when the set changes. This is useful for keeping [list][list-web-view] [views][list-ios-view] updated.\n\n[list-web-view]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/web/TodoList.js\n[list-ios-view]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/views/ios/TodoList.js\n\n[ampersand-collection][] also offers methods for serializing & deserializing the models it contains. That's just what I need, because I'd like to make my todo list items persistent between sessions with the app.\n\n[todo-model]: https://github.com/lmorchard/react-multiplatform/blob/master/lib/models/Todo.js\n[todo-model-ampersand]: https://github.com/tastejs/todomvc/blob/master/examples/ampersand/js/models/todo.js\n\nApropos of that, we have some storage capabilities on each platform: [localStorage][] for modern browsers, and [AsyncStorage][] for React Native. Both allow you to store small amounts of persistent data on a device. For the purposes of this toy app, these data stores are just about right.\n\nBut, these storage APIs differ. [Using localStorage][using-localstorage] looks like this:\n\n```javascript\nreadFromStorage: function () {\n  var existingData = localStorage[STORAGE_KEY];\n  if (existingData) {\n    this.set(JSON.parse(existingData));\n  }\n},\nwriteToStorage: function () {\n  localStorage[STORAGE_KEY] = JSON.stringify(this);\n}\n```\n\nMeanwhile, [using AsyncStorage][using-asyncstorage] looks like this:\n\n```javascript\nreadFromStorage() {\n  AsyncStorage.getItem(STORAGE_KEY).then((existingData) => {\n    this.set(JSON.parse(existingData));\n  });\n},\nwriteToStorage() {\n  AsyncStorage.setItem(STORAGE_KEY, JSON.stringify(this));\n}\n```\n\nIf you peek at those last two links, though, you might notice they both define classes that start like this:\n\n```javascript\nvar TodoCollection = module.exports = BaseCollection.extend({\n```\n\nSince [ampersand-collection][] supports class inheritance, the bulk of the logic for these collections can be housed in [a shared superclass][basecollection]. The subclasses just need to implement the platform-specific storage methods. A different mechanism than [React mixins][], but for basically the same purpose.\n\n[using-localstorage]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/models/web/TodoCollection.js#L14\n[using-asyncstorage]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/models/ios/TodoCollection.js#L9\n[basecollection]: https://github.com/lmorchard/react-multiplatform/blob/3fd16fe31473f249d8a54020ef252f524dd17d70/lib/models/TodoCollection.js#L8\n\n[AsyncStorage]: https://facebook.github.io/react-native/docs/asyncstorage.html\n[localstorage]: https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API\n\n## Sharing by the numbers\n\nThe main goal of this experiment is to get a feel as to whether a hybrid React approach is worth considering versus building totally separate apps for native and web platforms. The metric I decided to use for this is counting lines of code (LoC), and this is what I found:\n\n* Overall, ~30% shared LoC (226 / 748).\n\n* For Models, ~74% shared LoC (159 / 215).\n\n* For Views, ~12% shared LoC (67 / 533).\n\nBecause I like showing my work, here's how I came up with those numbers:\n\n```bash\n# Total LoC for models = 215\n$ cat lib/models/**/*.js | wc -l\n     215\n\n# ~74% common model code\n$ cat lib/models/*js | wc -l\n     159\n\n# ~12% iOS specific model code\n$ cat lib/models/ios/*js | wc -l\n      25\n\n# ~14% web specific model code\n$ cat lib/models/web/*js | wc -l\n      31\n\n# Total LoC for views = 533\n$ cat lib/views/**/*.js | wc -l\n     533\n\n# ~12% common view code\n$ cat lib/views/*js | wc -l\n      67\n\n# ~44% iOS specific view code\n$ cat lib/views/ios/*js | wc -l\n     235\n\n# ~43% web specific view code\n$ cat lib/views/web/*js | wc -l\n     231\n```\n\n## Conclusion\n\nUsing React for both web & native looks promising. However, the toy app I've built is too simple to present an overwhemingly compelling case.\n\nWhat I tried to do here was get a quick feel for the shape of things and where the code multipliers can be found. Your mileage will vary on app features and code refactoring ability.\n\nIn particular, this toy app's models are very simple. So, even though there's a lot of sharing, it doesn't make a big impact on the bottom line. In an app with more complex business logic, that could change favorably.\n\nOn the other hand, Views between platforms will have a greater impact as they get more complex in dealing with divergent UI elements. You could paper over many platform differences with reusable components that normalize APIs & usage patterns - hopefully while not squashing unique advantages of each platform. So far, this app is too simple to really expose those opportunities.\n\nAnd, of course, all bets are off once you've left React for straight native development. My hunch is that there are qualitative & quantitative benefits to reducing context switching. You can focus development & testing efforts on JavaScript & React as opposed to multiple native & web toolkits (e.g. Objective-C & Swift & Java - oh my!). But, measuring that hunch is beyond the scope of what I tried doing here.\n\nHopefully, I've raised some interesting features of the terrain. But, I know this is a very shallow look at things and I'm learning as I go along. Feel free to poke holes in this stuff and throw some suggestions at me!\n\n[ampersand-subcollection]: https://github.com/AmpersandJS/ampersand-subcollection\n[ampersand-collection]: https://github.com/AmpersandJS/ampersand-collection\n[ampersand-state]: https://github.com/AmpersandJS/ampersand-state\n[ampersand-view]: https://github.com/AmpersandJS/ampersand-view\n[Backbone.js]: http://backbonejs.org/\n[ampersand.js]: http://ampersandjs.com/\n[flux]: https://facebook.github.io/flux/docs/overview.html\n[TodoMVC]: http://todomvc.com/\n[react-multiplatform]: https://github.com/lmorchard/react-multiplatform/\n[react]: https://facebook.github.io/react/\n[feels-like-web]: https://code.facebook.com/posts/1014532261909640/react-native-bringing-modern-web-techniques-to-mobile/\n[rn-devtools]: https://facebook.github.io/react-native/docs/debugging.html#content\n[react-api]: https://facebook.github.io/react/docs/top-level-api.html\n[React Native]: https://facebook.github.io/react-native/\n",
    "parentPath": "../blog.lmorchard.com/posts/archives/2015",
    "path": "2015/07/22/react-multiplatform",
    "summary": "<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\n<p>TL;DR: I built <a href=\"https://github.com/lmorchard/react-multiplatform/\">a toy app using React for web and native</a> to get a feel for whether this hybrid approach is worth using. I think the answer is &quot;yes&quot; - but mainly for apps whose business logic &amp; data models are more complex than their views.</p>\n"
  }
]