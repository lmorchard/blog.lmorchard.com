{"title":"Fun with Themes in Firefox","tags":["mozilla","firefox","themes","themer","quantum","addons","webpack","node","webdev"],"date":"2018-03-01T00:00:00.000Z","url":"/2018/03/01/themesrfun/","thumbnail":"/2018/03/01/themesrfun/image_1.png","summary":"<p><strong>TL;DR</strong>: Last year, I started work on a new Test Pilot experiment playing with themes in Firefox. </p>\n","path":"2018/03/01/themesrfun","content":"<p><strong>TL;DR</strong>: Last year, I started work on a new Test Pilot experiment playing with themes in Firefox. </p>\n<!--more-->\n<nav role=\"navigation\" class=\"table-of-contents\"></nav>\n\n<h2 id=\"new-theme-apis-are-fun\">New theme APIs are fun</h2>\n<p>At the core of this experiment are <a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/theme\">new theme APIs for add-ons</a> shipping with Firefox. </p>\n<p>These APIs take inspiration <a href=\"https://developer.chrome.com/apps/themes\">from static themes in Google Chrome</a>, building from there to enable the creation of dynamic themes. </p>\n<p>For example, <a href=\"https://addons.mozilla.org/en-US/firefox/addon/quantum-lights-dynamic/\">Quantum Lights</a> changes based on the time of day.</p>\n<p><a href=\"https://addons.mozilla.org/en-US/firefox/addon/quantum-lights-dynamic/\"><img src=\"quantum-lights.png\" alt=\"Quantum Lights dynamic theme\"></a></p>\n<p><a href=\"https://addons.mozilla.org/en-US/firefox/addon/vivaldifox/\">VivaldiFox</a> reflects the sites you’re visiting.</p>\n<p><a href=\"https://addons.mozilla.org/en-US/firefox/addon/vivaldifox/\"><img src=\"image_0.png\" alt=\"VivaldiFox dynamic theme\"></a></p>\n<p>You could even build themes that use data from external HTTP services - e.g. to change based on the weather.</p>\n<p>To explore these new APIs, Firefox Themer consists of a website and a companion add-on for Firefox. The website offers a theme editor with a paper doll preview - you can click on parts of a simulated browser interface and dress it up however you like. The add-on grants special powers to the website, applying changes from the theme in the editor onto the browser itself.</p>\n<h2 id=\"editing-themes-on-the-web\">Editing themes on the web</h2>\n<p><a href=\"https://github.com/mozilla/Themer/tree/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web\">The site</a> is built <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/webpack.web.js\">using Webpack</a>, React, and Redux. React offers a solid foundation for composing the editor. Personally, I really like working with <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/lib/components/SavedThemeSelector/index.js\">stateless functional components</a> - they’re kind of what tipped me over into becoming a React convert a few years ago. I’m also a terrible visual designer with weak CSS-fu - but <a href=\"https://simonsmith.io/using-webpack-to-build-react-components-and-their-assets/\">using Webpack to bundle assets from per-component directories</a> makes it easier for teammates to step in where I fall short.</p>\n<p><img id=\"thumbnail\" title=\"An early snapshot of Themer in development\" alt=\"An early snapshot of Themer in development\" src=\"image_1.png\" /></p>\n<p>Further under the hood, Redux offers a clean way to <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/lib/store.js\">manage theme data and UI state</a>. Adding <a href=\"https://github.com/mozilla/Themer/tree/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/lib/components/UndoRedoButtons\">undo &amp; redo buttons</a> is easy, thanks to <a href=\"https://github.com/omnidan/redux-undo/\">redux-undo</a>. And, by way of some <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/index.js#L52\">simple Redux middleware</a>, I was able to easily add a hook to push every theme changes into the browser via the add-on.</p>\n<p>The website is just a static page - there’s no real server-side application. When you save a theme, <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/lib/storage.js\">it ends up in your browser’s localStorage</a>. Though we plan to move to a Mozilla-owned production server on launch, I’ve been <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/package.json#L29\">deploying</a> builds to <a href=\"https://mozilla.github.io/Themer/\">GitHub Pages</a> during development.</p>\n<p>Another interesting feature of the website is that we encode themes as a parameter in the URL. Rather than come up with a bespoke scheme, I use <a href=\"https://github.com/masotime/json-url\">this json-url module</a> to compress JSON and encode it as Base64, which makes for a long URL but not unreasonably so. This approach enables folks to simply copy &amp; paste a URL to share a theme they’ve made. You <a href=\"https://mozilla.github.io/Themer/?theme=XQAAAAK6AAAAAAAAAABBKYhm849SCiaxqiaEGccwS-xNVABND6bPaWX82IACoyBXlMz-ogPQMZx8jZw0gi6ZqepxjZiNq3qtC6ReDugh0DJEIcc-6Ekd4BML5haoPqlXvTBKbEuN12ZBm-SJaWyB2b9GzX0tU6b_u9yjWO4ukTDkntTK440uf__ug8AA\">can</a> <a href=\"https://mozilla.github.io/Themer/?theme=XQAAAAK5AAAAAAAAAABBKYhm849SCiaxqiaEGccwS-xNVABNBRtj-x-Szc1kMeuEtwJYdDlHdJFchkY8sMP4iOzSOnr2vDVLFHcDTGfvoD2F-saWB-4Q-0HlUiMST82W8NTW8EedwTOfbOY_8T30w0e4gC9vlGFCU9f6FVIWiWSteBgU_b2G6fBR_7tUIAA\">even</a> <a href=\"https://mozilla.github.io/Themer/?theme=XQAAAAK8AAAAAAAAAABBKYhm849SCiaxqiaEGccwS-xNVABNKtQKc4Qr-u-HdLUSjaBjcrH658wB_k4I1-yfpFsfTFeutvkNHhJd47c-oR5Cmx-mMJXZ4Lq7R98D2PE8etCHIG-B5_8oTyfPCjY6DxXN-uebtBycPe1q5OYxejC4KXCppxfkfniiH__gvZgA\">link</a> <a href=\"https://mozilla.github.io/Themer/?theme=XQAAAAK7AAAAAAAAAABBKYhm849SCiaxqiaEGccwS-xNVABNC6bT6OtXpulKBw4DX1CffRksp6558s0k0DnUhq_LUMnHsWC8m0Ch34ivMZQ9sgV8nw4smjNTF6KwTBLBWoGene--BIiLoZeK7cfULCJbaoBYqyuNgz2tcB6oGDKcpyWUdMoffLb2h__-XfwA\">to</a> <a href=\"https://mozilla.github.io/Themer/?theme=XQAAAAK2AAAAAAAAAABBKYhm849SCiaxqiaEGccwS-xNVAAfaPFobPrtxqh09bZ0dFlllNZAoZN2KxC18prV-JbJ_OWRSXO_BkFys9aW3y-ZXvULv_v6dWy1x1lwnCABmI9hLlcXkVKtiPaJ2TBI4QUpuGXbvJ__-RkwAA\">themes</a> from a blog post, if you wanted to!</p>\n<p><img src=\"image_2.png\" alt=\"Copy themes as URLs\"></p>\n<p>When the page loads and sees the ?theme URL, <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/index.js#L201\">it unpacks the data</a> and <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/index.js#L204\">loads it into editor’s Redux store</a>. I’ve also been able to work this into the location bar with the HTML5 History API and <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/index.js#L61\">Redux middleware</a>. The browser location represents the current theme, while back &amp; forward buttons double as undo &amp; redo.</p>\n<h2 id=\"add-ons-can-be-expansion-cartridges\">Add-ons can be expansion cartridges</h2>\n<p><a href=\"http://www.syntiac.com/chameleon.html\"><img title=\"The Turbo Chameleon 64 cartridge adds many new capabilities to a Commodore 64\" class=\"inset wide right\" src=\"chameleon_housing_small.jpg\" /></a></p>\n<p><a href=\"https://github.com/mozilla/Themer/tree/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/extension\">The companion add-on</a> is also built <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/webpack.extension.js\">using Webpack</a> and acts as an <a href=\"https://www.c64-wiki.com/wiki/Simons%27_BASIC\">expansion cartridge</a> for the theme editor on the website. (Can you tell <a href=\"https://blog.lmorchard.com/2018/03/01/sio2pi/\">I’ve had retro computers on the mind</a>, lately?)</p>\n<p>Add-ons in Firefox can install <a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Content_scripts\">content scripts</a> that access content and data on web pages. Content scripts can communicate with the parent add-on <a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Content_scripts#Communicating_with_background_scripts\">by way of a message port</a>. They can also communicate with a web page <a href=\"https://developer.mozilla.org/en-US/Add-ons/WebExtensions/Content_scripts#Communicating_with_the_web_page\">by way of synthetic events</a>. Put the two together, and you’ve got <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/extension/contentScript.js\">a messaging channel</a> between a web page and an add-on in Firefox.</p>\n<p>Here&#39;s the heart of <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/extension/contentScript.js\">that messaging bridge</a>:</p>\n<pre><code class=\"lang-javascript\">import { CHANNEL_NAME } from &quot;../lib/constants&quot;;\n\n// Relay backend port messages to content\nlet port;\n\nfunction connect() {\n  port = browser.runtime.connect({ name: CHANNEL_NAME });\n  port.onDisconnect.addListener(() =&gt; {\n    port = null;\n    reconnect();\n  });\n  port.onMessage.addListener(message =&gt; {\n    window.postMessage({ ...message, channel: `${CHANNEL_NAME}-web` }, &quot;*&quot;);\n  });\n}\n\n// Relay content messages to backend port if the channel name matches\n// (Not a security feature so much as a noise filter)\nwindow.addEventListener(&quot;message&quot;, event =&gt; {\n  if (\n    port &amp;&amp;\n    event.source === window &amp;&amp;\n    event.data &amp;&amp;\n    event.data.channel === `${CHANNEL_NAME}-extension`\n  ) {\n    port.postMessage({ ...event.data, location: window.location.href });\n  }\n});\n\nconnect();\n</code></pre>\n<p>With this approach, the web page doesn’t actually gain access to any Firefox APIs. <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/extension/background.js#L23\">The add-on can decide what to do with with messages it receives</a>. If the page sends invalid data or asks to do something not supported - nothing happens. Here&#39;s a snippet of that logic from the extension:</p>\n<pre><code class=\"lang-javascript\">const messageListener = port =&gt; message =&gt; {\n  let theme;\n  switch (message.type) {\n    case &quot;fetchTheme&quot;:\n      log(&quot;fetchTheme&quot;);\n      fetchTheme().then(({ theme: currentTheme }) =&gt;\n        port.postMessage({ type: &quot;fetchedTheme&quot;, theme: currentTheme })\n      );\n      break;\n    case &quot;setTheme&quot;:\n      theme = normalizeTheme(message.theme);\n      log(&quot;setTheme&quot;, theme);\n      storeTheme({ theme });\n      applyTheme({ theme });\n      break;\n    case &quot;ping&quot;:\n      port.postMessage({ type: &quot;pong&quot; });\n      break;\n    default:\n      log(&quot;unexpected message&quot;, message);\n  }\n};\n</code></pre>\n<p>And here&#39;s a peek at <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/src/web/index.js#L52\">that Redux middleware I mentioned earlier</a> which updates the add-on from the web:</p>\n<pre><code class=\"lang-javascript\">const postMessage = (type, data = {}) =&gt;\n  window.postMessage(\n    { ...data, type, channel: `${CHANNEL_NAME}-extension` },\n    &quot;*&quot;\n  );\n\nconst updateExtensionThemeMiddleware = ({ getState }) =&gt; next =&gt; action =&gt; {\n  const returnValue = next(action);\n  const meta = action.meta || {};\n  if (!meta.skipAddon &amp;&amp; themeChangeActions.includes(action.type)) {\n    postMessage(&quot;setTheme&quot;, { theme: selectors.theme(getState()) });\n  }\n  return returnValue;\n};\n</code></pre>\n<p>The add-on can also restrict the set of pages from which it will accept messages: We <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/webpack.extension.js#L55\">hardcode the URL for the theme editor</a> into the add-on’s content script configuration at build time, which means no other web page should be able to ask the add-on to alter the theme in Firefox.</p>\n<h2 id=\"add-on-detection-is-hard\">Add-on detection is hard</h2>\n<p><img class=\"inset wide right\" src=\"loader.png\" title=\"The loading overlay that appears until the editor is visually stable\" /></p>\n<p>There is a wrinkle to the relationship between website and add-on, though: A normal web page cannot detect whether or not a particular add-on has been installed. All the page can do is send a message. If the add-on responds, then we know the add-on is available.</p>\n<p>Proving a negative, however, is impossible: the web page can’t know for sure that the addon is <em>not </em>available. Responses to asynchronous messages take time - not necessarily a long time, but more than zero time. </p>\n<p>If the page sends a message and doesn’t get a response, that doesn’t mean the add-on is missing. It could just mean that the add-on is taking awhile to respond. So, we have to render the theme editor such that it starts off by assuming the add-on is not installed. If the add-on shows up, minutes or milliseconds later, the page can update itself to reflect the new state of things.</p>\n<p>Left as-is, you’d see several flashes of color and elements on the page move as things settle. That seems unpleasant and possibly confusing, so we came up with a loading spinner: When the page loads, it displays the spinner and a timer starts. If that timer expires, we consider things ready and reveal the editor. But, if there’s any change to the Redux store while that timer is running, we restart the clock.</p>\n<p>This is the gist of what that code does:</p>\n<pre><code class=\"lang-javascript\">const unsubscribeLoader = store.subscribe(() =&gt; {\n  if (selectors.loaderDelayExpired(store.getState())) {\n    // State settled down long enough for timer to expire - stop listening.\n    unsubscribeLoader();\n  } else {\n    // Reset the timer again.\n    startLoaderDelay();\n  }\n});\n\n// Utility to (re)start up a timer to dismiss the loading indicator\nlet loaderTimer = null;\nfunction startLoaderDelay() {\n  if (loaderTimer) {\n    clearTimeout(loaderTimer);\n  }\n  loaderTimer = setTimeout(\n    () =&gt; store.dispatch(actions.ui.setLoaderDelayExpired(true)),\n    LOADER_DELAY_PERIOD\n  );\n}\n</code></pre>\n<p>Early changes to the store are driven by things like decoding a shared theme and responses from the add-on. Again, these are asynchronous and unpredictable. The timer duration is an arbitrary guess I made that seems to feel right. It’s a dirty hack, but it seems like a good enough effort for now.</p>\n<h2 id=\"using-npm-scripts-and-multiple-webpack-configs\">Using npm scripts and multiple Webpack configs</h2>\n<p>One of the things that has worked nicely on this project is building everything in parallel with a single npm command. You can <a href=\"https://github.com/mozilla/Themer/tree/5cdcb7e15d64934f0e71521512c74337dc58fa05#get-started\">clone the repo and kick things off for development</a> with a simple <code>npm install &amp;&amp; npm start</code> dance.</p>\n<p>The add-on and the site both use Webpack. There’s <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/webpack.common.js\">a shared config</a> as a base and then specific configurations with tweaks for <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/webpack.web.js\">the site</a> and <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/webpack.extension.js\">the add-on</a>. So, we want to run two separate instances of Webpack to build everything, watch files, and host the dev server.</p>\n<p>This is where <a href=\"https://www.npmjs.com/package/npm-run-all\">npm-run-all</a> comes in: It’s a CLI tool that lets you run multiple npm scripts. I used to use gulp to orchestrate this sort of thing, but <a href=\"https://www.npmjs.com/package/npm-run-all\">npm-run-all</a> lets me arrange it all <a href=\"https://docs.npmjs.com/misc/scripts\">in <code>package.json</code></a>. It would be fine if this just enabled running scripts in series. But, npm-run-all also lets you run scripts<em> in parallel</em>. The cherry on top is that <a href=\"https://www.npmjs.com/package/npm-run-all#%EF%B8%8F-motivation\">this parallelization works on Linux, OS X, <em>and Windows</em></a>.</p>\n<pre><code class=\"lang-json\">&quot;scripts&quot;: {\n  &quot;start&quot;: &quot;npm-run-all --parallel server watch:extension watch:lint&quot;,\n  &quot;server&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --config webpack.web.js&quot;,\n  &quot;watch&quot;: &quot;npm-run-all --parallel watch:*&quot;,\n  &quot;watch:web&quot;: &quot;cross-env NODE_ENV=development webpack --watch --progress --colors --config webpack.web.js&quot;,\n  &quot;watch:extension&quot;: &quot;cross-env NODE_ENV=development webpack --watch --progress --colors --config webpack.extension.js&quot;,\n  &quot;watch:lint&quot;: &quot;onchange -p -v \\&quot;src/**/*.js\\&quot; -- npm run lint&quot;,\n  &quot;lint&quot;: &quot;eslint --color .&quot;,\n},\n</code></pre>\n<p>In past years, Windows support might have been an abstract novelty for me. But, in recent months, I’ve switched from Apple hardware to a PC laptop. I’ve found the new <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\">Windows Subsystem for Linux</a> to be essential to that switch. But, sometimes it’s nice to just fire up a Node.js dev environment directly in PowerShell - <a href=\"https://www.npmjs.com/package/npm-run-all\">npm-run-all</a> lets me (and you) do that!</p>\n<p>So, <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/package.json#L12\">the start script in our package.json</a> is able to fire up both Webpack processes for the site and add-on. It can also <a href=\"https://github.com/mozilla/Themer/blob/5cdcb7e15d64934f0e71521512c74337dc58fa05/package.json#L17\">start a file watcher to run linting</a> and tests (when we have them) alongside. That simplifies using everything in a single shell window across platforms. <a href=\"https://decafbad.com/2011/06/os-webdev-vm/slides.html#1\">I used to lean on Vagrant or Docker to offer something &quot;simple&quot; to folks interested in contributing to a project</a>. But, though virtual machines and containers can hide apparent complexity in development, it’s hard to beat just running things in node on the native OS.</p>\n<h2 id=\"help-us-make-themes-more-fun-\">Help us make themes more fun!</h2>\n<p>We’re launching this experiment soon. And, though it only makes limited use of the new theme APIs for now, we’re hoping that the web-based editor and ease of sharing makes it fun &amp; worth playing with. We’ve got some ideas on what to add over the course of the experiment and hope to get more from the community. </p>\n<p>Whether you can offer code, give feedback, participate in discussions, or just let us watch how you use something - everyone has something valuable to offer. In fact, one of <a href=\"https://wiki.mozilla.org/Test_Pilot/mission\">the overarching goals of Test Pilot</a> is to expand channels of contribution for folks interested in helping us build Firefox.</p>\n<p>As with all Test Pilot experiments, we’ll be watching how folks use this stuff as input for what happens next. We also encourage participation in our <a href=\"https://discourse.mozilla.org/c/test-pilot\">Discourse forums</a>. And finally, the project itself is <a href=\"https://github.com/mozilla/Themer\">open source on Github</a> and open to pull requests. </p>\n<p>In the meantime, start collecting color swatches for your own theme. Personally, I might try my hand at <a href=\"https://draculatheme.com/\">a Dracula theme</a> or maybe raid my Vim config directory for some inspiration.</p>\n"}