{"comments_archived":true,"date":"2005-06-28T00:00:00.000Z","layout":"post","title":"Building a proper shared syndication feed foundation","wordpress_id":663,"wordpress_slug":"building-a-proper-shared-syndication-feed-foundation","wordpress_url":"http://www.decafbad.com/blog/?p=663","url":"/2005/06/28/building-a-proper-shared-syndication-feed-foundation/","path":"2005/06/28/building-a-proper-shared-syndication-feed-foundation","content":"<p>While I&#39;m thinking on the subject of common syndication feed frameworks, it occurred to me that it might be instructive to jot down some thoughts on one of the concerns at the root of my ideas for FeedReactor:  Shared feed fetching, caching, and storage.</p>\n<p>I wanted to build something that would intelligently handle all <a href=\"http://fishbowl.pastiche.org/2002/10/21/http_conditional_get_for_rss_hackers\">the issues</a> <a href=\"http://diveintomark.org/tests/client/http/\">of HTTP</a> and <a href=\"http://www.decafbad.com/blog/2003/09/25/dynamic_feed_scan_times\">feed</a> <a href=\"http://www.decafbad.com/blog/2003/09/29/dynamic_polling_freq_too\">polling</a> <a href=\"http://www.decafbad.com/blog/2003/11/26/polling_and_urgency\">schedules</a>, across all my apps, all in one spot--once and for all.  Maybe it wouldn&#39;t have quite that guarantee of finality, but I&#39;d <em>hope</em> to never directly perform an HTTP GET for a feed from one of my apps ever again.</p>\n<p>Toward that end, one of my primary requirements is this:  Once I&#39;ve acquired feed data, I need to store it in some form usable by my other programs and by some method as agnostic as possible toward the actual contents of the feed.  I want to preserve potential extension data, without needing prior knowledge of what that might be.  Extensions are one area where the fun stuff with syndication feeds will be taking off, and I&#39;ve wanted a foundation to support that.</p>\n<p>So, in my tinkering, I&#39;ve explored four main variations of storing feed data:</p>\n<ol>\n<li>Fine-grained relational DB tables</li>\n<li>Triples in an RDF store</li>\n<li>XML database storage</li>\n<li>Coarse-grained persistence</li>\n</ol>\n<h3 id=\"feeds-in-relational-db-tables\">Feeds in relational DB tables</h3>\n<p>Mapping feed data to relational database tables seems to be the most common approach I&#39;ve seen in use by aggregators.  Another similar approach involves maintaining a persistent object model.  <a href=\"http://www.decafbad.com/blog/2005/06/28/safarirssdb\">Syndication.framework</a>, <a href=\"http://inessential.com/?comments=1&amp;postid=2993\">NetNewsWire</a>, <a href=\"http://www.nongnu.org/straw/\">Straw</a>, and <a href=\"http://feedonfeeds.com/\">Feed on Feeds</a> all do something like this, more or less--and I&#39;m sure many others do, as well.   </p>\n<p>The idea is that the raw feed XML comes in, gets parsed, and then methodically dissected to populate columns in a table or properties of an object.  Since the table schema or class definition is planned out ahead of time, only feed data which conforms to this model gets preserved.</p>\n<p>Occasionally, an effort is made to &quot;expose all possible data&quot;, <a href=\"http://www.feedparser.org/docs/namespace-handling.html\">ala the Universal Feed Parser</a>.  But, this is really only practical if your objects are particularly dynamic--and even then <a href=\"http://bitsko.slc.ut.us/blog/rdf-longhorn.html\">you&#39;ll run into issues</a>, depending on just what shows up in a given feed.  But, if you don&#39;t really care much about anything all that exotic in feeds beyond title / link / description, this approach might work out just fine.</p>\n<h3 id=\"feeds-as-rdf-triples\">Feeds as RDF triples</h3>\n<p>But if you do care about extension data, and if you&#39;re going to go through all that trouble of dissecting a feed, you might as well have a sufficiently granular and flexible repository to dump it.  So, how about an RDF triple store?  The underlying model behind RDF can capture anything you can throw at it from syndication feed structures.  In fact, RSS 1.0 and all of its extension modules <em>are</em> serialized RDF data.</p>\n<p>Here, though, the issue isn&#39;t so much a matter of signal loss because pieces don&#39;t fit the model.  Instead, the issue is more akin to an impedance mismatch:  </p>\n<p>Do you try to transliterate pieces of RSS 2.0 and Atom 0.x feeds into RSS 1.0 parts?  Or do you <a href=\"http://semtext.org/atom/\">recast a feed format like Atom as an RDF vocabulary</a>?  Then, what do you do about all the mostly similar yet slightly different feed bits floating around as triples (i.e. RSS 1.0 vs Atom OWL)?  And, don&#39;t even get me started on all the annoyances involved in dismembering and reassembling arrangements of triples--although that&#39;s more a function of a particular RDF toolkit.</p>\n<h3 id=\"feeds-in-an-xml-database\">Feeds in an XML database</h3>\n<p>Admittedly, I haven&#39;t done as much as I&#39;d like with feeds in an XML database--such as <a href=\"http://www.sleepycat.com/products/xml.shtml\">Berkeley DB XML</a>.  In part, that&#39;s been because the various packages have either just been too frustratingly dog-slow or nigh-impossible to get built and running on my OS X development machine.  </p>\n<p>One of the main benefits to this approach--on paper, anyway--is that the feed data stays intact in in the original format as XML.  It doesn&#39;t get dismembered, recast, rearranged, or exposed to much of anything that would put any exotic cargo it carries at risk.</p>\n<p>But, I think I&#39;ve got more playing to do with this option.  Although the opportunity to play much more with XSLT, XPath, and XQuery are attractive to me--this seems like potential overkill.  And, whereas the previous two approaches can accommodate a little <a href=\"http://www.xml.com/pub/a/2003/01/22/dive-into-xml.html\">liberal parsing</a>, this approach requires valid feeds.  So, here I&#39;ll need to pull in some repair kit tools to normalize and tidy any broken / soupy feeds.  Or, if I&#39;m feeling particularly annoyed, I can just <a href=\"http://diveintomark.org/archives/2004/01/08/postels-law\">ignore Postel&#39;s Law</a> and <a href=\"http://www.w3.org/TR/REC-xml#dt-wfc\">pound my fist on the spec</a>.</p>\n<h3 id=\"feeds-in-coarse-grained-persistence\">Feeds in coarse-grained persistence</h3>\n<p>The notion which brought me to this final approach toward storing feed data  goes something like <a href=\"http://www.tbradford.org/2005/06/advanced-revelation.html\">what this guy wrote</a>:</p>\n<blockquote>\n<p>The biggest design mistake of dbXML was making it an XML database. The problem with XML databases is that they store XML, and the problems with XML are too numerous to go into here. Let&#39;s just say that processing XML in a native fashion in the database engine itself is a fool&#39;s errand, and leads to far too many potential external dependency problems to be worthwhile. If you&#39;re doing anything but the simplest of stripped down document storage, It&#39;s a much wiser approach to simply store the XML text in a BLOB, delegating the work of schema checking and external entity processing to a higher layer of your system. Otherwise, you can bet your ass that at some point in the feature, when you can least afford for it to happen, something is going to break.</p>\n</blockquote>\n<p>So, in FeedReactor, <a href=\"http://www.decafbad.com/kwiki/index.cgi?FeedReactorDataModel\">that&#39;s pretty much what I did</a>.  I took Atom feeds and chopped them up into coarse feed and entry chunks, squirreled them away as blobs in a database table, along with a few select columns extracted from the XML data and indexed for easier future retrieval.  </p>\n<p>Other than digging for the feed start/end tags and element start/end tags, as well as using a few XPaths to extract those indexed columns, the feed store didn&#39;t do anything else other than stow away the XML source.  I left any further handling of the feed data up to XSL and REST API client apps.  </p>\n<p>Of course, FeedReactor has been sleeping for quite awhile now, so this is more an idea and an intention than a successfully demonstrated approach.  But, I was eating this dogfood as my main aggregator for the better part of a year, so I think it still has potential.</p>\n<h3 id=\"so-what-now-\">So, what now?</h3>\n<p>I&#39;m not sure what quite to do with feeds in a shared way, now and for the future.  Sticking things in a relational database is pretty quick, but very lossy.  Using RDF seems very flexible, but often not too quick or all that friendly.  Calling in an XML database seems like a &quot;good&quot; idea, but my spider sense is tingling.  And finally, chopping feeds up into coarse, vaguely indexed chunks seems less lossy, but not all that elegant.</p>\n<p>All in all, maybe it&#39;s just enough to download and cache the raw feeds.</p>\n<p>I&#39;ll post this now, but I&#39;m still thinking about all of this...</p>\n<div id=\"comments\" class=\"comments archived-comments\">\n            <h3>Archived Comments</h3>\n\n        <ul class=\"comments\">\n\n        <li class=\"comment\" id=\"comment-221090388\">\n            <div class=\"meta\">\n                <div class=\"author\">\n                    <a class=\"avatar image\" rel=\"nofollow\" \n                       href=\"http://dannyayers.com\"><img src=\"http://www.gravatar.com/avatar.php?gravatar_id=7028f422ca6da0180de6c9d922a3228f&amp;size=32&amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png\"/></a>\n                    <a class=\"avatar name\" rel=\"nofollow\" \n                       href=\"http://dannyayers.com\">Danny</a>\n                </div>\n                <a href=\"#comment-221090388\" class=\"permalink\"><time datetime=\"2005-06-29T04:29:39\">2005-06-29T04:29:39</time></a>\n            </div>\n            <div class=\"content\">I&#39;m very much looking forward to hearing what you come up with. \n\nRather predictably I&#39;m opting for the RDF store approach, but that&#39;s not to say the other approaches don&#39;t have their merits. Jon Udell (search his blog) has done some interesting work with feed data stored as XML, basically using XPath as the query language. It works, but I would suggest that he&#39;s tied to the XML structure too much. A year ago I might have gone for a hybrid RDF/RDBMS approach, with the core RSS material being contained in fixed tables bridged across to an RDF interface (somehow) to allow FOAF etc. But two factors put me off that idea now - the RSS 2.0 extensions that have appeared in recent weeks and SPARQL! Having a SQL-like query language that can be used against an RDF store (with XSLT-able results) really does simplify matters. Performance is likely to be an issue but I&#39;m hoping a bit of filtering &amp; caching will help there. I&#39;m getting feed data into the store currently using XSLT (to RDF/XML), it&#39;s ok but the setup I&#39;ve got could be a lot more modular.\n\nI think Microsoft have got things partly right in their RSS Longhorn architecture, separating out the &quot;Sync Engine&quot;. But in the data handling there&#39;s heavy use of objects, which I don&#39;t think should be needed when you can do things declaratively using SQL or SPARQL. Their object model is limited, I can guarantee that&#39;ll turn into a big ball of mud ;-)\n\nWhat I&#39;m intrigued by is the potential for using multiple stores on different hosts. My immediate target being a fairly big aggregator/store on a remote server and a shiny-GUI client tool with more limited storage that selectively addresses the remote store. But I&#39;m still at early-experiment stage.</div>\n\n<pre><code>    &lt;/li&gt;\n\n    &lt;li class=&quot;comment&quot; id=&quot;comment-221090389&quot;&gt;\n        &lt;div class=&quot;meta&quot;&gt;\n            &lt;div class=&quot;author&quot;&gt;\n                &lt;a class=&quot;avatar image&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://plasmasturm.org/&quot;&gt;&lt;img src=&quot;http://www.gravatar.com/avatar.php?gravatar_id=e17949267bbfe21a0fadf1bbf00592b4&amp;amp;size=32&amp;amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png&quot;/&gt;&lt;/a&gt;\n                &lt;a class=&quot;avatar name&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://plasmasturm.org/&quot;&gt;Aristotle Pagaltzis&lt;/a&gt;\n            &lt;/div&gt;\n            &lt;a href=&quot;#comment-221090389&quot; class=&quot;permalink&quot;&gt;&lt;time datetime=&quot;2005-06-29T07:16:38&quot;&gt;2005-06-29T07:16:38&lt;/time&gt;&lt;/a&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;content&quot;&gt;I use [Liferea](http://liferea.sf.net/) as my desktop aggregator (it&#39;s a bit basic, but works very well), which uses LibXML to parse feeds. You&#39;d be surprised (or not) how many of them are valid XML. The only issue that comes up regularly is charset brokenness.\n</code></pre><p>Also, I&#39;ve found that most people, if told that their feed is broken, will thank you for the note and proceed to fix it. Those who aren&#39;t technically savvy enough to fix their feeds generally don&#39;t <em>have</em> malformed ones to begin with because they use some ready-made webblogging tool -- and those tend to have correct feed generation by default.</p>\n<p>So if all your repair kit does is check and fix the feed encoding, then you should almost never see any bogosity.</div></p>\n<pre><code>    &lt;/li&gt;\n\n    &lt;li class=&quot;comment&quot; id=&quot;comment-221090390&quot;&gt;\n        &lt;div class=&quot;meta&quot;&gt;\n            &lt;div class=&quot;author&quot;&gt;\n                &lt;a class=&quot;avatar image&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://webseitz.fluxent.com/wiki&quot;&gt;&lt;img src=&quot;http://www.gravatar.com/avatar.php?gravatar_id=8157a5907b244071cda98ba5aa7a9635&amp;amp;size=32&amp;amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png&quot;/&gt;&lt;/a&gt;\n                &lt;a class=&quot;avatar name&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://webseitz.fluxent.com/wiki&quot;&gt;Bill Seitz&lt;/a&gt;\n            &lt;/div&gt;\n            &lt;a href=&quot;#comment-221090390&quot; class=&quot;permalink&quot;&gt;&lt;time datetime=&quot;2005-09-23T17:58:08&quot;&gt;2005-09-23T17:58:08&lt;/time&gt;&lt;/a&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;content&quot;&gt;If you&#39;re going to store chunks as BLOBs, would it just make more sense to store them in the filesystem? Put the meta-data in the SQL db, but just have a filename handle to get to the ultimate content.\n</code></pre><p>Then you really have recoverability, etc.</p>\n<p>Though it increases the risk that you&#39;ll do something tacky and update a file without triggering an update of the meta-data, etc. but you could do the same thing regardless of the infrastructure layer...</p>\n<p>(Probably-not-related, an interview with Hans Reiser I read recently included him saying that BLOBs are a bad thing. But I didn&#39;t track down his reference documents....)</div></p>\n<pre><code>    &lt;/li&gt;\n\n    &lt;li class=&quot;comment&quot; id=&quot;comment-221090391&quot;&gt;\n        &lt;div class=&quot;meta&quot;&gt;\n            &lt;div class=&quot;author&quot;&gt;\n                &lt;a class=&quot;avatar image&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://www.decafbad.com&quot;&gt;&lt;img src=&quot;http://www.gravatar.com/avatar.php?gravatar_id=2377f34a68801b861c3e54e1301f0dce&amp;amp;size=32&amp;amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png&quot;/&gt;&lt;/a&gt;\n                &lt;a class=&quot;avatar name&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://www.decafbad.com&quot;&gt;l.m.orchard&lt;/a&gt;\n            &lt;/div&gt;\n            &lt;a href=&quot;#comment-221090391&quot; class=&quot;permalink&quot;&gt;&lt;time datetime=&quot;2005-09-23T18:14:57&quot;&gt;2005-09-23T18:14:57&lt;/time&gt;&lt;/a&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;content&quot;&gt;Bill:  What&#39;s funny is that I&#39;ve actually started doing something along those lines with something I named FeedSpool.\n</code></pre><p><a href=\"http://decafbad.com/svn/trunk/feedspool/\">http://decafbad.com/svn/trunk/feedspool/</a></p>\n<p>Feeds fetched and stored on the filesystem--shortly thereafter sliced into entries, one per file.  I base file and folder names on MD5 hashes of feed URLs and entry ID/content.  Also considering leaving SQL out of the picture altogether, store per-user metadata on the filesystem, maybe indexed for searchability with Berkeley DB or Lucene.</div></p>\n<pre><code>    &lt;/li&gt;\n\n    &lt;/ul&gt;\n\n    &lt;/div&gt;\n</code></pre>"}