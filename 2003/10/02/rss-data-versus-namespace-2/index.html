<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"/>
    <meta name="microtip" content="1Ad1VPQBBk7WhyJPfB6cAgZoBs3gUngurN" data-currency="btc">
    <link rel="stylesheet" href="/css/main.css" type="text/css" media="screen, projection" />

    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>RSS 2.0 namespace versus RSS-Data, Part 2: First impressions - blog.lmorchard.com</title>
    <meta name="author" content="" />

    
      <link href="/index.rss" rel="alternate"
        title="blog.lmorchard.com" type="application/rss+xml" />
    

    <!--[if lt IE 9]>
    <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <meta property="og:type" content="article" />
    <meta property="og:site_name" content="blog.lmorchard.com"/>

    
  <meta property="og:title" content="RSS 2.0 namespace versus RSS-Data, Part 2: First impressions" />
  <meta property="og:url" content="https://blog.lmorchard.com/2003/10/02/rss-data-versus-namespace-2//" />
  
  <meta property="og:description" content=" Okay, I got the example data out there. Here&amp;apos;s what&amp;apos;s first on my mind about it:     Man, that RSS-Data is one verbose piece of XML.  The Amazon-specific namespace version looks much more compact and readable; I&amp;apos;d rather View Source on that one.     Python comes out of the box with xmlrpclib, and other languages have XML-RPC facilities available as well.  I can&amp;apos;t imagine it&amp;apos;d be too hard to get a hold of the core of it and employ it in unmarshalling the RSS-Data straight into idiomatic Python structures. On the other hand, I&amp;apos;ll need to write my own handlers for the Amazon XML using the XML parser modules that come with Python.     With its clean, almost self-documenting structure, the Amazon XML is easily handled with XPath and XSL.  If I had a pile of ProductInfo elements in a document, I could yank out all their images with something like: //az:ProductInfo/az:Details/az:ImageUrlSmall   Using the RSS-Data example, it&amp;apos;d probably be something more like: //sdl:data/sdl:struct/sdl:member/sdl:name[@text=&amp;apos;ImageUrlSmall&amp;apos;]/../sdl:value, and that&amp;apos;s not considering if I have mixed kinds of RSS-Data schema represented in the feed.   I suppose I could help this out by surrounding the struct with another struct, containing one member named &amp;apos;AzProductInfo&amp;apos;, making the path something like so: //sdl:data/sdl:struct/sdl:member/sdl:name[@text=&amp;apos;AzProductInfo&amp;apos;] /../sdl:value/sdl:struct/sdl:member/sdl:name[@text=&amp;apos;ImageUrlSmall&amp;apos;]/../sdl:value.      And these are the conclusions I&amp;apos;m jumping to at the moment, before experimenting:     RSS-Data&amp;apos;s convenience to script authors is at odds with the RSS 2.0 spirit of View Source.   Producing and consuming RSS-Data could be easier than handling purpose-specific XML schema in scripts.   Since RSS-Data doesn&amp;apos;t follow in the spirit of XML specs and schema, using formal XML tools to handle this stuff will give you nothing but headaches.  (Then again, it seems like some of the stuff that&amp;apos;s fully in the spirit of XML yields headaches just the same.)   RSS-Data might catch on and spread nonetheless, because lots of people don&amp;apos;t read XML, don&amp;apos;t use formal XML tools, and just write scripts to get their jobs done.   " />



  </head>
  <body>

    <section class="main">

      <header>
        <h1><a href="/">blog.lmorchard.com</a></h1>
        <h2>It&#39;s all spinning wheels and self-doubt until the first pot of coffee.</h2>
        <nav>

          <label for="nav-trigger"></label>
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />

          <ul>
            <li><a href="http://lmorchard.com/">about me</a></li>
            <li><a href="/archives.html">archives</a></li>
          </ul>

        </nav>
      </header>

      <section class="content">
<article class="post ">
    <time title="2003-10-02T00:00:00.000Z" pubdate="2003-10-02T00:00:00.000Z">
      <a href="/"><i class="fa fa-home"></i></a>
      &raquo;
      <a href="/2003">2003</a>
      &raquo;
      <a href="/2003/10">October</a>
      &raquo;
      <span>02</span>
      &raquo;
    </time>
    <h1 class="title">RSS 2.0 namespace versus RSS-Data, Part 2: First impressions</h1>
    
    <section class="post-content"><p>
Okay, I got
<a href="http://www.decafbad.com/blog/tech/rss_data_versus_namespace.html">the example data</a> out there.
Here&#39;s what&#39;s first on my mind about it:
</p>
<ol>
<li>
<p>
Man, that RSS-Data is one verbose piece of XML.  The Amazon-specific
namespace version looks much more compact and readable; I&#39;d rather
<a href="http://backend.userland.com/davesRss2PoliticalFaq">View Source</a>
on that one.
</p>
</li>
<li>
<p>
Python comes out of the box with
<a href="http://www.python.org/doc/current/lib/module-xmlrpclib.html">xmlrpclib</a>,
and other languages have XML-RPC facilities available as well.  I can&#39;t imagine
it&#39;d be too hard to get a hold of the core of it and employ it in
unmarshalling the RSS-Data straight into idiomatic Python structures.
On the other hand, I&#39;ll need to write my own handlers for the Amazon XML
using the XML parser modules that come with Python.
</p>
</li>
<li>
<p>
With its clean, almost self-documenting structure, the Amazon XML is easily
handled with XPath and XSL.  If I had a pile of ProductInfo elements
in a document, I could yank out all their images with something like:
<code>//az:ProductInfo/az:Details/az:ImageUrlSmall</code>
</p>
<p>
Using the RSS-Data
example, it&#39;d probably be something more like:
<code>//sdl:data/sdl:struct/sdl:member/sdl:name[@text=&#39;ImageUrlSmall&#39;]/../sdl:value</code>,
and that&#39;s not considering if I have mixed kinds of RSS-Data schema represented in the
feed.
</p>
<p>
I suppose I could help this out by surrounding the struct with another
struct, containing one member named &#39;AzProductInfo&#39;, making the path something
like so:
<code>//sdl:data/sdl:struct/sdl:member/sdl:name[@text=&#39;AzProductInfo&#39;]<br />
/../sdl:value/sdl:struct/sdl:member/sdl:name[@text=&#39;ImageUrlSmall&#39;]/../sdl:value</code>.
</p>
</li>
</ol>

<p>
And these are the conclusions I&#39;m jumping to at the moment, before experimenting:
</p>

<p><ol></p>
<p><li>
RSS-Data&#39;s convenience to script authors is at odds with the RSS 2.0
spirit of View Source.
</li></p>
<p><li>
Producing and consuming RSS-Data could be easier than handling
purpose-specific XML schema in scripts.
</li></p>
<p><li>
Since RSS-Data doesn&#39;t follow in the spirit of XML specs and schema,
using formal XML tools to handle this stuff will give you
nothing but headaches.  (Then again, it seems like some of the
stuff that&#39;s fully in the spirit of XML yields headaches just
the same.)
</li></p>
<p><li>
RSS-Data might catch on and spread nonetheless, because lots
of people don&#39;t read XML, don&#39;t use formal XML tools, and just
write scripts to get their jobs done.
</li>
</ol>
<!--more-->
shortname=rss_data_versus_namespace_2</p>
</section>
</article>



</section>

      <footer>
        <img id="growup" src="/uploads/growup.jpg">
      </footer>

    </section>

    <section id="javascript">
      <script src="/js/main.js"></script>
      
    </section>

  </body>
</html>
