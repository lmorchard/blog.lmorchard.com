<!DOCTYPE html>
    <html>
      <head>
        <title>Dynamic feed polling times for news aggregators - blog.lmorchard.com</title>
        <meta property="og:type" content="article" />
        <meta property="og:site_name" content="blog.lmorchard.com" />
        <meta http-equiv="content-type" content="text/html; charset=utf-8" />
        <meta name="author" content="Les Orchard" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0"
        />
        <link
          rel="shortcut icon"
          href="https://www.gravatar.com/avatar/b45c48fc9e05922e2f368a9d7d7d8de1?s=16"
        />

        <script
          defer
          data-domain="blog.lmorchard.com"
          src="https://analytics.lmorchard.com/js/plausible.js"
        ></script>

        <link
          rel="stylesheet"
          type="text/css"
          href="/blog.lmorchard.com/index.css"
        />
        <script type="module" src="/blog.lmorchard.com/index.js"></script>

        <link
          href="https://lmorchard.github.io/blog.lmorchard.com/index.rss"
          rel="alternate"
          title="blog.lmorchard.com"
          type="application/rss+xml"
        />

        <link
                href="/blog.lmorchard.com/index.rss"
                rel="alternate"
                title="blog.lmorchard.com"
                type="application/rss+xml"
              />
        <meta property="og:title" content="Dynamic feed polling times for news aggregators" />
        <meta
          property="og:url"
          content="https://lmorchard.github.io/blog.lmorchard.com/2003/09/25/dynamic-feed-scan-times/"
        />
        
        <meta property="og:description" content="Today, my aggregator got
the following SQL worked into its feed poll scheduling machinery:

SELECT id as source,
       &#39;update_period&#39; as name,
       max(1, 1/max((1.0/24.0),
                    sum(update_count)/(7*24))) AS value 
FROM sources 
LEFT JOIN (
    SELECT source AS count_id,
                round(iso8601_to_epoch(created)/(60*60)) AS hour, 
                count(id) AS update_count 
    FROM items 
    WHERE created&gt;epoch_to_iso8601(now()-(7*(24*60*60))) 
    GROUP BY hour
) ON id=count_id
GROUP BY source
ORDER BY value


It&#39;s likely that this is really nasty, but I have only a street-level
working knowledge of SQL.  Also, a few of the date functions are
specific to how I&#39;ve extended sqlite in Python.  It works though, and
what it does is this:



For each feed to which I&#39;m subscribed, work out
an average time between updates for the past week, with a maximum
period of 24 hours and a minimum of 1 hour.



My aggregator does this daily, and uses the results to determine how
frequently to schedule scans.  In this way, it automatically backs off
on checking feeds which update infrequently, and ramps up its polling
of more active feeds.  This shortens my feed downloading and scanning
time, and is kinder in general to everyone on my subscription list.



Next, among other things, I have to look into making sure that the
HTTP client parts of this beast pass all the
aggregator client
HTTP tests that Mark
Pilgrim put together.



Update: Well, it seemed like a good idea, anyway.  But, on
further examination, it has flaws.  The most notable is that it
assumes a polling frequency of once per hour.  This works right up
until I start changing the polling frequency with the results of the
calculation.  I haven&#39;t poked at it yet, but maybe if I take this
into account, it&#39;ll be more accurate.



On the other hand, I&#39;ve also been thinking about a much simpler
approach to ramping polling frequency up and down:  Start out at
a poll every hour.  If, after a poll, no new items are found,
double the time until the next poll.  If new items were found,
halve the time until the next poll.


Provide lower and upper limits to this, say between 1 hour and 1
week.  Also, consider the ramp up and ramp down factor as a variable
setting too.  Instead of a factor of 2, maybe try 1.5 or even 1.25 for
a more gradual change.  To go even further, I wonder if it would be
valuable to dynamically alter this factor itself, to try to get the
polling time zeroed in on a realistic polling time.



Okay.  There the simpler approach leaves simplicity.  I&#39;m sure there&#39;s
some decently elegant math that could be pulled in here.  :)" />
      </head>
      <body>
        <header class="content-grid">
          <div class="masthead">
            <img src="https://www.gravatar.com/avatar/b45c48fc9e05922e2f368a9d7d7d8de1.jpg?s=128" />
            <div class="title">
              <h1>
                <a href="/blog.lmorchard.com/" title="blog.lmorchard.com">
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="100%"
                    height="100%"
                    viewBox="0 0 250 20"
                  >
                    <text
                      lengthAdjust="spacing"
                      fill="currentColor"
                      y="16"
                      textLength="240"
                      x="5"
                    >
                      blog.lmorchard.com
                    </text>
                  </svg>
                </a>
              </h1>
              <h2>
                <rotating-tagline
                  random
                  initial="1"
                  period="7000"
                  src="/blog.lmorchard.com/taglines.json"
                >
                  <a href="/blog.lmorchard.com/" title="It&#39;s all spinning wheels &amp; self-doubt until the first pot of coffee.">
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      width="100%"
                      height="100%"
                      viewBox="0 0 250 20"
                    >
                      <text
                        class="tagline"
                        lengthAdjust="spacing"
                        fill="currentColor"
                        y="16"
                        textLength="240"
                        x="5"
                      >
                        It&#39;s all spinning wheels &amp; self-doubt until the first pot of coffee.
                      </text>
                    </svg>
                  </a>
                </rotating-tagline>
              </h2>
            </div>
          </div>
          <nav class="main-nav">
            <div id="search"></div>
            <ul>
              <li>
                <a href="http://lmorchard.com/"
                  ><span class="fa fa-info-circle"></span> about me</a
                >
              </li>
              <li>
                <a href="/blog.lmorchard.com/archives.html"
                  ><span class="fa fa-archive"></span> archives</a
                >
              </li>
              <li>
                <a href="https://lmorchard.github.io/blog.lmorchard.com/index.rss" title="blog.lmorchard.com"
                  ><span class="fa fa-rss"></span> feed</a
                >
              </li>
              <li class="theme-selector">
                <theme-selector title="Enable dark theme">
                  <label>
                    <input type="checkbox" />
                    <span class="slider"></span>
                  </label>
                </theme-selector>
              </li>
            </ul>
          </nav>
        </header>

        <section class="main"><article
        data-pagefind-body
        class="content content-grid post "
      >
        <header>
          <time
            title="2003-09-25T22:45:29-04:00"
            pubdate="2003-09-25T22:45:29-04:00"
          >
            <span class="prevpost">
              <a
                title="Dynamic polling times for news aggregators, II"
                href="/blog.lmorchard.com/2003/09/29/dynamic-polling-freq-too/"
                >&nbsp;<span class="fa fa-long-arrow-left"></span>&nbsp;</a
              >
            </span>
            <span class="postdate">
              <a href="/blog.lmorchard.com/2003/"
                >2003</a
              >
              &#8226;
              <a href="/blog.lmorchard.com/2003/09/"
                >September</a
              >
              &#8226;
              <span>25</span>
            </span>
            <span class="nextpost">
              <a
                title="Atom is its Name-O?"
                href="/blog.lmorchard.com/2003/09/25/atom-is-its-name-o/"
                >&nbsp;<span class="fa fa-long-arrow-right"></span>&nbsp;</a
              >
            </span>
          </time>
          <h1 class="title">Dynamic feed polling times for news aggregators</h1>
          
        </header>

        <p>Today, <a href="http://www.decafbad.com/cvs/dbagg/&quot;">my aggregator</a> got
the following SQL worked into its <a href="http://www.decafbad.com/cvs/dbagg/lib/dbagg/scan.py?rev=HEAD&amp;content-type=text/vnd.viewcvs-markup">feed poll scheduling machinery</a>:</p>

<pre>SELECT id as source,
       'update_period' as name,
       max(1, 1/max((1.0/24.0),
                    sum(update_count)/(7*24))) AS value 
FROM sources 
LEFT JOIN (
    SELECT source AS count_id,
                round(iso8601_to_epoch(created)/(60*60)) AS hour, 
                count(id) AS update_count 
    FROM items 
    WHERE created&gt;epoch_to_iso8601(now()-(7*(24*60*60))) 
    GROUP BY hour
) ON id=count_id
GROUP BY source
ORDER BY value</pre>

<p>
It's likely that this is really nasty, but I have only a street-level
working knowledge of SQL.  Also, a few of the date functions are
specific to how I've <a href="http://pysqlite.sourceforge.net/documentation/pysqlite/node10.html#SECTION004231000000000000000">extended sqlite in Python</a>.  It works though, and
what it does is this:
</p>

<p>
For each feed to which I'm subscribed, work out
an average time between updates for the past week, with a maximum
period of 24 hours and a minimum of 1 hour.
</p>

<p>
My aggregator does this daily, and uses the results to determine how
frequently to schedule scans.  In this way, it automatically backs off
on checking feeds which update infrequently, and ramps up its polling
of more active feeds.  This shortens my feed downloading and scanning
time, and is kinder in general to everyone on my subscription list.
</p>

<p>
Next, among other things, I have to look into making sure that the
HTTP client parts of this beast pass all the
<a href="http://diveintomark.org/tests/client/http/">aggregator client
HTTP tests</a> that <a href="http://diveintomark.org/">Mark
Pilgrim</a> put together.
</p>

<p>
<b>Update</b>: Well, it seemed like a good idea, anyway.  But, on
further examination, it has flaws.  The most notable is that it
assumes a polling frequency of once per hour.  This works right up
until I start changing the polling frequency with the results of the
calculation.  I haven't poked at it yet, but maybe if I take this
into account, it'll be more accurate.
</p>

<p>
On the other hand, I've also been thinking about a much simpler
approach to ramping polling frequency up and down:  Start out at
a poll every hour.  If, after a poll, no new items are found,
double the time until the next poll.  If new items were found,
halve the time until the next poll.</p>

<p>
Provide lower and upper limits to this, say between 1 hour and 1
week.  Also, consider the ramp up and ramp down factor as a variable
setting too.  Instead of a factor of 2, maybe try 1.5 or even 1.25 for
a more gradual change.  To go even further, I wonder if it would be
valuable to dynamically alter this factor itself, to try to get the
polling time zeroed in on a realistic polling time.
</p>

<p>
Okay.  There the simpler approach leaves simplicity.  I'm sure there's
some decently elegant math that could be pulled in here.  :)
</p>


<!--more-->


<p>shortname=dynamic_feed_scan_times</p>
<div id="comments" class="comments archived-comments"><h3>Archived Comments</h3>
<ul class="comments">
<li class="comment" id="comment-221087768">
<div class="meta">
<div class="author">
<a class="avatar image" rel="nofollow" href="http://24.102.209.201/weblogs/ben/"><img src="http://www.gravatar.com/avatar.php?gravatar_id=588bdfdda82be46c638d6956c55ebc38&amp;size=32&amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png" width="" height=""></a>
<a class="avatar name" rel="nofollow" href="http://24.102.209.201/weblogs/ben/">Gnomon</a>
</div>


<p><a href="#comment-221087768" class="permalink"><time datetime="2003-09-26T09:56:09">2003-09-26T09:56:09</time></a></p>
</div>


<div class="content">Why not just go the TCP/IP route - Additive Increase / Multiplicative Decrease? Start by setting the check-interval to one hour (or whatever). For each feed, if a new post is found, cut the check-interval for that feed by half; if no new post is found, increase the check-interval by an hour.
It's not optimal, and it won't automagically zero in on the predicted post times of individual feeds, but it strikes a nice balance between bandwidth politeness, update rapidity and conceptual simplicity. The constant values (initial check-interval, check-interval increment, check-interval multiplier) can be tweaked for different behavioural styles.</div>


</li>
<li class="comment" id="comment-221087769">
<div class="meta">
<div class="author">
<a class="avatar image" rel="nofollow" href="http://www.decafbad.com/blog"><img src="http://www.gravatar.com/avatar.php?gravatar_id=2ac2cffd36ada8c734b90e02a1e5c1ac&amp;size=32&amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png" width="" height=""></a>
<a class="avatar name" rel="nofollow" href="http://www.decafbad.com/blog">l.m.orchard</a>
</div>


<p><a href="#comment-221087769" class="permalink"><time datetime="2003-09-26T11:04:24">2003-09-26T11:04:24</time></a></p>
</div>


<div class="content">Hmm...  I knew that this was something that someone had already handled somewhere.  :)  I'm just not all that familiar with the details of TCP/IP, but this sounds pretty much like a workable approach I'd like to go with.</div>


</li>
<li class="comment" id="comment-221087770">
<div class="meta">
<div class="author">
<a class="avatar image" rel="nofollow" href="http://www.decafbad.com/blog"><img src="http://www.gravatar.com/avatar.php?gravatar_id=2ac2cffd36ada8c734b90e02a1e5c1ac&amp;size=32&amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png" width="" height=""></a>
<a class="avatar name" rel="nofollow" href="http://www.decafbad.com/blog">l.m.orchard</a>
</div>


<p><a href="#comment-221087770" class="permalink"><time datetime="2003-09-26T11:07:00">2003-09-26T11:07:00</time></a></p>
</div>


<div class="content">Oh!  For a second I thought that what you're suggesting was basically what I was already working on with my multiplying/dividing by a factor...  But you're talking about something that ADDS to increase and MULTIPLIES to decrease, which is something much more biased to back off than ramp up, which seems very polite to me.  Yay!</div>


</li>
</ul>


</div>

        
      </article>

      <section class="posts-nav content-grid">
        <span class="prev-post">
            <span
              ><a href="/blog.lmorchard.com/2003/09/29/dynamic-polling-freq-too/"
                >Dynamic polling times for news aggregators, II</a
              ></span
            >
            <span
              ><span class="fa fa-long-arrow-left"></span>&nbsp;Previous</span
            >
          </span>
        <span class="next-post">
            <span
              ><a href="/blog.lmorchard.com/2003/09/25/atom-is-its-name-o/"
                >Atom is its Name-O?</a
              ></span
            >
            <span>Next&nbsp;<span class="fa fa-long-arrow-right"></span></span>
          </span>
      </section></section>

        <footer class="content-grid">
          <div class="left">
            Â© 2024 Les Orchard &lt;<a href="mailto:me@lmorchard.com"
              >me@lmorchard.com</a
            >&gt;
          </div>
          <img id="growup" src="/blog.lmorchard.com/uploads/growup.jpg" />
          <nav class="right">
            <ul>
              <li>
                <a href="https://lmorchard.github.io/blog.lmorchard.com/index.rss" title="blog.lmorchard.com"
                  ><span class="fa fa-rss"></span> feed</a
                >
              </li>
            </ul>
          </nav>
        </footer>
      </body>
    </html>