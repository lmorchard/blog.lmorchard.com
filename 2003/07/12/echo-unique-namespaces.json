{"comments_archived":true,"date":"2003-07-12T00:00:00.000Z","layout":"post","title":"On tag uniqueness and versioning in Pie/Echo feeds","wordpress_id":441,"wordpress_slug":"echo-unique-namespaces","wordpress_url":"http://www.decafbad.com/blog/?p=441","url":"/2003/07/12/echo-unique-namespaces/","summary":"<p><blockquote cite=\"http://radio.userland.com/stories/storyReader$26234\">\n&quot;feed&quot; is not a very unique name, and if another format were to come\nalong with the same top level element we would not be able to write a\nformat driver for it. Our architecture keys off the top-level\nelement. I suggest changing the top-level element to indicate the\nformat, and also add a version number so that aggregators can have an\nidea of what spec the content provider is using. I imagine Radio is\nnot the only aggregator that would like to key off the name of the\ntop-level element.\n</blockquote></p>\n<div class=\"credit\" align=\"right\"><small>Source:<cite><a href=\"http://radio.userland.com/stories/storyReader$26234\">Radio UserLand: Radio gets some kind of Echo support</a></cite></small></div>\n<br><br>\nNope, &quot;feed&quot; seems like a pretty poor choice as a name if the goal was\nuniqueness in the tag name itself.  But, since we have XML namespaces\nto ensure uniqueness between vocabularies, we can instead focus on a\nclear and simple name that only needs to be unique <strong>within</strong> the\nvocabulary.  And as for versioning, why not consider different\nversions of a namespace to be entirely different vocabularies,\neach with different namespaces?\n<br><br>\nI did some <a href=\"http://www.google.com/search?q=xml+namespaces&amp;ie=UTF-8&amp;oe=UTF-8\" target=\"_top\">quick</a> <a href=\"http://www.google.com/search?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=xml+namespaces+versioning&amp;btnG=Google+Search\" target=\"_top\">Googling</a> and found the following:\n<br><br>\n<blockquote cite=\"http://www.w3.org/TR/1999/REC-xml-names-19990114/Overview.html\">\n... documents, containing multiple markup vocabularies, pose problems\nof recognition and collision.  Software modules need to be able to\nrecognize the tags and attributes which they are designed to process,\neven in the face of &quot;collisions&quot; occurring when markup intended for\nsome other software package uses the same element type or attribute\nname.\nThese considerations require that document constructs should have\nuniversal names, whose scope extends beyond their containing document.\nThis specification describes a mechanism, XML namespaces, which\naccomplishes this.\n</blockquote>\n<div class=\"credit\" align=\"right\"><small>Source:<cite><a href=\"http://www.w3.org/TR/1999/REC-xml-names-19990114/Overview.html\">Namespaces in XML</a></cite></small></div>\n<br><br>\n<blockquote cite=\"http://www-106.ibm.com/developerworks/xml/library/x-tipnamsp.html\">\nOne of the core features of XML is its ability to deal with changes in\nthe rules for data (hence the extensible in its name -- Extensible\nMarkup Language).  As changes are made to XML vocabularies, the\ncreation of multiple versions is inevitable.  This makes it necessary\nto mark the versions clearly, for human and machine information.  The\nclear marking of versions can be used for driving validation, or for\nbranch processing according to the requirements of each version.\n<br><br>\nYou can mark the version of an XML vocabulary in many ways.  This\ndiscussion focuses on the use of XML namespaces for marking versions.\n</blockquote>\n<div class=\"credit\" align=\"right\"><small>Source:<cite><a href=\"http://www-106.ibm.com/developerworks/xml/library/x-tipnamsp.html\">Tip: Namespaces and versioning</a></cite></small></div>\n<br><br>\nI haven&apos;t looked into <a href=\"http://www.decafbad.com/twiki/bin/view/Main/RadioUserLand\">RadioUserLand</a> feed handling architecture,\nbut how difficult would it be to use the namespace and tag together\nas key, rather than the tag alone?\n","path":"2003/07/12/echo-unique-namespaces","content":"<p><blockquote cite=\"http://radio.userland.com/stories/storyReader$26234\">\n&quot;feed&quot; is not a very unique name, and if another format were to come\nalong with the same top level element we would not be able to write a\nformat driver for it. Our architecture keys off the top-level\nelement. I suggest changing the top-level element to indicate the\nformat, and also add a version number so that aggregators can have an\nidea of what spec the content provider is using. I imagine Radio is\nnot the only aggregator that would like to key off the name of the\ntop-level element.\n</blockquote></p>\n<div class=\"credit\" align=\"right\"><small>Source:<cite><a href=\"http://radio.userland.com/stories/storyReader$26234\">Radio UserLand: Radio gets some kind of Echo support</a></cite></small></div>\n<br /><br />\nNope, &quot;feed&quot; seems like a pretty poor choice as a name if the goal was\nuniqueness in the tag name itself.  But, since we have XML namespaces\nto ensure uniqueness between vocabularies, we can instead focus on a\nclear and simple name that only needs to be unique <strong>within</strong> the\nvocabulary.  And as for versioning, why not consider different\nversions of a namespace to be entirely different vocabularies,\neach with different namespaces?\n<br /><br />\nI did some <a href=\"http://www.google.com/search?q=xml+namespaces&amp;ie=UTF-8&amp;oe=UTF-8\" target=\"_top\">quick</a> <a href=\"http://www.google.com/search?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;q=xml+namespaces+versioning&amp;btnG=Google+Search\" target=\"_top\">Googling</a> and found the following:\n<br /><br />\n<blockquote cite=\"http://www.w3.org/TR/1999/REC-xml-names-19990114/Overview.html\">\n... documents, containing multiple markup vocabularies, pose problems\nof recognition and collision.  Software modules need to be able to\nrecognize the tags and attributes which they are designed to process,\neven in the face of &quot;collisions&quot; occurring when markup intended for\nsome other software package uses the same element type or attribute\nname.\nThese considerations require that document constructs should have\nuniversal names, whose scope extends beyond their containing document.\nThis specification describes a mechanism, XML namespaces, which\naccomplishes this.\n</blockquote>\n<div class=\"credit\" align=\"right\"><small>Source:<cite><a href=\"http://www.w3.org/TR/1999/REC-xml-names-19990114/Overview.html\">Namespaces in XML</a></cite></small></div>\n<br /><br />\n<blockquote cite=\"http://www-106.ibm.com/developerworks/xml/library/x-tipnamsp.html\">\nOne of the core features of XML is its ability to deal with changes in\nthe rules for data (hence the extensible in its name -- Extensible\nMarkup Language).  As changes are made to XML vocabularies, the\ncreation of multiple versions is inevitable.  This makes it necessary\nto mark the versions clearly, for human and machine information.  The\nclear marking of versions can be used for driving validation, or for\nbranch processing according to the requirements of each version.\n<br /><br />\nYou can mark the version of an XML vocabulary in many ways.  This\ndiscussion focuses on the use of XML namespaces for marking versions.\n</blockquote>\n<div class=\"credit\" align=\"right\"><small>Source:<cite><a href=\"http://www-106.ibm.com/developerworks/xml/library/x-tipnamsp.html\">Tip: Namespaces and versioning</a></cite></small></div>\n<br /><br />\nI haven&#39;t looked into <a href=\"http://www.decafbad.com/twiki/bin/view/Main/RadioUserLand\">RadioUserLand</a> feed handling architecture,\nbut how difficult would it be to use the namespace and tag together\nas key, rather than the tag alone?\n<!--more-->\nshortname=echo_unique_namespaces\n\n<div id=\"comments\" class=\"comments archived-comments\">\n            <h3>Archived Comments</h3>\n\n        <ul class=\"comments\">\n\n        <li class=\"comment\" id=\"comment-221082343\">\n            <div class=\"meta\">\n                <div class=\"author\">\n                    <a class=\"avatar image\" rel=\"nofollow\" \n                       href=\"\"><img src=\"http://www.gravatar.com/avatar.php?gravatar_id=dc59c5ba9a8aa0a6225d9959eea3b7f3&amp;size=32&amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png\"/></a>\n                    <a class=\"avatar name\" rel=\"nofollow\" \n                       href=\"\">Dave Winer</a>\n                </div>\n                <a href=\"#comment-221082343\" class=\"permalink\"><time datetime=\"2003-07-13T19:34:52\">2003-07-13T19:34:52</time></a>\n            </div>\n            <div class=\"content\">Easy but ugly.</div>\n\n<pre><code>    &lt;/li&gt;\n\n    &lt;li class=&quot;comment&quot; id=&quot;comment-221082345&quot;&gt;\n        &lt;div class=&quot;meta&quot;&gt;\n            &lt;div class=&quot;author&quot;&gt;\n                &lt;a class=&quot;avatar image&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://mah.everybody.org/weblog/&quot;&gt;&lt;img src=&quot;http://www.gravatar.com/avatar.php?gravatar_id=59e08b5b7c8ed1c82b20144ba8e65967&amp;amp;size=32&amp;amp;default=http://mediacdn.disqus.com/1320279820/images/noavatar32.png&quot;/&gt;&lt;/a&gt;\n                &lt;a class=&quot;avatar name&quot; rel=&quot;nofollow&quot; \n                   href=&quot;http://mah.everybody.org/weblog/&quot;&gt;Mark &quot;Hex&quot; Hershberger&lt;/a&gt;\n            &lt;/div&gt;\n            &lt;a href=&quot;#comment-221082345&quot; class=&quot;permalink&quot;&gt;&lt;time datetime=&quot;2003-07-14T16:27:46&quot;&gt;2003-07-14T16:27:46&lt;/time&gt;&lt;/a&gt;\n        &lt;/div&gt;\n        &lt;div class=&quot;content&quot;&gt;I added namespace support to Emacs&#39; xml.el recently.  It wasn&#39;t difficult at all.  Instead of parsing [feed xmlns:e=&quot;uri&quot;]...[/feed], into &#39;(feed ...), I parsed it into &#39;({uri}feed ...).  Namespace processing doesn&#39;t happen without a switch set to enable it, so it is completely backwards compatible.\n</code></pre><p>So, while I haven&#39;t looked at how Radio parses stuff either, I think it wouldn&#39;t be that hard to add.  And it doesn&#39;t have to be ugly, either.</div></p>\n<pre><code>    &lt;/li&gt;\n\n    &lt;/ul&gt;\n\n    &lt;/div&gt;\n</code></pre>"}